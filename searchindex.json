{"categories":[{"title":"Chez","uri":"https://lvsq.net/categories/chez/"},{"title":"Java","uri":"https://lvsq.net/categories/java/"},{"title":"LeetCode","uri":"https://lvsq.net/categories/leetcode/"},{"title":"Scheme","uri":"https://lvsq.net/categories/scheme/"},{"title":"tool","uri":"https://lvsq.net/categories/tool/"},{"title":"文史","uri":"https://lvsq.net/categories/%E6%96%87%E5%8F%B2/"}],"posts":[{"content":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。\n (make-engine thunk)\n 通过传递一个无参数的thunk(形实转换程序)给make-engine来创建一个engine。thunk的body是会被engine执行的计算，engine本身是带3个参数的过程：\n ticks： 一个正整数，指定提供给engine的执行时间片（原文用的是fuel这个单词，意思是燃料，正对应这engine的本意，十分贴切）的数量，engine将会执行到时间片用完或者计算完成为止； complete： 一个或多个参数的函数，用于指定计算完成后的操作。它的参数是剩余的时间片数量和计算产生的值； expire： 一个参数的函数，该函数指定如果在计算完成之前时间片用完了该怎么办。它的参数是一个能从中断点继续进行计算的新引擎。  将引擎应用于其参数时，它将开启一个时长为ticks的计时器，如果引擎计算在计时器执行之前完成，系统将调用complete，并将剩余的ticks和计算产生的值传递给它；\n另一方面，如果计时器在引擎计算完成之前耗尽了，则系统会从中断计算的continuation中创建一个新引擎，并使该引擎过期。complete和expire会被新引擎继续使用。If, on the other hand, the timer goes off before the engine computation completes, the system creates a new engine from the continuation of the in- terrupted computation and passes this engine to expire. complete and expire are invoked in the continuation of the engine invocation.\n请勿同时使用计时器中断（set-timer），因为engine就是由计时器实现的。\n看看具体的例子：\n(define eng (make-engine (lambda () 3))) (eng 10 ;; ticks (lambda (ticks value) value) ;; complete (lambda (x) x) ;; expire ) ⇒ 3  通常将列表作为完整过程传递给引擎，使引擎完成时返回一个列表，该列表的第一个元素是剩余的ticks，另一个元素是计算返回的值，这通常很有用。\n(define eng (make-engine (lambda () 3))) (eng 10 list (lambda (x) x)) ⇒ (9 3)  在上面的示例中，计算值为3，还剩下9个时间片，即，需要一单位的时间片来计算出3。\n再看一个复杂点的例子： 先定义一个计算裴波那切值的函数\n(define fibonacci (lambda (n) (let fib ([i n]) (cond [(= i 0) 0] [(= i 1) 1] [else (+ (fib (- i 1)) (fib (- i 2)))]))))  创建engine\n(define eng (make-engine (lambda () (fibonacci 10))))  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ (21 55)  每次时间片（燃料）用完时，到期程序都会将eng分配给新引擎。整个计算需要4个blocks，每个block包含50个ticks。最后50个燃料中，有21个都用掉了。因此，使用的燃料总量为179个。\n我们还可以统计一下消耗的ticks数量\n(define mileage (lambda (thunk) (let loop ([eng (make-engine thunk)] [total-ticks 0]) (eng 50 (lambda (ticks . values) (+ total-ticks (- 50 ticks))) (lambda (new-eng) (loop new-eng (+ total-ticks 50))))))) (mileage (lambda () (fibonacci 10))) ⇒ 179  再看看一个例子——round-robin:\n(define round-robin (lambda (engs) (if (null? engs) '() ((car engs) 1 ;;ticks (lambda (ticks value) (cons value (round-robin (cdr engs)))) ;;complete (lambda (eng) ;;expire (round-robin (append (cdr engs) (list eng)))))))) (round-robin (map (lambda (x) (make-engine (lambda () (fibonacci x)))) '(4 5 2 8 3 7 6 2))) ⇒ (1 1 2 3 5 8 13 21)  这段代码需要费些思量，首先map函数创建了8个engine, 然后代入round-robin函数，该函数依次执行各个engine，但是每个engine分配的时间片只有1，对于参数\u0026rsquo;(4 5 2 8 3 7 6 2)，数字越小，越先执行完成，所以越早执行complete函数，最终结果就是排好顺序的了，很棒的程序！\n","id":0,"section":"posts","summary":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。 (make-engine thunk) 通过传递一个无参数的thun","tags":["engine","scheme"],"title":"Engine in Scheme","uri":"https://lvsq.net/2019/12/engine-in-scheme/","year":"2019"},{"content":" case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Scheme提供了case语法来处理这种情况，这与Java中的switch语法非常相似。\n我们来看看case的语法：\n (case expr0 clause1 clause2 \u0026hellip;)\n 除了最后一个clause之外，每个子句都必须采用以下形式之一：\n ((key \u0026hellip;) expr1 expr2 \u0026hellip;) (key expr1 expr2 \u0026hellip;)  每一个key值都应该是不同的，最后一个子句要么是上述那种形式，或者是一个像下面这样的else子句\n (else expr1 expr2 \u0026hellip;)  那么返回值是什么呢？\n匹配到某个key的或者else中的最后一个expr的值\n(define p (lambda (x) (case x [(\u0026quot;abc\u0026quot; \u0026quot;def\u0026quot;) 'one '1] [((a b c)) 'two] [else #f]))) (p (string #\\d #\\e #\\f)) ⇒ 1 (p '(a b c)) ⇒ two (p \u0026quot;eee\u0026quot;) ⇒ #f  上面的例子定义了一个函数p，接收一个参数x\n 如果x为字符串\u0026rdquo;abc\u0026rdquo;或者\u0026rdquo;def\u0026rdquo;，则返回1； 如果x为列表((a b c)，则返回two 其他情况返回#f  可见，有了case语法多条件判断写起来就方便很多，并且代码也容易读了，当然这里也可以用cond来写，这里只是为了描述case的语法而没有使用cond\n再看一个例子，就不用解释了：\n(let ([ls '(ii iv)]) (case (cadr ls) [i 1] [ii 2] [iii 3] [(iiii iv) 4] [else 'out-of-range])) ⇒ 4  record-case 来看看另一个很类似的扩展，也十分有用，它就是record-case。它可以以record为单位来做条件判断并执行指令。\n语法格式：  (record-case expr clause1 clause2 \u0026hellip;)\n 除了最后一个子句之外，每个clause的格式如下：\n ((key \u0026hellip;) formals body1 body2 \u0026hellip;)\n 每一个*key*都不应该相同, 最后一个clause可能是上述的格式或者是一个else子句：\n (else body1 body2 \u0026hellip;)\n expr必须是一个pair。Chez会拿(car expr)与各个子句中的key进行比较（用eqv?）来确定哪一个clause匹配, 然后(cdr expr)将与formals绑定。\n来看换一个例子：\n(define calc (lambda (x) (record-case x [(add) (x y) (+ x y)] [(sub) (x y) (- x y)] [(mul) (x y) (* x y)] [(div) (x y) (/ x y)] [else (assertion-violationf 'calc \u0026quot;invalid expression ~s\u0026quot; x)]))) (calc '(add 3 4)) =\u0026gt; 7 (calc '(div 3 4)) =\u0026gt; 3/4  ","id":1,"section":"posts","summary":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Schem","tags":["chez","scheme"],"title":"Chez Scheme中的case扩展","uri":"https://lvsq.net/2019/12/case-in-chez-scheme/","year":"2019"},{"content":" 易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴至，克尽其用，上下一体，俱不倦而事可毕矣 周云成康，汉言文景。无有六十年与民休息，累藏蓄积，汉武开疆之功便是空文，此厚积薄发耳，俗语言，胳膊收回来，打出去才有力  ","id":2,"section":"posts","summary":"易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴","tags":["随想"],"title":"继学录","uri":"https://lvsq.net/2019/12/think/","year":"2019"},{"content":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。\n先看看该语法描述：\n(fluid-let ((var expr) \u0026hellip;) body1 body2 \u0026hellip;) returns: the values of the body body1 body2 \u0026hellip; libraries: (chezscheme)\n该Binding的作用类似局部变量，与set! 比较相似。由fluid-let定义的变量必须已绑定到顶层(top level)或者封闭的lambda内或者其他形式的绑定，这很关键！\n请看代码：\n(let ([x 3]) (+ (fluid-let ([x 5]) x) x)) ⇒ 8  先定义变量x=3，然后在加法操作当中临时将x的值改为5，最后结果为8，如果将fluid-let中的x换个名字，比如y，将如何呢？\n会得到一个异常：\n Exception: variable y is not bound\n y没有绑定，是的，y即没有在顶层中被定义，也未在某个lambda中或者任何其他形式，这里只能是x\n再学习下两个例子，加深印象：\n(let ([x 'a]) (letrec ([f (lambda (y) (cons x y))]) (fluid-let ([x 'b]) (f 'c)) )) ⇒ (b . c)  (let ([x 'a]) (call/cc (lambda (k) (fluid-let ([x 'b]) (letrec ([f (lambda (y) (k '*))]) (f '*))))) x) ⇒ a  ","id":3,"section":"posts","summary":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。 先看看该语法描","tags":["fluid-let","Scheme"],"title":"Fluid Binding in Chez Scheme","uri":"https://lvsq.net/2019/12/fluid-binding/","year":"2019"},{"content":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。\n这是语法描述：\n(rec var expr) syntax\nreturns: value of expr\nlibraries: (chezscheme)\nThe syntactic form rec creates a recursive object from expr by establishing a binding of var within expr to the value of expr. In essence, it is a special case of letrec for self-recursive objects.\nThis form is useful for creating recursive objects (especially procedures) that do not depend on external variables for the recursion, which are sometimes undesirable because the exter-nal bindings can change. For example, a recursive procedure defined at top level depends on the value of the top-level variable given as its name. If the value of this variable should change, the meaning of the procedure itself would change. If the procedure is defined instead with rec, its meaning is independent of the variable to which it is bound.\n简要翻译一下：\n语法rec 通过在expr中建立var与expr的值的绑定，创建一个递归对象。从本质上讲，这是letrec用于自递归对象的一种特殊情况。\n语法rec通过绑定expr中创建一个递归对象，用来 这种形式对于创建不依赖于外部变量进行递归的递归对象（尤其是过程）很有用，因为外部绑定可能会发生变化，所以有时这是不可取的。\n看一个例子来感受一下：\n给定一个全是数字的list，对于每一个数字n，算出$1+2+\u0026hellip;+n$的和，最终返回和的list.\n(map (rec sum (lambda (x) (if (= x 0) 0 (+ x (sum (- x 1)))))) ’(0 1 2 3 4 5)) ⇒ (0 1 3 6 10 15)  如果没有rec语法，用letrec也是可以的，但是稍显麻烦，代码也多一些，所以rec还是很好用的\n最后看一下rec语法的定义：\n(define-syntax rec (syntax-rules () [(_ x e) (letrec ((x e)) x)]))  ","id":4,"section":"posts","summary":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。 这是语法描述： (rec","tags":["Scheme","Chez","rec"],"title":"Recursive Bindings in Chez Scheme","uri":"https://lvsq.net/2019/12/recursive-bindings/","year":"2019"},{"content":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些时间，动手写了一个，目前已经在公司内部运行了几年，效果良好，并且已经开源在Github上，以飨各位。\n特点：\n API简洁 支持3种事件：\n UP DOWN JOIN  基于Vert.X\n  引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lvsq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jgossip\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  一个简单的例子：\nint gossip_port = 60001; String cluster = \u0026quot;gossip_cluster\u0026quot;; GossipSettings settings = new GossipSettings(); settings.setGossipInterval(1000); try { String myIpAddress = InetAddress.getLocalHost().getHostAddress(); List\u0026lt;SeedMember\u0026gt; seedNodes = new ArrayList\u0026lt;\u0026gt;(); SeedMember seed = new SeedMember(); seed.setCluster(cluster); seed.setIpAddress(myIpAddress); seed.setPort(60001); seedNodes.add(seed); gossipService = new GossipService(cluster, myIpAddress, gossip_port, null, seedNodes, settings, (member, state) -\u0026gt;System.out.println(\u0026quot;member:\u0026quot; + member + \u0026quot; state: \u0026quot; + state)); } catch (Exception e) { e.printStackTrace(); } gossipService.start();  详细介绍请看 =\u0026gt; 项目地址\n欢迎大家fork， 如果觉得好请start ~~~\n","id":5,"section":"posts","summary":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些","tags":["jgossip","gossip"],"title":"Jgossip - gossip协议的开源实现","uri":"https://lvsq.net/2019/12/jgossip/","year":"2019"},{"content":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加\nGolang的实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} nodes := []*ListNode{} var carry = 0 for { node, c := add(l1, l2, carry) carry = c if node != nil { nodes = append(nodes, node) if l1 != nil \u0026amp;\u0026amp; l1.Next != nil { l1 = l1.Next } else { l1 = nil } if l2 != nil \u0026amp;\u0026amp; l2.Next != nil { l2 = l2.Next } else { l2 = nil } if carry \u0026gt; 0 \u0026amp;\u0026amp; (l1 == nil \u0026amp;\u0026amp; l2 == nil) { nodes = append(nodes, \u0026amp;ListNode{Val:carry}) } } else { break } } for i, n := range nodes{ if i == 0 { result = n } if i + 1 \u0026lt; len(nodes) { n.Next = nodes[i + 1] } } return result } func add (n1 *ListNode, n2 *ListNode, carry int) (*ListNode, int) { node := \u0026amp;ListNode{} if (n1 == nil \u0026amp;\u0026amp; n2 == nil) { return nil, 0 } if n1 == nil { n1 = \u0026amp;ListNode{Val : 0} } if n2 == nil { n2 = \u0026amp;ListNode{Val : 0} } sum := n1.Val + n2.Val + carry carry = 0 if sum \u0026gt; 9 { carry = 1 sum = sum - 10 } node.Val = sum return node, carry }  下面提供Scheme版本的实现【(1 0) + (9 1 2) = (0 2 2)】，为了简单起见，与题目要求稍有不同，这里采用list，而不是题目要求的链表，但实际上应是一样的。比较之下可以看出，相对而言，Scheme语言的实现更加简短优雅，得益于其强大的表达能力\n(letrec ( [Polishing (lambda (l num) (if (eq? num 0) l (Polishing (append l '(0)) (- num 1))) ) ] [Align (lambda (l1 l2) (let ([len1 (length l1)] [len2 (length l2)]) (if [eq? len1 len2] [list l1 l2] [if (\u0026gt; len1 len2) (list l1 (Polishing l2 (- len1 len2))) (list (Polishing l1 (- len2 len1)) l2)])) ) ] [Add (lambda (l1 l2) (let ([ l (Align l1 l2)]) (Carry (map (lambda (x y) (+ x y)) (car l) (cadr l)) 0) ) ) ] [Carry (lambda (l c) (if (null? l) (if [eq? c 0] '() [cons c l]) (cons (mod ( + (car l) c ) 10) (Carry (cdr l) (quotient ( + (car l) c) 10))) ) ) ]) (Add '(1 0) '(9 1 2)))  Golang版本和Scheme版本的实现思路不相同，简要描述一下后者：\n (1 0) + (9 1 2), 先进行补位： (1 0 0) + (9 1 2), 按顺序相加，得： (10 1 2), 再计算进位： (0 2 2)  ","id":6,"section":"posts","summary":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加 Golang的实现： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result","tags":["Scheme","leetcode"],"title":"两数相加","uri":"https://lvsq.net/2019/12/leetcode-2/","year":"2019"},{"content":" 最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发。\n问题描述 假设我们已经有足够多的1分，2分，5分钱币，任意给定金额比如1元，问有多少种组合方式？ 换言之，$$1x+2y+5z = 100$$ 求x,y,z的解有多少个\n思路 组合方式的总和应为：\n 任意扣去一种钱币比如1分，1元采用2分，5分两种钱币的组合数，再加上：\n 总额为（1元-1分），采用1分，2分，5分三种钱币的组合数；\n  很明显这可以很容易用递归实现\n稍作一点解释：\na. 上面两步的意思是：不带1分的组合数 + 带1分的组合数 = 全部的组合数； 这是显而易见的\nb. 上述第2步，（1元-1分）的意思是：这样可以保证任意一种组合方式再加1分都等于1元，保证至少有1个1分的钱币\n(letrec [ (A (lambda (n d) (if (= 0 (mod n d)) 1 0))) (B (lambda (n d) (cond [(not (pair? d)) 0] [(null? d) 0] [(= 0 n) 1] [(\u0026gt; 0 n) 0] [(= 1 (length d)) (A n (car d))] [else ( + (B n (cdr d)) (B (- n (car d)) d)) ] ) ) ) ] [B 100 '(1 2 5)] )  ","id":7,"section":"posts","summary":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发","tags":["Scheme","SICP"],"title":"钱币组合问题","uri":"https://lvsq.net/2019/12/count-coins/","year":"2019"},{"content":" Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdquo;x-\u0026ldquo;）该如何开发做紧要的介绍。\n一切开始之前，有一点需要keep in mind，即增加扩展的位置不同，所用的方法不同，所以需要对Swagger的标准有所了解，可参考官方文档 springfox目前只允许三种扩展实现:\n ListVendorExtension:列表的形式,该对象支持泛型，最终形式：”x-field”:[{field:value}] ObjectVendorExtension:对象的扩展形式,最终的扩展形式是：”x-field”:[{field:value}] StringVendorExtension:string类型的扩展实现，最终的扩展形式是”x-field”:”value”  Swagger根对象扩展 以在info中添加一个x-logo为例\n\u0026quot;info\u0026quot;: { \u0026quot;description\u0026quot;: \u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;swagger-bootstrap-ui！！！\u0026quot;, \u0026quot;termsOfService\u0026quot;: \u0026quot;http://www.xxx.com/\u0026quot;, \u0026quot;contact\u0026quot;: { \u0026quot;name\u0026quot;: pxxxx@domain.com\u0026quot; }, \u0026quot;x-logo\u0026quot;: { \u0026quot;url\u0026quot;: \u0026quot;http://\u0026quot;, \u0026quot;color\u0026quot;: \u0026quot;#090807\u0026quot; } }, ...  后台代码：\nObjectVendorExtension logo = new ObjectVendorExtension(\u0026quot;x-logo\u0026quot;); logo.addProperty(new StringVendorExtension(\u0026quot;url\u0026quot;, \u0026quot;https://xxx.svg\u0026quot;)); logo.addProperty(new StringVendorExtension(\u0026quot;color\u0026quot;, \u0026quot;#090807\u0026quot;)); return new ApiInfoBuilder() .title(\u0026quot;swagger-bootstrap-ui！！\u0026quot;) .extensions(Lists.newArrayList(logo)) .description(\u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;) .termsOfServiceUrl(\u0026quot;http://www.xxx.com/\u0026quot;) .version(\u0026quot;1.0.0\u0026quot;) .build();  内部对象扩展 给Path添加一个扩展属性x-order为例\n@Component @Order(Ordered.HIGHEST_PRECEDENCE+100) public class OperationPositionBulderPlugin implements OperationBuilderPlugin { @Override public void apply(OperationContext context) { context.operationBuilder().extensions(Lists.newArrayList(new StringVendorExtension(\u0026quot;x-order\u0026quot;,\u0026quot;1\u0026quot;))); } @Override public boolean supports(DocumentationType delimiter) { return true; } }  详细介绍可以参考\n","id":8,"section":"posts","summary":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdq","tags":["swagger","vendorExtensions"],"title":"Swagger 如何使用vendorExtensions进行扩展","uri":"https://lvsq.net/2019/11/swagger-vendor/","year":"2019"},{"content":" 秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁，如平原君广纳异国宾客；苏秦上书于七国；荀子遍游天下者皆可证各国文字并无大乖。 《史籀篇》文首盖云“太史籀书”，人多误以太史籀所作，如此便望文生义了。太史乃官职，王国维先生引《说文》解释，籀即读，读即籀书。另太史籀书乃周世之成语，绝非人名。  ","id":9,"section":"posts","summary":"秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁","tags":["文史"],"title":"历史不能碰","uri":"https://lvsq.net/2019/11/do-not-touch-history/","year":"2019"},{"content":" M -\u0026gt; Alt(option) S -\u0026gt; Shift    快捷键 用途     M-v 上（后）一屏   C-v 下（前）一屏   C-l 重绘屏幕，将光标所在行置于屏幕中央   C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符   C-x C-f  查找或者新建一个文件   C-x C-b 列出缓冲区。 C-x 1 关闭缓冲区列表   C-x C-q 开启或者关闭buffer的只读模式   C-x C-s 保存当前文件   C-x s 保存所有文件   C-x h 全选   M-w 复制   C-y 粘贴   C-w 剪切   C-s 往前搜索   C-r 往后搜索. DEL 也可以往后搜索，   C-/ undo   M-x calendar 打开日历。按 q 退出。【g d 到指定日期】【. 到今日（不居中）】【\u0026gt; 前一个月】【\u0026lt; 后一个月】   M-x *-mode 选择Major mode   M-x shell 运行一个shell   M-x eshell 运行一个eshell   C-a 移到行首   C-a C-k、C-S-backspace 删除整行   C-u 5 C-S-backspace、M-5 C-S-backspace 删除后5行，不加数字则删除4行（默认），如果数字为负数，则往前删   C-g 停止当前的命令   C-k 删除从光标位置到行尾所有字符    Org-Mode    快捷键 用途     C-c . 插入时间   C-c C-e 导出其它格式   C-c C-s 在标题下面插入一个带有“==SCHEDULED==”关键字的时间戳。   C-c C-d 在标题下面插入一个带有“==DEADLINE==”关键字的时间戳   C-c C-t 将当前项的状态在（unmarked）-\u0026gt;TODO-\u0026gt;DONE 之间循环切换   M-RET 插入一个同级标题   M-LEFT/RIGHT 将当前的标题提升/降低一个等级   C-c C-c 插入标签tag。 光标在标题中   C-c C-q 插入标签tag。光标在任意位置   C-c , 设置当前标题的优先级,’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的   C-c  查找标签tag   S-Tab 展开所有标题   Tab 展开光标所在标题   C-c C-l 编辑链接   C-c C-o 打开链接    ","id":10,"section":"posts","summary":"M -\u0026gt; Alt(option) S -\u0026gt; Shift 快捷键 用途 M-v 上（后）一屏 C-v 下（前）一屏 C-l 重绘屏幕，将光标所在行置于屏幕中央 C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符 C-x C-f 查","tags":["emacs"],"title":"Emacs","uri":"https://lvsq.net/2019/11/emacs/","year":"2019"},{"content":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。\n (make-engine thunk)\n 通过传递一个无参数的thunk(形实转换程序)给make-engine来创建一个engine。thunk的body是会被engine执行的计算，engine本身是带3个参数的过程：\n ticks： 一个正整数，指定提供给engine的执行时间片（原文用的是fuel这个单词，意思是燃料，正对应这engine的本意，十分贴切）的数量，engine将会执行到时间片用完或者计算完成为止； complete： 一个或多个参数的函数，用于指定计算完成后的操作。它的参数是剩余的时间片数量和计算产生的值； expire： 一个参数的函数，该函数指定如果在计算完成之前时间片用完了该怎么办。它的参数是一个能从中断点继续进行计算的新引擎。  将引擎应用于其参数时，它将开启一个时长为ticks的计时器，如果引擎计算在计时器执行之前完成，系统将调用complete，并将剩余的ticks和计算产生的值传递给它；\n另一方面，如果计时器在引擎计算完成之前耗尽了，则系统会从中断计算的continuation中创建一个新引擎，并使该引擎过期。complete和expire会被新引擎继续使用。If, on the other hand, the timer goes off before the engine computation completes, the system creates a new engine from the continuation of the in- terrupted computation and passes this engine to expire. complete and expire are invoked in the continuation of the engine invocation.\n请勿同时使用计时器中断（set-timer），因为engine就是由计时器实现的。\n看看具体的例子：\n(define eng (make-engine (lambda () 3))) (eng 10 ;; ticks (lambda (ticks value) value) ;; complete (lambda (x) x) ;; expire ) ⇒ 3  通常将列表作为完整过程传递给引擎，使引擎完成时返回一个列表，该列表的第一个元素是剩余的ticks，另一个元素是计算返回的值，这通常很有用。\n(define eng (make-engine (lambda () 3))) (eng 10 list (lambda (x) x)) ⇒ (9 3)  在上面的示例中，计算值为3，还剩下9个时间片，即，需要一单位的时间片来计算出3。\n再看一个复杂点的例子： 先定义一个计算裴波那切值的函数\n(define fibonacci (lambda (n) (let fib ([i n]) (cond [(= i 0) 0] [(= i 1) 1] [else (+ (fib (- i 1)) (fib (- i 2)))]))))  创建engine\n(define eng (make-engine (lambda () (fibonacci 10))))  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ (21 55)  每次时间片（燃料）用完时，到期程序都会将eng分配给新引擎。整个计算需要4个blocks，每个block包含50个ticks。最后50个燃料中，有21个都用掉了。因此，使用的燃料总量为179个。\n我们还可以统计一下消耗的ticks数量\n(define mileage (lambda (thunk) (let loop ([eng (make-engine thunk)] [total-ticks 0]) (eng 50 (lambda (ticks . values) (+ total-ticks (- 50 ticks))) (lambda (new-eng) (loop new-eng (+ total-ticks 50))))))) (mileage (lambda () (fibonacci 10))) ⇒ 179  再看看一个例子——round-robin:\n(define round-robin (lambda (engs) (if (null? engs) '() ((car engs) 1 ;;ticks (lambda (ticks value) (cons value (round-robin (cdr engs)))) ;;complete (lambda (eng) ;;expire (round-robin (append (cdr engs) (list eng)))))))) (round-robin (map (lambda (x) (make-engine (lambda () (fibonacci x)))) '(4 5 2 8 3 7 6 2))) ⇒ (1 1 2 3 5 8 13 21)  这段代码需要费些思量，首先map函数创建了8个engine, 然后代入round-robin函数，该函数依次执行各个engine，但是每个engine分配的时间片只有1，对于参数\u0026rsquo;(4 5 2 8 3 7 6 2)，数字越小，越先执行完成，所以越早执行complete函数，最终结果就是排好顺序的了，很棒的程序！\n","id":11,"section":"posts","summary":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。 (make-engine thunk) 通过传递一个无参数的thun","tags":["engine","scheme"],"title":"Engine in Scheme","uri":"https://lvsq.net/2019/12/engine-in-scheme/","year":"2019"},{"content":" case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Scheme提供了case语法来处理这种情况，这与Java中的switch语法非常相似。\n我们来看看case的语法：\n (case expr0 clause1 clause2 \u0026hellip;)\n 除了最后一个clause之外，每个子句都必须采用以下形式之一：\n ((key \u0026hellip;) expr1 expr2 \u0026hellip;) (key expr1 expr2 \u0026hellip;)  每一个key值都应该是不同的，最后一个子句要么是上述那种形式，或者是一个像下面这样的else子句\n (else expr1 expr2 \u0026hellip;)  那么返回值是什么呢？\n匹配到某个key的或者else中的最后一个expr的值\n(define p (lambda (x) (case x [(\u0026quot;abc\u0026quot; \u0026quot;def\u0026quot;) 'one '1] [((a b c)) 'two] [else #f]))) (p (string #\\d #\\e #\\f)) ⇒ 1 (p '(a b c)) ⇒ two (p \u0026quot;eee\u0026quot;) ⇒ #f  上面的例子定义了一个函数p，接收一个参数x\n 如果x为字符串\u0026rdquo;abc\u0026rdquo;或者\u0026rdquo;def\u0026rdquo;，则返回1； 如果x为列表((a b c)，则返回two 其他情况返回#f  可见，有了case语法多条件判断写起来就方便很多，并且代码也容易读了，当然这里也可以用cond来写，这里只是为了描述case的语法而没有使用cond\n再看一个例子，就不用解释了：\n(let ([ls '(ii iv)]) (case (cadr ls) [i 1] [ii 2] [iii 3] [(iiii iv) 4] [else 'out-of-range])) ⇒ 4  record-case 来看看另一个很类似的扩展，也十分有用，它就是record-case。它可以以record为单位来做条件判断并执行指令。\n语法格式：  (record-case expr clause1 clause2 \u0026hellip;)\n 除了最后一个子句之外，每个clause的格式如下：\n ((key \u0026hellip;) formals body1 body2 \u0026hellip;)\n 每一个*key*都不应该相同, 最后一个clause可能是上述的格式或者是一个else子句：\n (else body1 body2 \u0026hellip;)\n expr必须是一个pair。Chez会拿(car expr)与各个子句中的key进行比较（用eqv?）来确定哪一个clause匹配, 然后(cdr expr)将与formals绑定。\n来看换一个例子：\n(define calc (lambda (x) (record-case x [(add) (x y) (+ x y)] [(sub) (x y) (- x y)] [(mul) (x y) (* x y)] [(div) (x y) (/ x y)] [else (assertion-violationf 'calc \u0026quot;invalid expression ~s\u0026quot; x)]))) (calc '(add 3 4)) =\u0026gt; 7 (calc '(div 3 4)) =\u0026gt; 3/4  ","id":12,"section":"posts","summary":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Schem","tags":["chez","scheme"],"title":"Chez Scheme中的case扩展","uri":"https://lvsq.net/2019/12/case-in-chez-scheme/","year":"2019"},{"content":" 易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴至，克尽其用，上下一体，俱不倦而事可毕矣 周云成康，汉言文景。无有六十年与民休息，累藏蓄积，汉武开疆之功便是空文，此厚积薄发耳，俗语言，胳膊收回来，打出去才有力  ","id":13,"section":"posts","summary":"易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴","tags":["随想"],"title":"继学录","uri":"https://lvsq.net/2019/12/think/","year":"2019"},{"content":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。\n先看看该语法描述：\n(fluid-let ((var expr) \u0026hellip;) body1 body2 \u0026hellip;) returns: the values of the body body1 body2 \u0026hellip; libraries: (chezscheme)\n该Binding的作用类似局部变量，与set! 比较相似。由fluid-let定义的变量必须已绑定到顶层(top level)或者封闭的lambda内或者其他形式的绑定，这很关键！\n请看代码：\n(let ([x 3]) (+ (fluid-let ([x 5]) x) x)) ⇒ 8  先定义变量x=3，然后在加法操作当中临时将x的值改为5，最后结果为8，如果将fluid-let中的x换个名字，比如y，将如何呢？\n会得到一个异常：\n Exception: variable y is not bound\n y没有绑定，是的，y即没有在顶层中被定义，也未在某个lambda中或者任何其他形式，这里只能是x\n再学习下两个例子，加深印象：\n(let ([x 'a]) (letrec ([f (lambda (y) (cons x y))]) (fluid-let ([x 'b]) (f 'c)) )) ⇒ (b . c)  (let ([x 'a]) (call/cc (lambda (k) (fluid-let ([x 'b]) (letrec ([f (lambda (y) (k '*))]) (f '*))))) x) ⇒ a  ","id":14,"section":"posts","summary":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。 先看看该语法描","tags":["fluid-let","Scheme"],"title":"Fluid Binding in Chez Scheme","uri":"https://lvsq.net/2019/12/fluid-binding/","year":"2019"},{"content":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。\n这是语法描述：\n(rec var expr) syntax\nreturns: value of expr\nlibraries: (chezscheme)\nThe syntactic form rec creates a recursive object from expr by establishing a binding of var within expr to the value of expr. In essence, it is a special case of letrec for self-recursive objects.\nThis form is useful for creating recursive objects (especially procedures) that do not depend on external variables for the recursion, which are sometimes undesirable because the exter-nal bindings can change. For example, a recursive procedure defined at top level depends on the value of the top-level variable given as its name. If the value of this variable should change, the meaning of the procedure itself would change. If the procedure is defined instead with rec, its meaning is independent of the variable to which it is bound.\n简要翻译一下：\n语法rec 通过在expr中建立var与expr的值的绑定，创建一个递归对象。从本质上讲，这是letrec用于自递归对象的一种特殊情况。\n语法rec通过绑定expr中创建一个递归对象，用来 这种形式对于创建不依赖于外部变量进行递归的递归对象（尤其是过程）很有用，因为外部绑定可能会发生变化，所以有时这是不可取的。\n看一个例子来感受一下：\n给定一个全是数字的list，对于每一个数字n，算出$1+2+\u0026hellip;+n$的和，最终返回和的list.\n(map (rec sum (lambda (x) (if (= x 0) 0 (+ x (sum (- x 1)))))) ’(0 1 2 3 4 5)) ⇒ (0 1 3 6 10 15)  如果没有rec语法，用letrec也是可以的，但是稍显麻烦，代码也多一些，所以rec还是很好用的\n最后看一下rec语法的定义：\n(define-syntax rec (syntax-rules () [(_ x e) (letrec ((x e)) x)]))  ","id":15,"section":"posts","summary":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。 这是语法描述： (rec","tags":["Scheme","Chez","rec"],"title":"Recursive Bindings in Chez Scheme","uri":"https://lvsq.net/2019/12/recursive-bindings/","year":"2019"},{"content":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些时间，动手写了一个，目前已经在公司内部运行了几年，效果良好，并且已经开源在Github上，以飨各位。\n特点：\n API简洁 支持3种事件：\n UP DOWN JOIN  基于Vert.X\n  引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lvsq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jgossip\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  一个简单的例子：\nint gossip_port = 60001; String cluster = \u0026quot;gossip_cluster\u0026quot;; GossipSettings settings = new GossipSettings(); settings.setGossipInterval(1000); try { String myIpAddress = InetAddress.getLocalHost().getHostAddress(); List\u0026lt;SeedMember\u0026gt; seedNodes = new ArrayList\u0026lt;\u0026gt;(); SeedMember seed = new SeedMember(); seed.setCluster(cluster); seed.setIpAddress(myIpAddress); seed.setPort(60001); seedNodes.add(seed); gossipService = new GossipService(cluster, myIpAddress, gossip_port, null, seedNodes, settings, (member, state) -\u0026gt;System.out.println(\u0026quot;member:\u0026quot; + member + \u0026quot; state: \u0026quot; + state)); } catch (Exception e) { e.printStackTrace(); } gossipService.start();  详细介绍请看 =\u0026gt; 项目地址\n欢迎大家fork， 如果觉得好请start ~~~\n","id":16,"section":"posts","summary":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些","tags":["jgossip","gossip"],"title":"Jgossip - gossip协议的开源实现","uri":"https://lvsq.net/2019/12/jgossip/","year":"2019"},{"content":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加\nGolang的实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} nodes := []*ListNode{} var carry = 0 for { node, c := add(l1, l2, carry) carry = c if node != nil { nodes = append(nodes, node) if l1 != nil \u0026amp;\u0026amp; l1.Next != nil { l1 = l1.Next } else { l1 = nil } if l2 != nil \u0026amp;\u0026amp; l2.Next != nil { l2 = l2.Next } else { l2 = nil } if carry \u0026gt; 0 \u0026amp;\u0026amp; (l1 == nil \u0026amp;\u0026amp; l2 == nil) { nodes = append(nodes, \u0026amp;ListNode{Val:carry}) } } else { break } } for i, n := range nodes{ if i == 0 { result = n } if i + 1 \u0026lt; len(nodes) { n.Next = nodes[i + 1] } } return result } func add (n1 *ListNode, n2 *ListNode, carry int) (*ListNode, int) { node := \u0026amp;ListNode{} if (n1 == nil \u0026amp;\u0026amp; n2 == nil) { return nil, 0 } if n1 == nil { n1 = \u0026amp;ListNode{Val : 0} } if n2 == nil { n2 = \u0026amp;ListNode{Val : 0} } sum := n1.Val + n2.Val + carry carry = 0 if sum \u0026gt; 9 { carry = 1 sum = sum - 10 } node.Val = sum return node, carry }  下面提供Scheme版本的实现【(1 0) + (9 1 2) = (0 2 2)】，为了简单起见，与题目要求稍有不同，这里采用list，而不是题目要求的链表，但实际上应是一样的。比较之下可以看出，相对而言，Scheme语言的实现更加简短优雅，得益于其强大的表达能力\n(letrec ( [Polishing (lambda (l num) (if (eq? num 0) l (Polishing (append l '(0)) (- num 1))) ) ] [Align (lambda (l1 l2) (let ([len1 (length l1)] [len2 (length l2)]) (if [eq? len1 len2] [list l1 l2] [if (\u0026gt; len1 len2) (list l1 (Polishing l2 (- len1 len2))) (list (Polishing l1 (- len2 len1)) l2)])) ) ] [Add (lambda (l1 l2) (let ([ l (Align l1 l2)]) (Carry (map (lambda (x y) (+ x y)) (car l) (cadr l)) 0) ) ) ] [Carry (lambda (l c) (if (null? l) (if [eq? c 0] '() [cons c l]) (cons (mod ( + (car l) c ) 10) (Carry (cdr l) (quotient ( + (car l) c) 10))) ) ) ]) (Add '(1 0) '(9 1 2)))  Golang版本和Scheme版本的实现思路不相同，简要描述一下后者：\n (1 0) + (9 1 2), 先进行补位： (1 0 0) + (9 1 2), 按顺序相加，得： (10 1 2), 再计算进位： (0 2 2)  ","id":17,"section":"posts","summary":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加 Golang的实现： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result","tags":["Scheme","leetcode"],"title":"两数相加","uri":"https://lvsq.net/2019/12/leetcode-2/","year":"2019"},{"content":" 最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发。\n问题描述 假设我们已经有足够多的1分，2分，5分钱币，任意给定金额比如1元，问有多少种组合方式？ 换言之，$$1x+2y+5z = 100$$ 求x,y,z的解有多少个\n思路 组合方式的总和应为：\n 任意扣去一种钱币比如1分，1元采用2分，5分两种钱币的组合数，再加上：\n 总额为（1元-1分），采用1分，2分，5分三种钱币的组合数；\n  很明显这可以很容易用递归实现\n稍作一点解释：\na. 上面两步的意思是：不带1分的组合数 + 带1分的组合数 = 全部的组合数； 这是显而易见的\nb. 上述第2步，（1元-1分）的意思是：这样可以保证任意一种组合方式再加1分都等于1元，保证至少有1个1分的钱币\n(letrec [ (A (lambda (n d) (if (= 0 (mod n d)) 1 0))) (B (lambda (n d) (cond [(not (pair? d)) 0] [(null? d) 0] [(= 0 n) 1] [(\u0026gt; 0 n) 0] [(= 1 (length d)) (A n (car d))] [else ( + (B n (cdr d)) (B (- n (car d)) d)) ] ) ) ) ] [B 100 '(1 2 5)] )  ","id":18,"section":"posts","summary":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发","tags":["Scheme","SICP"],"title":"钱币组合问题","uri":"https://lvsq.net/2019/12/count-coins/","year":"2019"},{"content":" Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdquo;x-\u0026ldquo;）该如何开发做紧要的介绍。\n一切开始之前，有一点需要keep in mind，即增加扩展的位置不同，所用的方法不同，所以需要对Swagger的标准有所了解，可参考官方文档 springfox目前只允许三种扩展实现:\n ListVendorExtension:列表的形式,该对象支持泛型，最终形式：”x-field”:[{field:value}] ObjectVendorExtension:对象的扩展形式,最终的扩展形式是：”x-field”:[{field:value}] StringVendorExtension:string类型的扩展实现，最终的扩展形式是”x-field”:”value”  Swagger根对象扩展 以在info中添加一个x-logo为例\n\u0026quot;info\u0026quot;: { \u0026quot;description\u0026quot;: \u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;swagger-bootstrap-ui！！！\u0026quot;, \u0026quot;termsOfService\u0026quot;: \u0026quot;http://www.xxx.com/\u0026quot;, \u0026quot;contact\u0026quot;: { \u0026quot;name\u0026quot;: pxxxx@domain.com\u0026quot; }, \u0026quot;x-logo\u0026quot;: { \u0026quot;url\u0026quot;: \u0026quot;http://\u0026quot;, \u0026quot;color\u0026quot;: \u0026quot;#090807\u0026quot; } }, ...  后台代码：\nObjectVendorExtension logo = new ObjectVendorExtension(\u0026quot;x-logo\u0026quot;); logo.addProperty(new StringVendorExtension(\u0026quot;url\u0026quot;, \u0026quot;https://xxx.svg\u0026quot;)); logo.addProperty(new StringVendorExtension(\u0026quot;color\u0026quot;, \u0026quot;#090807\u0026quot;)); return new ApiInfoBuilder() .title(\u0026quot;swagger-bootstrap-ui！！\u0026quot;) .extensions(Lists.newArrayList(logo)) .description(\u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;) .termsOfServiceUrl(\u0026quot;http://www.xxx.com/\u0026quot;) .version(\u0026quot;1.0.0\u0026quot;) .build();  内部对象扩展 给Path添加一个扩展属性x-order为例\n@Component @Order(Ordered.HIGHEST_PRECEDENCE+100) public class OperationPositionBulderPlugin implements OperationBuilderPlugin { @Override public void apply(OperationContext context) { context.operationBuilder().extensions(Lists.newArrayList(new StringVendorExtension(\u0026quot;x-order\u0026quot;,\u0026quot;1\u0026quot;))); } @Override public boolean supports(DocumentationType delimiter) { return true; } }  详细介绍可以参考\n","id":19,"section":"posts","summary":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdq","tags":["swagger","vendorExtensions"],"title":"Swagger 如何使用vendorExtensions进行扩展","uri":"https://lvsq.net/2019/11/swagger-vendor/","year":"2019"},{"content":" 秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁，如平原君广纳异国宾客；苏秦上书于七国；荀子遍游天下者皆可证各国文字并无大乖。 《史籀篇》文首盖云“太史籀书”，人多误以太史籀所作，如此便望文生义了。太史乃官职，王国维先生引《说文》解释，籀即读，读即籀书。另太史籀书乃周世之成语，绝非人名。  ","id":20,"section":"posts","summary":"秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁","tags":["文史"],"title":"历史不能碰","uri":"https://lvsq.net/2019/11/do-not-touch-history/","year":"2019"},{"content":" M -\u0026gt; Alt(option) S -\u0026gt; Shift    快捷键 用途     M-v 上（后）一屏   C-v 下（前）一屏   C-l 重绘屏幕，将光标所在行置于屏幕中央   C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符   C-x C-f  查找或者新建一个文件   C-x C-b 列出缓冲区。 C-x 1 关闭缓冲区列表   C-x C-q 开启或者关闭buffer的只读模式   C-x C-s 保存当前文件   C-x s 保存所有文件   C-x h 全选   M-w 复制   C-y 粘贴   C-w 剪切   C-s 往前搜索   C-r 往后搜索. DEL 也可以往后搜索，   C-/ undo   M-x calendar 打开日历。按 q 退出。【g d 到指定日期】【. 到今日（不居中）】【\u0026gt; 前一个月】【\u0026lt; 后一个月】   M-x *-mode 选择Major mode   M-x shell 运行一个shell   M-x eshell 运行一个eshell   C-a 移到行首   C-a C-k、C-S-backspace 删除整行   C-u 5 C-S-backspace、M-5 C-S-backspace 删除后5行，不加数字则删除4行（默认），如果数字为负数，则往前删   C-g 停止当前的命令   C-k 删除从光标位置到行尾所有字符    Org-Mode    快捷键 用途     C-c . 插入时间   C-c C-e 导出其它格式   C-c C-s 在标题下面插入一个带有“==SCHEDULED==”关键字的时间戳。   C-c C-d 在标题下面插入一个带有“==DEADLINE==”关键字的时间戳   C-c C-t 将当前项的状态在（unmarked）-\u0026gt;TODO-\u0026gt;DONE 之间循环切换   M-RET 插入一个同级标题   M-LEFT/RIGHT 将当前的标题提升/降低一个等级   C-c C-c 插入标签tag。 光标在标题中   C-c C-q 插入标签tag。光标在任意位置   C-c , 设置当前标题的优先级,’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的   C-c  查找标签tag   S-Tab 展开所有标题   Tab 展开光标所在标题   C-c C-l 编辑链接   C-c C-o 打开链接    ","id":21,"section":"posts","summary":"M -\u0026gt; Alt(option) S -\u0026gt; Shift 快捷键 用途 M-v 上（后）一屏 C-v 下（前）一屏 C-l 重绘屏幕，将光标所在行置于屏幕中央 C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符 C-x C-f 查","tags":["emacs"],"title":"Emacs","uri":"https://lvsq.net/2019/11/emacs/","year":"2019"}],"tags":[{"title":"about","uri":"https://lvsq.net/tags/about/"},{"title":"chez","uri":"https://lvsq.net/tags/chez/"},{"title":"emacs","uri":"https://lvsq.net/tags/emacs/"},{"title":"engine","uri":"https://lvsq.net/tags/engine/"},{"title":"fluid-let","uri":"https://lvsq.net/tags/fluid-let/"},{"title":"gossip","uri":"https://lvsq.net/tags/gossip/"},{"title":"jgossip","uri":"https://lvsq.net/tags/jgossip/"},{"title":"leetcode","uri":"https://lvsq.net/tags/leetcode/"},{"title":"rec","uri":"https://lvsq.net/tags/rec/"},{"title":"Scheme","uri":"https://lvsq.net/tags/scheme/"},{"title":"SICP","uri":"https://lvsq.net/tags/sicp/"},{"title":"swagger","uri":"https://lvsq.net/tags/swagger/"},{"title":"vendorExtensions","uri":"https://lvsq.net/tags/vendorextensions/"},{"title":"文史","uri":"https://lvsq.net/tags/%E6%96%87%E5%8F%B2/"},{"title":"随想","uri":"https://lvsq.net/tags/%E9%9A%8F%E6%83%B3/"}]}