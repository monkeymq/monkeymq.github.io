{"categories":[{"title":"Chez","uri":"https://lvsq.net/categories/chez/"},{"title":"Java","uri":"https://lvsq.net/categories/java/"},{"title":"LeetCode","uri":"https://lvsq.net/categories/leetcode/"},{"title":"Scheme","uri":"https://lvsq.net/categories/scheme/"},{"title":"tool","uri":"https://lvsq.net/categories/tool/"},{"title":"历史","uri":"https://lvsq.net/categories/%E5%8E%86%E5%8F%B2/"}],"posts":[{"content":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。\n先看看该语法描述：\n(fluid-let ((var expr) \u0026hellip;) body1 body2 \u0026hellip;) returns: the values of the body body1 body2 \u0026hellip; libraries: (chezscheme)\n该Binding的作用类似局部变量，与set! 比较相似。由fluid-let定义的变量必须已绑定到顶层(top level)或者封闭的lambda内或者其他形式的绑定，这很关键！\n请看代码：\n(let ([x 3]) (+ (fluid-let ([x 5]) x) x)) ⇒ 8  先定义变量x=3，然后在加法操作当中临时将x的值改为5，最后结果为8，如果将fluid-let中的x换个名字，比如y，将如何呢？\n会得到一个异常：\n Exception: variable y is not bound\n y没有绑定，是的，y即没有在顶层中被定义，也未在某个lambda中或者任何其他形式，这里只能是x\n再学习下两个例子，加深印象：\n(let ([x ’a]) (letrec ([f (lambda (y) (cons x y))]) (fluid-let ([x ’b]) (f ’c)) )) ⇒ (b . c)  (let ([x ’a]) (call/cc (lambda (k) (fluid-let ([x ’b]) (letrec ([f (lambda (y) (k ’*))]) (f ’*))))) x) ⇒ a  ","id":0,"section":"posts","summary":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。 先看看该语法描","tags":["fluid-let","Scheme"],"title":"Fluid Binding in Chez Scheme","uri":"https://lvsq.net/2019/12/fluid-binding/","year":"2019"},{"content":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。\n这是语法描述：\n(rec var expr) syntax\nreturns: value of expr\nlibraries: (chezscheme)\nThe syntactic form rec creates a recursive object from expr by establishing a binding of var within expr to the value of expr. In essence, it is a special case of letrec for self-recursive objects.\nThis form is useful for creating recursive objects (especially procedures) that do not depend on external variables for the recursion, which are sometimes undesirable because the exter-nal bindings can change. For example, a recursive procedure defined at top level depends on the value of the top-level variable given as its name. If the value of this variable should change, the meaning of the procedure itself would change. If the procedure is defined instead with rec, its meaning is independent of the variable to which it is bound.\n简要翻译一下：\n语法rec 通过在expr中建立var与expr的值的绑定，创建一个递归对象。从本质上讲，这是letrec用于自递归对象的一种特殊情况。\n语法rec通过绑定expr中创建一个递归对象，用来 这种形式对于创建不依赖于外部变量进行递归的递归对象（尤其是过程）很有用，因为外部绑定可能会发生变化，所以有时这是不可取的。\n看一个例子来感受一下：\n给定一个全是数字的list，对于每一个数字n，算出$1+2+\u0026hellip;+n$的和，最终返回和的list.\n(map (rec sum (lambda (x) (if (= x 0) 0 (+ x (sum (- x 1)))))) ’(0 1 2 3 4 5)) ⇒ (0 1 3 6 10 15)  如果没有rec语法，用letrec也是可以的，但是稍显麻烦，代码也多一些，所以rec还是很好用的\n最后看一下rec语法的定义：\n(define-syntax rec (syntax-rules () [(_ x e) (letrec ((x e)) x)]))  ","id":1,"section":"posts","summary":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。 这是语法描述： (rec","tags":["Scheme","Chez","rec"],"title":"Recursive Bindings in Chez Scheme","uri":"https://lvsq.net/2019/12/recursive-bindings/","year":"2019"},{"content":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些时间，动手写了一个，目前已经在公司内部运行了几年，效果良好，并且已经开源在Github上，以飨各位。\n特点：\n API简洁 支持3种事件：\n UP DOWN JOIN  基于Vert.X\n  引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lvsq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jgossip\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  一个简单的例子：\nint gossip_port = 60001; String cluster = \u0026quot;gossip_cluster\u0026quot;; GossipSettings settings = new GossipSettings(); settings.setGossipInterval(1000); try { String myIpAddress = InetAddress.getLocalHost().getHostAddress(); List\u0026lt;SeedMember\u0026gt; seedNodes = new ArrayList\u0026lt;\u0026gt;(); SeedMember seed = new SeedMember(); seed.setCluster(cluster); seed.setIpAddress(myIpAddress); seed.setPort(60001); seedNodes.add(seed); gossipService = new GossipService(cluster, myIpAddress, gossip_port, null, seedNodes, settings, (member, state) -\u0026gt;System.out.println(\u0026quot;member:\u0026quot; + member + \u0026quot; state: \u0026quot; + state)); } catch (Exception e) { e.printStackTrace(); } gossipService.start();  详细介绍请看 =\u0026gt; 项目地址\n欢迎大家fork， 如果觉得好请start ~~~\n","id":2,"section":"posts","summary":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些","tags":["jgossip","gossip"],"title":"Jgossip - gossip协议的开源实现","uri":"https://lvsq.net/2019/12/jgossip/","year":"2019"},{"content":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加\nGolang的实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} nodes := []*ListNode{} var carry = 0 for { node, c := add(l1, l2, carry) carry = c if node != nil { nodes = append(nodes, node) if l1 != nil \u0026amp;\u0026amp; l1.Next != nil { l1 = l1.Next } else { l1 = nil } if l2 != nil \u0026amp;\u0026amp; l2.Next != nil { l2 = l2.Next } else { l2 = nil } if carry \u0026gt; 0 \u0026amp;\u0026amp; (l1 == nil \u0026amp;\u0026amp; l2 == nil) { nodes = append(nodes, \u0026amp;ListNode{Val:carry}) } } else { break } } for i, n := range nodes{ if i == 0 { result = n } if i + 1 \u0026lt; len(nodes) { n.Next = nodes[i + 1] } } return result } func add (n1 *ListNode, n2 *ListNode, carry int) (*ListNode, int) { node := \u0026amp;ListNode{} if (n1 == nil \u0026amp;\u0026amp; n2 == nil) { return nil, 0 } if n1 == nil { n1 = \u0026amp;ListNode{Val : 0} } if n2 == nil { n2 = \u0026amp;ListNode{Val : 0} } sum := n1.Val + n2.Val + carry carry = 0 if sum \u0026gt; 9 { carry = 1 sum = sum - 10 } node.Val = sum return node, carry }  下面提供Scheme版本的实现【(1 0) + (9 1 2) = (0 2 2)】，为了简单起见，与题目要求稍有不同，这里采用list，而不是题目要求的链表，但实际上应是一样的。比较之下可以看出，相对而言，Scheme语言的实现更加简短优雅，得益于其强大的表达能力\n(letrec ( [Polishing (lambda (l num) (if (eq? num 0) l (Polishing (append l '(0)) (- num 1))) ) ] [Align (lambda (l1 l2) (let ([len1 (length l1)] [len2 (length l2)]) (if [eq? len1 len2] [list l1 l2] [if (\u0026gt; len1 len2) (list l1 (Polishing l2 (- len1 len2))) (list (Polishing l1 (- len2 len1)) l2)])) ) ] [Add (lambda (l1 l2) (let ([ l (Align l1 l2)]) (Carry (map (lambda (x y) (+ x y)) (car l) (cadr l)) 0) ) ) ] [Carry (lambda (l c) (if (null? l) (if [eq? c 0] '() [cons c l]) (cons (mod ( + (car l) c ) 10) (Carry (cdr l) (quotient ( + (car l) c) 10))) ) ) ]) (Add '(1 0) '(9 1 2)))  Golang版本和Scheme版本的实现思路不相同，简要描述一下后者：\n (1 0) + (9 1 2), 先进行补位： (1 0 0) + (9 1 2), 按顺序相加，得： (10 1 2), 再计算进位： (0 2 2)  ","id":3,"section":"posts","summary":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加 Golang的实现： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result","tags":["Scheme","leetcode"],"title":"两数相加","uri":"https://lvsq.net/2019/12/leetcode-2/","year":"2019"},{"content":" 最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发。\n问题描述 假设我们已经有足够多的1分，2分，5分钱币，任意给定金额比如1元，问有多少种组合方式？ 换言之，$$1x+2y+5z = 100$$ 求x,y,z的解有多少个\n思路 组合方式的总和应为：\n 任意扣去一种钱币比如1分，1元采用2分，5分两种钱币的组合数，再加上：\n 总额为（1元-1分），采用1分，2分，5分三种钱币的组合数；\n  很明显这可以很容易用递归实现\n稍作一点解释：\na. 上面两步的意思是：不带1分的组合数 + 带1分的组合数 = 全部的组合数； 这是显而易见的\nb. 上述第2步，（1元-1分）的意思是：这样可以保证任意一种组合方式再加1分都等于1元，保证至少有1个1分的钱币\n(letrec [ (A (lambda (n d) (if (= 0 (mod n d)) 1 0))) (B (lambda (n d) (cond [(not (pair? d)) 0] [(null? d) 0] [(= 0 n) 1] [(\u0026gt; 0 n) 0] [(= 1 (length d)) (A n (car d))] [else ( + (B n (cdr d)) (B (- n (car d)) d)) ] ) ) ) ] [B 100 '(1 2 5)] )  ","id":4,"section":"posts","summary":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发","tags":["Scheme","SICP"],"title":"钱币组合问题","uri":"https://lvsq.net/2019/12/count-coins/","year":"2019"},{"content":" Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdquo;x-\u0026ldquo;）该如何开发做紧要的介绍。\n一切开始之前，有一点需要keep in mind，即增加扩展的位置不同，所用的方法不同，所以需要对Swagger的标准有所了解，可参考官方文档 springfox目前只允许三种扩展实现:\n ListVendorExtension:列表的形式,该对象支持泛型，最终形式：”x-field”:[{field:value}] ObjectVendorExtension:对象的扩展形式,最终的扩展形式是：”x-field”:[{field:value}] StringVendorExtension:string类型的扩展实现，最终的扩展形式是”x-field”:”value”  Swagger根对象扩展 以在info中添加一个x-logo为例\n\u0026quot;info\u0026quot;: { \u0026quot;description\u0026quot;: \u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;swagger-bootstrap-ui！！！\u0026quot;, \u0026quot;termsOfService\u0026quot;: \u0026quot;http://www.xxx.com/\u0026quot;, \u0026quot;contact\u0026quot;: { \u0026quot;name\u0026quot;: pxxxx@domain.com\u0026quot; }, \u0026quot;x-logo\u0026quot;: { \u0026quot;url\u0026quot;: \u0026quot;http://\u0026quot;, \u0026quot;color\u0026quot;: \u0026quot;#090807\u0026quot; } }, ...  后台代码：\nObjectVendorExtension logo = new ObjectVendorExtension(\u0026quot;x-logo\u0026quot;); logo.addProperty(new StringVendorExtension(\u0026quot;url\u0026quot;, \u0026quot;https://xxx.svg\u0026quot;)); logo.addProperty(new StringVendorExtension(\u0026quot;color\u0026quot;, \u0026quot;#090807\u0026quot;)); return new ApiInfoBuilder() .title(\u0026quot;swagger-bootstrap-ui！！\u0026quot;) .extensions(Lists.newArrayList(logo)) .description(\u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;) .termsOfServiceUrl(\u0026quot;http://www.xxx.com/\u0026quot;) .version(\u0026quot;1.0.0\u0026quot;) .build();  内部对象扩展 给Path添加一个扩展属性x-order为例\n@Component @Order(Ordered.HIGHEST_PRECEDENCE+100) public class OperationPositionBulderPlugin implements OperationBuilderPlugin { @Override public void apply(OperationContext context) { context.operationBuilder().extensions(Lists.newArrayList(new StringVendorExtension(\u0026quot;x-order\u0026quot;,\u0026quot;1\u0026quot;))); } @Override public boolean supports(DocumentationType delimiter) { return true; } }  详细介绍可以参考\n","id":5,"section":"posts","summary":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdq","tags":["swagger","vendorExtensions"],"title":"Swagger 如何使用vendorExtensions进行扩展","uri":"https://lvsq.net/2019/11/swagger-vendor/","year":"2019"},{"content":" 秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁，如平原君广纳异国宾客；苏秦上书于七国；荀子遍游天下者皆可证各国文字并无大乖。 《史籀篇》文首盖云“太史籀书”，人多误以太史籀所作，如此便望文生义了。太史乃官职，王国维先生引《说文》解释，籀即读，读即籀书。另太史籀书乃周世之成语，绝非人名。  ","id":6,"section":"posts","summary":"秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁","tags":["历史"],"title":"历史不能碰","uri":"https://lvsq.net/2019/11/do-not-touch-history/","year":"2019"},{"content":" M -\u0026gt; Alt(option) S -\u0026gt; Shift    快捷键 用途     M-v 上（后）一屏   C-v 下（前）一屏   C-l 重绘屏幕，将光标所在行置于屏幕中央   C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符   C-x C-f  查找或者新建一个文件   C-x C-b 列出缓冲区。 C-x 1 关闭缓冲区列表   C-x C-q 开启或者关闭buffer的只读模式   C-x C-s 保存当前文件   C-x s 保存所有文件   C-x h 全选   M-w 复制   C-y 粘贴   C-w 剪切   C-s 往前搜索   C-r 往后搜索. DEL 也可以往后搜索，   C-/ undo   M-x calendar 打开日历。按 q 退出。【g d 到指定日期】【. 到今日（不居中）】【\u0026gt; 前一个月】【\u0026lt; 后一个月】   M-x *-mode 选择Major mode   M-x shell 运行一个shell   M-x eshell 运行一个eshell   C-a 移到行首   C-a C-k、C-S-backspace 删除整行   C-u 5 C-S-backspace、M-5 C-S-backspace 删除后5行，不加数字则删除4行（默认），如果数字为负数，则往前删   C-g 停止当前的命令   C-k 删除从光标位置到行尾所有字符    Org-Mode    快捷键 用途     C-c . 插入时间   C-c C-e 导出其它格式   C-c C-s 在标题下面插入一个带有“==SCHEDULED==”关键字的时间戳。   C-c C-d 在标题下面插入一个带有“==DEADLINE==”关键字的时间戳   C-c C-t 将当前项的状态在（unmarked）-\u0026gt;TODO-\u0026gt;DONE 之间循环切换   M-RET 插入一个同级标题   M-LEFT/RIGHT 将当前的标题提升/降低一个等级   C-c C-c 插入标签tag。 光标在标题中   C-c C-q 插入标签tag。光标在任意位置   C-c , 设置当前标题的优先级,’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的   C-c  查找标签tag   S-Tab 展开所有标题   Tab 展开光标所在标题   C-c C-l 编辑链接   C-c C-o 打开链接    ","id":7,"section":"posts","summary":"M -\u0026gt; Alt(option) S -\u0026gt; Shift 快捷键 用途 M-v 上（后）一屏 C-v 下（前）一屏 C-l 重绘屏幕，将光标所在行置于屏幕中央 C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符 C-x C-f 查","tags":["emacs"],"title":"Emacs","uri":"https://lvsq.net/2019/11/emacs/","year":"2019"}],"tags":[{"title":"about","uri":"https://lvsq.net/tags/about/"},{"title":"Chez","uri":"https://lvsq.net/tags/chez/"},{"title":"emacs","uri":"https://lvsq.net/tags/emacs/"},{"title":"fluid-let","uri":"https://lvsq.net/tags/fluid-let/"},{"title":"gossip","uri":"https://lvsq.net/tags/gossip/"},{"title":"jgossip","uri":"https://lvsq.net/tags/jgossip/"},{"title":"leetcode","uri":"https://lvsq.net/tags/leetcode/"},{"title":"rec","uri":"https://lvsq.net/tags/rec/"},{"title":"Scheme","uri":"https://lvsq.net/tags/scheme/"},{"title":"SICP","uri":"https://lvsq.net/tags/sicp/"},{"title":"swagger","uri":"https://lvsq.net/tags/swagger/"},{"title":"vendorExtensions","uri":"https://lvsq.net/tags/vendorextensions/"},{"title":"历史","uri":"https://lvsq.net/tags/%E5%8E%86%E5%8F%B2/"}]}