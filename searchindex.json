{"categories":[{"title":"Chez","uri":"https://lvsq.net/categories/chez/"},{"title":"erlang","uri":"https://lvsq.net/categories/erlang/"},{"title":"golang","uri":"https://lvsq.net/categories/golang/"},{"title":"Java","uri":"https://lvsq.net/categories/java/"},{"title":"leetcode","uri":"https://lvsq.net/categories/leetcode/"},{"title":"lisp","uri":"https://lvsq.net/categories/lisp/"},{"title":"pl","uri":"https://lvsq.net/categories/pl/"},{"title":"racket","uri":"https://lvsq.net/categories/racket/"},{"title":"scheme","uri":"https://lvsq.net/categories/scheme/"},{"title":"science","uri":"https://lvsq.net/categories/science/"},{"title":"tool","uri":"https://lvsq.net/categories/tool/"},{"title":"文史","uri":"https://lvsq.net/categories/%E6%96%87%E5%8F%B2/"}],"posts":[{"content":"模块基础 一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set!\n通常，每个Racket模块驻留在自己的文件中，换句话说，可以认为一个.rkt 文件里的内容属于某一个模块，模块名就是文件名。\n在任意目录下创建一个子目录：mod_demo\n├── mod_demo\n│ ├── ext\n│ │ └── cake.rkt\n│ └── main.rkt\nmod_demo目录下有一个main.rkt模块，和一个ext目录，该目录下有一个cake.rkt的模块。\ncake.rkt的内容如下：\n#lang racket (provide print-cake) (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (provide print-cake) 意味着将函数print-cake导出，在模块外部就可以使用该函数了；还有一个私有的函数show, 该函数未导出，所以外部无法访问。 main.rkt的内容为：\n#lang racket (require \u0026#34;ext/cake.rkt\u0026#34;) (print-cake (random 30)) (require \u0026ldquo;ext/cake.rkt\u0026rdquo;) 将cake模块引入，引用路径符合Unix风格(但是，不能以文件分隔符即'/\u0026lsquo;作为开始或者结束)，也支持相对路径，(require \u0026ldquo;./ext/cake.rkt\u0026rdquo;) 也是完全可以的。\nCollections collection中的模块通过不带引号的、无后缀的路径引用。例如：以下模块引用了作为“racket” collection一部分的“date.rkt”库：\n#lang racket (require racket/date) (printf \u0026#34;Today is ~s\\n\u0026#34; (date-\u0026gt;string (seconds-\u0026gt;date (current-seconds)))) 注意，(require racket/date)没有带双引号。像racket/date这样的模块看起来像一个标识符，当require看到一个未加引号的模块引用时，它会将引用转换为基于collection的模块路径：\n 首先，如果未引用的路径不包含 /，然后 require会自动向引用添加一个“/main”。例如，( require slideshow )等效于( require slideshow/main )。 其次，require 向路径隐式添加了“.rkt”后缀。 最后，require通过在已安装的collection中搜索来解析路径，而不是将路径视为相对于封闭模块的路径。  Packages and Collections 一个package是一组通过Racket包管理器安装的库的集合。Racket 程序不直接引用包。相反，程序通过collections引用库，并且添加或删除包会更改可用的基于集合的库集。\n添加Collections library的旨在跨多个项目使用，因此将库的源文件保存在一个目录中并没有意义，更不能将库复制到不同的项目中使用。在这种情况下，最好的选择是新增一个collection，将lib放在collection中，这样就可以使用不带引号的路径引用它，就像Racket 发行版中包含的库一样。\n不用担心，创建一个包无需提交到公开的包服务器，可以安装到本地来使用。\n 采用raco pkg命令行工具： raco pkg install \u0026ndash;link /path/to/mod_demo\n 安装之后，在任何模块中使用(require mod_demo/ext/cake)都会从/path/to/mod_demo/ext/cake.rkt导入print-cake含函数。\n\u0026gt; (require mod_demo/ext/cake) \u0026gt; (print-cake 4) ...... .-||||||-. | | ------------ \u0026gt; 默认情况下，您安装的目录名称既用作包名称又用作包提供的collection\n将lib放入collection之后，仍然可以使用raco make来编译库的源文件，但是使用raco setup更加方便。尤其是修改了模块代码后，使用raco setup会重新编译所有库文件，并重新安装包。与raco make不同的是，raco setup 后面的参数是包名，即raco setup mod_demo, 而raco make后面是模块名，即raco make main.rkt。\n模块语法 模块文件开头处的#lang其实是模块形式的简写，但不能用于REPL。\n模块形式 普通形式的模块声明，可以工作于REPL\n (module name-id initial-module-path decl \u0026hellip;)\n name-id是模块的名字，initial-module-path 为初始化导入，每个decl可以是导入，或者导出，或者定义，或者表达式。\ninitial-module-path是必须的，模块内部也是一个环境（SICP中的环境，即上下文），内部使用的指令是需要通过initial-module-path引导的。常用的initial-module-path是racket, require/define/provide等等都来自racket。另一个常用的initial-module-path是racket-base,它提供的功能较少，但仍然是很常用。\n上一节中的“cake.rkt”也可以写成：\n(module cake racket (provide print-cake) (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline))) 这种模块形式是可以被REPL求值的（注意(require \u0026lsquo;cake)， 模块名cake需要被quote，因为这时cake是非文件的模块声明）：\n\u0026gt; (require \u0026#39;cake) \u0026gt; (print-cake 3) ... .-|||-. | | --------- 声明一个模块，其body不会被立刻求值，只有在显式地被require之后才会求值一次。\n\u0026gt; (module hi racket (printf \u0026#34;Hello\\n\u0026#34;)) \u0026gt; (require \u0026#39;hi) Hello \u0026gt; (require \u0026#39;hi) #lang #lang声明的模块的body没有特定的语法，因为其语法由#lang之后的名称所决定。\n比如，#lang racket的语法是：\n#lang racket decl ... 等同于：\n(module name racket decl ...) name是包含#lang形式的文件名\n子模块 一个模块可以嵌套在另一个模块中，父模块可以直接访问子模块导出的函数、定义、表达式。\n#lang racket (module zoo racket (provide tiger) (define tiger \u0026#34;Tony\u0026#34;)) (require \u0026#39;zoo) tiger module* module*形式类似module：\n(module* name-id initial-module-path-or-#f decl ...) module*与module的不同之处在于：\n 由module声明的子模块，可以被其父模块require, 但是子模块不能require父模块； 由module*声明的字模块，可以require父模块，但是父模块不能require该子模块；  此外，module*形式可以用#f代替initial-module-path，这意味着，子模块可以访问父模块所以绑定，包括未通过provide导出的绑定。\n因此，用module*和#f来声明一个模块的一个用途是，将某个模块未provide出去的绑定导出。\n#lang racket (provide print-cake) (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (module* extras #f (provide show)) 尽管show函数未导出，但是子模块extras却将其导出了，外部程序可以使用(require (submod \u0026ldquo;caske.rkt\u0026rdquo; extras))来访问隐藏的show函数。\nMain和Test子模块 #lang racket (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (module* main #f (print-cake 10)) 这个“cake.rkt”变体，包含了一个main子模块，并调用了print-cake函数。\n一般来说，运行一个模块时并不会运行其中由module*声明的子模块，但是main子模块除外。\nmain子模块并不一定由module*声明，如果不需要使用父模块的绑定，也可以由module来声明。 更常见的做法是由module+来声明\n(module+ name-id decl ...) module+声明的模块就像采用module*声明且使用#f作为initial-module-path的模块。此外，多个module+模块可以同名，同名的模块会组合成一个模块。这种组合特性可以用来定义一个test模块，在使用 raco test命令时就可以大显身手了。\n假设\u0026quot;physics.rkt\u0026quot; 为：\n#lang racket (module+ test (require rackunit) (define ε 1e-10)) (provide drop to-energy) (define (drop t) (* 1/2 9.8 t t)) (module+ test (check-= (drop 0) 0 ε) (check-= (drop 10) 490 ε)) (define (to-energy m) (* m (expt 299792458.0 2))) (module+ test (check-= (to-energy 0) 0 ε) (check-= (to-energy 1) 9e+16 1e+15)) 导入\u0026quot;physics.rkt\u0026quot; 时，并不会运行drop和to-energy的测试，不过运行raco test physics.rkt将会执行这些测试。\n这等价于使用module*:\n#lang racket (provide drop to-energy) (define (drop t) (* 1/2 49/5 t t)) (define (to-energy m) (* m (expt 299792458 2))) (module* test #f (require rackunit) (define ε 1e-10) (check-= (drop 0) 0 ε) (check-= (drop 10) 490 ε) (check-= (to-energy 0) 0 ε) (check-= (to-energy 1) 9e+16 1e+15)) module+的组合行为对main模块也有帮助，即使不需要组合， ( module+ main \u0026hellip;. )也是首选，因为它比( module* main #f \u0026hellip;. )更具可读性 。\nRequire require的定义为：\n (require require-spec \u0026hellip;)\n only-in 用来限制模块导出的绑定，也可重命名绑定\n\u0026gt; (module m (lib \u0026#34;racket\u0026#34;) (provide tastes-great? less-filling?) (define tastes-great? #t) (define less-filling? #t)) \u0026gt; (require (only-in \u0026#39;m tastes-great?)) \u0026gt; tastes-great? #t \u0026gt; less-filling? less-filling?: undefined; cannot reference an identifier before its definition in module: top-level \u0026gt; (require (only-in \u0026#39;m [less-filling? lite?])) \u0026gt; lite? #t except-in 是only-in的补充，用来排除某些绑定\n (except-in require-spec id \u0026hellip;)\n rename-in 与only-in类似。\n (rename-in require-spec [orig-id bind-id] \u0026hellip;)\n prefix-in  (prefix-in prefix-id require-spec) 给每一个require-spec的绑定添加前缀\n Provide  (provide provide-spec \u0026hellip;)\n provide-spec允许递归定义：\n id: 最简单的形式，上文中多次出现\n  (rename-out [orig-id export-id] \u0026hellip;): 重命名导出的绑定\n  (struct-out struct-id): 导出struct\n  (all-defined-out): 导出所有绑定，不推荐\n  (all-from-out module-path): 导出所有由module-path指定的绑定\n  (except-out provide-spec id \u0026hellip;): 排除id指定的绑定\n  (prefix-out prefix-id provide-spec)：给每个导出绑定添加一个前缀\n ","id":0,"section":"posts","summary":"模块基础 一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set! 通常，每个Racket模块驻留在自己的文件中，换句话说，可以","tags":["racket","module"],"title":"Racket Modules","uri":"https://lvsq.net/2021/07/racket-modules/","year":"2021"},{"content":"这是一个leet code出现的问题:\n 给 n 个非负整数 $a_1$，$a_2$，\u0026hellip;，$a_n$，每个数代表坐标中的一个点(i, $a_i$) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i, $a_i$) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n  说明：不能倾斜容器\n 更详细的描述请访问：https://leetcode-cn.com/problems/container-with-most-water/\n首先可以想到的最简单的方法，就是暴力求解，将所有的面积都计算出来，取最大值即可。下面给出(Racket)[https://racket-lang.org/]的代码，得益于函数式语言和S表达式强大的表现力，代码可以很短：\n(define/contract (max-area height) (-\u0026gt; (listof exact-integer?) exact-integer?) (define len (length height)) (cond ((\u0026lt; len 2) 0) ((= len 2) (area (list 1 (car height)) (list 2 (cadr height)))) (else (max (each-area height) (max-area (cdr height)))))) (define (area n1 n2) (* (- (car n2) (car n1)) (min (cadr n1) (cadr n2)))) (define (each-area height) (let ([first (list 1 (car height))]) (foldl max 0 (map (lambda (i h) (area first (list i h))) (range 2 (add1 (length height)) ) (cdr height))))) 上述解法虽然正确，但是效率很低, 如果有10000个整数，即n=10000，其执行时间超过了2秒：\n(time (max-area (build-list 10000 (lambda(x) (random 1000000))))) =\u0026gt; cpu time: 2387 real time: 2466 gc time: 137 那么有更好的解决方法吗？\n显然可以认为所有整数都保存在一个列表或者数组中，假设我们有两个指针，一个叫head，指向第一个整数, 表示为：head -\u0026gt; (i, $h_i$)，i为列表下标， $h_i$代表第i个整数值；另一个叫tail，指向最后一个整数，表示为tail -\u0026gt; (j, $h_j$)，我们可以仅仅利用这两个指针的移动，就能计算出最大的面积，其过程为：\n 计算由head和tail围成的矩形的面积$S_{ij}$, 矩形的长度x = j - i, 高度y = min ($h_i$, $h_j$); 将矩形收窄一格，即x减少1，那么有两种收窄方式：  将高度短的一侧收窄，那么，收窄后高度可能变大，则面积可能增大; 将高度长的一侧收窄，由于另一侧不变,但是长度变小了一格，则面积会变小;   因此，需要移动高度短的一侧，才有可能找到面积更大的矩形  很显然，使用双指针算法，时间复杂度降低到了$O(n)$。\nRacket 版本 ;;better solution (define/contract (max-area-pair-pointer height) (-\u0026gt; (listof exact-integer?) exact-integer?) (define (area n1 n2) (* (- (car n2) (car n1)) (min (cadr n1) (cadr n2)))) (let ([len (length height)]) (if (\u0026lt; len 2) 0 (let loop ([h height] [hindex (range 0 len)] [rheight (reverse height)] [rindex (reverse (range 0 len))] [maxa 0]) (let* ([head (list (car hindex) (car h))] [tail (list (car rindex) (car rheight))] [a (area head tail)]) (if (= (car head) (car tail)) maxa (if (\u0026gt; (cadr head) (cadr tail)) (loop h hindex (cdr rheight) (cdr rindex) (max maxa a)) (loop (cdr h) (cdr hindex) rheight rindex (max maxa a))) )))))) 如果使用这个方法计算10000个整数的面积，执行时间只需1毫秒，而且不需要GC（对照暴力破解版本，2+秒）\n(time (max-area-pair-pointer (build-list 10000 (lambda(x) (random 1000000))))) =\u0026gt; cpu time: 1 real time: 1 gc time: 0 Rust版本 同时提供一个Rust版本的实现，\nuse std::cmp::{max, min}; type HeightType = i64; #[derive(Debug)] struct Solution {} impl Solution { pub fn max_area(height: Vec\u0026lt;HeightType\u0026gt;) -\u0026gt; HeightType { let len = height.len(); return if len \u0026lt; 2 { 0 } else { let mut max_area = 0; let mut hi = 0; let mut ti = len - 1; while ti \u0026gt; hi { let hd = height.get(hi).unwrap(); let td = height.get(ti).unwrap(); let a = ((ti - hi) as HeightType) * min(hd, td); max_area = max(max_area, a); if hd \u0026lt; td { hi += 1; } else { ti -= 1; } } max_area }; } } 两个版本做一个简单的比较：\n   size Racket(8.0 CS) Rust(1.50.0)     100000 49ms 60ms   1000000 560ms 550ms   10000000 5s 5.6s    两个版本的实现均未使用编译器优化,令人意外的是Racket的执行效率与Rust几乎没有差别，使用了CS编译器的Racket真是突飞猛进。 由于我的Rust经验并不是很多，或许有更好的写法。从测试可以看到Racket至少在CPU密集型应用中可堪大用。\n","id":1,"section":"posts","summary":"这是一个leet code出现的问题: 给 n 个非负整数 $a_1$，$a_2$，\u0026hellip;，$a_n$，每个数代表坐标中的一个点(i, $a_i$) 。在","tags":[],"title":"【盛最多水的容器】问题的求解","uri":"https://lvsq.net/2021/05/container-with-most-water/","year":"2021"},{"content":"神经科学家发现，解释代码可以激活通用的大脑网络，但不能激活语言处理中心。\n安妮·特拉夫顿 | 麻省理工学院新闻办公室 发布日期：2020年12月15日\n 在某些方面，学习计算机编程与学习新语言相似。它需要学习新的符号和术语，必须正确组织这些符号和术语以指导计算机该怎么做。计算机代码还必须足够清晰，以便其他程序员可以阅读和理解。\n尽管存在这些相似之处，麻省理工学院的神经科学家发现，阅读计算机代码并不能激活与语言处理有关的大脑区域。取而代之的是，它激活了一个称为多需求网络的分布式网络，该网络也被招募用于解决复杂的认知任务，例如解决数学问题或填字游戏。\n但是，尽管阅读计算机代码会激活多需求网络，但与数学或逻辑问题相比，它似乎更多地依赖于网络的不同部分，这表明编码也不能精确地复制数学的认知需求。\n“理解计算机代码似乎是自己的事。它与语言不同，数学与逻辑也不相同。”麻省理工学院研究生，该研究的主要作者安娜·伊凡诺娃（Anna Ivanova）说。\nEvelina Fedorenko，Frederick A.和Carole J. Middleton职业发展神经科学副教授，麦戈文脑科学研究所的成员，是该论文的高级作者，该论文今天发表在eLife上。麻省理工学院计算机科学与人工智能实验室和塔夫茨大学的研究人员也参与了这项研究。\n语言与认知 Fedorenko研究的主要重点是语言与其他认知功能之间的关系。特别是，她一直在研究其他功能是否依赖于大脑的语言网络（包括Broca区域和大脑左半球的其他区域）的问题。在先前的工作中，她的实验室表明，音乐和数学似乎并未激活该语言网络。\n“在这里，我们有兴趣探索语言和计算机编程之间的关系，部分原因是计算机编程是一个新发明，我们知道不可能有任何硬连线机制使我们成为优秀的程序员，”伊万诺娃说。\n她说，关于大脑如何学习编码，存在两种思想流派。有人认为，要精通编程，就必须精通数学。另一个建议认为，由于编码和语言之间的相似性，语言技能可能更相关。为了阐明这一问题，研究人员着手研究在阅读计算机代码时大脑活动模式是否会与语言相关的大脑活动重叠。\n研究人员在本研究中重点关注以可读性着称的两种编程语言——Python和ScratchJr。ScratchJr这是一种专为5岁及5岁以上儿童设计的可视化编程语言。研究对象均为精通测试语言的年轻人。当程序员躺在功能磁共振（fMRI）扫描仪中时，研究人员向他们展示了代码片段，并要求他们预测代码将产生什么动作。\n研究人员几乎看不到大脑语言区域对代码的反应。相反，他们发现编码任务主要激活了所谓的多需求网络。这个网络的活动遍布整个大脑的额叶和顶叶，通常是为需要同时记住许多信息的任务而招募的，它负责我们执行各种心理任务的能力。\n伊万诺娃说：“它所做的几乎所有在认知上都具有挑战性的事情，使您难以思考。”\n先前的研究表明，数学和逻辑问题似乎主要取决于左半球的多个需求区域，而涉及空间导航的任务比右半球更多地激活右半球。麻省理工学院的研究小组发现，读取计算机代码似乎可以激活多需求网络的左侧和右侧，而ScratchJr激活右侧的程度要比左侧高一些。这一发现违背了数学和编码依赖相同大脑机制的假设。\n经验的影响 研究人员说，尽管他们没有发现任何似乎专门用于编程的区域，但是这种具有特殊脑活动的区域可能会在具有更多编码经验的人中发展。\nFedorenko说：“如果您聘用了以30年或40年的特定语言编写代码的专业程序员的人，您可能会开始看到某些专业化知识，或者是多个需求系统某些部分的结晶”，Fedorenko说。“对于那些熟悉编码并且可以有效地完成这些任务，但经验相对有限的人来说，似乎您还看不到任何专业化知识。”\n约翰·霍普金斯大学的一组研究人员在同一期eLife上发表的一篇伴随论文中也报告说，解决代码问题可以激活多需求网络而不是语言区域。\n研究结果表明，对于编码应该以基于数学的技能还是基于语言的技能进行教授，尚无定论。研究人员说，部分原因是因为学习编程可能会同时依赖语言和多种需求系统，即使—一旦学会了编程，就不会依赖语言区域。\n伊万诺娃说：“两个阵营都宣称，它必须与数学结合在一起，必须与语言结合在一起。” “但是看来，计算机科学教育者将不得不开发自己的方法来最有效地教授代码。”\n全文完。\n 如果您想看原文，可以访问：链接\n","id":2,"section":"posts","summary":"神经科学家发现，解释代码可以激活通用的大脑网络，但不能激活语言处理中心。 安妮·特拉夫顿 | 麻省理工学院新闻办公室 发布日期：2020年12月15","tags":[],"title":"对大脑而言，阅读计算机代码与阅读语言不同","uri":"https://lvsq.net/2020/12/brain-reading-computer-code/","year":"2020"},{"content":"作者\nMATTHEW FLATT, University of Utah,USACANER DERICI, Indiana University, USAR. KENT DYBVIG, Cisco Systems, Inc., USAANDREW W. KEEP, Cisco Systems, Inc., USAGUSTAVO E. MASSACCESI, Universidad de Buenos Aires, ArgentinaSARAH SPALL, Indiana University, USASAM TOBIN-HOCHSTADT, Indiana University, USAJON ZEPPIERI, independent researcher, USA 概要\n我们在Chez Scheme上重建了Racket，并且运行良好——只要对Chez Scheme进行一些修补，就可以运行DrRacket。Racket发行版可以自行构建，并且几乎所有核心​​的Racket测试套件都可以通过。尽管仍有一些工作可以提高端到端的性能，但最终的实现还是不错的。我们评估的最不可预测的部分是，Racket和Chez Scheme之间的不同将变得多大，以及我们如何处理这些不同。我们希望Racket CS成为主要的Racket实现，并且我们鼓励其他语言实现者将Chez Scheme视为目标虚拟机。\n 该文详细地介绍了Racket CS是如何构建的，以及与Chez Scheme之间的差异， 完整内容见(https://dl.acm.org/doi/epdf/10.1145/3341642)\n","id":3,"section":"posts","summary":"作者 MATTHEW FLATT, University of Utah,USACANER DERICI, Indiana University, USAR. KENT DYBVIG, Cisco Systems, Inc., USAANDREW W. KEEP, Cisco Systems, Inc., USAGUSTAVO E. MASSACCESI, Universidad de Buenos Aires, ArgentinaSARAH SPALL, Indiana University, USASAM TOBIN-HOCHSTADT, Indiana University, USAJON ZEPPIERI, independent researcher, USA 概要 我们在Chez Scheme上重建了Racket，并且","tags":["pl"],"title":"基于Chez Scheme重建Racket","uri":"https://lvsq.net/2020/10/rebuilding-racket/","year":"2020"},{"content":"我相信每一位程序员在学习或者实践编程时，都会遇到作用域的问题。您可能觉得作用域很简单，甚至都不能当做一个问题来看待，我想原因可能是目前主流的计算机语言Java, Python, C等等几乎一致采用Lexical Scoping,程序员没有机会察觉到异样，从而掩盖了还有其他作用域的事实，许多教科书也很配合地一笔带过，当然还有一种可能是您已经洞察了不同作用域的差异和内涵，自觉地规避了问题。我衷心的希望所有程序员都是第二种可能。\n本文将浅显地描述两种作用域的特点及差异，希望可以解释地清楚一点，如果读完之后您更加模糊了，请记住，这并非我的本意。\n在计算机编程中，名称绑定的作用域（名称与实体的关联，比如变量）是程序中名称绑定有效的部分，也就是说，该名称可以被引用到一个实体。程序的其他部分，名称可能指向不同的实体（它可能具有不同的绑定），或者根本什么都没有（它可能是未绑定的）。作用域也称为实体的可见性， 尤其在较早的技术文献中可见，这是从所引用的实体的角度出发，而非引用的名称。\n术语\u0026quot;scope\u0026ldquo;也用于指代程序中有效的名称绑定的那部分集合，更加正确的称呼应该是上下文 或者 环境\n Lexical Scoping 词法作用域，某些书中也叫静态作用域，其在编写代码时或者说定义时就确定的，通过文本（源代码）就可以观察到名称与实体的关联，程序运行时会在距离被调用代码最近的环境中去查找绑定，如果存在多个环境，在优先从最里面一层的环境查找。\n来看一个例子：\n(setf x 1) ;; bind x to 1 (setq f (let ((x 2)) ;; bind x to 2 (lambda (y) (* x y)))) (funcall f 3) ;; result is 6 (format t \u0026#34;X = ~d \u0026#34; x) ;; X = 1 先绑定x为1，然后定义一个函数f，f中的变量x绑定为2，实际上f形成了一个闭包，由于两个x的环境不同，所以互不干扰，结果正是我们期望的，这就属于词法作用域。\nDynamic Scoping 动态作用域曾经让很多人深恶痛绝，以至于不愿意再提起它。早期的Lisp普遍使用了动态作用域，并带来了非常严重的问题，这也是Lisp Machine被Unix打败的除了商业因素之外的重要原因，Lisp至今未成为主流语言就不难理解了，尽管Lisp的语法最精炼、最优美，还具有最强悍的宏系统，还是世界上第一个使用GC的语言\u0026hellip;\n庆幸的是，Scheme, Common Lisp等Lisp方言已经都是用了Lexial Scoping（局部变量。所以某些时候我们可以把Lexical Scoping和Local Variable等价）, 我们无需再为一些莫名其妙的问题而烦恼，珍惜生命，不是吗？ 不过Scheme, Common Lisp还是保留了动态作用域的操作，Scheme可以参考Fluid Binding, Common Lisp的动态作用域将在后文举例说明，尽管如此，我们无需为这个保留担忧，因为基本上我们很少需要使用到这个功能。\n所谓dynamic scoping就是说，在函数定义中存在了“自由变量”（free variable）, 会在运行时随着函数的“调用位置”不同而发生变化，还是用上面的例子来说明，但是稍作变化：\n(defvar x 1) ;; bind x to 1, x is a free variable (setq f (let ((x 2)) ;; bind x to 2 (lambda (y) (* x y)))) (funcall f 3) (format t \u0026#34;X = ~d \u0026#34; x) (let ((x 100)) (format t \u0026#34;Inner X is ~d \u0026#34; x)) (defvar x 1)定义了x，值为1，但是这个x属于自由变量，处于动态作用域，因为Lisp自动将全局变量即由defvar、defparameter、special定义的变量自动声明为动态作用域。 x对于(lambda (y) (* x y))来说是“ **自由** ” 的，它可不会在意x绑定为2或者任何其他值，因为(let ((x 2)) \u0026hellip;)中指定的x已经不是(lambda \u0026hellip;)的参数了。\n所以当我们执行(funcall f 3) 时，其结果不像词法作用域那样等于6，而是3\n(format t \u0026ldquo;X = ~d \u0026quot; x) 依然输出： X = 1\n(let ((x 100)) (format t \u0026ldquo;Inner X is ~d \u0026quot; x)) 输出为：Inner X is 100。 等等，这里的x为什么又是100了？ 还记得上文提到的环境 吗？！\n如果将函数f放到不同的位置执行会发生什么？ 上面(funcall f 3)是在顶层执行的，我们换到let中执行会怎么样？\n(let ((x 2)) (funcall f 3)) 这次居然返回6，而不是3了。\n看到问题了吗？函数f的行为，会随着调用位置的一个名叫x的变量的值的不同而变化。虽然都叫x，但并不是同一个变量，只是名字相同而已。顺带提一句，现在可以理解Java中namespace的用处了吧。\n 词法作用域是通过搜索本地词法上下文解决的，而动态作用域是通过搜索本地执行上下文（即位置）解决的。这是编译器必须面对并解决的问题，或许编写程序时无需过多关注，但是多了解一下一定大有裨益。尽管动态作用域存在很大问题，但它并非洪水猛兽，它可以使全局变量更易于管理；假设您希望临时改变自由变量的值时，也可以声明为dynamic socping；另外在异常处理中也可以使用动态作用域将处理程序与异常相关联。\n","id":4,"section":"posts","summary":"我相信每一位程序员在学习或者实践编程时，都会遇到作用域的问题。您可能觉得作用域很简单，甚至都不能当做一个问题来看待，我想原因可能是目前主流的","tags":["lexical","scoping"],"title":"Lexical Scoping and Dynamic Scoping","uri":"https://lvsq.net/2020/09/lexical-dynamic-scoping/","year":"2020"},{"content":"快速排序是一种常见的排序手段，由C.A.R.Hoare在1960年提出。其基本思路为：\n  设定一个分界值，通常为第一个元素；\n  遍历列表，将所有小于分界值的元素集中到列表的左侧，所有大于或等于分界值的元素集中到右侧；\n  分别对左侧和右侧的元素进行快排；\n  重复上述的步骤，排序完成；\n  在平均状况下，排序n个元素需要$O(nlog n)$复杂度，最坏情况下需要$O(n^2)$,但一般很少出现这种情况。\n从算法的原理可以看出，需要多次执行重复的操作，自然采用递归可以减少很多代码，若问递归技术哪家强？首屈一指Lisp,下面给出CL版本的快排实现（简易版本，只支持数字类型的列表，其他类型的排序只需增加一个比较函数即可，本文不扩展）：\n(defun quickSort (lst) (let ( (len (list-length lst)) (st (lambda (l pk) ;; st函数实现上述第2步 (let ((left nil) (right nil)) (dolist (each l) (if (\u0026lt; each pk) (push each left) (push each right))) (values left right) ) ) ) ) (if (\u0026lt; len 2) lst (multiple-value-bind (l r) (st (cdr lst) (car lst)) (append (quickSort l) (cons (car lst) (quickSort r)))) ) ) ) (quickSort \u0026#39;(1 2 6 3 5 4)) =\u0026gt; (1 2 3 4 5 6) st函数可以用宏来实现：\n(defmacro st (lst pk) (let ((gslist (gensym))) `(let ((,gslist ,lst)) (let ((left nil) (right nil)) (dolist (each ,gslist) (if (\u0026lt; each ,pk) (push each left) (push each right))) (values left right) ) ) ) ) (defun quickSort (lst) (let ( (len (list-length lst)) ) (if (\u0026lt; len 2) lst (multiple-value-bind (l r) (st (cdr lst) (car lst)) (append (quickSort l) (cons (car lst) (quickSort r)))) ) ) ) ","id":5,"section":"posts","summary":"快速排序是一种常见的排序手段，由C.A.R.Hoare在1960年提出。其基本思路为： 设定一个分界值，通常为第一个元素； 遍历列表，将所有小于","tags":["lisp"],"title":"快速排序（Lisp版本）","uri":"https://lvsq.net/2020/07/quick-sort-in-cl/","year":"2020"},{"content":"讲故事并不是我擅长的事情，不过事情总有一个开始，诸位看官莫嫌我絮烦，只是希望可以讲述的更有条理一些。某日正读一本关于Erlang的书，书中出了一个关于八皇后的题目，这是计算机科学中经典的问题，当年上学时曾绞尽脑汁仍然云山雾罩，不得其解。如今再次相遇，岂能再坐壁上观？！更何况手边已有趁手的兵器。试看Erlang的实现：\n-module(queens). -export([queens/1]). queens(0) -\u0026gt; [[]]; queens(N) -\u0026gt; [[Row | Columns] || Columns \u0026lt;- queens(N - 1), Row \u0026lt;- lists:seq(1, 8) -- Columns, safe(Row, Columns, 1)]. safe(_Row, [], _N) -\u0026gt; true; safe(Row, [Column | Columns], N) -\u0026gt; (Row /= Column + N) andalso (Row /= Column - N) andalso safe(Row, Columns, (N + 1)). 从头至尾10行代码，如果不是为了使代码美观，6行足矣（这还包括了**-module** 和**-export** 两行声明语法，与算法本身无关的代码）。如此简短尽然可以清晰地实现复杂的**八皇后** 问题，如果采用命令式程序语言得写多少行？本文的重点不在于比较这个，Erlang是一门非常强大的语言，对于我来说Erlang好比探春，但是Scheme才是林黛玉呀，所以毫不迟疑用Scheme来实现：\n(define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence)))) ) (define (enumerate-interval low high) (if (\u0026gt; low high) \u0026#39;() (cons low (enumerate-interval (+ low 1) high))) ) (define (flatmap proc seq) (accumulate append \u0026#39;() (map proc seq)) ) (define empty-board \u0026#39;()) (define (safe? k position) (let loop ([new-queen (car position)] [rest-queens (cdr position)] [i 1]) (if (null? rest-queens) #t (let ([rest-current-queen (car rest-queens)]) (if (or (= new-queen rest-current-queen) (= new-queen (+ rest-current-queen i)) (= new-queen (- rest-current-queen i)) ) #f (loop new-queen (cdr rest-queens) (+ i 1)) ) ) ) ) ) (define (adjoin-position new-row k rest-of-queens) (cons new-row rest-of-queens) ) (define (queens board-size) (define (queen-cols k) (if (= k 0) (list empty-board) (filter (lambda (position) (safe? k position)) ;过滤无效的解 (flatmap (lambda (rest-of-queens) (map (lambda (new-row) ;扩充（k-1）个皇后的每一个解，给每个解都增加第k个皇后 (adjoin-position new-row k rest-of-queens)) (enumerate-interval 1 board-size) ) ) (queen-cols (- k 1)) ;前（k-1）个有效的皇后，虽然是太虚幻境，但可以认为是事实 ) ) ) ) (queen-cols board-size) ) Scheme版本比Erlang版本代码增加了不少，原因在于其没有模式匹配 和列表推导 这两大利器，不过我更喜欢Scheme强大的表现力，可以随心所欲地构造我需要的一切，而且S-表达式看起来十分优美自然。Scheme版本实际上解决了n-皇后，更进一步了。\n事情到这里并没有结束，原因在于我刚开始实现Scheme版本的八皇后时，选择翻译Erlang代码，最终失败了！一番挣扎之后，意识到该问题属于非确定性计算，猛然想起《SICP》中有一节专门介绍了此种计算，也即本文的主角——amb\n 非确定性计算 amb这个名字源于ambiguous ,其含义并不是很好理解。一番披肝沥胆之后，终于窥到了一些门径，趁机厘清很多知识点。我将尽力平铺直述，简要的介绍这种强大且十分有用的武器。\n首先，我们来观察一个问题：\n 假设有两个数组，数组中都是一些正整数，比如l1 = [1 2 3 4 5], l2 = [3 4 6 7 8]，我们分别从l1和l2中各取一个数字，相加之后，如果是素数，则满足要求。怎么办呢？\n 对于这个简单的问题，相信难不倒大家，采用回溯算法轻易就解决了，这里只是想引出“非确定性计算”的概念。非确定性计算和流处理类似，对于“生成和检测式”的应用特别有价值，它往往只描述问题，但没有描述问题的解决方法，这句话很有意思，如果暂时没有理解不用着急，继续往下看。\n对于非确定性计算，首先需要明确的一点是，表达式是允许存在多个值的，比如上面的问题的解至少有(1 4),(2 3)两个解吧。\n有一件很有教益的事情，那就是非确定性计算和流处理对于时间的不同看法。流处理利用了惰性求值，这会给我们一种错觉，仿佛所有可能的结果的出现没有时间顺序；对于非确定性的求值，一个表达式是对一个可能的世界的探索，每一个值都由一次选择所确定，某些选择会走入死胡同，而另一些会得到有用的值，所以非确定性计算给我们的感觉是，时间是有分支的。程序当中会保存所有可能的不同执行历史，在遇到一个死胡同时，总是可以回到以前的选择点，并沿着另一个分支继续下去。\n下面将要实现的非确定性求值器称为——amb求值器\namb求值器 假设目前已经扩充了Scheme以支持非确定性计算，引入了一种新的称为amb的新形式，表达式 $(amb \u0026lt;e_1\u0026gt; \u0026lt;e_2\u0026gt; \u0026hellip; \u0026lt;e_n\u0026gt;)$ 会“有歧义地”返回n个表达式之一的值，比如：\n(list (amb 1 2 3) (amb \u0026#39;a \u0026#39;b)) 可以有如下6个可能的值：(1 a) (1 b) (2 a) (2 b) (3 a) (3 b)\n对于没有选项的amb，即(amb) ——视为没有可接收值的表达式，这将导致求值“fail”。\namb求值器在每个选择点，总是选择第一个可能性，如果选择的结果失败，那么求值器自动地回溯到最近的选择点，去尝试下一个可能性。如果它用完了所以的可能性，则自动退回到上一个选择点，并从那里继续（这个“继续”很有意思，后文会看到，“继续”不但是结论，还是其实现的方式，一语双关）下去。从这个过程可以看出，这是一种深度优先 算法。\n逻辑谜题 在讨论amb求值器的实现之前，先看一道逻辑谜题：\n 曹操、孙权、刘备、袁绍、马超5人住在一栋5层的楼房里面，每人住一层。曹操不住顶层，孙权不住底层，刘备不住顶层也不住底层，袁绍比刘备高一层，马超与刘备不在相邻的楼层，刘备与孙权也不在相邻的楼层，请问他们各住在哪一层？\n 在没有amb时，代码怎么写呢？恐怕不容易吧。但是现在有了amb求值器，瞬间美好了：\n(define (multiple-dwelling) (let ( [caocao (amb 1 2 3 4 5)] [sunquan (amb 1 2 3 4 5)] [liubei (amb 1 2 3 4 5)] [yuanshao (amb 1 2 3 4 5)] [machao (amb 1 2 3 4 5)] ) (require (distinct? (list caocao sunquan liubei yuanshao machao))) (require (not (= caocao 5))) (require (not (= sunquan 1))) (require (not (= liubei 5))) (require (not (= liubei 1))) (require (\u0026gt; yuanshao liubei)) (require (not (= (abs (- machao liubei)) 1)) (require (not (= (abs (- sunquan liubei)) 1)) (list (list \u0026#39;caocao caocao) (list \u0026#39;sunquan sunquan) (list \u0026#39;liubei liubei) (list \u0026#39;yuanshao yuanshao) (list \u0026#39;machao machao)) ) ) 上述代码只是描述问题的关系，即各个require部分（先不考虑性能问题。还记得上文提到的“描述问题，但没有描述问题的解决方法”吗？），并没有添加什么“处理逻辑”，但是会产生下面结果：\n((caocao 3) (sunquan 2) (liubei 4) (yuanshao 5) (machao 1))\n居然得到了谜题的解，这是什么魔法？？？\namb轻而易举地解决了这种需要大量回溯的问题。\n实现 现在该谈一谈神奇的amb如何实现了吧。前文已经多次提到过，amb求值的过程可能会不断的回溯，这势必导致程序流程的跳转，程序跳转该怎么办呢？函数式语言可没有break,continue之类的语法，因为根本不需要，那么函数式语言有啥？答案是continuation(翻译成继续，或者延续都可以。还记得“一语双关”吗？)\nScheme内置了这个强大的控制抽象，过程名为：call-with-current-continuation， 名字略长，不过一般都是用其缩写：call/cc。囿于篇幅，本文不打算介绍continuation，如果想详细了解它，请自行搜索。\n常规求值器的执行过程有一个参数：执行环境env。amb求值器的执行过程有三个参数，除了执行环境env之外，还有两个continuation过程（一个成功延续、一个失败延续）。对一个表达式进行求值，结束后会调用这两个continuation过程之一：如果此次求值得到了一个结果，则调用成功延续；如果结果是遇到了死胡同，则调用失败延续。\n成功延续的工作是：接受一个值，并将计算进行去下，与这个值一起，成功延续过程还将得到一个另一个失败延续，如果使用该值时遇到了死胡同，则需要调用这个失败延续。\n失败延续的工作是：试探非确定性过程的另一个分支。非确定性计算的最关键的特征，在于表达式可以表示于不同可能性之间的选择。\n我承认有点烧脑，但还算清晰，让递归在脑海中奔涌吧。\n利用宏来简化amb的构造，代码参考这里：\n(define amb-fail \u0026#39;*) (define initialize-amb-fail (lambda () (set! amb-fail (lambda () (error \u0026#34;amb tree exhausted\u0026#34;))))) (initialize-amb-fail) (define-syntax amb (syntax-rules () ((amb alt ...) (let ((prev-amb-fail amb-fail)) ;保存前一个选择点 (call/cc (lambda (sk) ;对于整个amb表达式构造一个sk的contnuation (call/cc (lambda (fk) ;对于每一个amb的选项构造一个fk的continuation (set! amb-fail ;先把amb-fail设置为一个函数，该函数可将amb-fail恢复到进入amb前的值 (lambda () (set! amb-fail prev-amb-fail) (fk \u0026#39;fail)) ) (sk alt) ;立即返回自己的分支的值,从而引起amb表达式中途返回。注意，每一个分支执行时都会引起 amb 立即返回。后面的分支都还没有执行！ ) ) ... (prev-amb-fail) ) ) ) ) ) ) 第一个选项（也可以叫分支）会被立即返回，后面的暂时不执行。假设该值被认为是“无效的（比如应用该值后，执行到(amb)了）”，则执行(prev-amb-fail)，而prev-amb-fail在进入amb的时候被绑定到了amb-fail， 不过amb-fail已被设置成了一个函数：\n(lambda () (set! amb-fail prev-amb-fail) (fk \u0026#39;fail)) 它先把amb-fail设置成prev-amb-fail,也就是进入（amb alt \u0026hellip;）之前的值， 然后用(fk \u0026lsquo;fail)返回\u0026rsquo;fail到分支的continuation，即可以执行下一个分支（下一个选项）了。\n十分精巧的程序！！！\n上述的amb每次只能返回一个结果，如果需要返回所有有效的结果，可以用下面定义的宏：\n(define-syntax bag-of (syntax-rules () ((bag-of e) (let ((prev-amb-fail amb-fail) (results \u0026#39;())) (if (call/cc (lambda (k) (set! amb-fail (lambda () (k #f))) ;\u0026lt;-----+ (let ((v e)) ;amb-fail will be modified by e | (set! results (cons v results)) ;| (k #t)))) ;| (amb-fail)) ;so this amb-fail may not be ---+ (set! amb-fail prev-amb-fail) (reverse! results))))) (bag-of (let ([a (amb 1 2 3)] [b (amb 0 -1 2)]) (if (= (+ a b) 1) (list a b) (amb)) )) ;结果为：((1 0) (2 -1)) 回到n-皇后问题 到目前为止，我已手握amb这把利器，是时候重构一下n-皇后问题了。\n(define number-between (lambda (lo hi) (let loop ((i lo)) (if (\u0026gt; i hi) (amb) (amb i (loop (+ i 1))))))) ; (amb 1 (amb 2 (amb 3 ... ))) (define (n-queens n) (call/cc (lambda (return) (let add-queen ([i 0] [result \u0026#39;()]) (when (\u0026lt; i n) ;最多摆几个皇后 (let ([new-queen (number-between 1 n)]) (if (safe? n (append (list new-queen) result)) ;新加入的皇后必须是有效的 (add-queen (+ i 1) (append (list new-queen) result)) (amb)) ) ) (return result) ) ) ) ) (bag-of (n-queens 8)) ;8个皇后的所有解 该版本比之前的Scheme版本的实现改进了很多，现在只需要描述一下我的问题的关系即可，程序会自动选择所有正确的值，无需关心计算机内部到底发生了什么。在面对很多逻辑问题时，我们可以很轻松地解决了。\n也许有人会问，如果采用命令式语言来处理的话，可能几个嵌套的循环也能达到相同的结果，如此大费周章的介绍这个叫amb的技术，到底有什么价值呢？ 那就来聊一聊。\n有什么意义？ 在谈论意义之前，容许我提一个问题\n 为什么SQL语言要设计成这样？与命令式语言如此的不同？\n 首先需要明确的一点是，计算机科学处理的是命令式（怎样做）的知识，而数学处理的是说明式（是什么）的知识。 事实上，人类不可能只面临其中一种问题，程序设计中一个重要的分支就是逻辑程序设计，有很多问题或者数据之间存在着关联关系，难以观测到结论，描述它们的关系很简单，但是直接告诉计算机如何去做却不那么容易，或许我们可以为若干此类问题编写命令式代码，但是不可能对所有这样的问题都编写代码，显然信息之间的关系是多种多样的，那么代码就需要相应的变化，往往修改这样的代码是很困难的， 甚至需要重新设计并编码。另一方面，如果程序设计可以处理说明式的知识，岂不是大大减轻了程序员的工作了呢？函数式语言的设计是基于lambda理论，围绕着数学函数值的计算组织起来的，依靠其强大的表现力，在处理逻辑问题上更加得心应手，可以化繁为简。\n说到这里，是不是觉得，保存在数据库中的数据之间存在着种种联系呢？SQL正是描述了这种关系，我们只需要告诉数据库我们需要什么数据（select）, 数据在什么位置（from）, 哪些是有意义的（where）就行了，并不需要告诉数据库该如何具体操作，数据库可以根据我们的描述（SQL）就能够准确的返回结果，这真是关于非确定性计算的一个极好的例子，此时我们总该明白为什么数据库叫做关系型数据库 了吧。我们不妨设想一下，如果不采用描述的方式来查询数据，程序员们该怎么做？还能够轻易的查找到需要的数据吗？\n刚才我提出的问题，想必此刻应该有答案了。\n","id":6,"section":"posts","summary":"讲故事并不是我擅长的事情，不过事情总有一个开始，诸位看官莫嫌我絮烦，只是希望可以讲述的更有条理一些。某日正读一本关于Erlang的书，书中出","tags":["scheme"],"title":"从“八皇后”到amb","uri":"https://lvsq.net/2020/05/n-queens/","year":"2020"},{"content":"作者是 Francesco Cesarini \u0026amp; Gabor Olah\n 任何编程语言在Erlang生态系统中的成功都可以分为三个紧密耦合的组件。它们是：1）Erlang编程语言的语义，并在其上实现其他语言2）用于构建可伸缩和弹性并发系统的OTP库和中间件，以及3）与语言语义紧密耦合的BEAM虚拟机和OTP。单独使用这些组件中的任何一个，您将获得亚军。但是，将这三个因素放在一起，您将获得可伸缩，灵活的软实时系统的无可争议的赢家。引用Joe Armstrong的话：“您可以复制Erlang库，但是如果它不能在BEAM上运行，则无法模拟语义”。这是由罗伯特·维尔丁（Robert Virding）的《第一条编程规则》强制执行的，该条规定：“任何另一种足够复杂的并发程序都使用另一种语言，包含非正式的，临时指定的，bug缠身的缓慢的Erlang一半实现。”\n在本文中，我们想探索BEAM VM内部。我们将在适用的情况下将它们与JVM进行比较和对比，强调您为什么要注意它们并加以注意。长期以来，此组件一直被视为黑匣子，并且在不了解原因或含义的情况下被视为理所当然。现在该改变这种情况了！\nBEAM的亮点 发明Erlang和BEAM VM是解决特定问题的正确工具。它们是由爱立信开发的，旨在帮助实现处理移动和固定网络的电信基础设施。该基础架构本质上是高度并发和可伸缩的。它必须显示软实时属性，并且永远不会失败。我们不希望在手机上与祖母进行环聊通话时掉线或Fortnite的在线游戏体验不会受到系统升级，高用户负载或软件，硬件和网络中断的影响。BEAM VM通过提供可在可预测的并发编程模型之上运行的微调功能进行了优化，以解决许多挑战。\n它的秘诀是轻量级进程，它们不共享内存，由调度程序管理，该调度程序可以跨多个内核管理数百万个进程。它使用基于每个进程运行的垃圾收集器，并对其进行了高度优化以减少对其他进程的影响。结果，垃圾收集器不会影响系统的整体软实时属性。BEAM也是唯一使用规模广泛且具有内置分发模型的VM，它具有内置的分发模型，该模型允许程序透明地在多台计算机上运行。\nJVM的亮点 Java虚拟机（JVM）是​​由Sun Microsystem开发的，旨在提供一个可在任何地方运行的“一次写入”代码的平台。他们创建了一种类似于C++的面向对象的语言，但是内存安全，因为其运行时错误检测会检查数组范围和指针取消引用。在Internet时代，JVM生态系统变得非常流行，使其成为企业服务器应用程序的实际标准。满足广泛用例的虚拟机和可满足企业发展需求的令人印象深刻的库集使广泛的适用性成为可能。\nJVM设计时考虑了效率。它的大多数概念是流行操作系统中功能的抽象，例如映射到操作系统线程的线程模型。JVM是高度可定制的，包括垃圾收集器（GC）和类加载器。一些最先进的GC实现提供高度可调整的功能，以适应基于共享内存的编程模型。JVM允许您在程序运行时更改代码。而且，JIT编译器允许将字节码编译为本机代码，目的是加快应用程序的各个部分。\nJava世界中的并发性主要与在并行线程中运行应用程序有关，以确保它们是快速的。由于并发原语的共享内存模型带来了挑战，因此使用并发原语进行编程是一项艰巨的任务。为了克服这些困难，人们尝试简化和统一并发编程模型，最成功的尝试是Akka框架。\n并发与并行 如果部分代码在多个内核，处理器或计算机上同时运行，则我们谈论并行代码执行，而并发编程是指独立处理到达系统的事件。可以在单线程硬件上模拟并发执行，而并行执行则不能。尽管这种区别似乎很古怪，但这种差异导致需要解决的问题非常不同。想想很多厨师在做一盘Carbonara意大利面。在并行方法中，将任务分配给可用厨师的数量，并且只要完成这些厨师完成其特定任务的速度，就可以完成单个部分。在一个并发的世界中，每位厨师将获得一部分，每位厨师将完成所有任务。您将并行性用于速度，并发性用于规模。\n并行执行试图将问题的最佳分解解决为彼此独立的部分。将水煮沸，煮意大利面，混合鸡蛋，炸瓜里阿塞火腿，将佩克立诺奶酪磨碎1。共享数据（或在我们的示例中为餐盘）由锁，互斥锁和各种其他技术处理，以确保正确性。另一种看待这种情况的方式是存在数据（或成分），并且我们希望利用尽可能多的并行CPU资源来尽快完成工作。\n另一方面，并​​发编程处理许多事件，这些事件在不同的时间到达系统，并尝试在合理的时间内处理所有事件。在多核或分布式体系结构上，某些执行是并行运行的，但这不是必需的。另一种看待它的方法是，同一位厨师按照始终相同的顺序算法，将水煮沸，煮意大利面，混合鸡蛋等。跨过程（或做饭）的变化是要处理的数据（或成分），这些数据（或成分）存在于多个实例中。\nJVM是为并行而构建的，而BEAM是为并发构建的。它们是两个本质上不同的问题，需要不同的解决方案。\nBEAM和并发 BEAM提供轻量级流程为正在运行的代码提供上下文。这些进程也称为actor，不共享内存，而是通过消息传递进行通信，将数据从一个进程复制到另一个进程。消息传递是虚拟机通过各个进程拥有的邮箱实现的功能。消息传递是一种非阻塞操作，这意味着将消息发送到另一个进程几乎是即时的，并且不会阻塞发送者的执行。发送的消息采用不可变数据的形式，从发送过程的堆栈复制到接收者的邮箱。无需在进程之间使用锁和互斥锁即可实现此目的，而在多个进程并行将消息发送到同一收件人的情况下，只需对邮箱进行锁定即可。\n不变的数据和消息传递使程序员能够编写彼此独立工作的流程，并专注于功能而不是内存的低级管理和任务调度。事实证明，这种简单的设计不仅适用于单个线程，而且适用于在同一VM中运行的本地计算机上的多个线程，并使用内置的分发，在整个网络上通过VM和计算机集群运行。如果消息在进程之间是不可变的，则可以不加锁地将它们发送到另一个线程（或计算机），从而在分布式多核体系结构上几乎线性地扩展。进程在本地VM上的寻址方式与VM群集中的寻址方式相同，无论接收进程的位置如何，消息发送都是透明的。\n进程不共享内存，因此您可以复制数据以恢复弹性并分发数据以实现规模扩展。这意味着在两个不同的机器上具有相同进程的两个实例，彼此之间共享状态更新。如果一台计算机发生故障，则另一台计算机具有数据副本，并且可以继续处理该请求，从而使系统具有容错能力。如果两台计算机都可运行，则两个进程都可以处理请求，从而为您提供可伸缩性。BEAM为所有这些无缝集成提供了高度优化的原语，而OTP（“标准库”）则提供了更高级别的结构以简化程序员的生活。\nAkka在复制更高级别的结构方面做得很好，但是由于缺少JVM提供的原语而在一定程度上受到了限制，从而使其可以高度优化并发性。尽管JVM的原语支持更广泛的用例，但由于它们没有用于通信的内置原语且通常基于共享内存模型，因此它们使对分布式系统的编程变得更加困难。例如，您在分布式系统中的何处放置共享内存？以及访问它的成本是多少？\n调度器 我们提到过，BEAM的最强功能之一就是能够将程序分解为小的，轻量级的过程。管理这些过程是调度程序的任务。与JVM将其线程映射到OS线程并让操作系统调度它们不同，BEAM带有自己的调度程序。\n默认情况下，调度程序为每个内核启动一个OS线程，并优化它们之间的工作负载。每个过程都包含要执行的代码和随时间变化的状态。调度程序会选择运行队列中准备运行的第一个进程，并为其赋予定量的reductions（译者注：2000个），其中每次reduction都大致等同于一条指令。一旦进程用尽了reductions，会被I/O阻塞，等待消息或代码完成，调度程序就会在运行队列中选择下一个进程并将其分派（此句翻译有问题：原文是Once the process has either run out of reductions, is blocked by I/O, is waiting for a message or completes executing its code, the scheduler picks the next process in the run queue and dispatches it. 如果您有更好的翻译请不吝指教）。这种调度技术称为抢先式。\n我们多次提到Akka框架，因为它的最大缺点是需要在调度处添加注解，因为调度不是在JVM级别进行的。通过解除程序员的控制，可以保留和保证软实时属性，从而减低了导致进程饿死的风险。\n进程围绕着调度程序线程，并最大程度地利用CPU。有许多方法可以调整调度程序，但是它很少见，仅在边缘和边界情况下才需要，因为默认选项涵盖了大多数使用模式。\n关于调度程序，经常出现一个敏感的话题：如何处理本机实现的函数（NIF）。NIF是用C编写的代码片段，被编译为库并在与BEAM相同的内存空间中运行以提高速度。NIF的问题在于它们不是抢占式的，并且会影响调度程序。在最新的BEAM版本中，添加了一项新功能，即脏调度程序，以更好地控制NIF。肮脏的调度程序是在不同线程中运行的单独的调度程序，以最大程度地减少NIF对系统造成的中断。脏这个词是指这些调度程序运行的代码的性质。\n垃圾收集器 当今，现代的高级编程语言大多使用垃圾回收器进行内存管理。BEAM语言也不例外。当您要编写高级并发代码时，信任虚拟机来处理资源和管理内存非常方便，因为这可以简化任务。归功于基于不可变状态的内存模型，垃圾收集器的基础实现非常简单有效。数据被复制而不是突变，并且进程不共享内存这一事实消除了任何进程的相互依赖关系，因此不需要管理它们。\nBEAM的另一个功能是，仅在需要时才在每个进程的基础上运行垃圾回收，而不会影响在运行队列中等待的其他进程。结果，Erlang中的垃圾收集不会“stop-the-world”。它可以防止处理延迟高峰，因为VM不会从整体上停止——仅特定进程停止，并且绝不会同时停止所有进程。实际上，这只是流程的一部分，并且被视为另一种reduction。垃圾收集器收集过程将过程暂停很短的时间间隔，通常是微秒。代价是，将有许多小的爆发（bursts），仅在进程需要更多内存时才触发。单个进程通常不会分配大量内存，并且通常是短暂的，通过在终止时立即释放所有分配的内存，进一步降低了影响。JVM的一个功能是具备切换垃圾收集器的能力，因此，通过使用商用GC，还可以在JVM中实现不间断的GC。\nLukas Larsson在一篇出色的博客文章中讨论了垃圾收集器的功能。有许多复杂的细节，但已对其进行了优化以有效地处理不可变数据，并为每个进程在堆栈和堆之间分配了数据。最好的方法是在短暂的过程中完成大部分工作。\n这个主题上经常出现的一个问题是BEAM使用多少内存。虚拟机在后台分配了大块内存，并使用自定义分配器来有效地存储数据并最大程度地减少系统调用的开销。这有两个明显的效果：1）在不需要空间之后，已用内存逐渐减少2）重新分配大量数据可能意味着将当前工作内存加倍。如果确实需要，可以通过调整分配器策略来减轻第一个影响。如果您可以看到不同类型的内存使用情况，则第二个易于监视和计划。（WombatOAM就是这样一种提供开箱即用的系统指标的监视工具。）\n热代码加载 热代码加载可能是BEAM引用最多的独特功能。热代码加载意味着可以通过更改系统中的可运行代码来更新应用程序逻辑，同时保留内部流程状态。这是通过替换已加载的BEAM文件并指示VM替换正在运行的进程中的代码引用来实现的。\n对于电信基础架构无需停机代码升级而言，这是一项至关重要的功能，被裁减的硬件可用于处理高峰。如今，在容器化时代，其他技术也可以实现产线的更新。从未使用过它的人会认为它是不重要的功能，但是在开发工作流程中仍然有用。开发人员可以通过替换部分代码来加快迭代速度，而不必重新启动系统来对其进行测试。即使该应用程序并非设计为可在生产环境中进行升级，也可以减少重新编译和重新部署所需的时间。\n何时不使用BEAM 正确的工具非常重要。您需要一个速度极快的系统，但不关心并发性吗？并行处理一些事件，并且必须快速处理它们？是否需要计算图形，人工智能或分析数据？沿C ++，Python或Java路线走。电信基础设施不需要快速运行，因此速度从来都不是优先事项。在动态类型的辅助下，它必须在运行时进行所有类型检查，这意味着编译器时间优化并不那么简单。因此，数字运算最好留给JVM，Go或其他编译成本地语言的语言使用。毫不奇怪，在JVM上运行的Erlang版本Erjang上的浮点运算比BEAM快5000％。但是我们看到BEAM大放异彩的地方是利用它的并发来安排数字运算，将分析外包给C，Julia，Python或Rust。您可以在BEAM外部做map，而在BEAM内部做reduce(译者注：map-reduce思想)。\n口头禅总是很快。人类感知刺激（事件）并在大脑中进行处理需要几百毫秒，这意味着对于许多应用而言，微秒或纳秒的响应时间并不是必需的。您也不会将BEAM用于微控制器，这太浪费资源了。但是对于具有更多处理能力的嵌入式系统（多核已成为常态），您需要并发性，而BEAM令人眼前一亮。上世纪90年代，我们实现了电话交换机，以处理运行在具有16MB内存的嵌入式板上的成千上万的用户。RaspberryPi都有多少内存了？还有，硬实时系统，您可能不希望BEAM管理您的安全气囊控制系统。你需要硬保证 仅仅是硬实时操作系统，没有垃圾收集或异常的语言。在诸如GRiSP之类的裸机上运行的Erlang VM的实现将为您提供类似的保证。\n结论 使用正确的工具完成工作。如果您正在编写一个软实时系统，而该系统必须能够立即扩展并且永远不会失败，并且无需重新发明轮子就可以做到，那么BEAM是您正在寻找的经过验证的技术。对于许多人来说，它就像一个黑匣子。不知道它的工作原理类似于驾驶法拉利，无法获得最佳性能或无法理解奇怪声音来自马达的哪个部分。这就是为什么您应该更多地了解BEAM，了解其内部结构并准备对其进行微调和修复的原因。对于在实际任务中使用Erlang和Elixir的人（译者注：in anger 的意思是to do or use something in a real situation），我们开设了一天的讲师指导课程，该课程通俗易懂并解释您所看到的很多内容，同时为您准备大规模处理大规模并发做好准备。在这里了解更多。我们也推荐Erik Stenman撰写的关于BEAM的书和Dmytro Lytovchenko的文章集——BEAM Wisdoms。\n","id":7,"section":"posts","summary":"作者是 Francesco Cesarini \u0026amp; Gabor Olah 任何编程语言在Erlang生态系统中的成功都可以分为三个紧密耦合的组件。它们是：1）Erlang编程语言的语义，并在其上实现","tags":["erlang"],"title":"[译]BEAM vs JVM","uri":"https://lvsq.net/2020/05/beam-vs-jvm/","year":"2020"},{"content":"实现 下面将使用Scheme语言来实现“无重复字符的最长子串”，即，对于字符串\u0026quot;abbabcx\u0026quot;,其最长无重复字符的子串为\u0026quot;abcx\u0026quot;，长度4，详细描述可访问https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n(let* ( [s \u0026#34;abbabcx\u0026#34;] [arr-index 0] [ans 0] [d -1] [vec (make-vector 128 -1)] [keep-last-position (lambda (c pos-in-s) (vector-set! vec c pos-in-s))] [scan (lambda (c pos-in-s) (let* ([previous-pos (vector-ref vec c)] [len 0]) (begin (when (and (\u0026gt;= previous-pos 0) (\u0026gt; previous-pos d)) (set! d previous-pos) ) (set! len (- pos-in-s d)) (keep-last-position c pos-in-s) (when (\u0026gt; len ans) (set! ans len)) ) ) )] ) ( string-for-each (lambda (e) (scan (char-\u0026gt;integer e) arr-index) (set! arr-index (+ arr-index 1))) s ) ans ) 实现的思路为：\n由于字符可以有ASCII码表示，故可以用一个长度为128的向量vec来保存每个字符在给定的字符串中出现的最后一次的位置。维护一个变量d来记录最近一次出现重复的字符的起始位置。 如果：\n 判断某字符是否重复：1.1 某字符第一次出现，执行第2步1.2 某字符非第一次出现，如果该字符上次出现的位置，在d之后，则将d设置为该字符上次出现的位置。由于之前的最大长度已经由ans保存，所以只需要计算剩下的子串的长度能不能大于ans，这就是为什么d记录最近一次出现重复的字符串的起始位置就好了 计算当前位置和d的长度len 保存其位置到vec 如果len大于ans，改变ans为len  这种实现只需遍历一遍就可以计算出结果，性能非常棒。当然暴力计算或者滑动窗口也可以实现该功能，只是需要多次遍历，性能比不上。\n概要分析 上文说到性能问题，拿点数据出来证明一下吧。\n将上面的代码稍微改造一下，作为一个definition，并保存在longest_substr.ss文件中，\n(define longest-substr (lambda (str) (let* ( [s str] [arr-index 0] [ans 0] [d -1] [vec (make-vector 128 -1)] [keep-last-position (lambda (c pos-in-s) (vector-set! vec c pos-in-s))] [scan (lambda (c pos-in-s) (let* ([previous-pos (vector-ref vec c)] [len 0]) (begin (when (and (\u0026gt;= previous-pos 0) (\u0026gt; previous-pos d)) (set! d previous-pos) ) (set! len (- pos-in-s d)) (keep-last-position c pos-in-s) (when (\u0026gt; len ans) (set! ans len)) ) ) )] ) ( string-for-each (lambda (e) (scan (char-\u0026gt;integer e) arr-index) (set! arr-index (+ arr-index 1))) s ) ans ) ) ) Chez Scheme提供了一个概要分析工具，非常好用，来试用一下： 生成的html可以非常直观的看到该函数的执行情况 字符串越长，执行次数越多，执行时间是多少呢？选一个上面例子中最长的字符串来看看：\n\u0026gt; (time (longest-substr \u0026#34;abcabcxsfsdfw232sdfssdfsdfsdfsf1234567890\u0026#34;)) (time (longest-substr \u0026#34;abcabcxsfsdfw232sdfssdfsdfsdfsf1234567890\u0026#34;)) no collections 0.000003672s elapsed cpu time 0.000002000s elapsed real time 1792 bytes allocated 12 \u0026gt; 消耗的CPU时间0.000003672s，可以说非常短了，且分配的内存仅仅1792个字节。超乎寻常的性能，我想应该有两个方面原因：\n 算法 Scheme 和 Chez Scheme  ","id":8,"section":"posts","summary":"实现 下面将使用Scheme语言来实现“无重复字符的最长子串”，即，对于字符串\u0026quot;abbabcx\u0026quot;,其最长无重复字符的子串为","tags":["scheme"],"title":"无重复字符的最长子串-Scheme实现","uri":"https://lvsq.net/2020/03/longest-substr/","year":"2020"},{"content":"为什么要用Go练习函数式编程？简而言之，正是由于缺少状态和可变数据，函数式编程使您的代码更易读，更易于测试且不太复杂。如果遇到错误，只要不违反函数式编程规则，就可以快速调试应用程序。当函数被隔离时，您不必处理影响输出的隐藏状态的更改。\n软件工程师兼作者Eric Elliot定义了以下函数编程。\n 函数式编程是通过组合纯函数，避免共享状态，可变数据和副作用来构建软件的过程。函数式编程是声明性的，而不是命令性的，应用程序状态通过纯函数流动。与面向对象的编程相反，后者通常将应用程序状态与对象中的方法共享并放置在对象中。\n 我将更进一步：函数式编程（如面向对象和过程式编程）代表着范式的转变。它在编写代码时采用了独特的思维方式，并引入了一套全新的规则。\n4个重要概念 要完全掌握函数式编程，必须首先了解以下相关概念。\n 纯函数和幂等 副作用 函数构成 共享状态和不变数据  让我们快速回顾一下。\n纯函数和幂等 如果给纯函数提供相同的输入，则它总是会返回相同的输出。此属性也称为幂等。幂等意味着函数应始终返回相同的输出，而与调用次数无关。\n副作用 纯函数不能有任何副作用。换句话说，您的函数无法与外部环境进行交互。\n例如，函数式编程将API调用视为副作用。为什么？因为API调用被认为是不受您直接控制的外部环境。一个API可能有几个不一致的地方，例如超时或失败，或者甚至可能返回意外的值。它不适合纯函数的定义，因为每次调用API时都需要一致的结果。\n其他常见的副作用包括：\n 数据变化 DOM操作 请求有冲突的数据，例如当前时间time.Now()  函数构成 函数构成的基本思想很简单：将两个纯函数组合在一起以创建一个新函数。这意味着为相同输入产生相同输出的概念在这里仍然适用。因此，从简单的纯函数开始创建更高级的函数很重要。\n共享状态和不变数据 函数式编程的目的是创建不保持状态的函数。共享状态尤其会在纯函数中引入副作用或可变性问题，使它们变得不纯粹。\n但是，并非所有状态都不好。有时，必须有一个状态才能解决特定的软件问题。函数式编程的目的是使状态可见和显式，以消除任何副作用。程序使用不可变数据结构从纯函数中派生新数据。这样，就不需要可能引起副作用的可变数据。\n 现在我们已经涵盖了基础，让我们定义一些在Go中编写功能代码时要遵循的规则。\n功能编程规则 如前所述，函数式编程是一种范例。因此，很难为这种编程风格定义确切的规则。也不一定总是遵循这些规则。有时，您确实需要依赖拥有状态的功能。\n但是，为了尽可能严格地遵循函数式编程范例，我建议坚持以下准则。\n 没有可变数据以避免副作用 无状态（或者隐式状态，例如循环计数器） 给变量赋值后请勿修改 避免副作用，例如API调用  我们在函数式编程中经常遇到的一个好的“副作用”是强大的模块化。函数式编程不是自上而下地进行软件工程，而是鼓励自下而上的编程风格。首先定义模块，把将来可能使用的同类纯函数组合起来。接下来，开始编写那些小的，无状态的独立函数，以创建您的第一个模块。\n实质上我们是在创建黑匣子。稍后，我们将按照自下而上的方式将各个块捆绑在一起。这使您可以建立强大的测试基础，尤其是可以验证纯函数正确性的单元测试。\n一旦您可以信任您的模块，就可以将模块捆绑在一起了。开发过程中的这一步还涉及编写集成测试，以确保两个组件的正确集成。\n5个示例 为了更全面地描述Go函数编程的工作原理，让我们探索五个基本示例。\n 更新字符串  这是纯函数的最简单示例。通常，当您要更新字符串时，请执行以下操作。\nname：= \u0026#34;first name\u0026#34; name：= name + \u0026#34;last name\u0026#34; 上面的代码片段不符合函数式编程的规则，因为不能在函数内修改变量。因此，我们应该重写代码段，以便每个值都具有自己的变量。\n下面的代码段中的代码更具可读性。\nfirstname := \u0026#34;first\u0026#34; lastname := \u0026#34;last\u0026#34; fullname := firstname + \u0026#34; \u0026#34; + lastname 在查看非函数式代码段时，我们必须浏览程序以确定最新状态，才可以找到name变量的结果值。这需要更多的精力和时间来了解该功能的作用。\n避免更新数组  如前所述，函数式编程的目的是使用不变数据通过纯函数得出新的不变数据状态。我们可以在每次需要更新数组时创建一个新数组来实现\n在非函数式编程中，更新数组如下：\nnames := [3]string{\u0026#34;Tom\u0026#34;, \u0026#34;Ben\u0026#34;} // Add Lucas to the array \tnames[2] = \u0026#34;Lucas\u0026#34; 让我们根据功能编程范例进行尝试。\nnames := []string{\u0026#34;Tom\u0026#34;, \u0026#34;Ben\u0026#34;} allNames := append(names, \u0026#34;Lucas\u0026#34;) 避免更新map  这是函数编程的极端示例。想象一下，我们有一个带有字符串类型的键和整数类型的值的map。该map包含我们仍然留在家中的水果数量。但是，我们刚购买了苹果，并希望将其添加到列表中。\nfruits := map[string]int{\u0026#34;bananas\u0026#34;: 11} // Buy five apples \tfruits[\u0026#34;apples\u0026#34;] = 5 我们可以在功能编程范例下完成相同的功能。\nfruits := map[string]int{\u0026#34;bananas\u0026#34;: 11} newFruits := map[string]int{\u0026#34;apples\u0026#34;: 5} allFruits := make(map[string]int, len(fruits) + len(newFruits)) for k, v := range fruits { allFruits[k] = v } for k, v := range newFruits { allFruits[k] = v } 由于我们不想修改原始map，因此代码会遍历两个map，并将值添加到新map。这样，数据保持不变。\n正如您可能通过代码的长度可以看出的那样，此代码段的性能比对map进行简单的可变更新要差得多，因为我们要遍历两个map。这是您为代码性能交换更好的代码质量的时间。\n高阶函数和柯里化  大多数程序员在他们的代码中通常不会使用高阶函数，但是在函数式编程中柯里化很方便。\n假设我们有一个简单的函数，将两个整数相加。尽管这已经是一个纯粹的功能，但我们希望详细说明该示例，以展示如何通过curring创建更高级的功能。\n在这种情况下，我们只能接受一个参数。接下来，该函数返回另一个函数作为闭包。因为该函数返回一个闭包，所以它将记住外部范围，该范围包含初始输入参数。\nfunc add （x int）func （y int）int { return func（y int）int { return x + y } } 现在，让我们尝试currying并创建更多高级纯函数。\nfunc main() { // Create more variations \tadd10 := add(10) add20 := add(20) // Currying \tfmt.Println(add10(1)) // 11 \tfmt.Println(add20(1)) // 21 } 这种方法在函数式编程中很常见，尽管您通常不会在范式之外看到它。\n递归  递归是一种通常用于规避循环使用的软件模式。因为循环始终保持内部状态以明确循环在哪一轮，所以我们不能在函数式编程范式下使用循环。\n例如，下面的代码片段尝试计算数字的阶乘。阶乘是一个整数与其下所有整数的乘积。因此，阶乘4等于24（= 4 * 3 * 2 * 1）。\n通常，您将为此使用循环。\nfunc factorial(fac int) int { result := 1 for ; fac \u0026gt; 0; fac-- { result *= fac } return result } 为了在函数式编程范例中完成此任务，我们需要使用递归。换句话说，我们将一遍又一遍地调用相同的函数，直到达到阶乘的最低整数为止。\nfunc calculateFactorial(fac int) int { if fac == 0 { return 1 } return fac * calculateFactorial(fac - 1) } 结论 让我们总结一下我们从函数式编程中学到的知识：\n 尽管Golang支持函数式编程，但它并非为此目的而设计的，如缺少Map，Filter和Reduce函数。 函数式编程提高了代码的可读性，因为函数是纯粹的，因此易于理解 纯函数更易于测试，因为没有内部状态会改变输出  原文在此: https://blog.logrocket.com/functional-programming-in-go/\n","id":9,"section":"posts","summary":"为什么要用Go练习函数式编程？简而言之，正是由于缺少状态和可变数据，函数式编程使您的代码更易读，更易于测试且不太复杂。如果遇到错误，只要不违","tags":["functional"],"title":"使用Golang进行函数式编程","uri":"https://lvsq.net/2020/03/fp-in-go/","year":"2020"},{"content":"闲来无事，用Scheme实现一个FIFO队列，数据从末端插入，从前端删除或者查询。\n队列可以看成是由下面一组操作定义的结构：\n 构造函数  (make-queue)返回一个空队列\n 选择函数  (empty-queue? \u0026lt;queue\u0026gt; )检查队列是否为空(front-queue \u0026lt;queue\u0026gt; )返回最早进入队列的数据，其不会修改队列(length-queue \u0026lt;queue\u0026gt; )返回队列长度\n 改变函数  (insert-queue! \u0026lt;queue\u0026gt; \u0026lt;item\u0026gt; )将数据插入末端(delete-queue! \u0026lt;queue\u0026gt; )删除列头的数据\n 打印函数  (print-queue \u0026lt;queue\u0026gt;)\n(module FIFO-QUEUE (make-queue empty-queue? front-queue insert-queue! delete-queue! length-queue print-queue) (define front-ptr (lambda (q) (caar q))) (define set-front-ptr! (lambda (q item) (set-car! (car q) item))) (define rear-ptr (lambda (q) (cdar q))) (define set-rear-ptr! (lambda (q item) (set-cdr! (car q) item))) (define make-queue (lambda () (cons (cons \u0026#39;() \u0026#39;()) 0))) (define empty-queue? (lambda (q) (null? (front-ptr q)))) (define front-queue (lambda (q) (if (empty-queue? q) (error \u0026#34;FRONT called with an empty queue\u0026#34; q) (car (front-ptr q))))) (define (insert-queue! q item) (let ((new-pair (cons item \u0026#39;()))) (if (empty-queue? q) (begin (set-front-ptr! q new-pair) (set-rear-ptr! q new-pair) (set-cdr! q (+ 1 (cdr q))) q) (begin (set-cdr! (rear-ptr q) new-pair) (set-rear-ptr! q new-pair) (set-cdr! q ( + 1 (cdr q))) q) ) ) ) (define delete-queue! (lambda (q) (if (empty-queue? q) (error \u0026#34;DELETE! called with an empty queue\u0026#34; q) (begin (set-front-ptr! q (cdr (front-ptr q))) (set-cdr! q (- (cdr q) 1)) q) ) ) ) (define length-queue (lambda (q) (cdr q))) (define print-queue (lambda (q) (if (empty-queue? q) \u0026#39;() (front-ptr q)) )) ) 前4个过程是用于内部的帮助函数，队列维护两个指针，一个指向列头（front-ptr）,一个指向列尾（rear-ptr），这样可以弥补原生的set-car!和set-cdr!的不足。\n\u0026gt; (load \u0026#34;/path/to/FIFO-QUEUE.scm\u0026#34;) ;;加载FIFO-QUEUE模块 \u0026gt; (import FIFO-QUEUE) \u0026gt; (define q (make-queue)) \u0026gt; (insert-queue! q 1) ;; (((1) 1) . 1), 最后一个数字1表示队列长度, 在队列有删除或者插入时，及时修改该值，为了在取队列长度时减小开销，否则要遍历一次才行 \u0026gt; (insert-queue! q 2) ;; (((1 2) 2) . 2) \u0026gt; (insert-queue! q 3) ;; (((1 2 3) 3) . 3) \u0026gt; (insert-queue! q 4) ;; (((1 2 3 4) 4) . 4) \u0026gt; (delete-queue! q) ;; (((2 3 4) 4) . 3) \u0026gt; (delete-queue! q) ;; (((3 4) 4) . 2) \u0026gt; (front-queue q) ;; 3 \u0026gt; (length-queue q) ;; 2 ","id":10,"section":"posts","summary":"闲来无事，用Scheme实现一个FIFO队列，数据从末端插入，从前端删除或者查询。 队列可以看成是由下面一组操作定义的结构： 构造函数 (make","tags":["scheme"],"title":"Scheme实现一个FIFO队列","uri":"https://lvsq.net/2020/03/fifo-queue/","year":"2020"},{"content":"本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可能使用Scheme标准机制。\nHash Tables 略过。应使用标准hash table.\nExtend-Syntax Macros 本节介绍了extend-syntax，它是一种功能强大但易于使用的基于模式匹配的语法扩展工具。 使用extend-syntax编写的语法转换与使用define-syntax和syntax-case编写的语法转换相似，不同之处在于extend-syntax产生的转换不会自动遵循词法作用域。\n通常不可能将使用syntax-case编写的语法抽象与使用extend-syntax编写的语法抽象无缝地混合在一起。 通常尽可能只使用其中一种。 仅在迁移到syntax-case时提供了对syntax-case扩展器中extend-syntax的支持。\n (extend-syntax (name key \u0026hellip;) (pat fender template) \u0026hellip;)\n 标识符name 是要定义的句法扩展名或语法关键字。 当系统扩展器处理car为name 的任何list表达式时，将在该表达式上调用extend-syntax生成的语法转换过程。 其余的标识符key \u0026hellip; 是在扩展过程中要在输入表达式中识别的其他关键字（例如cond中的else或case）。\nkey列表之后的每个子句都包含一个模式pat ，一个可选的fender 和一个template 。 可选的fender 经常被省略。pat 指定了语法，用于匹配子句。模式中不是关键字（模式变量）的标识符绑定到输入表达式的相应部分。fender 如果存在，则是Scheme表达式，它指定输入表达式（通过模式变量访问）上的附加约束，必须选择这些约束才能选择子句。template 通常根据模式变量来指定输出采用什么形式。\n在扩展过程中，转换过程extend-syntax会尝试以给定的子句的顺序将输入表达式与每个模式进行匹配。如果输入表达式匹配了某个模式，则将模式变量绑定到输入表达式的相应部分，并对子句的fender （如果有）进行求值。如果fender 返回一个真值，则执行给定的扩展。 如果输入与模式不匹配，或者fender 返回错误值，则转换过程将尝试下一个子句。如果无法选择任何子句，则会引发条件类型**＆assertion**的异常。\n在模式内，省略号（\u0026hellip;）可用于指定零个或多个出现的前面的模式片段或原型。类似地，可以在输出中使用省略号来指定零个或多个扩展原型的结构。在这种情况下，扩展原型必须包含输入模式原型的一部分。\n第一个例子，定义了rec, 使用单个关键字，一个子句，且没有fender和省略号\n(extend-syntax (rec) [(rec id val) (let ([id #f]) (set! id val) id)]) 第二个例子，定义了when，展示了如何使用省略号\n(extend-syntax (when) [(when test exp1 exp2 ...) (if test (begin exp1 exp2 ...) #f)]) 下一个示例显示let的定义。 let的定义显示了多个省略号的使用，其中一个用于标识符/值序对，另一个用于body中的表达式。它还表明原型不必是单个标识符，并且在template中可以将原型的各个部分彼此分开。\n(extend-syntax (let) [(let ([x e] ...) b1 b2 ...) ((lambda (x ...) b1 b2 ...) e ...)]) 下一个示例显示let*，其语法与let相同，但是根据let以两个子句（一个用于基本情况，一个用于递归步骤）递归定义，因为它必须产生一个嵌套结构。\n(extend-syntax (let*) [(let* () b1 b2 ...) (let () b1 b2 ...)] [(let* ([x e] more ...) b1 b2 ...) (let ([x e]) (let* (more ...) b1 b2 ...))]) 定义式and需要3个子句。第一个子句对于识别**(and)**是必要的，后两个以递归方式定义所有其他**and**形式。\n(extend-syntax (and) [(and) #t] [(and x) x] [(and x y ...) (if x (and y ...) #f)]) cond的定义需要四个子句。 与let*一样，必须对cond进行递归描述，部分原因是它会产生嵌套的if表达式，部分原因是一个省略号原型不足以描述所有可能的cond子句。 cond的定义还要求除cond之外，我们还指定else作为关键字。 这是定义：\n(extend-syntax (cond else) [(cond) #f] [(cond (else e1 e2 ...)) (begin e1 e2 ...)] [(cond (test) more ...) (or test (cond more ...))] [(cond (test e1 e2 ...) more ...) (if test (begin e1 e2 ...) (cond more ...))]) 为了使let的语法绝对正确，我们实际上必须要求输入中的绑定标识符是符号。 如果我们输入类似**（let（[3 x]）x）**的内容，则不会从**let**中得到错误，因为它不会检查验证标识符位置中的对象是否为符号。 相反，lambda可能会抱怨，或者可能是扩展完成很久之后的求值程序。 这是*fenders* 起作用的地方。\n(extend-syntax (let) [(let ([x e] ...) b1 b2 ...) (andmap symbol? \u0026#39;(x ...)) ((lambda (x ...) b1 b2 ...) e ...)]) '（x \u0026hellip;）上的symbol?的andmap确保每个绑定标识符都是一个符号。 fender 仅仅是Scheme表达式。 在该表达式中，首先使用与子句的template 部分相同的规则来扩展引用的对象。 在这种情况下，将**'（x \u0026hellip;）**扩展到标识符/值对中的标识符列表。\nextend-syntax通常可以处理您的一切需求，但是某些语法扩展定义要求能够包含对任意Scheme表达式求值的结果。 该功能由with提供。\n (with ((pat expr) \u0026hellip;) template)\n with仅在extend-syntax内部的template 内有效。 with模式与extend-syntax模式相同，with表达式与extend-syntax的fenders 相同，with模板与extend-syntax模板相同。\nwith可用于引入新的模式标识符，该标识符绑定到extend-syntax模板中的任意Scheme表达式所生成的表达式。 也就是说，with允许从extend-syntax的声明式样式转为full Scheme的过程式样式。\nwith的一种常见用法是在模板中引入临时标识符或临时标识符列表。 如果在extend-syntax框架内执行，with也可用于执行可能笨拙或效率低下的复杂转换。\n例如，or需要使用临时标识符。 我们可以如下定义or：\n(extend-syntax (or) [(or) #f] [(or x) x] [(or x y ...) (let ([temp x]) (if temp temp (or y ...)))]) 这会一直有效，直到将or表达式放置在temp发生的范围内为止，在这种情况下，可能会发生奇怪的事情，因为extend-syntax不尊重词法作用域。 （这是define-syntax优于extend-syntax的原因之一。）\n(let ([temp #t]) (or #f temp)) ⇒ #f  如果将标识符temp换个名字，则一切正常。就可以理解\u0026quot;extend-syntax不尊重词法作用域\u0026quot;这句话了。 实际上，上述的(let \u0026hellip;)表达式，展开之后就变成了：\n (let ([temp #t]) (let ([temp #f]) (if temp temp (or temp)) ) ) 一种解决方案是，使用gensym和with来创建临时标识符，如下：\n(extend-syntax (or) [(or) #f] [(or x) x] [(or x y ...) (with ([temp (gensym)]) (let ([temp x]) (if temp temp (or y ...))))]) 而且，with可以以extend-syntax无法直接使用的方式来组合输入模式的元素，例如以下folding-plus示例:\n(extend-syntax (folding-plus) [(folding-plus x y) (and (number? \u0026#39;x) (number? \u0026#39;y)) (with ([val (+ \u0026#39;x \u0026#39;y)]) val)] [(folding-plus x y) (+ x y)]) 如果x和y均为数字常数，则folding-plus折叠为（+ x y）的值。 否则，folding-plus转换为（+ x y）以供以后评估。 fender在扩展时检查操作数是否为数字，并使用with进行求值。 与fender一样，扩展仅在带引号的表达式内执行，因为quote将数据与Scheme表达式的其余部分区分开。\n下面的示例利用with允许我们将模式绑定到表达式这一事实，将模式变量列表绑定到临时符号列表。 此临时列表帮助我们实现sigma语法扩展。 sigma与lambda相似，除了它在标识符列表中分配标识符而不是创建新绑定之外。 它可用于并行执行一系列分配。\n(extend-syntax (sigma) [(sigma (x ...) e1 e2 ...) (with ([(t ...) (map (lambda (x) (gensym)) \u0026#39;(x ...))]) (lambda (t ...) (set! x t) ... e1 e2 ...))]) (let ([x \u0026#39;a] [y \u0026#39;b]) ((sigma (x y) (list x y)) y x)) ⇒ (b a) 结构体 本节介绍一种机制，类似于第7.15节的record定义机制，该机制允许使用固定的命名字段集创建数据结构。 与record类型不同，结构体类型不是唯一类型，而是实现为向量。 具体而言，将结构体实现为向量，其长度比字段数大一倍，并且其第一个元素包含该结构体的符号名称。\n将结构体表示为向量可以在某种程度上简化结构体的读取和打印以及结构体定义工具的扩展。但是，它确实有一些缺点。 一个是在不适当的情况下，结构体可能会被错误地视为普通向量。当在程序中处理结构体和向量时，在检查更通用的向量类型之前，必须注意先寻找更具体的结构体类型，例如在一系列cond子句中。一个类似的缺点是，结构体实例容易被有意或无意地“伪造”。 也不可能控制如何打印和读取结构体。\n通过define-structure创建结构体。 每个结构体定义式都定义一个构造过程，一个类型谓词，每个字段的访问过程以及每个字段的分配过程。define-structure允许程序员控制哪些字段是构造函数过程的参数，以及哪些字段由构造函数过程显式初始化。define-structure非常简单，但对于大多数应用程序来说足够强大，如果还不足以应付应用程序的需求还可以很容易的扩展以满足之。 本节末尾给出的define-structure定义可以作为更复杂变体的起点。\n (define-structure (name id1 \u0026hellip;) ((id2 expr) \u0026hellip;))\n define-structure形式可以出现在任意位置。\ndefine-structure定义一个新的数据结构name ，并创建一组用于构造和操作该结构实例的过程。 标识符id1 \u0026hellip; 和id2 \u0026hellip; 命名数据结构的字段。\n下面的过程都有define-structure定义：\n 名为**make-**name 的构造过程 名为name? 的类型谓词 对于每一个字段id1 \u0026hellip; 和id2 \u0026hellip; ，都有名为name-field 的访问过程 对于每一个字段id1 \u0026hellip; 和id2 \u0026hellip; ，都有名为**set-**name-field! 的分配过程  标识符id1 \u0026hellip; 命名的字段由构造函数的参数初始化。 由标识符id2 \u0026hellip; 命名的字段被显式初始化为表达式expr \u0026hellip; 的值。每个表达式都在标识符id1 \u0026hellip; （绑定到相应的字段值）的范围内进行求值，并且在标识符id2 \u0026hellip; （绑定到相应的字段值）的范围内出现（类似let*） 。\n为了清晰起见，构造函数的行为就像定义为：\n(define make-name (lambda (id1 ...) (let* ([id2 expr ] ...) body ))) 其中body 根据标识符id1 \u0026hellip; 和id2 \u0026hellip; 的值构建结构体。\n如果不需要除构造函数过程的参数初始化的字段以外的其他字段，则可以省略第二个子表达式*( (id2 expr) \u0026hellip;)* 。\n以下简单示例演示了如何在Scheme中定义pair（如果它们不存在的话）。 这两个字段都由构造函数过程的参数初始化。\n(define-structure (pare car cdr)) (define p (make-pare ’a ’b)) (pare? p) ⇒ #t (pair? p) ⇒ #f (pare? ’(a . b)) ⇒ #f (pare-car p) ⇒ a (pare-cdr p) ⇒ b (set-pare-cdr! p (make-pare \u0026#39;b \u0026#39;c)) (pare-car (pare-cdr p)) ⇒ b (pare-cdr (pare-cdr p)) ⇒ c 以下示例定义了一个方便的字符串数据结构，称为strext-string ，该结构会根据需要增长。本例子中，会显式地初始化一个字段的值，该字段在构造函数中定义。\n(define-structure (stretch-string length fill) ([string (make-string length fill)])) (define stretch-string-ref (lambda (s i) (let ([n (stretch-string-length s)]) (when (\u0026gt;= i n) (stretch-stretch-string! s (+ i 1) n)) (string-ref (stretch-string-string s) i)))) (define stretch-string-set! (lambda (s i c) (let ([n (stretch-string-length s)]) (when (\u0026gt;= i n) (stretch-stretch-string! s (+ i 1) n)) (string-set! (stretch-string-string s) i c)))) (define stretch-string-fill! (lambda (s c) (string-fill! (stretch-string-string s) c) (set-stretch-string-fill! s c))) (define stretch-stretch-string! (lambda (s i n) (set-stretch-string-length! s i) (let ([str (stretch-string-string s)] [fill (stretch-string-fill s)]) (let ([xtra (make-string (- i n) fill)]) (set-stretch-string-string! s (string-append str xtra)))))) 通常，大多数自动定义的过程都用于定义更特殊的过程， 在这个例子中，说的就是stretch-string-ref ** 和stretch-string-set!。而stretch-string-length** 和 **stretch-string-string**是惟一直接使用的自动生成的过程。\n(define ss (make-stretch-string 2 #\\X)) (stretch-string-string ss) ⇒ \u0026#34;XX\u0026#34; (stretch-string-ref ss 3) ⇒ #\\X (stretch-string-length ss) ⇒ 4 (stretch-string-string ss) ⇒ \u0026#34;XXXX\u0026#34; (stretch-string-fill! ss #\\@) (stretch-string-string ss) ⇒ \u0026#34;@@@@\u0026#34; (stretch-string-ref ss 5) ⇒ #\\@ (stretch-string-string ss) ⇒ \u0026#34;@@@@@@\u0026#34; (stretch-string-set! ss 7 #\\=) (stretch-string-length ss) ⇒ 8 (stretch-string-string ss) ⇒ \u0026#34;@@@@@@@=\u0026#34; 《The Scheme Programming Language》（第4版）的8.4节定义了define-structure的简化变体，作为使用syntax-case的示例。 下面给出的定义实现了完整版本。\n(define-syntax define-structure (lambda (x) (define gen-id (lambda (template-id . args) (datum-\u0026gt;syntax template-id (string-\u0026gt;symbol (apply string-append (map (lambda (x) (if (string? x) x (symbol-\u0026gt;string (syntax-\u0026gt;datum x)))) args)))))) (syntax-case x () ((_ (name field1 ...)) (andmap identifier? #\u0026#39;(name field1 ...)) #\u0026#39;(define-structure (name field1 ...) ())) ((_ (name field1 ...) ((field2 init) ...)) (andmap identifier? #\u0026#39;(name field1 ... field2 ...)) (with-syntax ((constructor (gen-id #\u0026#39;name \u0026#34;make-\u0026#34; #\u0026#39;name)) (predicate (gen-id #\u0026#39;name #\u0026#39;name \u0026#34;?\u0026#34;)) ((access ...) (map (lambda (x) (gen-id x #\u0026#39;name \u0026#34;-\u0026#34; x)) #\u0026#39;(field1 ... field2 ...))) ((assign ...) (map (lambda (x) (gen-id x \u0026#34;set-\u0026#34; #\u0026#39;name \u0026#34;-\u0026#34; x \u0026#34;!\u0026#34;)) #\u0026#39;(field1 ... field2 ...))) (structure-length (+ (length #\u0026#39;(field1 ... field2 ...)) 1)) ((index ...) (let f ([i 1] [ids #\u0026#39;(field1 ... field2 ...)]) (if (null? ids) \u0026#39;() (cons i (f (+ i 1) (cdr ids))))))) #\u0026#39;(begin (define constructor (lambda (field1 ...) (let* ([field2 init] ...) (vector \u0026#39;name field1 ... field2 ...)))) (define predicate (lambda (x) (and (vector? x) (#3%fx= (vector-length x) structure-length) (eq? (vector-ref x 0) \u0026#39;name)))) (define access (lambda (x) (vector-ref x index))) ... (define assign (lambda (x update) (vector-set! x index update))) ...)))))) ","id":11,"section":"posts","summary":"本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可","tags":["scheme"],"title":"兼容性（Compatibility Features in Chez Scheme）","uri":"https://lvsq.net/2020/02/compatibility/","year":"2020"},{"content":"下面介绍Chez Scheme线程系统过程和语法形式。 除了锁，锁增量和锁减量之外，线程系统的功能在非基于Windows的系统上在Posix线程系统（pthreads）之上实现，并在基于Windows的系统上直接使用Windows API。 有关线程创建和交互的基本详细信息，请查阅系统上的相应文档。\n大多数原生的Scheme过程都是线程安全 的，这意味着可以从多个线程中同时调用它们。 这包括诸如cons和make-string之类的分配操作，诸如car和vector-ref之类的访问器，诸如**+**和**sqrt**之类的数字运算符以及诸如**append**和**map**之类的非破坏性的高级原生操作。\n简单的变动运算符（例如set-car！，vector-set！和record字段变动器）是线程安全的。 同样，对局部变量的分配，包括（未导出的）库和顶级程序变量的分配也是线程安全的。\n大多数I/O操作应被视为具有破坏性，因为它们可能会修改端口的内部结构。\n使用没有进行合适的同步策略的非线程安全的运算符可能会破坏它们所操作的对象。 这种损坏可能导致错误的行为，内存故障，甚至导致系统中止的不可恢复的错误。\n线程创建  (fork-thread thunk)\n thunk 必须是一个接受0个参数的过程。\nfork-thread在一个新线程中调用thunk ，并返回一个线程对象。\n除了打印它外，fork-thread返回的线程对象无法执行任何操作。\n除了使用fork-thread以外，可通过外部代码来创建的线程必须在触及任何Scheme数据或调用任何Scheme过程之前调用Sactivate_thread\n (thread? obj)\n 返回：如果obj 是一个线程对象，返回#t,否则返回#f\n (get-thread-id)\n 返回：当前线程的id\n线程id是由线程分配的线程号，并且与get-process-id返回的进程id没有关系，进程id在所有线程中都是相同的。\n互斥锁  (make-mutex)\n 返回：一个新的互斥锁对象\n (mutex? obj)\n 返回：如果obj 是互斥锁，返回#t\n (mutex-acquire mutex) | (mutex-acquire mutex block?)\n mutex 必须是一个互斥锁。\nmutex-acquire获取由mutex 标识的互斥锁。可选的bool参数block？ 默认为#t，指定线程是否应阻塞等待互斥锁。block？ 如果省略或为true，则线程将阻塞，直到获取了互斥锁为止，并返回未指定的值。\n如果block？ 为false并且互斥锁当前已属于其他线程，当前线程并不会阻塞，而是，mutex-acquire立即返回值**#f**，以指示互斥锁不可用。 如果*block？* 为false并且成功获取了互斥锁，**mutex-acquire**返回#t。\n互斥锁在Posix线程术语中是递归的，这意味着调用线程可以使用互斥锁获取（重新）获取它已经拥有的互斥锁（注：锁是可以重入的）。 在这种情况下，释放互斥锁需要执行相等数量的mutex-release。\n (mutex-release mutex)\n mutex 必须是一个互斥锁。\nmutex-release释放由mutex 标识的互斥锁。 如果mutex 不属于调用线程（即释放别人的互斥锁），则会导致无法预料的行为。\n (with-mutex mutex body1 body2 \u0026hellip;)\n with-mutex计算表达式mutex ，其必须可以计算为一个互斥锁，获取锁，并计算body1 body2 \u0026hellip; ,然后释放锁。无论body是正常返回还是通过控制操作（即可能由于错误而抛到continuation）释放互斥量，这都会导致with-mutex形式的非本地退出。如果控制随后通过continuation调用返回到body，则将重新获取互斥锁。\n与直接使用mutex-acquire和mutex-release相比，使用with-mutex通常更方便，更安全。\n条件  (make-condition)\n 返回：一个新的条件对象\n (thread-condition? obj)\n 返回：如果obj 是条件对象，返回#t\n (condition-wait cond mutex) | (condition-wait cond mutex timeout)\n 返回：如果调用线程被条件唤醒返回#t，如果调用线程超时等待返回#f\ncond 必须是条件对象，并且mutex 必须是互斥锁。 可选参数timeout 是类型为time-duration或time-utc或**#f**的时间记录，表示没有超时。 默认为**#f**。\ncondition-wait等待由cond 标识的条件，且等待指定的timeout时长。在调用condition-wait时，调用线程必须已获取互斥锁mutex 。由于调用condition-wait的副作用而释放了mutex 。当稍后通过下述的过程之一从条件变量释放线程或超时到期时，将重新获取mutex ，并返回condition-wait。\n (condition-signal cond)\n cond 必须是一个条件对象。\ncondition-signal释放所有等待cond 标识的条件对象的线程的其中一个。\n (condition-broadcast cond)\n cond 必须是一个条件对象。\ncondition-broadcast释放所有等待cond 标识的条件对象的线程\n锁 锁比互斥锁更原生，但是更加灵活和有效。\n只要锁在进程共享的内存中分配，它们还可以独立于线程系统使用（包括在Chez Scheme的非线程版本中）以在分离的Scheme进程中执行同步操作。锁只是一个字长的整数，即iptr或uptr外部类型，其中包含目标计算机的本机字节序，可能是使用define-ftype定义的大结构的一部分。必须在驻留于Scheme堆外部的内存中显式分配它，并在适当时显式释放。当仅涉及线程时（即，当不涉及多个进程时），可以通过foreign-alloc分配内存。 当涉及多个进程时，应在进程共享的某个区域中分配该锁。\n使用ftype-init-lock! 初始化后，进程或线程可以尝试通过**ftype-lock!或ftype-spin-lock!锁定lock 。一旦锁已被锁定并且在解锁之前，即使通过最近锁定它的进程或线程，再一次尝试锁定该锁也会失败。 任何进程或线程可以使用ftype-unlock!**来解锁lock，而不仅仅是通过最近锁定锁的进程或线程来解锁。\n锁机制提供的结构很少，并且分配和使用中的错误可能导致内存错误，死锁和其他问题。 因此，通常建议仅将锁用作更高级别抽象的一部分，以确保按规范方式使用锁。\n(define lock (make-ftype-pointer uptr (foreign-alloc (ftype-sizeof uptr)))) (ftype-init-lock! uptr () lock) (ftype-lock! uptr () lock) ⇒ #t (ftype-lock! uptr () lock) ⇒ #f (ftype-unlock! uptr () lock) (ftype-spin-lock! uptr () lock) (ftype-lock! uptr () lock) ⇒ #f (ftype-unlock! uptr () lock)  (ftype-init-lock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-init-lock! ftype-name (a \u0026hellip;) fptr-expr index)\n  (ftype-lock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-lock! ftype-name (a \u0026hellip;) fptr-expr index)\n  (ftype-spin-lock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-spin-lock! ftype-name (a \u0026hellip;) fptr-expr index)\n  (ftype-unlock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-unlock! ftype-name (a \u0026hellip;) fptr-expr index)\n 它们每个的语法都类似于ftype-set!，尽管带有隐式的val-expr 。 特别是，对fptr-expr 和访问器a \u0026hellip; 的限制和处理是相似的，但有一个重要的限制：最后一个访问器所指定的字段（该格式在其上进行操作）必须是一个字长的整数，即 ，iptr，uptr或具有本地字节序的等效项。\n**ftype-init-lock!**应该在使用任何其他运算符之前用于初始化锁； 如果不这样做，则其他操作符的行为是不确定的。\nftype-lock! 可用于加锁。如果发现在操作时锁已解锁，则将其锁定并返回#t；如果发现该锁已加锁，则返回#f且不更改该锁。\nftype-spin-lock! 也可以用来加锁。 如果在操作时发现该锁已解锁，则将其锁定并返回； 如果发现该锁已锁定，它将一直等待直到锁被解锁，然后再锁定并返回。如果没有其他进程或者线程来释放该锁，该操作不会返回且不能以正常的方式（包括GC）中断。也不保证公平，因此即使其他进程正在主动锁定和释放该锁，进程也可能无限期挂起。\nftype-unlock! 用于解锁。如果发现锁已被锁定，则将其解锁并返回。 否则，它将返回而不更改锁。\n原子操作Locked increment and decrement 当需要原子递增或递减时，可以使用此处描述的锁定操作。\n (ftype-locked-incr! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-locked-incr! ftype-name (a \u0026hellip;) fptr-expr index)\n 返回：如果更新的值为0，则为#t，否则为#f\n (ftype-locked-decr! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-locked-decr! ftype-name (a \u0026hellip;) fptr-expr index)\n 返回：如果更新的值为0，则为#t，否则为#f\n它们每个的语法都类似于ftype-set!，尽管带有隐式的val-expr 。 特别是，对fptr-expr 和访问器a \u0026hellip; 的限制和处理是相似的，但有一个重要的限制：最后一个访问器所指定的字段（该格式在其上进行操作）必须是一个字长的整数，即 ，iptr，uptr或具有本地字节序的等效项。\nftype-locked-incr! 自动读取指定字段的值，将值加1，然后将新值写回该字段。 同样，ftype-locked-decr! 原子读取指定字段的值，从该值中减去1，然后将新值写回到该字段中。 如果新值为0，则两者都返回#t，否则返回#f。\n引用计数 在Scheme堆之外管理内存的应用程序可以利用Scheme存储管理系统通过ftype guardians 执行引用计数。 在引用计数的内存管理系统中，每个对象都保存着指向它的指针计数。 当创建一个新的指针时，该计数增加；而在删除指针时，该计数减小。 当计数达到零时，不再需要该对象，并且可以将其占用的内存用于其他目的。\n (ftype-guardian ftype-name)\n ftype-name 必须命名一个ftype。 ftype的第一个基本字段（或在unions的情况下为第一个基本字段）必须是具有本地尾数的字长整数（iptr或uptr）。 假定此字段保存引用计数。\n返回新的ftype guardian g ，可以使用其注册ftype-name 类型（或ftype-nam e的某些子类型）的ftype-pointer。 通过使用ftype指针作为参数调用g ，可以向g 注册ftype指针。\nftype guardian不会像普通的guardian那样自动保护其注册的ftype指针免遭回收。而是，对于每个通过普通（非弱，非监护人指针）变得不可访问的已注册的ftype指针，guardian会减少ftype指针指向的对象的引用计数。如果引用计数值为0，则ftype指针将保留并可以从guardian中检索。 但是，如果生成的引用计数值非零，则不会保留ftype指针。假设回收器外部的代码正确维护了引用计数，则从ftype guardian检索的对象（通过不带参数的调用）将确保具有0引用计数。回收器使用等效的ftype-locked-decr!来减少引用计数，以支持由多个进程共享的内存中的非Scheme对象。在这样的系统中，程序本身应使用ftype-locked-incr! 和ftype-locked-decr! 或非Scheme等效项（例如，第4.8节中所述C语言的scheme.h中的 LOCKED_INCR和LOCKED_DECR宏）来维护引用计数。\n下面的示例为ftype对象定义了一个简单的ftype和一个分配器，该对象释放以前分配的且不再可访问的ftype对象。\nmodule (A make-A free-dropped-As) (define-ftype A (struct [refcount uptr] [data int])) (define g (ftype-guardian A)) (define free-dropped-As (lambda () (let ([a (g)]) (when a (printf \u0026#34;freeing ~s\\n\u0026#34; (ftype-ref A (data) a)) (foreign-free (ftype-pointer-address a)) (free-dropped-As))))) (define make-A (lambda (n) (free-dropped-As) (let ([a (make-ftype-pointer A (foreign-alloc (ftype-sizeof A)))]) (ftype-set! A (refcount) a 1) (ftype-set! A (data) a n) (g a) a)))) 我们可以通过分配，丢弃并立即回收指向A的ftype指针进行测试。\n\u0026gt; (do ([i 10 (fx- i 1)]) ((fx= i 0)) (make-A i) (collect)) freeing 10 freeing 9 freeing 8 freeing 7 freeing 6 freeing 5 freeing 4 freeing 3 freeing 2 \u0026gt; (free-dropped-As) freeing 1 由ftype guardian保护的对象可能包含指向其他对象的指针，这些其他对象的引用计数也应在分配包含对象时增加，并在释放包含对象时减少。\n线程参数  (make-thread-parameter object) | (make-thread-parameter object procedure)\n 创建线程参数后，将在每个当前线程和将来的线程中放置一个单独的位置，以保存参数的内部状态变量的值。 （当该参数变得不可访问时，存储管理器可以消除该位置。）一个线程中对线程参数的更改不会被其他任何线程看到。\n创建新线程时（请参阅fork-thread），每个线程参数的当前值（而非位置）都由新线程从派生线程继承。 类似地，当第一次激活通过其他方式创建的线程时（请参见4.8节中的Sactivate_thread），每个线程参数的当前值（而非位置）都由新线程从主（原始）线程继承。\n大多数内置参数是线程参数，但有些是全局的。 在他们定义的地方已经标注了是线程的还是全局的。 在非线程版本的Chez Scheme中，内置全局参数和线程参数之间没有区别。\nI/O 缓冲区 Chez Scheme为提高效率而缓冲文件I/O操作，但是缓冲的I/O不是线程安全的。 两个线程并发地读写同一个缓冲端口可能会破坏该端口，从而导致缓冲区溢出，并最终导致无效的内存引用。\n当以缓冲模式none打开时，可以禁用二进制输出端口上的缓冲。 但是，由于需要支持先行（lookahead），因此无法完全禁用输入端口上的缓冲，并且由于要在字符和字节之间进行转换的代码转换器有时需要先行输入，因此无法完全禁用文本端口（甚至是文本输出端口）上的缓冲。\n因此，除非在二进制输出端口开启缓冲模式为none的特殊情况下，否则两个线程绝不应该并发地读写同一个端口。替代方法包括指定一个线程为给定端口执行所有I / O，和为每个线程提供通用端口包装程序，仅在获取互斥量后才将请求转发到端口。\n初始的控制台以及当前的输入和输出端口以及transcript端口都是线程安全的，因此多个线程向控制台打印错误和/或调试消息是安全的。即使在同一行内，输出也可能是交错的，但是端口不会损坏。 这些端口的线程安全性是通过为每个I/O操作获取一个互斥锁的高成本来实现的。\n实例：有界队列 以下代码摘自文章“A Scheme for native threads1”，它使用许多线程系统功能实现了有界队列。 有界队列具有固定数量的可用插槽。 当队列已满时尝试入队会导致调用线程阻塞。 尝试从空队列中出队会导致调用线程阻塞。\n(define-record-type bq (fields (immutable data) (mutable head) (mutable tail) (immutable mutex) (immutable ready) (immutable room)) (protocol (lambda (new) (lambda (bound) (new (make-vector bound) 0 0 (make-mutex) (make-condition) (make-condition)))))) (define dequeue! (lambda (q) (with-mutex (bq-mutex q) (let loop () (let ([head (bq-head q)]) (cond [(= head (bq-tail q)) (condition-wait (bq-ready q) (bq-mutex q)) (loop)] [else (bq-head-set! q (incr q head)) (condition-signal (bq-room q)) (vector-ref (bq-data q) head)])))))) (define enqueue! (lambda (item q) (with-mutex (bq-mutex q) (let loop () (let* ([tail (bq-tail q)] [tail^ (incr q tail)]) (cond [(= tail^ (bq-head q)) (condition-wait (bq-room q) (bq-mutex q)) (loop)] [else (vector-set! (bq-data q) tail item) (bq-tail-set! q tail^) (condition-signal (bq-ready q))])))))) (define incr (lambda (q i) (modulo (+ i 1) (vector-length (bq-data q))))) 下面的代码演示了有界队列在一组线程中的应用，这些线程分别扮演数据的消费者和生产者。\n(define job-queue) (define die? #f) (define make-job (let ([count 0]) (define fib (lambda (n) (if (\u0026lt; n 2) n (+ (fib (- n 2)) (fib (- n 1)))))) (lambda (n) (set! count (+ count 1)) (printf \u0026#34;Adding job #~s = (lambda () (fib ~s))\\n\u0026#34; count n) (cons count (lambda () (fib n)))))) (define make-producer (lambda (n) (rec producer (lambda () (printf \u0026#34;producer ~s posting a job\\n\u0026#34; n) (enqueue! (make-job (+ 20 (random 10))) job-queue) (if die? (printf \u0026#34;producer ~s dying\\n\u0026#34; n) (producer)))))) (define make-consumer (lambda (n) (rec consumer (lambda () (printf \u0026#34;consumer ~s looking for a job~%\u0026#34; n) (let ([job (dequeue! job-queue)]) (if die? (printf \u0026#34;consumer ~s dying\\n\u0026#34; n) (begin (printf \u0026#34;consumer ~s executing job #~s~%\u0026#34; n (car job)) (printf \u0026#34;consumer ~s computed: ~s~%\u0026#34; n ((cdr job))) (consumer)))))))) (define (bq-test np nc) (set! job-queue (make-bq (max nc np))) (do ([np np (- np 1)]) ((\u0026lt;= np 0)) (fork-thread (make-producer np))) (do ([nc nc (- nc 1)]) ((\u0026lt;= nc 0)) (fork-thread (make-consumer nc)))) 这是示例程序运行后的可能的前几行输出：\n\u0026gt; (begin (bq-test 3 4) (system \u0026#34;sleep 3\u0026#34;) (set! die? #t)) producer 3 posting a job Adding job #1 = (lambda () (fib 29)) producer 3 posting a job Adding job #2 = (lambda () (fib 26)) producer 3 posting a job Adding job #3 = (lambda () (fib 22)) producer 3 posting a job Adding job #4 = (lambda () (fib 21)) producer 2 posting a job Adding job #5 = (lambda () (fib 29)) producer 1 posting a job Adding job #6 = (lambda () (fib 29)) consumer 4 looking for a job producer 3 posting a job Adding job #7 = (lambda () (fib 24)) consumer 4 executing job #1 consumer 3 looking for a job producer 2 posting a job Adding job #8 = (lambda () (fib 26)) consumer 3 executing job #2 consumer 3 computed: 121393 consumer 3 looking for a job producer 1 posting a job Adding job #9 = (lambda () (fib 26)) ... 在“A Scheme for native threads1”中给出了其他示例，包括可悬挂线程的定义和在无法访问时自动终止的线程。\n  R. Kent Dybvig. A Scheme for native threads. In Symposium in Honor of Mitchell Wand, August 2009. http://www.ccs.neu.edu/events/wand-symposium/.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","id":12,"section":"posts","summary":"下面介绍Chez Scheme线程系统过程和语法形式。 除了锁，锁增量和锁减量之外，线程系统的功能在非基于Windows的系统上在Posix线程","tags":["thread","scheme"],"title":"线程（Thread System in Chez Scheme）","uri":"https://lvsq.net/2020/02/thread/","year":"2020"},{"content":"垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。\n回收由默认的collect-request处理程序自动触发，该处理程序通过collect-request中断调用，该中断在分配了大约n个字节的存储空间后发生，其中n是参数collect-trip-bytes 的值。 默认的collect-request处理程序通过调用不带参数的collect程序来进行会睡。 可以通过更改参数collect-request-handler 的值来重新定义collect-request处理程序。 程序还可以通过直接调用collect来导致在collect-request中断之间发生回收。\nChez Scheme的回收器是基于分代 的。它根据对象的年龄（大致来说，回收幸存数）来对对象进行分类，且老对象比年轻对象回收的频率要低。由于年轻对象比老对象更快地变为不可访问，因此结果是大多数的回收花费的时间更少。系统还维护一个静态代（static generation, 类似Java的永久代），不会对此存储进行回收。仅当压缩堆（Scompact_heap）或要collect的target-generation 参数为static符号时，才将对象放入静态代中。\n非静态代的编号从最年轻的世代（开始于0）到collect-maximum-generation的当前值。存储管理器将新分配的对象放入第0代。在第0代的回收过程中，默认情况下，将第0代的对象挪到第1代，类似地，在第1代回收期间，存活的第0代和第1代对象移动到第2代，依此类推。在最大非静态对象回收的过程中，所有幸存的非静态对象都将移动（可能返回）到最大非静态代中。 通过这种机制，一个对象有可能跳过一个或多个世代，但这在许多对象上不太可能发生，并且如果这些对象变得不可访问，则最终将回收它们的存储。\n维护内部计数器gc-trip来控制何时回收每一代。 每次调用不带参数的collect 时（从默认的collect-request处理程序开始），gc-trip都会加1。在collect-generation基数为r 的情况下，回收的世代编号为g ，其gc-trip是$r^g$的倍数。 如果将collect-generation-radix设置为4，则系统将每次收集0代，每4次收集1代，每16次收集2代，依此类推。\n每次某个世代g 调用collect时，该世代g 被回收且gc-trip前进到下个$r^g$的边界，但是不会超过$r^{g+1}$的边界，r 不变还是collect-generation-radix的值。\n如果使用第二个参数tg 调用collect，则tg 确定目标代。 当g 是最大的非静态代时，tg 必须为g 或为static。 否则，tg 必须为g 或g + 1 。 当目标代是static符号时，非静态代中的所有数据都将移动到静态代中。静态代中的对象从不会被回收。 这在加载和初始化应用程序的永久代码和数据结构之后非常有用，以减少后续回收的开销。\n通过设置本节中描述的参数，可以对回收器的行为进行实质性的调整。通过重新定义collect-request处理程序且使用显式的g 和tg 参数调用collect，甚至有可能完全覆盖收集器的默认策略来确定何时回收每个世代。例如，程序员可以通过使用显式的g 和tg 参数调用collect来重新定义处理程序，以在长时间内将最大的非静态代视为静态代，该参数在该时间段内绝不等于最大的非静态代。\n (collect) | (collect g) | (collect g tg)\n g 必须是不大于最大非静态代（collect-maximum-generation返回的值）的非负确定编号。 如果g 已经是最大的非静态代编号，则tg 必须是一个等于g 的fixnum或static符号。 否则，tg 必须是一个等于g 或大于g 的fixnum。\n此过程使存储管理器执行垃圾回收。 collect是通过collect-request处理程序定期调用的，但是也可以显式调用它，以在特定时间（例如，在计时计算之前）强制进行回收。 在Chez Scheme的线程版本中，调用collect的线程必须是唯一的活动线程。\n系统将根据g 和tg （如果提供）确定回收哪些世代，如本节的介绍中所述。\n (collect-rendezvous)\n 请求垃圾回收的方式应该与由系统自动发起的GC的方式相一致。所有正在运行的线程经过协调，以便其中一个调用collect-request处理程序，而其他线程暂停直到处理程序返回。\n请注意，如果collect-request处理程序（请参阅collect-request-handler）没有调用collect，那么collect-rendezvous实际上不会执行垃圾回收。\n collect-notify\n 如果将collect-notify设置为true，则每当运行GC时，回收器都会打印一条消息。 默认情况下，collect-notify设置为#f。\n collect-trip-bytes\n Chez Scheme在内部以大块分配内存，并通过内联操作将这些块细分以提高效率。存储管理器确定是否为每个分配的大块仅请求一次回收。此外，在存储管理器请求回收和兑现回收请求之间可能会花费一些时间，尤其是如果通过with-interrupts-disabled或disable-interrupts临时禁用了中断时。因此，collect-trip-bytes仅是一种近似度量。\n collect-generation-radix\n 此参数确定默认情况下的collect-request处理程序调用不带参数的collect时回收每一代的频率。每$r^g$次发生一次对应世代的回收，其中r 是collect-generation-radix的值，g 是世代数。\n将collect-generation-radix设置为1会强制所有世代每次都被回收， 将collect-generation-radix设置为非常大的数目将无限期有效地延迟较早的一代的回收。\n collect-maximum-generation\n 此参数确定当前可以使用的最大非静态世代数,它的值是1到254范围内的精确整数。设置为1时，仅使用两个非静态生成。 设置为2时，将使用三个非静态世代，依此类推。 当设置为254时，将使用255个非静态代，再加上一个静态代，总共256个世代。增加世代数可以减少了收集旧对象的频率，潜在地减少了收集开销，但同时也潜在地增加了系统中保留的不可访问对象的数量，从而增加了所需的内存总量。\n collect-request-handler\n collect-request-handler的值必须是一个过程。当系统认为应该要进行GC时（即，自上次GC以来，系统分配了由参数collect-trip-bytes规定的存储量之后），该过程在不带参数的情况下被调用。\n默认情况下，collect-request-handler仅调用不带参数的collect。 可以通过将collect-request-handler设置为不执行任何操作的过程来禁用自动收集，例如：\n(collect-request-handler void) 也可以利用防止任何中断的critical-section来临时禁用GC\n release-minimum-generation\n 此参数的值必须介于0到collect-maximum-generation的值（包括）之间，并且默认为collect-maximum-generation的值。\n当分配新数据且进行GC时，storage-management会自动地从操作系统中请求额外的虚拟内存地址。相应地，在堆显著减小的情况下，系统尝试将先前从操作系统获得的某些虚拟内存返回给操作系统。默认情况下，系统仅在针对最大非静态时代的GC之后才这样做。也可以让系统在对更年轻的世代回收之后就执行此操作，方法是将release-minimum-generation的值更改为小于collect-maximum-generation的值。由参数指定的世代，或者任何较老的世代是GC的目标世代时，存储管理系统将在GC之后尝试将不需要的虚拟内存返回给操作系统。\n当collect-maximum-generation设置为一个新值g 时，release-minimum-generation也同时隐式地更改为g ，有两个前提：（a）修改前这两个参数具有相同的值；（b）release-minimum-generation的值大于g\n heap-reserve-ratio\n 此参数确定了保留的内存的大概数量（没有返回给OS，如release-minimum-generation所描述的）与当前已占用的内存量（不包含已变为静态的内存区域）的比例，它的值必须是不精确的非负整数值； 如果设置为精确的实数值，则精确的值将转换为不精确的值。默认值1.0，为每个当前占用的非静态页面保留一页内存。 将其设置为较小的值可能会导致较小的平均虚拟内存占用量，而将其设置为较大的值可能会导致较少的操作系统调用以请求和释放内存空间。\n弱序对，暂时序对和守护者Weak Pairs, Ephemeron Pairs, and Guardians weak pairs允许程序维护指向对象的弱指针。 指向对象的弱指针不会阻止存储管理系统回收该对象，但是只要该对象在系统中是可访问的，它仍然有效。\nephemeron pairs与weak pairs类似，但是ephemeron pairs拥有两个指针，其中仅仅在第一个指针存在的情况第二个指针才能存在\nguardians允许程序保护对象免遭垃圾回收器的重分配，并确定该对象何时被重新分配。\nweak paris, ephemeron pairs 和guardians允许程序将有关对象的信息保留在单独的数据结构（例如哈希表）中，而无需担心维护此信息将导致对象无限期地保留在系统中。\n另外，guardians允许无限期地从释放对象中保存对象，以便可以重用它们，或者可以使用存储在对象中的数据执行清理或其他操作。\n (weak-cons obj1 obj2)\n 返回：一个新的弱序对\nobj1 是新对的car, obj2构成了新对的cdr。弱序对和普通对是无法区分的，除了这两种方式：\n 弱序对可以使用**weak-pair?**这个谓词来区别普通对 弱序对维护了一个指向(car obj)的弱指针  弱序对的car中的弱指针就像普通指针一样，只要它指向的对象可以通过系统中某个地方的普通（非弱）指针访问即可。 但是，如果垃圾收集器在某个时候识别出不存在指向该对象的非弱指针，则它将每个指向该对象的弱指针替换为“ broken weak-pointer”对象**#!bwp**，并丢弃该对象。\n弱序对的cdr字段不是弱指针，因此可以使用弱序对来构造弱保持对象的列表。可以像使用普通的列表的处理操作（例如length，map和assv）来操作这些list。弱序对可以使用set-car!和set-cdr!来修改； 在set-car!之后，car字段包含指向新对象的弱指针，代替了旧对象。弱序对的打印方式与普通对相同。 弱序对没有reader语法。弱序对在被写入然后被读取时成为普通对。\n(define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x \u0026#39;())) (car p) ⇒ (a . b) (define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x \u0026#39;())) (set! x \u0026#39;*) (collect) (car p) ⇒ #!bwp  (weak-pair? obj)\n (weak-pair? (weak-cons ’a ’b)) ⇒ #t (weak-pair? (cons ’a ’b)) ⇒ #f (weak-pair? \u0026#34;oops\u0026#34;) ⇒ #f  (ephemeron-cons obj1 obj2)\n obj1 是新对的car, obj2构成了新对的cdr。暂时序对和普通对是无法区分的，除了这两种方式：\n 暂时序对可以使用**ephemeron-pair?**这个谓词来区别普通对 暂时序对维护了一个指向(car obj)的弱指针，并且仅仅在pair的car存在时cdr才能保留  暂时序对的行为与弱序对类似，不过cdr有特殊的处理：如果car被设置为**#!bwp**的同时也会将cdr设置为**#!bwp**。由于同时将car和cdr字段设置为为**#!bwp**，因此可以通过cdr对象引用car对象这一事实本身并不意味着必须保留car（与弱序对不同）。 相反，出于某种原因，car必须独立于cdr对象保存。\n与弱序对和其他对一样，暂时序对使用**set-car!和set-cdr!**来修改数据，暂时序对的打印方式与普通对一样，但没有reader语法\n(define x (cons \u0026#39;a \u0026#39;b)) (define p (ephemeron-cons x x)) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b) (define x (cons \u0026#39;a \u0026#39;b)) (define p (ephemeron-cons x x)) (set! x \u0026#39;*) (collect) (car p) ⇒ #!bwp (cdr p) ⇒ #!bwp (define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x x)) ; not an ephemeron pair (set! x \u0026#39;*) (collect) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b) 与弱序对一样，如果在将x设置为*之前进行了垃圾回收将该pair提升为较老的一代，则上面中间示例的最后两个表达式实际上可能返回（a . b）。 但是，在上面的最后一个示例中，最后两个表达式的结果将始终为（a . b），因为弱序对的cdr持有非弱引用，并且该非弱引用阻止car字段变** #!bwp**。\n (ephemeron-pair? obj)\n (ephemeron-pair? (ephemeron-cons \u0026#39;a \u0026#39;b)) ⇒ #t (ephemeron-pair? (cons \u0026#39;a \u0026#39;b)) ⇒ #f (ephemeron-pair? (weak-cons \u0026#39;a \u0026#39;b)) ⇒ #f (ephemeron-pair? \u0026#34;oops\u0026#34;) ⇒ #f  (bwp-object? obj)\n 返回：如果obj是断开的broken weak-pair对象，则返回#t，否则返回#f\n(bwp-object? #!bwp) ⇒ #t (bwp-object? \u0026#39;bwp) ⇒ #f (define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x \u0026#39;())) (set! x \u0026#39;*) (collect (collect-maximum-generation)) (car p) ⇒ #!bwp (bwp-object? (car p)) ⇒ #t  (make-guardian)\n Guardians由要保护的对象组的过程表示。创建guardian后，注册对象组为空。 通过将对象作为参数传递给守护者，可以向guardian注册对象：\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) x ⇒ (aaa . bbb) (G x) 注册对象时也可以指定“representative”（即，y）对象。 继续上面的示例：\n(define y (cons \u0026#39;ccc \u0026#39;ddd)) y ⇒ (ccc . ddd) (G y \u0026#39;rep) 与守护者关联的一组注册对象在逻辑上细分为两个不相交的子组：一个子组称为“可访问”对象，一个子组称为“不可访问”对象。不可访问的对象是已被证明无法访问的对象（通过guardian机制本身或通过弱序对或暂时序对的car字段除外），可访问的对象是未经证明的对象。“已证明”一词在这里很重要：可能是可访问组中的某些对象确实是不可访问的，但这尚未得到证明。 在某些情况下，直到对象实际上变得不可访问很久之后（在当前实现中，直到发生包含对象的世代的垃圾回收），才可能做出这种证明。\n向guardian注册的对象最初被放置在可访问组中，并在它们变得不可访问后的某个时刻移入不可访问组。 不可访问组中的对象是通过调用不带参数的guardian来检索的。 如果不可访问组中没有对象，则guardian返回#f。 继续上面的示例：\n(G) ⇒ #f (set! x #f) (set! y #f) (collect) (G) ⇒ (aaa . bbb) ; 也有可能这个后打印出来 (G) ⇒ rep ; 这个先打印出来 (G) ⇒ #f 对G的初始调用返回#f，因为绑定到x和y的对是向G注册的唯一对象，并且仍然可以通过这些绑定访问这些序对。调用collect时，对象将移入不可访问的组。 因此，对G的两个调用返回先前绑定到x的序对和先前绑定到y的序对的representative，尽管可能与所示顺序相反。 （如上所述，对于弱序对，如果对象已迁移到较老的一代，则调用collect实际上可能不足以证明该对象不可访问。）\n实际上，从guardian那里获取的对象在任何方面都没有特殊的地位。 此功能避免了共享或循环结构可能会出现的问题。 由不可访问对象组成的共享或循环结构将被完整保留，将注册由guardian保护的部分都放置在该guardian不可访问的集合中。 然后，程序员可以完全控制结构的处理顺序。\n一个对象可以在guardian处多次注册，在这种情况下，可以多次检索该对象：\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) (G x) (G x) (set! x #f) (collect) (G) ⇒ (aaa . bbb) (G) ⇒ (aaa . bbb) 它也可以向不止一个guardian注册，并且guardian本身也可以向其他guardian注册。 在没有“representative”的情况下向guardian注册的对象，并放置在一个弱序对或暂时对的car字段中，其直到从guardian处将返回并由程序丢弃，或者直到guardian本身被丢弃为止。\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) (define p (weak-cons x \u0026#39;())) (G x) (set! x #f) (collect) (set! y (G)) y ⇒ (aaa . bbb) (car p) ⇒ (aaa . bbb) (set! y #f) (collect 1) (car p) ⇒ #!bwp 另一方面，如果指定了representative（对象本身除外），则在从guardian处获得representative的同时，也会从弱序对或暂时序对的car字段中丢弃受保护的对象。\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) (define p (weak-cons x \u0026#39;())) (G x \u0026#39;rep) (set! x #f) (collect) (G) ⇒ rep ; 获得representative的值 (car p) ⇒ #!bwp ; 自动丢弃 下面的示例说明了当guardian本身丢弃时，该对象已被释放并且弱序对的car字段设置为#!bwp：\n(define G (make-guardian)) (define x (cons aaa \u0026#39;bbb)) (define p (weak-cons x \u0026#39;())) (G x) (set! x #f) (set! G #f) (collect) (car p) ⇒ #!bwp 下面的示例演示了如何使用guardian来释放外部存储，就像由C库“malloc”和“free”操作管理存储。\n(define malloc (let ([malloc-guardian (make-guardian)]) (lambda (size) ; first free any storage that has been dropped. to avoid long ; delays, it might be better to deallocate no more than, say, ; ten objects for each one allocated (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f)))) ; then allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x)))) do-malloc必须返回一个Scheme对象“header”，该header封装一个指向外部存储的指针（可能是无符号整数），并且必须通过此header对外部存储进行所有访问。特别是，必须注意在删除相应的header之后，在Scheme之外不存在指向外部存储的指针。 do-free必须使用封装的指针释放外部存储。这两个原语都可以使用外部分配和外部无关的定义，也可以作为外部过程导入的C库“malloc”和“free”运算符进行定义。\n如果不希望调用malloc来释放存储，则可以使用collect-request处理器来检查并释放已丢弃的存储，如下所示：\n(define malloc) (let ([malloc-guardian (make-guardian)]) (set! malloc (lambda (size) ; allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x))) (collect-request-handler (lambda () ; first, invoke the collector (collect) ; then free any storage that has been dropped (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f))))))) 通过一点重构，就有可能将封装的外部地址注册为带header的representative，在这种情况下，do-free将仅将外部地址作为参数。 这将使标头一旦变得不可访问，便可以将其从Scheme堆中删除。\n锁对象Locking Objects 来自C语言的变量或数据结构到Scheme对象的所有指针，通常应在输入（或重新输入）Scheme之前丢弃。 当无法遵循该准则时，可以通过锁定对象或等效的C库过程Slock_object锁定该对象。\n (lock-object obj)\n 锁定对象可防止存储管理器收回或重定位该对象。 应谨慎使用锁定，因为它会导致内存碎片并增加存储管理开销。\n如果未解锁对象，锁定也会导致意外保留存储空间。 可以通过解锁对象或等效的C库过程Sunlock_object来解锁对象。\n锁定立即数（例如，fixnum，布尔值和字符）或已被静态化的对象是不必要但无害的。\n (unlock-object obj)\n 通过连续调用lock-object，Slock_object或同时调用这两个对象，可以多次锁定对象，在这种情况下，必须先通过相等次数的对unlock-object或Sunlock_object的调用来将其解锁。\n除非存在指向对象的单独的C指针，否则也无需锁定包含在锁定对象中的对象（例如，锁定序对的car中的对象）。也就是说，如果仅允许通过外部对象来间接访问的内部对象，则应将其解锁，以便回收器在回收期间可以自由地重分配它。\n解锁立即值（例如，fixnum，布尔值和字符）或已设为静态的对象是不必要的，无效的，但无害。\n (locked-object? obj)\n 返回：如果obj是锁定的，立即的或静态的，返回#t\n如果回收器无法重分配或回收obj，则该谓词将返回true，包括立即值，例如fixnums，布尔值和字符以及已设为静态的对象。\n","id":13,"section":"posts","summary":"垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动","tags":["scheme"],"title":"存储管理(Storage Management in Chez Scheme)","uri":"https://lvsq.net/2020/02/storage-management/","year":"2020"},{"content":"异常  (warning who msg irritant \u0026hellip;)\n  返回：未指定\n 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止程序继续运行但可能在以后导致更严重问题的情况。通常最好是识别程序员已调用的过程，而不是程序员可能不知道的其他过程。 msg必须为字符串，并应描述异常情况。irritant可以是任何Scheme对象，并且应包含可能导致或严重涉及异常情况的值。\n (assertion-violationf who msg irritant \u0026hellip;) | (errorf who msg irritant \u0026hellip;) | (warningf who msg irritant \u0026hellip;)\n 这些过程类似于assertion-violation, error, warning, 所不同的在于 msg 设定为一个格式字符串\n中断 Chez Scheme允许程序在发生各种事件时控制Scheme系统的操作，这些事件包括键盘中断，由set-timer设置的内部计时器到期，由中断调用引发的断点或者来自存储管理器的请求启动GC。\n无论何时break被调用，系统都会立即启用中断处理程序\n (break who msg irritant \u0026hellip;) | (break who) | (break)\n break参数遵循上述errorf的协议。默认的中断处理程序（请参见break-handler）显示一条消息并调用调试器。可以省略格式字符串和对象，在这种情况下，默认中断处理程序发出的消息使用who参数标识中断，但不提供有关中断的更多信息。如果也省略了who参数，则不会生成任何消息。如果调试器正常退出，则默认的中断处理程序将正常返回。\n break-handler\n 此参数的值必须是一个过程。当前的中断处理程序由break调用，它传递其参数。有关默认中断处理程序的描述，请参见break。以下示例显示了如何禁用breaks。\n(break-handler (lambda args (void)))  (set-timer n)\n n 必须为非负整数。当n 为非零时，设置计时器启动一个内部计时器，其初始值为n。经过n个tick后，将发生计时器中断，从而导致计时器中断处理程序被调用。tick不是统一的时间单位，而是在很大程度上取决于每个过程调用要完成多少工作。\n当n为零时，设置计时器关闭计时器。\nengine机制建立在计时器中断之上，因此不应与engine共同使用。\n (register-signal-handler sig procedure)\n register-signal-handler用于为给定的底层信号建立信号处理程序。 sig必须是标识有效信号的精确整数，过程应接受一个参数。在注册了给定signal的处理程序之后，收到了给定的signal会调用该处理程序。signal编号会传递给该处理程序，从而允许同一处理程序用于不同的信号，同时区分它们。\n以这种方式处理的信号类似于键盘中断，因为在将信号传递到进程时不会立即调用处理程序，而是在信号传递后在某个过程调用边界处调用该处理程序。因此，为内存故障，非法指令等建立处理程序通常不是一个好主意，因为导致故障或非法指令的代码将在调用处理程序之前继续执行（可能是错误的）一段时间。\n另外，仅在基于Unix的系统上才支持register-signal-handler。\n环境 环境是包含标识符绑定的顶级（first-class）对象。它们类似于模块，但是与模块不同，它们可以在运行时进行操作。环境可以作为eval，expand以及过程的定义，分配或引用顶级值的可选参数。\n有几种内置环境，也可以通过复制现有环境或从现有环境中选择的绑定来创建新环境。\n环境可以是可变的或不变的。可变的环境可以使用新的绑定进行扩展，可以修改其现有绑定，还可以分配其变量。不变的环境不能以任何这些方式进行修改。\n 联想一下SICP中关于环境的内容   (environment? obj)\n (environment? (interaction-environment)) ⇒ #t (environment? \u0026#39;interaction-environment) ⇒ #f (environment? (copy-environment (scheme-environment))) ⇒ #t (environment? (environment \u0026#39;(prefix (rnrs) $rnrs-))) ⇒ #t  (environment-mutable? env)\n (environment-mutable? (interaction-environment)) ⇒ #t (environment-mutable? (scheme-environment)) ⇒ #f (environment-mutable? (copy-environment (scheme-environment))) ⇒ #t (environment-mutable? (environment \u0026#39;(prefix (rnrs) $rnrs-))) ⇒ #f  (scheme-environment)\n scheme-environment返回一个包含初始顶级绑定的环境。该环境对应于Scheme模块。此过程返回的环境是不可变的。\n(define cons 3) (top-level-value \u0026#39;cons (scheme-environment)) ⇒ #\u0026lt;procedure cons\u0026gt; (set-top-level-value! \u0026#39;cons 3 (scheme-environment)) ⇒ exception  (copy-environment env) | (copy-environment env mutable?) | (copy-environment env mutable? syms)\n copy-environment返回env的副本，即包含与env 相同绑定的新环境。mutable? 如果为true，则该environment是可变的，反之则不可变；\n从env 复制到新环境的绑定集由syms 确定，其默认值为（environment-symbols env）。每个syms 元素的绑定（如果有）都被复制到新环境中，并且新环境中不存在其他绑定。\n在当前的实现中，永远不会收集环境使用的存储空间，因此重复使用复制环境最终将导致系统内存不足。\n(define e (copy-environment (scheme-environment))) (eval \u0026#39;(define cons +) e) (eval \u0026#39;(cons 3 4) e) ⇒ 7 (eval \u0026#39;(cons 3 4) (scheme-environment)) ⇒ (3 . 4)  (environment-symbols env)\n 此过程返回代表环境env中绑定的标识符的符号列表。它主要用于构建要从一种环境复制到另一种环境的符号列表。\n(define listless-environment (copy-environment (scheme-environment) #t (remq \u0026#39;list (environment-symbols (scheme-environment))))) (eval \u0026#39;(let ([x (cons 3 4)]) x) listless-environment) ⇒ (3 . 4) (eval \u0026#39;(list 3 4) listless-environment) ⇒ exception 编译、求值和加载  (eval obj) | (eval obj env)\n eval将obj 视为表达式的表示形式。它在环境env中计算表达式并返回其值。如果未提供任何环境，则默认为由交互环境返回的环境。单参数求值是Chez Scheme的扩展。当环境可变时，Chez Scheme还允许obj表示非表达形式，比如一个definition。 Chez Scheme还允许obj作为一个annotation，默认求值程序利用注释将源文件信息合并到错误消息中，并将源文件信息与编译后的代码相关联。\n在Chez Scheme中，eval实际上是一个包装器，仅将其参数传递给当前求值器（请参阅current-eval）。默认的评估器是compile，它通过当前的扩展器（参阅current-expand）扩展表达式，对其进行编译，执行生成的代码，并返回其值。如果存在环境参数env ，则compile将其传递给当前的扩展器，默认情况下为sc-expand。\n (compile obj) | (compile obj env)\n obj 可以为Scheme表达式，在指定的环境（或交互环境，如果未提供环境）中使用当前扩展器（current-expand的值）进行扩展），编译为机器代码，然后执行。 compile是current-eval参数的默认值。\n(compile \u0026#39;(cons 1 2)) =\u0026gt; (1 . 2)  (interpret obj) | (interpret obj env)\n 解释类似于编译，只是表达式是解释的而不是编译的（the expression is interpreted rather than compiled）。解释可以用作编译的替代品，但有以下警告：\n 解释后的代码运行速度大大降低 解释后的代码不会生成检查器信息，因此检查器对于解释的代码不如在编译的代码中有用、 无法解释外部过程表达式，因此解释器需要为所有外部过程表达式调用编译器（这是透明完成的）  当求值形式运行时间较短时，解释有时比编译更快，因为它避免了在求值之前通过编译完成的某些工作。\n (load path) | (load path eval-proc)\n path 必须是字符串。 load读取并求值path 指定的文件的内容。该文件可能包含源代码或目标代码。默认情况下，load使用eval求值源文件中找到的每个源表达式。如果指定了eval-proc ，则load将使用此过程。 eval-proc 必须接受一个参数，即要求值的表达式。\neval-proc参数有助于实现嵌入的类似于Scheme的语言，并有助于使用用于Scheme程序的替代评估机制。 eval-proc也可以用于其他用途。例如，\n(load \u0026#34;myfile.ss\u0026#34; (lambda (x) (pretty-print (if (annotation? x) (annotation-stripped x) x)) (newline) (eval x))) 对每一个表达式求值之前使用pretty-print打印。\n参数source-directorys确定了搜索目录，以搜索未由绝对路径名标识的源文件。\n (load-library path) | (load-library path eval-proc)\n load-library与load相同，除了它会将输入文件视为由隐式**＃!r6rs**作为前缀。这有效地禁用了所有**非R6RS**词法语法，除非随后被**＃！chezscheme**覆盖\n (load-program path) | (load-program path eval-proc)\n path 必须是字符串。加载程序读取并求值path指定的文件的内容。该文件可能包含源代码或目标代码。如果包含源代码，则加载程序会将代码以顶级程序形式包装起来，以便将文件的内容视为RNRS顶级程序（Scheme编程语言，第4版的10.3节）。默认情况下，加载程序使用eval求值文件中找到的每个源表达式。如果指定了eval-proc，则装入程序将使用此过程。 eval-proc必须接受一个参数，即要评估的表达式。传递给eval-proc的表达式可能是注释或未注释的值。 参数source-directorys确定了搜索目录，以搜索未由绝对路径名标识的源文件。\n (load-compiled-from-port input-port)\n load-compiled-from-port读取并求值来自input-port的对象代码的内容，这些input-port是事先由诸如compile-file, compile-script, compile-library, compile-to-port创建的返回值是最后一个表达式的值，该表达式的编译形式为input-port。如果input-port为空，则结果值未指定。\n (compile-file input-filename) | (compile-file input-filename output-filename)\n input-filename 和output-filename 必须是字符串。input-filename 必须是已存在的可读文件。它必须包含零个或多个源表达式的序列；如果不是这种情况，则编译文件会引发条件类型为＆syntax的异常。\n正常求值过程分为两个步骤：编译和执行。 compile-file对整个源文件执行编译过程，从而生成目标文件。随后加载目标文件（请参见load）时，不需要编译过程，并且文件加载通常快几倍。\n (compile-script input-filename) | (compile-script input-filename output-filename)\n compile-script与compile-file类似，不同点在于，它会从源文件复制开头的**#!**行到目标文件，同时该行不会被压缩，尽管参数**compile-compressed**被设置为#t，其他代码会被压缩，这样会保证操作系统可以正确地解释。\ncompile-script允许从源脚本创建已编译的脚本文件，以减少脚本加载时间。与源代码脚本一样，可以使用**\u0026ndash;script**命令行选项运行已编译的脚本。\n (compile-library input-filename) | (compile-library input-filename oiutput-filename)\n compile-library与compile-file相同，不同之处在于，它会将输入文件视为由隐式**＃!r6rs**作为前缀。这有效地禁用了所有非R6RS词法语法，除非随后被＃!chezscheme覆盖。\n (compile-program input-filename) | (compile-program input-filename output-filename)\n compile-program类似于compile-script，但不同之处在于，它实现了RNRS顶级程序的语义，而compile-script则实现了交互式顶级程序的语义。与通过compile-file或compile-script进行编译相比，生成的已编译程序的运行速度也更快。\ncompile-program返回由编译的顶层程序直接调用的库的列表，不包括（rnrs）和（chezscheme）之类的内置库\n (compile-whole-program input-filename output-filename) | (compile-whole-program input-filename output-filename libs-visible?)\n compile-whole-program接受一个文件名作为名称输入，该文件名为顶级程序命名为“ whole program optimization”（wpo）文件，并生成一个包含该程序及其所依赖的每个库的目标文件，前提是需要一个可以找到库的wpo文件。\n如果wpo文件找不到所需库，但可以找到该库的目标文件，则该库不会合并到生成的目标文件中。这些库将在运行时加载。 compile-whole-program返回这些库的列表。如果没有这样的库，则生成的目标文件是自包含的，并且compile-whole-program返回空列表。\n如果libs-visible? 设置为非false，则库合并到目标文件是可见的（供environment和eval使用），任何合并到目标文件中并在运行时保留下来的目标文件所要求的库都是可见的。\n当generate-wpo-files参数设置为#t时，过程compile-file，compile-program，compile-library，compile-script和compile-whole-library会生成wpo文件以及普通目标文件。 （默认值为#f）。另外如果传递可选的wpo端口时，compile-port和compile-to-port也会这样做。\n (compile-whole-library input-filename output-filename)\n compile-whole-library类似于compile-whole-program，不同之处在于input-filename必须为库指定一个wpo文件，所有库自动显示，并生成一个新的wpo文件（当generate-wpo-files为#t时）以及用于生成的库组合的目标文件。\n (compile-port input-port output-port) | (compile-port input-port output-port sfd) | (compile-port input-port output-port sfd wpo-port)\n input-port 必须是文本输入端口。out-port 和wpo-port（如果存在）必须是二进制输出端口。如果存在sfd ,必须是源文件描述符。\n (make-boot-file output-filename base-boot-list input-filename \u0026hellip;)\n 所有参数都必须是字符串。\nmake-boot-file将引导标头（boot header）写入以output-filename 命名的文件，然后依次写入每个input-filename 的目标代码。如果尚未编译输入文件，make-boot-file将在对其进行编译。\n引导文件通过\u0026ndash;boot或-b命令行选项显式加载，或基于可执行文件的名称隐式加载。\n (make-boot-header output-filename base-boot1 base-boot2\u0026hellip;)\n 该过程已包含在make-boot-file中，并提供了向后兼容性。\n(make-boot-header output-filename base-boot1 base-boot2 \u0026hellip;)等价于：(make-boot-file output-filename ’(base-boot1 base-boot2 \u0026hellip;))源目录和文件  source-directories\n source-directories的值必须是一个字符串列表，每个字符串都命名一个目录路径。当通过load, load-library, load-program, include, visit, or revisit在交互式检查器中发生语法错误或打开源文件时，source-directory确定用于搜索源文件或目标文件的目录集。\n默认值为列表（“.”），这意味着仅在当前目录中或相对于当前目录才能找到源文件，除非使用绝对路径命名。\n (with-source-path who name procedure)\n 过程with-source-path依次搜索当前源目录路径，以查找具有指定名称的文件，并在结果上调用过程。如果未找到这样的文件，则引发**\u0026amp;assertion**和**\u0026amp;who**异常，**\u0026amp;who**的值为*who* 的值\n如果name 是绝对路径，或者以./（Windows下是./），或者../（Windows下是..\\），或者源目录列表中只包含“.”，或者默认值 \u0026ldquo;\u0026quot;，相当于 \u0026ldquo;.\u0026quot;，不执行搜索并返回name。\nwho 必须是符号，name 必须是字符串，procedure 应接受一个参数。\n以下示例假定文件“ pie”存在于目录“ ../spam”中，但不在“ ../ham”或当前目录中。\n(define find-file (lambda (fn) (with-source-path \u0026#39;find-file fn values))) (find-file \u0026#34;pie\u0026#34;) ⇒ \u0026#34;pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../ham\u0026#34;)) (find-file \u0026#34;pie\u0026#34;) ⇒ exception in find-file: pie not found (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../spam\u0026#34;)) (find-file \u0026#34;pie\u0026#34;) ⇒ \u0026#34;../spam/pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../ham\u0026#34;)) (find-file \u0026#34;/pie\u0026#34;) ⇒ \u0026#34;/pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../ham\u0026#34;)) (find-file \u0026#34;./pie\u0026#34;) ⇒ \u0026#34;./pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../spam\u0026#34;)) (find-file \u0026#34;../pie\u0026#34;) ⇒ \u0026#34;../ham/pie\u0026#34; 编译器管理  optimize-level\n 该参数可以是0，1，2，3这4个值中的一个。\n理论上，此参数控制编译器执行的优化量。 实际上，它只是间接执行此操作，唯一的区别在于优化级别3（编译器生成“不安全”代码）与优化级别0-2（编译器生成“安全”代码）之间。 安全代码会执行完整类型和范围检查，例如，尝试应用非过程，尝试对non-pair的car操作或尝试引用向量的末尾，均会导致 引发异常。 对于不安全的代码，相同的情况可能会导致无效的内存引用，Scheme堆损坏（这可能在以后引起看似无关的问题），系统崩溃或其他不良行为。不安全的代码通常会更快，但是应该谨慎使用优化级别3，并且仅运用在必须尽快运行且经过良好测试的代码中。\n尽管编译器为优化0至2级生成了相同的代码，但如果需要，用户定义的宏转换器可以区分不同的级别。\n一种使用优化级别的方法是在每个文件上，强制使用eval-when。 例如:\n(eval-when (compile) (optimize-level 3))  也可以通过\u0026ndash;optimize-level命令行选项设置优化级别。此选项对于通过\u0026ndash;program命令行选项在优化级别3运行RNRS顶层程序特别有用，因为eval-when对RNRS顶层程序无效。\n ($primitive variable) | ($primitive 2 variable) | ($primitive 3 variable)\n variable 必须是一个原始procedure的名字。** $primitive**语法形式允许以单个原始引用的粒度控制优化级别，并且它可以用于访问原始值。\n表达式（$primitive variable）可以缩写为**#%variable**。\n(#%car ’(a b c)) ⇒ a (let ([car cdr]) (car \u0026#39;(a b c))) ⇒ (b c) (let ([car cdr]) (#%car \u0026#39;(a b c))) ⇒ a (begin (set! car cdr) (#%car \u0026#39;(a b c))) ⇒ a  debug-level\n 该参数可以采用0、1、2和3这四个值之一。它用于告诉编译器保留调试信息的重要性，其中0的重要性最低，而3的重要性最高。 默认值是1。从9.0版开始，它仅用于确定在非尾部位置遇到的引起错误的调用是否被视为在尾部位置（因此，导致调用者的帧不出现在堆栈回溯中）。 这发生在低于2的调试级别。\n概要分析Profiling ChezScheme支持两种类型的配置文件：源代码概要分析和块概要分析。\n启用源概要分析后，编译器会对生成的代码进行检测，以计算每个源代码表达式的执行次数。 该信息可以HTML格式显示或打包在列表中，以进行任意用户定义的处理。 也可以将其转储到文件中，然后再加载到编译器的概要分析信息数据库中，以用于源代码级优化。\n源代码概要分析至少包含下面一些步骤：\n 编译代码且开启source profiling 运行编译后的代码生成源代码概要分析信息，且 转储概要分析信息  通过将参数compile-profile设置为符号源或布尔值#t，可以启用源概要分析。 可以通过以下方式转储概要分析信息：\nprofile-dump-html 以HTML格式显示，以便程序员可以直观地看到使用彩色编码系统执行每个表达式的频率，该系统可以轻松发现“热点”profile-dump-list 以适合用户定义的后处理的形式;profile-dump 以适合于通过上述方法之一或某些自定义方式进行离线处理的形式，或profile-dump-data 以适合加载到编译器数据库中的形式。\n由profile-dump-data转储的概要分析信息通过profile-load-data加载到编译器的profiling数据库中。 除非通过profile-dump-data显式转储并通过profile-load-data加载，否则分析信息对编译器不可用。\n当使用块概要文件信息进行优化时，步骤是相似的： 编译代码并开启block profiling 运行代码生成block-profiling信息 转储概要分析信息 加载概要信息，且 重新编译代码  通过将参数compile-profile设置为符号块或布尔值#t，可以启用块分析。 概要文件信息必须通过profile-dump-data转储，并通过profile-load-data加载。 与源配置文件信息一样，块配置文件信息可以与转储信息的加载过程相同或不同。\n对于块优化，要重新编译的代码必须相同。 通常，这意味着所涉及的文件必须未经修改，并且其他任何更改都不会间接影响编译器生成的代码。\n出于同样的原因，当要同时使用源概要分析和块概要分析信息进行优化时，必须先收集并加载源信息，然后再运行涉及块概要分析的第一次和第二次编译。 即，必须使用以下步骤：1. 编译代码并起开源代码概要分析 2. 运行代码生成source-profiling信息 2. 转储source-profiling 3. 加载source-profiling 3. 重新编译代码，并开启块概要分析 4. 运行代码生成block-profiling信息 4. 转储block-profiling 5. 加载source-和block-profiling 5. 重新编译代码  标记每个步骤的数字既指示步骤的顺序，又指示必须在同一计划过程中执行的顺序。 （如果需要，所有步骤都可以在同一Scheme流程中执行。） 当compile-profile设置为默认值#f时，将禁用源和块分析。\n假设文件/tmp/fatfib/fatfib.ss包含以下代码：\n(define fat+ (lambda (x y) (if (zero? y) x (fat+ (1+ x) (1- y))))) (define fatfib (lambda (x) (if (\u0026lt; x 2) 1 (fat+ (fatfib (1- x)) (fatfib (1- (1- x))))))) 我们可以像下面这样加载fatfib.ss并且开启概要分析：\n(parameterize ([compile-profile \u0026#39;source]) (load \u0026#34;/tmp/fatfib/fatfib.ss\u0026#34;)) 然后运行代码：\n(fatfib 20) ⇒ 10946 运行（或多次运行）之后，转储概要文件为一些html文件集合： 使用profile-dump-html\n(profile-dump-html) 这将创建一个名为profile.html的文件\n在图中，执行最频繁的代码以接近红色的颜色突出显示，而执行最不频繁的代码以接近紫色的颜色突出显示。\n compile-profile\n 当将此参数设置为符号source或布尔值**#t**时，编译器将使用指令对生成的代码进行检测，这些指令对源代码的每个部分执行的次数进行计数。 当设置为符号**block**时，编译器类似地使用指令对生成的代码进行检测，该指令对每个代码块的执行次数进行计数。 当设置为**#f**（默认值）时，编译器不会插入这些指令。\n当compile-profile为非false时生成的代码较大且效率较低，因此仅在需要概要分析信息时才应设置此参数。启用概要分析检测后编译的代码的概要文件计数器将无限期保留，即使与它们关联的代码已被垃圾收集器回收。 这样可以得到更完整和准确的概要分析数据，但会导致动态生成或加载代码的程序出现空间泄漏，程序可以通过profile-release-counters过程显式地释放计数器，从而避免潜在的空间泄漏。\n (profile-clear)\n 调用此过程会清空概要分析信息，代码每个部分关联的计数都被置为0\n (profile-release-counters)\n 调用此过程将丢弃概要分析\n (profile-dump)\n 此过程将生成自启动或上次调用profile-clear以来收集的所有配置文件信息的转储。 它返回一个pair的列表，其中每个pair的car是一个source-object，而cdr是一个精确的非负整数计数。\nprofile-dump优于profile-dump-list的优点在于，profile-dump仅执行最少的处理，并保留完整的源对象，包括其嵌入式源文件描述符。 例如，它可以用于将概要分析信息转储到一台计算机上的fasl文件中，以便在另一台计算机上进行后续处理。\n (profile-dump-html) | (profile-dump-html prefix) | (profile-dump-html prefix dump)\n 此过程将生成一个或多个HTML文件，包括profile.html（其中包含用颜色编码的摘要信息），以及一个文件source.html，其中每个源文件源都包含用源代码进行颜色编码的副本，如前导中所述： 在本节中。 如果指定了prefix ，则它必须是字符串，并且在生成的HTML文件的名称之前。 例如，如果前缀为**“ /tmp/”**，则生成的文件将放置在目录/tmp中。 原始概要分析信息是从转储获取的，默认为**profile-dump**返回的值\n (profile-palette)\n 此参数的值必须是至少三对的非空向量。 每个pair的car是背景色，而cdr是前景（文本）色。 每种颜色都必须是一个字符串，并且每个字符串都应包含HTML层叠样式表（CSS）颜色说明符。 第一组用于未配置的代码，第二对用于未执行的配置的代码。 第三个用于执行频率最低的代码，第四个用于执行频率倒数第二低的代码，以此类推，最后一个用于执行频率最高的代码。 程序员可能希望提供自己的调色板以增强可见性或更改所用颜色的数量。\n默认情况下，黑色背景用于未配置文件的代码，灰色背景用于未执行的配置文件的代码。 根据执行频率，紫色到红色的背景颜色用于执行的概要分析代码，而最频繁执行的代码使用红色。\n(profile-palette) ⇒ #((\u0026#34;#111111\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#607D8B\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#9C27B0\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#673AB7\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#3F51B5\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#2196F3\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#00BCD4\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#4CAF50\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#CDDC39\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FFEB3B\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FFC107\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FF9800\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#F44336\u0026#34; . \u0026#34;white\u0026#34;)) (profile-palette ; set palette with rainbow colors and black text ; for all but unprofiled or unexecuted code \u0026#39;#((\u0026#34;#000000\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#666666\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#8B00FF\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#6600FF\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#0000FF\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#00FF00\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FFFF00\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FF7F00\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FF0000\u0026#34; . \u0026#34;black\u0026#34;))) ; red  (profile-line-number-color)\n 此参数的值必须是字符串或#f。 如果是字符串，则该字符串应包含HTML层叠样式表（CSS）颜色说明符。 如果参数设置为字符串，则profile-dump-html使用指定的颜色在每个源文件的html呈现中包括行号。 如果参数设置为#f，则不包含行号。\n个性化（Waiter Customization）  (new-cafe) | (new-cafe eval-proc)\n Chez Scheme通过waiter 或read-eval-print循环（REPL）与用户进行交互。 waiter在称为caf́e的上下文中运行。 当系统启动时，将用户置于caf́e中并分配waiter 。 new-cafe在旧的caf́e之上开启了一个新的Scheme caf́e。 除了启动waiter 之外，new-cafe还设置了caf́e的重置和退出处理程序（请参阅reset-handler和exit-handler）。 退出caf́e会返回到创建该caf́e的caf́e。从最初的caf́e退出后会完全退出了Scheme。 caf́e可以通过显式调用exit或通过接收end-of-file（Unix系统上为“ control-D”）来退出。在前一种情况下，传递给exit的任何值都是从new-cafe返回的。\n\u0026gt; (define x 1) \u0026gt; x 1 \u0026gt; (new-cafe) \u0026gt;\u0026gt; x 1 \u0026gt;\u0026gt; (define y 2) \u0026gt;\u0026gt; y 2 \u0026gt;\u0026gt; (exit 1) 1 如果指定了可选的eval-proc 参数，则使用eval-proc 求值从控制台输入的程序。 否则，将使用参数current-eval 的值。 eval-proc必须接受一个参数，即要求值的表达式。\n\u0026gt; (new-cafe (lambda (x) x)) \u0026gt;\u0026gt; 3 3 \u0026gt;\u0026gt; (a . (b . (c . ()))) (a b c) \u0026gt; (define sum (lambda (ls) (if (null? ls) 0 (+ (car ls) (sum (cdr ls)))))) \u0026gt; (new-cafe sum) \u0026gt;\u0026gt; (1 2 3) 6 时间和日期 时间由时间对象表示。 时间对象记录特定时间或持续时间的纳秒和秒，以及标识时间对象性质的time type 。 时间类型是以下符号之一：time-utc: 从“纪元”1970年1月1日0点0分0秒以来的时间time-monotonic: 从过去某个任意时间点开始经过的时间，理想情况下无需进行调整。time-duration: 两个时间的间隔。当作为current-time的参数时，其行为与time-monotonic类似，但也可以用来表示两个时间对象相减的结果time-process: 当前进程使用的CPU时间量。time-thread: 当前线程使用的CPU时间量。 如果未运行线程，或者系统不允许确定单个线程时间，则该时间与time-process相同。time-collector-cpu: 当前进程用于垃圾回收的这部分CPU消耗的时间。time-collector-real: 当前进程用于垃圾回收的这部分实时消耗的时间日期由日期对象表示。 日期对象记录特定日期的纳秒，秒，分钟，小时，日，月和年，以及标识时区的偏移量。\n (current-time) | (current-time time-type)\n time-type 必须是上述的时间对象之一，默认为time-utc\n(current-time) ⇒ #\u0026lt;time-utc 1198815722.473668000\u0026gt; (current-time ’time-process) ⇒ #\u0026lt;time-process 0.120534264\u0026gt;  (make-time type nsec sec)\n type 必须是上面列出的时间类型符号之一。 nsec 表示纳秒，并且必须是小于$10^9$的精确非负整数。sec 表示秒，并且必须是精确的整数。\n(make-time \u0026#39;time-utc 787511000 1198783214) (make-time \u0026#39;time-duration 10 5) (make-time \u0026#39;time-duration 10 -5)  (time? obj)\n (time? (current-time)) ⇒ #t (time? (make-time ’time-utc 0 0)) ⇒ #t (time? \u0026#34;1400 hours\u0026#34;) ⇒ #f  (time-type time)\n 返回time 的时间类型\n (time-nanosecond time)\n 返回time 的纳秒\n (time-second time)\n 返回time 的秒\n (set-time-type! time type) | (set-time-nanosecond! time nsec) | (set-time-second! time sec)\n 每一个过程都会修改时间对象，只改变局部，而其他值则不受影响。 例如，set-time-nanosecond! 只更改纳秒时间，而不更改秒或类型。 特别地，当时间对象的类型改变时，值并不会更改。\n (time=? time1 time2) | (time\u0026lt;? time1 time2) | (time\u0026gt;? time1 time2) | (time\u0026lt;=? time1 time2) | (time\u0026gt;=? time1 time2)\n 时间比较。\n (copy-time time)\n 复制时间。\n(define t1 (current-time)) (define t2 (copy-time t1)) (eq? t2 t1) ⇒ #f (eqv? (time-second t2) (time-second t1)) ⇒ #t (eqv? (time-nanosecond t2) (time-nanosecond t1)) ⇒ #t  (time-difference time1 time2 ) | (time-difference! time1 time2 ) | (add-duration time timed) | (add-duration! time timed) | (subtract-duration time timed) | (subtract-duration! time timed)\n 对于time-difference，time1和time2必须具有相同的时间类型，结果是时间类型为time-duration的时间对象。 对于add-duration，add-duration！，subtract-duration和subtract-duration！，timed必须具有时间类型time-duration，并且结果是时间类型与时间相同的时间对象。 time-difference！，add-duration！和subtract-duration！ 可能具有破坏性，即每个对象都可能修改并返回其第一个参数，或者可能分配了新的时间对象\n(let ([delay (make-time \u0026#39;time-duration 0 1)]) (let ([t1 (current-time \u0026#39;time-monotonic)]) (sleep delay) (let ([t2 (current-time \u0026#39;time-monotonic)]) (let ([t3 (time-difference t2 t1)]) (and (eq? (time-type t3) \u0026#39;time-duration) (time\u0026gt;=? t3 delay) (time=? (add-duration t1 t3) t2) (time=? (subtract-duration t2 t3) t1)))))) ⇒ #t  (current-date) | (current-date offset)\n 如上所述，offset 表示UTC以东的时区偏移量（以秒为单位）。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 可以通过传递零偏移量来获得UTC.offset表示UTC以东以秒为单位的时区偏移量，如上所述。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 UTC可以通过传递零偏移来获得。\n如果未提供offset ，则使用当前时区的offset，以及date-dst？ 和date-zone-name报告有关时区的信息。 如果提供了偏移量，那么date-dst？ 和结果日期对象上的date-zone-name都是**#f**。\n(current-date) ⇒ #\u0026lt;date Thu Dec 27 23:23:20 2007\u0026gt; (current-date 0) ⇒ #\u0026lt;date Fri Dec 28 04:23:20 2007\u0026gt; (date-zone-name (current-date)) ⇒ \u0026#34;EST\u0026#34; or other system-provided string (date-zone-name (current-date 0)) ⇒ #f  (make-date nsec sec min hour day mon year) | (make-date nsec sec min hour day mon year offset)\n nsec代表纳秒，并且必须是小于$10^9$的精确非负整数。sec代表秒，并且必须是小于62的精确非负整数。min代表分钟，并且必须是小于60的精确非负整数。hour必须是精确的非负整数 小于24。day必须是一个精确的整数，1≤day≤31。（实际上限可能取决于月份和年份。）mon表示月份必须是一个精确的整数，1≤mon≤12。年必须 是一个精确的整数。 如上所述，它应至少为1970。offset表示UTC以东的时区偏移（以秒为单位）。 它必须是-86400到+86400（含）范围内的精确整数。 可以通过传递零偏移量来指定UTC。\n(make-date 0 0 0 0 1 1 1970 0) ⇒ #\u0026lt;date Thu Jan 1 00:00:00 1970\u0026gt; (make-date 0 30 7 9 23 9 2007 -14400) ⇒ #\u0026lt;date Sun Sep 23 09:07:30 2007\u0026gt; (date-zone-name (make-date 0 30 7 9 23 9 2007 -14400)) ⇒ #f (string? (date-zone-name (make-date 0 30 7 9 23 9 2007))) ⇒ #t  (date-nanosecond date) | (date-second date) | (date-minute date) | (date-hour date) | (date-day date) | (date-month date) | (date-year date) | (date-zone-offset date)\n 如字面的意思， 返回日期的对应的部分的值\n (date-week-day date) | (date-year-day date)\n 通过这些过程，可以确定以date 表示的日期是星期几还是每年的某天。 week-day是小于7的精确非负整数，其中0表示星期日，1表示星期一，依此类推。 year-day是小于367的精确非负整数，其中0代表一年的第一天（1月1日），1代表第二天，2代表第三天，依此类推。\n (time-utc-\u0026gt;date time) | (time-utc-\u0026gt;date time offset) | (date-\u0026gt;time-utc date)\n 这些过程用于在时间和日期对象之间进行转换。 time-utc-\u0026gt;date的时间参数必须具有time-type utc，date-\u0026gt;time-utc始终返回带有time-type utc的时间对象。\n对于time-utc-\u0026gt;date，offset 表示UTC以东的秒数中的时区偏移，如本节开头所述。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 UTC可以通过传递零偏移来获得。\n (date-and-time) | (date-and-time date)\n 字符串始终采用以下示例所示的格式，长度始终为24。\n(date-and-time) ⇒ \u0026#34;Fri Jul 13 13:13:13 2001\u0026#34; (defined (make-date 0 0 0 0 1 1 2007 0)) (date-and-time d) ⇒ \u0026#34;Mon Jan 01 00:00:00 2007\u0026#34;  (sleep time)\n time 必须是类型为time-duration的时间对象。 sleep 导致调用线程在大约由时间对象指示的时间量内暂停操作，除非该进程收到中断睡眠操作的信号。 实际睡眠时间取决于系统时钟的粒度以及系统运行其他线程和进程的繁忙程度。\n时间和统计  (time expr) time求值expr ，并且作为副作用，打印（到console-output端口）cpu时间量，实时时间量，分配的字节数以及与求值expr 相关的收集开销。\n \u0026gt; (time (collect)) (time (collect)) 1 collection 1 ms elapsed cpu time, including 1 ms collecting 1 ms elapsed real time, including 1 ms collecting 160 bytes allocated, including 8184 bytes reclaimed   (cpu-time)\n 返回：自系统启动以来消耗的cpu时间量。\n该量以毫秒为单位。 该数量包括“system”时间和“user”时间，即代表进程在内核中花费的时间以及在进程本身中花费的时间。\n (real-time)\n 返回：自系统启动以来经过的实时时间\n以毫秒为单位的时间总量\n (bytes-allocated) | (bytes-allocated g)\n 返回：当前分配的字节数\n如果提供了g ，则bytes-allocated返回指定generation中当前为Scheme对象分配的字节数。 g 必须为非负精确整数，且不得大于最大非静态generation，即，collect-maximum-generation返回的值或符号为static。 如果未提供g ，则bytes-allocated返回所有generation中分配的字节总数。\n (initial-bytes-allocated)\n 返回：加载启动文件后分配的总字节数\n (bytes-deallocated)\n 返回：垃圾回收器释放的总字节数\n通过将（bytes-deallocated）和（bytes-allocated）相加并减去（initial-bytes-allocated），可以获得当前进程分配的总字节数（无论是否仍在使用中）。\n (current-memory-bytes)\n 返回：当前分配的字节总数，包括开销.\ncurrent-memory-bytes返回堆的总大小（以字节为单位），不仅包括Scheme对象占用的字节，还包括各种形式的开销（包括碎片和保留但当前不占用的内存），因此，它是操作系统中当前进程的堆内存量的准确度量值\n (maximum-memory-bytes)\n 返回：分配过的最大字节数，包括开销\n (reset-maximum-memory-bytes!)\n 将堆内存的最大记录值重置为当前堆大小\n (collections)\n 返回：到目前为止的垃圾回收次数\n (statistics)\n 返回：包含当前统计信息的sstats记录\nstatistics将各种时间和分配统计信息打包在一起，形成一个sstats记录。 sstats记录具有以下字段：\n         cpu, 消耗的cpu时间   real, 经过的时间   bytes, 分配的字节数   gc-count, gc次数   gc-real, gc经历的时间   gc-bytes, gc回收的字节数    所有值都是从系统启动开始算\nstatistics可以像如下定义：\n(define statistics (lambda () (make-sstats (current-time ’time-thread) (current-time ’time-monotonic) (- (+ (bytes-allocated) (bytes-deallocated)) (initial-bytes-allocated)) (collections) (current-time ’time-collector-cpu) (current-time ’time-collector-real) (bytes-deallocated))))  (make-sstats cpu real bytes gc-count gc-cpu gc-real gc-bytes) 返回：sstats记录\n  (sstats-cpu s) | (sstats-real s) | (sstats-bytes s) | (sstats-gc-count s) | (sstats-gc-cpu s) | (sstats-gc-real s) | (sstats-gc-bytes s)\n 返回：s 对应的部分的值\n (set-sstats-cpu! s new-value) | (set-sstats-real! s new-value) | (set-sstats-bytes! s new-value) | (set-sstats-gc-count! s new-value) | (set-sstats-gc-cpu! s new-value) | (set-sstats-gc-real! s new-value) | (set-sstats-gc-bytes! s new-value)\n 设置对应部分的值\n (sstats-difference s1 s2)\n 比较两个sstats\n enable-object-counts\n enable-object-counts的值是一个布尔值，它确定收集器在运行时是否记录对象计数，从而确定过程对象计数返回的object-counts是否准确。 由于启用对象计数会增加收集的开销，因此默认情况下该参数设置为#f。\n (object-counts)\n 过程object-countsx返回一个嵌套的关联列表，该列表表示为一个或多个世代中至少有一个活动实例的每个堆分配的原始类型和记录类型分配的对象计数和字节。 （堆分配的基本类型包括，例如，pair和向量，但不包括，例如，fixnum或字符。）仅当enable-object-countsxx为#t时，收集器才会收集对象计数。\nobject-countsx返回的关联列表具有以下结构： ((type (generation count . bytes) \u0026hellip;) \u0026hellip;)\ntype是原始类型的名称，以符号（例如，对）表示，或者是record-type描述符（rtd）。 generation是介于0和（collect-maximum-generation）的值（包含在内）或表示静态生成的符号static之间的非负固定编号。 count和字节是非负的fixnum。\n(collect-request-handler void) (enable-object-counts #t) (define-record-type frob (fields x)) (define x (make-frob (make-frob #f))) (collect 3 3) (cdr (assoc 3 (cdr (assoc (record-type-descriptor frob) (object-counts))))) =\u0026gt; (2. 16) 成本中心 Cost Centers 成本中心用于在求值选定的代码段时跟踪分配的字节，执行的指令和/或经过的CPU时间。 成本中心是通过过程make-cost-center创建的，而成本是通过with-cost-center过程进行跟踪的。\n仅为此目的代码跟踪分配和指令计数。 该工具由两个参数控制：generate-allocation-counts和generate-instruction-counts。 默认情况下禁用检测。 内置程序没有检测，解释代码或非Scheme代码也没有。 仅当过程with-cost-center的可选参数*timed?*有值且不为false时才会跟踪经历的时间\nwith-cost-center过程即使在使用同一成本中心重新输入，在多个线程中同时使用并通过继续调用退出或重新输入一次或多次后，也要遵循上述注意事项来准确跟踪成本。\n generate-allocation-counts\n 当此参数为true时，编译器会在生成的代码的每个分配点插入一小段指令，以跟踪发生的分配量。此参数最初为false。\n generate-instruction-counts\n 当此参数为true时，编译器将在生成的代码的每个块中插入简短的指令序列，以跟踪该块执行的指令数。 此参数最初为false。\n (make-cost-center)\n 返回: 新的成本中心\n (with-cost-center cost-center thunk) | (with-cost-center timed? cost-center thunk)\n thunk 必须是一个接受零参数的过程。 with-cost-center调用不带参数的thunk 并返回其值。 它还可以动态计算分配的字节数，执行的指令以及在计算thunk 调用时所经过的cpu时间，并将跟踪的成本添加到成本中心记录中。\n如上所述，仅对于将参数generate-allocation-counts 设置为true的编译的代码跟踪分配计数，并且仅对将generate-instruction-counts 设置为true的编译的代码跟踪指令计数。 仅在提供timed? 且不为false的情况下，才会跟踪cpu时间，其中包括在已测量的代码，未测量代码和非Scheme代码中花费的cpu时间。\n (cost-center-instruction-count cost-center)\n 返回：成本中心跟踪的指令数\n (cost-center-allocation-count cost-center)\n 返回：成本中心跟踪的已分配字节数\n (cost-center-time cost-center)\n 返回：成本中心跟踪的CPU时间\n (reset-cost-center! cost-center)\n 此过程将成本中心记录的成本重置为零。\n参数 本节介绍了用于创建和操作参数的机制。 可以使用make-parameter方便地创建新参数。 但是，除了它们的行为外，没有什么能将参数与其他过程区分开。 如果调用参数时必须采取比通过make-parameter机制容易容纳的更为复杂的动作，则可以直接使用case-lambda定义该参数\n (make-parameter object) | (make-parameter object procudure)\n make-parameter接受一个或两个参数。 第一个参数是内部变量的初始值，第二个参数（如果存在）是应用于初始值和所有后续值的过滤器。 过滤器应接受一个参数。 如果该值不合适，则过滤器应引发异常或将值转换为更合适的形式。\n例如，print-length的默认定义如下：\n(define print-length (make-parameter #f (lambda (x) (unless (or (not x) (and (fixnum? x) (fx\u0026gt;= x 0))) (assertion-violationf ’print-length \u0026#34;~s is not a positive fixnum or #f\u0026#34; x)) x))) (print-length) ⇒ #f (print-length 3) (print-length) ⇒ 3 (format\u0026#34;~s\u0026#34;’(123456)) ⇒ \u0026#34;(123...)\u0026#34; (print-length #f) (format\u0026#34;~s\u0026#34;’(123456)) ⇒ \u0026#34;(123456)\u0026#34; make-parameter的定义使用case-lambda很简单：\n(define make-parameter (case-lambda [(init guard) (let ([v (guard init)]) (case-lambda [() v] [(u) (set! v (guard u))]))] [(init) (make-parameter init (lambda (x) x))]))  (parameterize ((param expr) \u0026hellip;) body1 body2 \u0026hellip;)\n 使用语法形式parameterize，可以以类似于普通变量的fluid-let的方式更改参数的值。 在计算body时，将每个param 设置为相应的expr 的值。\n(define test (make-parameter 0)) (test) ⇒ 0 (test 1) (test) ⇒ 1 (parameterize ([test 2]) (test)) ⇒ 2 (test) ⇒ 1 (parameterize ([test 2]) (test 3) (test)) ⇒ 3 (test) ⇒ 1 (define k (lambda (x) x)) (begin (set! k (call/cc k)) ’k) ⇒ k (parameterize ([test 2]) (test (call/cc k)) (test)) ⇒ k (test) ⇒ 1 (k3) ⇒3 (test) ⇒ 1 虚拟寄存器Virtual registers 编译器支持一组有限的虚拟寄存器 ，以供需要高速，全局和可变存储位置的程序使用。 引用或分配虚拟寄存器可能比访问可分配的局部变量或全局变量更快，并且访问时永远不会比它们更慢，而且这样做的代码序列通常更小。 分配可能会显著加快，因为不需要跟踪从虚拟寄存器到年轻对象的指针，因为可能存在于较早一世代中的可变位置。 在系统的线程版本上，虚拟寄存器是“每个线程”的，因此可以以比线程参数低廉的方式用作thread-local存储。\n该接口包含三个过程：virtual-register-count（返回虚拟寄存器的数量），set-virtual-register!（设置指定的虚拟寄存器的值）和virtual-register（获取指定虚拟寄存器的值）。\n虚拟寄存器由小于虚拟寄存器数量的非负fixnum索引指定。 为了获得set-virtual-register!和virtual-register的最佳性能，索引应该是直接嵌入在调用中的常量（或者可以通过对调用的优化来传播）。 为了避免将这些常量放在源代码中，程序员应考虑使用标识符宏为虚拟寄存器命名，例如：\n(define-syntax current-state (identifier-syntax [id (virtual-register 0)] [(set! id e) (set-virtual-register! 0 e)])) (set! current-state \u0026#39;start) current-state ⇒ start 虚拟寄存器必须被视为应用程序级资源，即，打算由多个应用程序使用的库通常不应使用虚拟寄存器，以避免与应用程序使用寄存器冲突。\n (virtual-register-count)\n 从9.0版开始，虚拟寄存器的数量设置为16。除非通过源重新编译Chez Scheme，否则无法更改。\n (set-virtual-register! k x)\n **set-virtual-register!**将x 存储在虚拟寄存器k 中。 k 必须是小于（virtual-register-count）的值的非负fixnum。\n (virtual-register k)\n virtual-register返回最后一次存储在虚拟寄存器k 中的值（在当前线程上）。\n环境查询和设置Environmental Queries and Settings  (scheme-version)\n Chez Scheme的版本\n (threaded?)\n 返回：#t（如果在系统为线程版本），否则返回#f\n (get-process-id)\n 返回：当前进程的PID\n (getenv key)\n 返回：环境中key 的值，或 #f\n(getenv \u0026#34;HOME\u0026#34;) ⇒ \u0026#34;/u/freddy\u0026#34;  (putenv key value)\n key 和 value 必须是字符串\n(putenv \u0026#34;SCHEME\u0026#34; \u0026#34;rocks!\u0026#34;) (getenv \u0026#34;SCHEME\u0026#34;) ⇒ \u0026#34;rocks!\u0026#34;  (get-registry key)\n 返回：key 的注册表值，或者**#f**\n (put-registry! key val) | (remove-registry! key)\n key 和 value 必须是字符串\n","id":14,"section":"posts","summary":"异常 (warning who msg irritant \u0026hellip;) 返回：未指定 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止","tags":["scheme"],"title":"系统操作(System Operations in Chez Scheme)","uri":"https://lvsq.net/2020/02/system-operations/","year":"2020"},{"content":"define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回true的谓词、以及每个字段的访问procedure和针对可变字段的赋值procedure。总的来说，与Java中的POJO类比较相似，不过不用自定义getter和setter方法，这与Kotlin倒为类似，例如：\n(define-record-type point (fields x y)) 创建了一个名为point的record类型，并且有两个字段x和y，和如下几个定义式（自动生成）：         (make-point x y) 构造函数   (point? obj) 谓词   (point-x p) 字段x的访问器   (point-y p) 字段y的访问器    默认下，字段是不可变的，但是可以声明为可变的（mutable）。如下定义point中，字段x是可变的，但y维持不变：\n(define-record-type point (fields (mutable x) y)) 当然亦可显式地将字段声明为不可变的：\n(define-record-type point (fields (mutable x) (immutable y))) 在这个例子中，define-record-type除了生成了上述的几个定义式之外，还为字段x增加了一个赋值过程：\n(point-x-set! p x)\n该赋值过程可以用于改变x的内容\n(define p (make-point 36 -17)) (point-x-set! p (- (point-x p) 12)) (point-x p) =\u0026gt; 24 自动生成的几个定义式是允许改变名称的，下面的point定义式，其构造函数名为mkpoint, 谓词为ispoint?，x和y的访问器分别为x-val和y-val, x的赋值器为set-x-val!\n(define-record-type (point mkpoint ispoint?) (fields (mutable x x-val set-x-val!) (immutable y y-val))) 默认情况下，每次一个record definition创建一个新类型（为方便理解，可以用Java来解释，即对于同一个POJO类new出两个实例，但这两个实例并不能equal），如下所示：\n(define (f p) (define-record-type point (fields x y)) (if (eq? p \u0026#39;make) (make-point 3 4) (point? p))) (f (f \u0026#39;make)) =\u0026gt; #f 第一个f的调用即(f \u0026lsquo;make)返回一个point类型的p，将p传递给第二个f，但p是由第一个调用生成的类型，所以point?返回#f。按照SICP的说法，这两个define-record-type并不在一个环境中，只是名字一样而已。\n默认的生产行为(generative behavior)或许可以由记录定义式中的nongenerative子句来重载：\n(define (f p) (define-record-type point (fields x y) (nongenerative)) (if (eq? p \u0026#39;make) (make-point 3 4) (point? p))) (f (f \u0026#39;make)) =\u0026gt; #t 以这种方式创建的记录类型仍然不同于由定义出现在程序的不同部分中创建的记录类型，即使这些定义在语法上是相同的：\n(define (f) (define-record-type point (fields x y) (nongenerative)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative)) (point? p)) (g (f)) =\u0026gt; #f 甚至可以通过在nongenerative子句中包含uid（唯一id）来覆盖它：\n(define (f) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (point? p)) (g (f)) =\u0026gt; #t 记录类型可以定义为有parent子句的子类型，即一个记录类型可以声明为某一个记录类型的子类型，如果指定了父类型，则子类型将继承父类型所有字段，且子类型的每个实例都被视为父类型的实例，因此可以直接使用父类型的访问器和字段等等。\n(define-record-type point (fields x y)) (define-record-type cpoint (parent point) (fields color)) (define cp (make-cpoint 3 4 \u0026#39;red)) (point? (make-cpoint 3 4 \u0026#39;red)) =\u0026gt;  #t (cpoint? (make-point 3 4)) =\u0026gt; #f (define cp (make-cpoint 3 4 \u0026#39;red)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (cpoint-color cp) =\u0026gt; red 到目前为止，define-record-type定义的默认构造函数接受record包含的字段一样多的参数，其实我们可以重写默认值，这里需要引入protocol子句，以下定义将创建一个具有三个字段的点记录：x，y和d，其中d表示距原点的位移。构造函数仍然只接受两个参数，即x和y值，并将d初始化为x和y平方和的平方根。\n(define-record-type point (fields x y d) (protocol (lambda (new) (lambda (x y) (new x y (sqrt (+ (* x x) (* y y)))))))) (define p (make-point 3 4)) (point-x p) =\u0026gt; 3 (point-y p) =\u0026gt; 4 (point-d p) =\u0026gt; 5 另外，子类型的构造函数中的参数顺序是不可改变的，即先是父类型构造函数的字段，然后才是子类型的参数，如果需要改变子类型的构造函数的参数顺序该如何呢？\n(define-record-type cpoint (parent point) (fields color) (protocol (lambda (pargs-\u0026gt;new) (lambda (x c y) ((pargs-\u0026gt;new x y) c))))) (define cp (make-cpoint 3 \u0026#39;red 4)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (point-d cp) =\u0026gt; 5 (cpoint-color cp) =\u0026gt; red 最后来看看define-record-type的语法形式：\n syntax: (define-record-type record-name clause \u0026hellip;)\n  syntax: (define-record-type (record-name constructor pred) clause \u0026hellip;)\n Fields clause语法形式:\n (fields field-spec \u0026hellip;)\n field-spec必须是下面5个中的一个:\n field-name (immmutable field-name) (mutable field-name) (immmutable field-name accessor-name) (mutable field-name accessor-name mutator-name)   define-record in Chez Scheme Chez Scheme依然支持$R^6RS$中传统的record类型的定义，另外还提供一个新的语法，即define-record，其语法形式与define-record-type一样，所不同的地方在于，define-record中的字段默认是可变的，这与$R^6RS$中的record相反，因此，创建一个记录类型时，同时会定义下列过程：\n(define-record point (x y)) (make-point x y) ;;\tconstructor (point? obj) ;;\tpredicate (point-x p) ;;\taccessor for field x (point-y p) ;;\taccessor for field y (set-point-x! p obj) ;;\tmutator for field x (set-point-y! p obj) ;;\tmutator for field y  通过对define-record-type的了解，可以发现其非常OO，smalltalk是否受其影响不得而知，至少经过纵向比较对于我们学习技术大有裨益。\n","id":15,"section":"posts","summary":"define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回tr","tags":["scheme"],"title":"Scheme语法define-record-type介绍","uri":"https://lvsq.net/2020/02/define-record-type/","year":"2020"},{"content":"Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以在 Chez Scheme 中以“微模块”级别使用，因为 Chez Scheme 中的模块和 import 形式属于定义，并且可以出现在定义可以出现的任意位置，包括在 lambda 表达式的程序体或其他局部作用域中。\n 微模块与函数孰好？？？还是视情况而定？？？\n 模块控制绑定的可见性，可以用作扩展词法作用域，以允许更精确地控制绑定的可见范围。模块导出标识符的绑定，即变量绑定、关键字绑定或模块名绑定。模块可以是具名的抑或匿名的。只要模块名可见，那么在具名模块出现处导入的绑定都可见。匿名模块中导出的绑定，在模块出现的地方被隐式地导入。匿名模块可用于隐藏一组绑定中的一些绑定，同时允许其余绑定可见。\n语法  (module name interface defn \u0026hellip; init \u0026hellip;)\n  (module interface defn \u0026hellip; init \u0026hellip;)\n name 是标识符，defn \u0026hellip; 是定义，init \u0026hellip; 是表达式。interface 是形如 (export \u0026hellip;) 的导出表，其中每个 export 都是标识符 identifier 抑或形式 (identifier export \u0026hellip;)。\n模块由一组（可能为空的）定义和一组（可能为空的）初始化表达式序列组成。模块中定义的标识符（可理解为变量或者状态，下同）在模块的程序体中可见，被导出的标识符在模块的导入作用域内亦可见。模块接口中列出的每个标识符必须在该模块中定义或被导入该到模块。module 形式是一种定义，因此可以出现在其他定义可以出现的任何位置，包括嵌套在 lambda 表达式的程序体、 library 形式、顶层程序，以及嵌套在其他模块中。此外，因为模块名的作用域与其他标识符相同，所以模块和库可以像变量和关键字那样导出模块名。\n模块名与其他标识符占用相同的名字空间，并遵循相同的作用域规则。除非被导出，否则模块中定义的标识符仅在该模块中可见。\n模块内的表达式可以引用在模块外部绑定的标识符。\n(let ([x 3]) (module m (plusx) (define plusx (lambda (y) (+ x y)))) (import m) (let ([x 4]) (plusx 5))) ; =\u0026gt; 8,注意不是9哦，可以将plusx视为：(define plusx (lambda (y) (+ 3 y)))) 同样，import不会阻止访问出现导入表单的可见标识符，但import标识符所覆盖的变量除外（啥叫覆盖，看下面两段代码）。\n(module m (y) (define y \u0026#39;m-y)) (let ([x \u0026#39;local-x] [y \u0026#39;local-y]) (import m) (list x y)) ; =\u0026gt; (local-x m-y) 模块m中定义了标识符y, 在其被import之后会覆盖let中的y；\n(module m (y) (define y \u0026#39;m-y)) (let () (import m) (let ([x \u0026#39;local-x] [y \u0026#39;local-y]) (list x y)) ; =\u0026gt; (local-x local-y) ) 先import m，之后再定义y，模块中定义的y不会覆盖let的y。\n另一方面，在模块中使用 import-only 会建立一个隔离的作用域，其中唯一可见的是被导入模块所导出的标识符，下面的代码中只有y可见。对于静态验证，有时不希望使用任何标识符，除了明确导入模块或本地范围的标识符外，这有时是合乎需要的。\n(module m (y) (define y \u0026#39;m-y)) (let ([x \u0026#39;local-x] [y \u0026#39;local-y]) (import-only m) x) ; =\u0026gt; Error: x is not visible 除非通过“import-only”导入的模块导出“import”或“import-only”以及至少一个模块的名称，否则无法在“import-only”范围内进行后续导入。 要创建一个包含多个模块导出的隔离范围而又不使“import”或“import-only”可见，必须以相同的“import-only”形式列出所有要导入的模块。\n另一种解决方案是创建一个包含每个其他模块的导出的模块。\n(module m2 (y) (define y \u0026#39;y)) (module m1 (x) (define x \u0026#39;x)) (module mega-module (cons x y) (import m1) (import m2) (import scheme)) (let ([y 3]) (import-only mega-module) (cons x y)) ; =\u0026gt; (x . y) 在它被编译之前，源程序被翻译成不含语法抽象、语法定义、库定义、模块定义以及 import 形式的核心语言程序。翻译由语法展开器负责，语法展开器以递归下降的方式处理源程序中的形式。\nmodule 和 import 特殊形式仅影响标识符(identifier)在源程序中的可见性，而不影响其含义。特别地，无论变量被绑定到在模块内部或外部定义的位置，import 都不会引入新位置。为了保持由模块和语法抽象建立的作用域关系，局部变量在必要时会被重命名。因此，表达式：\n(let ([x 1]) (module m (x setter) (define-syntax x (identifier-syntax z)) (define setter (lambda (x) (set! z x))) (define z 5)) (let ([y x] [z 0]) (import m) (setter 3) (+ x y z))) ; =\u0026gt; 4 等价于下面的表达式，其中标识符被统一地更名，并带上了下标：\n(let ([x0 1]) (define-syntax x1 (identifier-syntax z1)) (define setter1 (lambda (x2) (set! z1 x2))) (define z1 5) (let ([y3 x0] [z3 0]) (setter1 3) (+ x1 y3 z3))) 互递归module (module (a b) (module a (x) (define x (lambda () y))) (module b (y) (define y (lambda () x))) (import a) (import b)) 此模式的一般化语法定义如下，允许定义多个互递归的模块\n(define-syntax rec-modules (syntax-rules (module) [(_ (module m (id ...) form ...) ...) (module (m ...) (module m (id ...) form ...) ... (import m) ...)])) 组合module 由于模块可以重新导出所导入的绑定，所以很容易在单个模块上提供多个视图，就像下面的 s 和 t 为 r 提供的视图那样，或者将几个模块组合成一个复合，就像 r 那样。\n(module p (x y) (define x 1) (define y 2)) (module q (y z) (define y 3) (define z 4)) (module r (a b c d) (import* p (a x) (b y)) (import* q (c y) (d z))) (module s (a c) (import r)) (module t (b d) (import r)) import* 稍微解释一下import*, 其语法定义如下：\n(define-syntax import* (syntax-rules () [(_ m) (begin)] [(_ m (new old)) (module (new) (module (tmp) (import m) (alias tmp old)) (alias new tmp))] [(_ m id) (module (id) (import m))] [(_ m spec0 spec1 ...) (begin (import* m spec0) (import* m spec1 ...))])) 它支持重命名import的绑定和选择性导入特定的绑定，无需使用内置的import子形式来选择和重命名标识符，举例来说：\n(let () (import* scheme (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7) (let () (import* (rnrs) (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7) 元定义Meta Definitions  语法：(meta . definition)\n meta 关键字实际上是一个可以放在任何定义关键字前面的前缀，例如，\n (meta define x 3)\n 它告诉展开器，该定义式产生的任何变量定义都只是展开期定义，只能用于其他元定义的右侧，最主要是用在转换器表达式中。它用于定义展开期辅助函数，以及供一个或多个 syntax-case 转换器所使用的其他信息。\n元定义的语义类似于let*，它可以是自递归，但不是互递归的。\n元定义通过宏展开传播，因此可以编写，例如：\n(module (a) (meta define-record foo (x)) (define-syntax a (let ([q (make-foo #\u0026#39;\u0026#39;q)]) (lambda (x) (foo-x q))))) a ；=\u0026gt; q 条件展开Conditional expansion 可以通过 meta-cond 在展开期做出决策，这类似于 cond，但是是在展开期求值并测试表达式，并且可以在预期为定义的上下文中以及在表达式上下文中使用。\n 语法：(meta-cond clause1 clause2 \u0026hellip;)\n 除了最后一个 clause，其余的必须采取以下形式：\n (test expr1 expr2 \u0026hellip;)\n 最后一个 cluase 除可采取上述形式外，还可以使用下面的 else 子句形式：\n (else expr1 expr2 \u0026hellip;)\n 在展开期间，test 表达式会被顺序地求值，直到某条表达式求值为真或者求值完所有的表达式为止。如果一条 test 表达式求值为真，则 meta-cond 形式将展开为包含相应表达式 expr1 expr2 \u0026hellip; 所组成的 begin 形式。如果没有求值为真的 test 表达式，且存在 else 子句，则 meta-cond 形式将展开为由来自于 else 子句的表达式 expr1 expr2 \u0026hellip; 所组成的 begin 形式。否则，meta-cond 表达式展开为对 void 过程的调用。\nmeta-cond 可以按如下定义：\n(define-syntax meta-cond (syntax-rules () [(_ [a0 a1 a2 ...] [b0 b1 b2 ...] ...) (let-syntax ([expr (cond [a0 (identifier-syntax (begin a1 a2 ...))] [b0 (identifier-syntax (begin b1 b2 ...))] ...)]) expr)])) meta-cond 用于在展开期从一组可能的形式中进行选择。例如，程序员可以定义过程的安全（进行错误检查）和不安全（不进行错误检查）版本，并根据编译期优化级别决定调用版本，如下所示:\n(meta-cond [(= (optimize-level) 3) (unsafe-frob x)] [else (safe-frob x)]) 别名Aliases  语法：(alias id1 id2)\n alias 是一类定义，可以出现在其他定义可以出现的任何位置。它用于将绑定从一个标识符转移到另一个标识符。\n(let ([x 3]) (alias y x) (set! y 4) (list x y)) ; =\u0026gt; (4 4) 由于展开是由左至右进行的，别名应该出现在右侧的标识符的定义之后，例如：\n(let () (import-only (chezscheme)) (define y 3) (alias x y) x) ; =\u0026gt; 3 而不是：\n(let () (import-only (chezscheme)) (alias x y) (define y 3) x) ; =\u0026gt; exception: unbound identifier ","id":16,"section":"posts","summary":"Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以","tags":["modules"],"title":"Chez Scheme Modules","uri":"https://lvsq.net/2020/01/modules/","year":"2020"},{"content":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。\n (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_ ((a1 v1) (a2 v2) ...) bodys ...) (let ((a1 v1)) (my-let* ((a2 v2) ...) bodys ...)) ) ) ) 注意，my-let*是可以递归使用的，以及**\u0026hellip;**的用法。\n(define-syntax my-let* (syntax-rules () ( (_ () bodys ...) (let () bodys ...) ) ( (_ ((a1 v1) ...) bodys ...) (let () (define a1 v1) ... bodys ... ) ) ) ) 这个实现方式与上面的不同，上面的是嵌套let，这里将直接按顺序define内部变量，代码更短。注意此处的**\u0026hellip;**的用法。\n","id":17,"section":"posts","summary":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。 (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_","tags":["scheme"],"title":"自定义 Let*","uri":"https://lvsq.net/2020/01/my-let/","year":"2020"},{"content":"Fluid Keyword Bindings fluid-let-syntax  语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩展期间会暂时更改keyword的现有绑定，而不是引入keyword的新绑定。也就是说，在扩展form1 form2 \u0026hellip;的过程中，每个keyword的可见范围（或顶级）将会临时替换为新的绑定关系。\n (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 2 ) ) ) (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (fluid-let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 1 ) ) ) 对比上述两段代码，可知：两个表达式基本相同的，除了前者采用内部let-synctax语法，第二个采用fluid-let-syntax语法。在第一个表达式中，(g 1)扩展中的出现的f引用的是let-bound的变量f，而第二个表达式，f引用的是由fluid-let-syntax绑定的f\n","id":18,"section":"posts","summary":"Fluid Keyword Bindings fluid-let-syntax 语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩","tags":["module","syntactic"],"title":"Syntactic Extension and Modules in Chez Scheme","uri":"https://lvsq.net/2020/01/syntactic-extension-and-modules/","year":"2020"},{"content":"Chez Scheme中有一种Boxes结构，它是一个单元素对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构可以共享指向一个对象的引用，或指针。例如，在采用此种参数传递规则的语言的解释器中，可以用 boxes 实现 call-by-reference 的语义。解释有点绕，按我的理解boxes就相当于Golang的struct、Java中的类，将一些状态包装成一个整块，外界通过引用该整块的指针来访问内部的各个状态。\nBoxes 的字面形式带有前缀 #\u0026amp; (发音为 “hash-ampersand”). 例如， #\u0026amp;(a b c) 是一个 box，内容为列表 (a b c). 读取器若遇到 #!r6rs ，则会在其后的输入流中禁用 box 语法，除非在更近的位置遇到 #!chezscheme.\n所有 boxes 默认是可变的，包括常量。程序可以通过 box-immutable 创建不可变 boxes. 尝试修改不可变 box 会导致抛出异常。\n我们来看看一些用法：\n (box? obj) 如果 obj 是 box, 则为 #t, 否则为 #f.\n(box? \u0026#39;#\u0026amp;a) =\u0026gt; #t (box? \u0026#39;a) =\u0026gt; #f (box? (box 3)) =\u0026gt; #t (box obj) 创建一个由obj组成的box\n(box \u0026#39;a) =\u0026gt; #\u0026amp;a (box (box \u0026#39;(a b c))) =\u0026gt; #\u0026amp;#\u0026amp;(a b c) (unbox box) 返回box的内容\n(unbox #\u0026amp;a) =\u0026gt; a (unbox #\u0026amp;#\u0026amp;(a b c)) =\u0026gt; #\u0026amp;(a b c) (let ([b (box \u0026#34;hi\u0026#34;)]) (unbox b)) =\u0026gt; \u0026#34;hi\u0026#34; (set-box! box obj) box 必须是可变的。 set-box! 把 box 的内容设置为 obj.\n(let ([b (box \u0026#39;x)]) (set-box! b \u0026#39;y) b) =\u0026gt; #\u0026amp;y (let ([incr! (lambda (x) (set-box! x (+ (unbox x) 1)))]) (let ([b (box 3)]) (incr! b) (unbox b))) =\u0026gt; 4 (box-cas! box old-obj new-obj) 如果 box 被改变，则为 #t, 否则为 #f.box 必须是可变的。 若 box 待替换的内容和 old-obj 相同(基于 eq?), 则 box-cas! 自动将 box 的内容替换为 new-obj; 若不相同，则 box 保持不变。即CAS操作，原子的。\n(define b (box \u0026#39;old)) (box-cas! b \u0026#39;old \u0026#39;new) =\u0026gt; #t (unbox b) =\u0026gt; \u0026#39;new (box-cas! b \u0026#39;other \u0026#39;wrong) =\u0026gt; #f (unbox b) =\u0026gt; \u0026#39;new (mutable-box? obj) 如果 obj 是可变的 box ，则为 #t, 否则为 #f.\n(immutable-box? obj) 如果 obj 是不可变的 box ，则为 #t, 否则为 #f.\n(box-immutable obj) 返回一个内容为obj的不可变的box。Boxes 通常用来支持共享的，可变的结构，所以不可变的 box 一般没什么用。\n","id":19,"section":"posts","summary":"Chez Scheme中有一种Boxes结构，它是一个单元素对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构","tags":["scheme"],"title":"Chez Scheme中Boxes介绍","uri":"https://lvsq.net/2020/01/boxes-in-chez/","year":"2020"},{"content":"Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x)))\n(atom? \u0026#39;(a b c)) ⇒ #f (atom? \u0026#39;(3 . 4)) ⇒ #f (atom? \u0026#39;()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) n是一个非负整数，且小于等于list的长度；list-head和Scheme标准过程list-tail可能会同时使用来切割一个list，不同点在于，list-tail不会分配内存而只是返回源list的一个子列表，list-head总是返回源list前n个元素的副本\n(list-head \u0026#39;(a b c) 0) ⇒ () (list-head \u0026#39;(a b c) 2) ⇒ (a b) (list-head \u0026#39;(a b c) 3) ⇒ (a b c) (list-head \u0026#39;(a b c . d) 2) ⇒ (a b) (list-head \u0026#39;(a b c . d) 3) ⇒ (a b c) (list-head \u0026#39;#1=(a . #1#) 5) ⇒ (a a a a a) last-pair(Chez) 用法：(last-pair list) 列表不能为空。 last-pair返回列表的最后一对（pair）（不是最后一个元素）, list可能是不正确的列表，在这种情况下，最后一对是包含最后一个元素和终止对象的一个pair。\n(last-pair \u0026#39;(a b c d)) ⇒ (d) (last-pair \u0026#39;(a b c.d)) ⇒ (c . d) list-copy(Chez) 用法： (list-copy list) 返回一个list的副本，equal?（结构和值相同）判断为#t\nlist*(Chez) 用法：(list* obj \u0026hellip; final-obj)返回一个由obj \u0026hellip; final-obj 组成的list, 与R6RS的**cons***相同\nmake-list(Chez) 用法： (make-list n) 或者 (make-list n obj)返回n个对象的列表。n是一个正整数， 如果obj不指定，则返回的list是不确定的\n(make-list 0 \u0026#39;()) =\u0026gt; () (make-list 3 0) =\u0026gt; (0 0 0) (make-list 2 \u0026#34;hi\u0026#34;) =\u0026gt; (\u0026#34;hi\u0026#34; \u0026#34;hi\u0026#34;) iota(Chez) 用法：(iota n)返回从 0（包含）到 n（不包含）的整数列表，n须为精确的非负整数\n(iota 0) =\u0026gt; () (iota 5) =\u0026gt; (0 1 2 3 4) enumerate(Chez) 用法： (enumerate ls)返回: 从 0（包含）到长度 ls（不包含）的整数列表\n(enumerate \u0026#39;()) =\u0026gt; () (enumerate \u0026#39;(a b c)) =\u0026gt; (0 1 2) (let ([ls \u0026#39;(a b c)]) (map cons ls (enumerate ls))) =\u0026gt; ((a . 0) (b . 1) (c . 2)) remq! | remv! | remove!(Chez) 用法： (remq! obj list) | (remv! obj list) | (remove! obj list)返回: 列表中所有 obj 都被移除后的列表这些过程与 R6RS 中的 remq, remv, 及 remove 过程类似，只是 remq!, remv! 和 remove! 使用输入列表中的pair来构成输出列表。它们进行较少的空间分配，但并不一定比它们非破坏性的相应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(remq! \u0026#39;a \u0026#39;(a b a c a d)) ⇒ (b c d) (remv! #\\a \u0026#39;(#\\a #\\b #\\c)) =\u0026gt; (#\\b #\\c) (remove! \u0026#39;(c) \u0026#39;((a) (b) (c))) =\u0026gt; ((a) (b)) substq | substv | subst | substq! | substv! | subst!(Chez) 用法： (subs* new old tree)返回：在tree中将匹配到的old元素全部替换为new之后的tree.对于 substq 和 substq! ，相等性测试是基于 eq?, substv 和 substv! 是基于 eqv?, 而 subst 和 subst! 是基于 equal? substq!, substv!, 和 subst! 执行破坏性的替换。它们进行较少的空间分配，但并不一定比它们非破坏性的对应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(substq \u0026#39;a \u0026#39;b \u0026#39;((b c) b a)) =\u0026gt; ((a c) a a) (substv 2 1 \u0026#39;((1 . 2) (1 . 4) . 1)) =\u0026gt; ((2 . 2) (2 . 4) . 2) (subst \u0026#39;a \u0026#39;(a . b) \u0026#39;((a . b) (c a . b) . c)) =\u0026gt; (a (c . a) . c) (let ([tr \u0026#39;((b c) b a)]) (substq! \u0026#39;a \u0026#39;b tr) tr) =\u0026gt; ((a c) a a) reverse! 用法：(reverse! list)返回：将原list反向输出reverse! 通过反转其链接破坏性地反向排序列表。以 reverse! 取代 reverse 减少了空间分配，但并不一定比使用 reverse 更快。如果滥用，会很容易导致混乱或错误的结果。\n(reverse! \u0026#39;()) =\u0026gt; () (reverse! \u0026#39;(a b c)) =\u0026gt; (c b a) (let ([x \u0026#39;(a b c)]) (reverse! x) x) =\u0026gt; (a) (let ([x \u0026#39;(a b c)]) (set! x (reverse! x)) x) =\u0026gt; (c b a) append! 用法：(append! list \u0026hellip;)返回：将所有输入list串联起来的列表如同 append, append! 返回一个新的列表，其中元素依次为第一个列表中的元素，第二个列表中的元素，第三个列表中的元素，等等。不同之处在于， append! 重用所有参数中的点对以构造新列表。即，每一个列表参数的最后一个cdr, 其后一元素变为指向下一个列表参数。除最后一个参数外，如果任一参数为空列表，它实质上会被忽略。最后一个参数（并不一定得是列表）是不变的。\n相比于 append, append! 进行更少的空间分配（因为只修改指针，并没有数据拷贝），但并不一定更快。如果滥用，会很容易导致混乱或错误的结果。\n(append! \u0026#39;(a b) \u0026#39;(c d)) =\u0026gt; (a b c d) (let ([x \u0026#39;(a b)]) (append! x \u0026#39;(c d)) x) =\u0026gt; (a b c d) (append \u0026#39;(1 2 (3 4)) \u0026#39;(5 6)) =\u0026gt; (1 2 (3 4) 5 6) (append \u0026#39;(1 2 (3 4)) \u0026#39;() \u0026#39;(5 6)) =\u0026gt; (1 2 (3 4) 5 6) ","id":20,"section":"posts","summary":"Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x))) (atom? \u0026#39;(a b c)) ⇒ #f (atom? \u0026#39;(3 . 4)) ⇒ #f (atom? \u0026#39;()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) n是一个非负整数，且小于等于list的长度","tags":["scheme"],"title":"Scheme/Chez Scheme 对象操作","uri":"https://lvsq.net/2019/12/operations-on-objects/","year":"2019"},{"content":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。\n (make-engine thunk)\n 通过传递一个无参数的thunk(形实转换程序)给make-engine来创建一个engine。thunk的body是会被engine执行的计算，engine本身是带3个参数的过程： ticks： 一个正整数，指定提供给engine的执行时间片（原文用的是fuel这个单词，意思是燃料，正对应这engine的本意，十分贴切）的数量，engine将会执行到时间片用完或者计算完成为止； complete： 一个或多个参数的函数，用于指定计算完成后的操作。它的参数是剩余的时间片数量和计算产生的值； expire： 一个参数的函数，该函数指定如果在计算完成之前时间片用完了该怎么办。它的参数是一个能从中断点继续进行计算的新引擎。  将引擎应用于其参数时，它将开启一个时长为ticks的计时器，如果引擎计算在计时器执行之前完成，系统将调用complete，并将剩余的ticks和计算产生的值传递给它；\n另一方面，如果计时器在引擎计算完成之前耗尽了，则系统会从中断计算的continuation中创建一个新引擎，并使该引擎过期。complete和expire会被新引擎继续使用。If, on the other hand, the timer goes off before the engine computation completes, the system creates a new engine from the continuation of the in- terrupted computation and passes this engine to expire. complete and expire are invoked in the continuation of the engine invocation.\n 看看具体的例子：\n(define eng (make-engine (lambda () 3))) (eng 10 ;; ticks (lambda (ticks value) value) ;; complete (lambda (x) x) ;; expire ) ⇒ 3 通常将列表作为完整过程传递给引擎，使引擎完成时返回一个列表，该列表的第一个元素是剩余的ticks，另一个元素是计算返回的值，这通常很有用。\n(define eng (make-engine (lambda () 3))) (eng 10 list (lambda (x) x)) ⇒ (9 3) 在上面的示例中，计算值为3，还剩下9个时间片，即，需要一单位的时间片来计算出3。\n 再看一个复杂点的例子： 先定义一个计算裴波那切值的函数\n(define fibonacci (lambda (n) (let fib ([i n]) (cond [(= i 0) 0] [(= i 1) 1] [else (+ (fib (- i 1)) (fib (- i 2)))])))) 创建engine\n(define eng (make-engine (lambda () (fibonacci 10)))) (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ \u0026#34;expired\u0026#34; (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ \u0026#34;expired\u0026#34; (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ \u0026#34;expired\u0026#34; (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ (21 55) 每次时间片（燃料）用完时，到期程序都会将eng分配给新引擎。整个计算需要4个blocks，每个block包含50个ticks。最后50个燃料中，有21个都用掉了。因此，使用的燃料总量为179个。\n我们还可以统计一下消耗的ticks数量\n(define mileage (lambda (thunk) (let loop ([eng (make-engine thunk)] [total-ticks 0]) (eng 50 (lambda (ticks . values) (+ total-ticks (- 50 ticks))) (lambda (new-eng) (loop new-eng (+ total-ticks 50))))))) (mileage (lambda () (fibonacci 10))) ⇒ 179  再看看一个例子——round-robin:\n(define round-robin (lambda (engs) (if (null? engs) \u0026#39;() ((car engs) 1 ;;ticks (lambda (ticks value) (cons value (round-robin (cdr engs)))) ;;complete (lambda (eng) ;;expire (round-robin (append (cdr engs) (list eng)))))))) (round-robin (map (lambda (x) (make-engine (lambda () (fibonacci x)))) \u0026#39;(4 5 2 8 3 7 6 2))) ⇒ (1 1 2 3 5 8 13 21) 这段代码需要费些思量，首先map函数创建了8个engine, 然后代入round-robin函数，该函数依次执行各个engine，但是每个engine分配的时间片只有1，对于参数'(4 5 2 8 3 7 6 2)，数字越小，越先执行完成，所以越早执行complete函数，最终结果就是排好顺序的了，很棒的程序！\n","id":21,"section":"posts","summary":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。 (make-engine thunk) 通过传递一个无参数的thun","tags":["engine","scheme"],"title":"Engine in Scheme","uri":"https://lvsq.net/2019/12/engine-in-scheme/","year":"2019"},{"content":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Scheme提供了case语法来处理这种情况，这与Java中的switch语法非常相似。\n我们来看看case的语法：\n (case expr0 clause1 clause2 \u0026hellip;)\n 除了最后一个clause之外，每个子句都必须采用以下形式之一：\n ((key \u0026hellip;) expr1 expr2 \u0026hellip;) (key expr1 expr2 \u0026hellip;)  每一个key值都应该是不同的，最后一个子句要么是上述那种形式，或者是一个像下面这样的else子句\n (else expr1 expr2 \u0026hellip;)   那么返回值是什么呢？\n(define p (lambda (x) (case x [(\u0026#34;abc\u0026#34; \u0026#34;def\u0026#34;) \u0026#39;one \u0026#39;1] [((a b c)) \u0026#39;two] [else #f]))) (p (string #\\d #\\e #\\f)) ⇒ 1 (p \u0026#39;(a b c)) ⇒ two (p \u0026#34;eee\u0026#34;) ⇒ #f 上面的例子定义了一个函数p，接收一个参数x\n 如果x为字符串\u0026quot;abc\u0026quot;或者\u0026quot;def\u0026quot;，则返回1； 如果x为列表((a b c)，则返回two 其他情况返回#f  可见，有了case语法多条件判断写起来就方便很多，并且代码也容易读了，当然这里也可以用cond来写，这里只是为了描述case的语法而没有使用cond\n再看一个例子，就不用解释了：\n(let ([ls \u0026#39;(ii iv)]) (case (cadr ls) [i 1] [ii 2] [iii 3] [(iiii iv) 4] [else \u0026#39;out-of-range])) ⇒ 4  record-case 来看看另一个很类似的扩展，也十分有用，它就是record-case。它可以以record为单位来做条件判断并执行指令。语法格式：  (record-case expr clause1 clause2 \u0026hellip;)\n 除了最后一个子句之外，每个clause的格式如下：\n ((key \u0026hellip;) formals body1 body2 \u0026hellip;)\n 每一个key都不应该相同, 最后一个clause可能是上述的格式或者是一个else子句：\n (else body1 body2 \u0026hellip;)\n expr必须是一个pair。Chez会拿(car expr)与各个子句中的key进行比较（用eqv?）来确定哪一个clause匹配, 然后(cdr expr)将与formals绑定。\n来看换一个例子：\n(define calc (lambda (x) (record-case x [(add) (x y) (+ x y)] [(sub) (x y) (- x y)] [(mul) (x y) (* x y)] [(div) (x y) (/ x y)] [else (assertion-violationf 'calc \u0026quot;invalid expression ~s\u0026quot; x)]))) (calc '(add 3 4)) =\u0026gt; 7 (calc '(div 3 4)) =\u0026gt; 3/4 ","id":22,"section":"posts","summary":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Schem","tags":["chez","scheme"],"title":"Chez Scheme中的case扩展","uri":"https://lvsq.net/2019/12/case-in-chez-scheme/","year":"2019"},{"content":"  易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴至，克尽其用，上下一体，俱不倦而事可毕矣\n  周云成康，汉言文景。无有六十年与民休息，累藏蓄积，汉武开疆之功便是空文，此厚积薄发耳，俗语言，胳膊收回来，打出去才有力\n  武帝一代雄主，文治武功，奋高祖之余烈，承三王之圣绪，开万世不拔之基，吾国斯民之幸，铭记汉青\n  ","id":23,"section":"posts","summary":"易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴","tags":["随想"],"title":"继学录","uri":"https://lvsq.net/2019/12/think/","year":"2019"},{"content":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫易变绑定吧，如果有更好的翻译请在文后的评论中尽情发表。\n先看看该语法描述：(fluid-let ((var expr) \u0026hellip;) body1 body2 \u0026hellip;) returns: the values of the body body1 body2 \u0026hellip; libraries: (chezscheme)该Binding的作用类似局部变量，与set! 比较相似。由fluid-let定义的变量必须已绑定到顶层(top level)或者封闭的lambda内或者其他形式的绑定，这很关键！\n 请看代码：\n(let ([x 3]) (+ (fluid-let ([x 5]) x) x)) ⇒ 8 先定义变量x=3，然后在加法操作当中临时将x的值改为5，最后结果为8，如果将fluid-let中的x换个名字，比如y，将如何呢？会得到一个异常：\n Exception: variable y is not bound\n y没有绑定，是的，y即没有在顶层中被定义，也未在某个lambda中或者任何其他形式，这里只能是x\n 再学习下两个例子，加深印象：\n(let ([x \u0026#39;a]) (letrec ([f (lambda (y) (cons x y))]) (fluid-let ([x \u0026#39;b]) (f \u0026#39;c)) )) ⇒ (b . c) (let ([x \u0026#39;a]) (call/cc (lambda (k) (fluid-let ([x \u0026#39;b]) (letrec ([f (lambda (y) (k \u0026#39;*))]) (f \u0026#39;*))))) x) ⇒ a  Fluid Binding实际上是Scheme对Dynamic Scoping的保留，Scheme使用的是Lexical Scoping， 对于这两种Scoping更详细的描述可参考Lexical Scoping and Dynamic Scoping\n","id":24,"section":"posts","summary":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫易变绑定吧，如果有更好的翻译请在文后的评论中尽情发表。 先看看该语法描","tags":["fluid-let","Scheme"],"title":"Fluid Binding in Chez Scheme","uri":"https://lvsq.net/2019/12/fluid-binding/","year":"2019"},{"content":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。\n 这是语法描述：(rec var expr) syntaxreturns: value of exprlibraries: (chezscheme)The syntactic form rec creates a recursive object from expr by establishing a binding of var within expr to the value of expr. In essence, it is a special case of letrec for self-recursive objects.\nThis form is useful for creating recursive objects (especially procedures) that do not depend on external variables for the recursion, which are sometimes undesirable because the exter-nal bindings can change. For example, a recursive procedure defined at top level depends on the value of the top-level variable given as its name. If the value of this variable should change, the meaning of the procedure itself would change. If the procedure is defined instead with rec, its meaning is independent of the variable to which it is bound.\n简要翻译一下：语法rec 通过在expr中建立var与expr的值的绑定，创建一个递归对象。从本质上讲，这是letrec用于自递归对象的一种特殊情况。\n语法rec通过绑定expr中创建一个递归对象，用来 这种形式对于创建不依赖于外部变量进行递归的递归对象（尤其是过程）很有用，因为外部绑定可能会发生变化，所以有时这是不可取的。\n 看一个例子来感受一下：给定一个全是数字的list，对于每一个数字n，算出$1+2+\u0026hellip;+n$的和，最终返回和的list.\n(map (rec sum (lambda (x) (if (= x 0) 0 (+ x (sum (- x 1)))))) ’(0 1 2 3 4 5)) ⇒ (0 1 3 6 10 15) 如果没有rec语法，用letrec也是可以的，但是稍显麻烦，代码也多一些，所以rec还是很好用的\n 最后看一下rec语法的定义：\n(define-syntax rec (syntax-rules () [(_ x e) (letrec ((x e)) x)])) ","id":25,"section":"posts","summary":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。 这是语法描述：(","tags":["Scheme","Chez","rec"],"title":"Recursive Bindings in Chez Scheme","uri":"https://lvsq.net/2019/12/recursive-bindings/","year":"2019"},{"content":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些时间，动手写了一个，目前已经在公司内部运行了几年，效果良好，并且已经开源在Github上，以飨各位。\n 特点：\n  API简洁\n  支持3种事件：\n UP DOWN JOIN    基于Vert.X\n  引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lvsq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jgossip\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 一个简单的例子：\nint gossip_port = 60001; String cluster = \u0026#34;gossip_cluster\u0026#34;; GossipSettings settings = new GossipSettings(); settings.setGossipInterval(1000); try { String myIpAddress = InetAddress.getLocalHost().getHostAddress(); List\u0026lt;SeedMember\u0026gt; seedNodes = new ArrayList\u0026lt;\u0026gt;(); SeedMember seed = new SeedMember(); seed.setCluster(cluster); seed.setIpAddress(myIpAddress); seed.setPort(60001); seedNodes.add(seed); gossipService = new GossipService(cluster, myIpAddress, gossip_port, null, seedNodes, settings, (member, state) -\u0026gt;System.out.println(\u0026#34;member:\u0026#34; + member + \u0026#34; state: \u0026#34; + state)); } catch (Exception e) { e.printStackTrace(); } gossipService.start();  详细介绍请看 =\u0026gt; 项目地址\n欢迎大家fork， 如果觉得好请start ~~~\n","id":26,"section":"posts","summary":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些","tags":["jgossip","gossip"],"title":"Jgossip - gossip协议的开源实现","uri":"https://lvsq.net/2019/12/jgossip/","year":"2019"},{"content":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加\nGolang的实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} nodes := []*ListNode{} var carry = 0 for { node, c := add(l1, l2, carry) carry = c if node != nil { nodes = append(nodes, node) if l1 != nil \u0026amp;\u0026amp; l1.Next != nil { l1 = l1.Next } else { l1 = nil } if l2 != nil \u0026amp;\u0026amp; l2.Next != nil { l2 = l2.Next } else { l2 = nil } if carry \u0026gt; 0 \u0026amp;\u0026amp; (l1 == nil \u0026amp;\u0026amp; l2 == nil) { nodes = append(nodes, \u0026amp;ListNode{Val:carry}) } } else { break } } for i, n := range nodes{ if i == 0 { result = n } if i + 1 \u0026lt; len(nodes) { n.Next = nodes[i + 1] } } return result } func add (n1 *ListNode, n2 *ListNode, carry int) (*ListNode, int) { node := \u0026amp;ListNode{} if (n1 == nil \u0026amp;\u0026amp; n2 == nil) { return nil, 0 } if n1 == nil { n1 = \u0026amp;ListNode{Val : 0} } if n2 == nil { n2 = \u0026amp;ListNode{Val : 0} } sum := n1.Val + n2.Val + carry carry = 0 if sum \u0026gt; 9 { carry = 1 sum = sum - 10 } node.Val = sum return node, carry }  下面提供Scheme版本的实现【(1 0) + (9 1 2) = (0 2 2)】，为了简单起见，与题目要求稍有不同，这里采用list，而不是题目要求的链表，但实际上应是一样的。比较之下可以看出，相对而言，Scheme语言的实现更加简短优雅，得益于其强大的表达能力\n(letrec ( [Polishing (lambda (l num) (if (eq? num 0) l (Polishing (append l \u0026#39;(0)) (- num 1))) ) ] [Align (lambda (l1 l2) (let ([len1 (length l1)] [len2 (length l2)]) (if [eq? len1 len2] [list l1 l2] [if (\u0026gt; len1 len2) (list l1 (Polishing l2 (- len1 len2))) (list (Polishing l1 (- len2 len1)) l2)])) ) ] [Add (lambda (l1 l2) (let ([ l (Align l1 l2)]) (Carry (map (lambda (x y) (+ x y)) (car l) (cadr l)) 0) ) ) ] [Carry (lambda (l c) (if (null? l) (if [eq? c 0] \u0026#39;() [cons c l]) (cons (mod ( + (car l) c ) 10) (Carry (cdr l) (quotient ( + (car l) c) 10))) ) ) ]) (Add \u0026#39;(1 0) \u0026#39;(9 1 2)))  Golang版本和Scheme版本的实现思路不相同，简要描述一下后者：\n (1 0) + (9 1 2), 先进行补位： (1 0 0) + (9 1 2), 按顺序相加，得： (10 1 2), 再计算进位： (0 2 2)  ","id":27,"section":"posts","summary":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加 Golang的实现： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result","tags":["Scheme","leetcode"],"title":"两数相加","uri":"https://lvsq.net/2019/12/leetcode-2/","year":"2019"},{"content":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发。\n 问题描述 假设我们已经有足够多的1分，2分，5分钱币，任意给定金额比如1元，问有多少种组合方式？ 换言之，$$1x+2y+5z = 100$$ 求x,y,z的解有多少个\n 思路 组合方式的总和应为：\n  任意扣去一种钱币比如1分，1元采用2分，5分两种钱币的组合数，再加上：\n  总额为（1元-1分），采用1分，2分，5分三种钱币的组合数；\n  很明显这可以很容易用递归实现\n 稍作一点解释：\na. 上面两步的意思是：不带1分的组合数 + 带1分的组合数 = 全部的组合数； 这是显而易见的\nb. 上述第2步，（1元-1分）的意思是：这样可以保证任意一种组合方式再加1分都等于1元，保证至少有1个1分的钱币\n(letrec [ (A (lambda (n d) (if (= 0 (mod n d)) 1 0))) (B (lambda (n d) (cond [(not (pair? d)) 0] [(null? d) 0] [(= 0 n) 1] [(\u0026gt; 0 n) 0] [(= 1 (length d)) (A n (car d))] [else ( + (B n (cdr d)) (B (- n (car d)) d)) ] ) ) ) ] [B 100 \u0026#39;(1 2 5)] ) ","id":28,"section":"posts","summary":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发","tags":["Scheme","SICP"],"title":"钱币组合问题","uri":"https://lvsq.net/2019/12/count-coins/","year":"2019"},{"content":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026quot;x-\u0026quot;）该如何开发做紧要的介绍。\n一切开始之前，有一点需要keep in mind，即增加扩展的位置不同，所用的方法不同，所以需要对Swagger的标准有所了解，可参考官方文档  springfox目前只允许三种扩展实现:\n ListVendorExtension:列表的形式,该对象支持泛型，最终形式：”x-field”:[{field:value}] ObjectVendorExtension:对象的扩展形式,最终的扩展形式是：”x-field”:[{field:value}] StringVendorExtension:string类型的扩展实现，最终的扩展形式是”x-field”:”value”   Swagger根对象扩展 以在info中添加一个x-logo为例\n\u0026#34;info\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;\u0026lt;div style=\u0026#39;font-size:14px;color:red;\u0026#39;\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;swagger-bootstrap-ui！！！\u0026#34;, \u0026#34;termsOfService\u0026#34;: \u0026#34;http://www.xxx.com/\u0026#34;, \u0026#34;contact\u0026#34;: { \u0026#34;name\u0026#34;: pxxxx@domain.com\u0026#34; }, \u0026#34;x-logo\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#090807\u0026#34; } }, ... 后台代码：\nObjectVendorExtension logo = new ObjectVendorExtension(\u0026#34;x-logo\u0026#34;); logo.addProperty(new StringVendorExtension(\u0026#34;url\u0026#34;, \u0026#34;https://xxx.svg\u0026#34;)); logo.addProperty(new StringVendorExtension(\u0026#34;color\u0026#34;, \u0026#34;#090807\u0026#34;)); return new ApiInfoBuilder() .title(\u0026#34;swagger-bootstrap-ui！！\u0026#34;) .extensions(Lists.newArrayList(logo)) .description(\u0026#34;\u0026lt;div style=\u0026#39;font-size:14px;color:red;\u0026#39;\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026#34;) .termsOfServiceUrl(\u0026#34;http://www.xxx.com/\u0026#34;) .version(\u0026#34;1.0.0\u0026#34;) .build();  内部对象扩展 给Path添加一个扩展属性x-order为例\n@Component @Order(Ordered.HIGHEST_PRECEDENCE+100) public class OperationPositionBulderPlugin implements OperationBuilderPlugin { @Override public void apply(OperationContext context) { context.operationBuilder().extensions(Lists.newArrayList(new StringVendorExtension(\u0026#34;x-order\u0026#34;,\u0026#34;1\u0026#34;))); } @Override public boolean supports(DocumentationType delimiter) { return true; } } 详细介绍可以参考\n","id":29,"section":"posts","summary":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026quo","tags":["swagger","vendorExtensions"],"title":"Swagger 如何使用vendorExtensions进行扩展","uri":"https://lvsq.net/2019/11/swagger-vendor/","year":"2019"},{"content":" 秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁，如平原君广纳异国宾客；苏秦上书于七国；荀子遍游天下者皆可证各国文字并无大乖。 《史籀篇》文首盖云“太史籀书”，人多误以太史籀所作，如此便望文生义了。太史乃官职，王国维先生引《说文》解释，籀即读，读即籀书。另太史籀书乃周世之成语，绝非人名。  ","id":30,"section":"posts","summary":"秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁","tags":["文史"],"title":"历史不能碰","uri":"https://lvsq.net/2019/11/do-not-touch-history/","year":"2019"},{"content":"M -\u0026gt; Alt(option) S -\u0026gt; Shift    快捷键 用途     M-v 上（后）一屏   C-v 下（前）一屏   C-l 重绘屏幕，将光标所在行置于屏幕中央   C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符   C-x C-f  查找或者新建一个文件   C-x C-b 列出缓冲区。 C-x 1 关闭缓冲区列表   C-x C-q 开启或者关闭buffer的只读模式   C-x C-s 保存当前文件   C-x s 保存所有文件   C-x h 全选   M-w 复制   C-y 粘贴   C-w 剪切   C-s 往前搜索   C-r 往后搜索. DEL 也可以往后搜索，   C-/ undo   M-x calendar 打开日历。按 q 退出。【g d 到指定日期】【. 到今日（不居中）】【\u0026gt; 前一个月】【\u0026lt; 后一个月】   M-x *-mode 选择Major mode   M-x shell 运行一个shell   M-x eshell 运行一个eshell   C-a 移到行首   C-a C-k、C-S-backspace 删除整行   C-u 5 C-S-backspace、M-5 C-S-backspace 删除后5行，不加数字则删除4行（默认），如果数字为负数，则往前删   C-g 停止当前的命令   C-k 删除从光标位置到行尾所有字符    Org-Mode    快捷键 用途     C-c . 插入时间   C-c C-e 导出其它格式   C-c C-s 在标题下面插入一个带有“==SCHEDULED==”关键字的时间戳。   C-c C-d 在标题下面插入一个带有“==DEADLINE==”关键字的时间戳   C-c C-t 将当前项的状态在（unmarked）-\u0026gt;TODO-\u0026gt;DONE 之间循环切换   M-RET 插入一个同级标题   M-LEFT/RIGHT 将当前的标题提升/降低一个等级   C-c C-c 插入标签tag。 光标在标题中   C-c C-q 插入标签tag。光标在任意位置   C-c , 设置当前标题的优先级,’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的   C-c \\ 查找标签tag   S-Tab 展开所有标题   Tab 展开光标所在标题   C-c C-l 编辑链接   C-c C-o 打开链接    ","id":31,"section":"posts","summary":"M -\u0026gt; Alt(option) S -\u0026gt; Shift 快捷键 用途 M-v 上（后）一屏 C-v 下（前）一屏 C-l 重绘屏幕，将光标所在行置于屏幕中央 C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符 C-x C-f 查","tags":["emacs"],"title":"Emacs","uri":"https://lvsq.net/2019/11/emacs/","year":"2019"},{"content":"模块基础 一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set!\n通常，每个Racket模块驻留在自己的文件中，换句话说，可以认为一个.rkt 文件里的内容属于某一个模块，模块名就是文件名。\n在任意目录下创建一个子目录：mod_demo\n├── mod_demo\n│ ├── ext\n│ │ └── cake.rkt\n│ └── main.rkt\nmod_demo目录下有一个main.rkt模块，和一个ext目录，该目录下有一个cake.rkt的模块。\ncake.rkt的内容如下：\n#lang racket (provide print-cake) (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (provide print-cake) 意味着将函数print-cake导出，在模块外部就可以使用该函数了；还有一个私有的函数show, 该函数未导出，所以外部无法访问。 main.rkt的内容为：\n#lang racket (require \u0026#34;ext/cake.rkt\u0026#34;) (print-cake (random 30)) (require \u0026ldquo;ext/cake.rkt\u0026rdquo;) 将cake模块引入，引用路径符合Unix风格(但是，不能以文件分隔符即'/\u0026lsquo;作为开始或者结束)，也支持相对路径，(require \u0026ldquo;./ext/cake.rkt\u0026rdquo;) 也是完全可以的。\nCollections collection中的模块通过不带引号的、无后缀的路径引用。例如：以下模块引用了作为“racket” collection一部分的“date.rkt”库：\n#lang racket (require racket/date) (printf \u0026#34;Today is ~s\\n\u0026#34; (date-\u0026gt;string (seconds-\u0026gt;date (current-seconds)))) 注意，(require racket/date)没有带双引号。像racket/date这样的模块看起来像一个标识符，当require看到一个未加引号的模块引用时，它会将引用转换为基于collection的模块路径：\n 首先，如果未引用的路径不包含 /，然后 require会自动向引用添加一个“/main”。例如，( require slideshow )等效于( require slideshow/main )。 其次，require 向路径隐式添加了“.rkt”后缀。 最后，require通过在已安装的collection中搜索来解析路径，而不是将路径视为相对于封闭模块的路径。  Packages and Collections 一个package是一组通过Racket包管理器安装的库的集合。Racket 程序不直接引用包。相反，程序通过collections引用库，并且添加或删除包会更改可用的基于集合的库集。\n添加Collections library的旨在跨多个项目使用，因此将库的源文件保存在一个目录中并没有意义，更不能将库复制到不同的项目中使用。在这种情况下，最好的选择是新增一个collection，将lib放在collection中，这样就可以使用不带引号的路径引用它，就像Racket 发行版中包含的库一样。\n不用担心，创建一个包无需提交到公开的包服务器，可以安装到本地来使用。\n 采用raco pkg命令行工具： raco pkg install \u0026ndash;link /path/to/mod_demo\n 安装之后，在任何模块中使用(require mod_demo/ext/cake)都会从/path/to/mod_demo/ext/cake.rkt导入print-cake含函数。\n\u0026gt; (require mod_demo/ext/cake) \u0026gt; (print-cake 4) ...... .-||||||-. | | ------------ \u0026gt; 默认情况下，您安装的目录名称既用作包名称又用作包提供的collection\n将lib放入collection之后，仍然可以使用raco make来编译库的源文件，但是使用raco setup更加方便。尤其是修改了模块代码后，使用raco setup会重新编译所有库文件，并重新安装包。与raco make不同的是，raco setup 后面的参数是包名，即raco setup mod_demo, 而raco make后面是模块名，即raco make main.rkt。\n模块语法 模块文件开头处的#lang其实是模块形式的简写，但不能用于REPL。\n模块形式 普通形式的模块声明，可以工作于REPL\n (module name-id initial-module-path decl \u0026hellip;)\n name-id是模块的名字，initial-module-path 为初始化导入，每个decl可以是导入，或者导出，或者定义，或者表达式。\ninitial-module-path是必须的，模块内部也是一个环境（SICP中的环境，即上下文），内部使用的指令是需要通过initial-module-path引导的。常用的initial-module-path是racket, require/define/provide等等都来自racket。另一个常用的initial-module-path是racket-base,它提供的功能较少，但仍然是很常用。\n上一节中的“cake.rkt”也可以写成：\n(module cake racket (provide print-cake) (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline))) 这种模块形式是可以被REPL求值的（注意(require \u0026lsquo;cake)， 模块名cake需要被quote，因为这时cake是非文件的模块声明）：\n\u0026gt; (require \u0026#39;cake) \u0026gt; (print-cake 3) ... .-|||-. | | --------- 声明一个模块，其body不会被立刻求值，只有在显式地被require之后才会求值一次。\n\u0026gt; (module hi racket (printf \u0026#34;Hello\\n\u0026#34;)) \u0026gt; (require \u0026#39;hi) Hello \u0026gt; (require \u0026#39;hi) #lang #lang声明的模块的body没有特定的语法，因为其语法由#lang之后的名称所决定。\n比如，#lang racket的语法是：\n#lang racket decl ... 等同于：\n(module name racket decl ...) name是包含#lang形式的文件名\n子模块 一个模块可以嵌套在另一个模块中，父模块可以直接访问子模块导出的函数、定义、表达式。\n#lang racket (module zoo racket (provide tiger) (define tiger \u0026#34;Tony\u0026#34;)) (require \u0026#39;zoo) tiger module* module*形式类似module：\n(module* name-id initial-module-path-or-#f decl ...) module*与module的不同之处在于：\n 由module声明的子模块，可以被其父模块require, 但是子模块不能require父模块； 由module*声明的字模块，可以require父模块，但是父模块不能require该子模块；  此外，module*形式可以用#f代替initial-module-path，这意味着，子模块可以访问父模块所以绑定，包括未通过provide导出的绑定。\n因此，用module*和#f来声明一个模块的一个用途是，将某个模块未provide出去的绑定导出。\n#lang racket (provide print-cake) (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (module* extras #f (provide show)) 尽管show函数未导出，但是子模块extras却将其导出了，外部程序可以使用(require (submod \u0026ldquo;caske.rkt\u0026rdquo; extras))来访问隐藏的show函数。\nMain和Test子模块 #lang racket (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (module* main #f (print-cake 10)) 这个“cake.rkt”变体，包含了一个main子模块，并调用了print-cake函数。\n一般来说，运行一个模块时并不会运行其中由module*声明的子模块，但是main子模块除外。\nmain子模块并不一定由module*声明，如果不需要使用父模块的绑定，也可以由module来声明。 更常见的做法是由module+来声明\n(module+ name-id decl ...) module+声明的模块就像采用module*声明且使用#f作为initial-module-path的模块。此外，多个module+模块可以同名，同名的模块会组合成一个模块。这种组合特性可以用来定义一个test模块，在使用 raco test命令时就可以大显身手了。\n假设\u0026quot;physics.rkt\u0026quot; 为：\n#lang racket (module+ test (require rackunit) (define ε 1e-10)) (provide drop to-energy) (define (drop t) (* 1/2 9.8 t t)) (module+ test (check-= (drop 0) 0 ε) (check-= (drop 10) 490 ε)) (define (to-energy m) (* m (expt 299792458.0 2))) (module+ test (check-= (to-energy 0) 0 ε) (check-= (to-energy 1) 9e+16 1e+15)) 导入\u0026quot;physics.rkt\u0026quot; 时，并不会运行drop和to-energy的测试，不过运行raco test physics.rkt将会执行这些测试。\n这等价于使用module*:\n#lang racket (provide drop to-energy) (define (drop t) (* 1/2 49/5 t t)) (define (to-energy m) (* m (expt 299792458 2))) (module* test #f (require rackunit) (define ε 1e-10) (check-= (drop 0) 0 ε) (check-= (drop 10) 490 ε) (check-= (to-energy 0) 0 ε) (check-= (to-energy 1) 9e+16 1e+15)) module+的组合行为对main模块也有帮助，即使不需要组合， ( module+ main \u0026hellip;. )也是首选，因为它比( module* main #f \u0026hellip;. )更具可读性 。\nRequire require的定义为：\n (require require-spec \u0026hellip;)\n only-in 用来限制模块导出的绑定，也可重命名绑定\n\u0026gt; (module m (lib \u0026#34;racket\u0026#34;) (provide tastes-great? less-filling?) (define tastes-great? #t) (define less-filling? #t)) \u0026gt; (require (only-in \u0026#39;m tastes-great?)) \u0026gt; tastes-great? #t \u0026gt; less-filling? less-filling?: undefined; cannot reference an identifier before its definition in module: top-level \u0026gt; (require (only-in \u0026#39;m [less-filling? lite?])) \u0026gt; lite? #t except-in 是only-in的补充，用来排除某些绑定\n (except-in require-spec id \u0026hellip;)\n rename-in 与only-in类似。\n (rename-in require-spec [orig-id bind-id] \u0026hellip;)\n prefix-in  (prefix-in prefix-id require-spec) 给每一个require-spec的绑定添加前缀\n Provide  (provide provide-spec \u0026hellip;)\n provide-spec允许递归定义：\n id: 最简单的形式，上文中多次出现\n  (rename-out [orig-id export-id] \u0026hellip;): 重命名导出的绑定\n  (struct-out struct-id): 导出struct\n  (all-defined-out): 导出所有绑定，不推荐\n  (all-from-out module-path): 导出所有由module-path指定的绑定\n  (except-out provide-spec id \u0026hellip;): 排除id指定的绑定\n  (prefix-out prefix-id provide-spec)：给每个导出绑定添加一个前缀\n ","id":32,"section":"posts","summary":"模块基础 一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set! 通常，每个Racket模块驻留在自己的文件中，换句话说，可以","tags":["racket","module"],"title":"Racket Modules","uri":"https://lvsq.net/2021/07/racket-modules/","year":"2021"},{"content":"这是一个leet code出现的问题:\n 给 n 个非负整数 $a_1$，$a_2$，\u0026hellip;，$a_n$，每个数代表坐标中的一个点(i, $a_i$) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i, $a_i$) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n  说明：不能倾斜容器\n 更详细的描述请访问：https://leetcode-cn.com/problems/container-with-most-water/\n首先可以想到的最简单的方法，就是暴力求解，将所有的面积都计算出来，取最大值即可。下面给出(Racket)[https://racket-lang.org/]的代码，得益于函数式语言和S表达式强大的表现力，代码可以很短：\n(define/contract (max-area height) (-\u0026gt; (listof exact-integer?) exact-integer?) (define len (length height)) (cond ((\u0026lt; len 2) 0) ((= len 2) (area (list 1 (car height)) (list 2 (cadr height)))) (else (max (each-area height) (max-area (cdr height)))))) (define (area n1 n2) (* (- (car n2) (car n1)) (min (cadr n1) (cadr n2)))) (define (each-area height) (let ([first (list 1 (car height))]) (foldl max 0 (map (lambda (i h) (area first (list i h))) (range 2 (add1 (length height)) ) (cdr height))))) 上述解法虽然正确，但是效率很低, 如果有10000个整数，即n=10000，其执行时间超过了2秒：\n(time (max-area (build-list 10000 (lambda(x) (random 1000000))))) =\u0026gt; cpu time: 2387 real time: 2466 gc time: 137 那么有更好的解决方法吗？\n显然可以认为所有整数都保存在一个列表或者数组中，假设我们有两个指针，一个叫head，指向第一个整数, 表示为：head -\u0026gt; (i, $h_i$)，i为列表下标， $h_i$代表第i个整数值；另一个叫tail，指向最后一个整数，表示为tail -\u0026gt; (j, $h_j$)，我们可以仅仅利用这两个指针的移动，就能计算出最大的面积，其过程为：\n 计算由head和tail围成的矩形的面积$S_{ij}$, 矩形的长度x = j - i, 高度y = min ($h_i$, $h_j$); 将矩形收窄一格，即x减少1，那么有两种收窄方式：  将高度短的一侧收窄，那么，收窄后高度可能变大，则面积可能增大; 将高度长的一侧收窄，由于另一侧不变,但是长度变小了一格，则面积会变小;   因此，需要移动高度短的一侧，才有可能找到面积更大的矩形  很显然，使用双指针算法，时间复杂度降低到了$O(n)$。\nRacket 版本 ;;better solution (define/contract (max-area-pair-pointer height) (-\u0026gt; (listof exact-integer?) exact-integer?) (define (area n1 n2) (* (- (car n2) (car n1)) (min (cadr n1) (cadr n2)))) (let ([len (length height)]) (if (\u0026lt; len 2) 0 (let loop ([h height] [hindex (range 0 len)] [rheight (reverse height)] [rindex (reverse (range 0 len))] [maxa 0]) (let* ([head (list (car hindex) (car h))] [tail (list (car rindex) (car rheight))] [a (area head tail)]) (if (= (car head) (car tail)) maxa (if (\u0026gt; (cadr head) (cadr tail)) (loop h hindex (cdr rheight) (cdr rindex) (max maxa a)) (loop (cdr h) (cdr hindex) rheight rindex (max maxa a))) )))))) 如果使用这个方法计算10000个整数的面积，执行时间只需1毫秒，而且不需要GC（对照暴力破解版本，2+秒）\n(time (max-area-pair-pointer (build-list 10000 (lambda(x) (random 1000000))))) =\u0026gt; cpu time: 1 real time: 1 gc time: 0 Rust版本 同时提供一个Rust版本的实现，\nuse std::cmp::{max, min}; type HeightType = i64; #[derive(Debug)] struct Solution {} impl Solution { pub fn max_area(height: Vec\u0026lt;HeightType\u0026gt;) -\u0026gt; HeightType { let len = height.len(); return if len \u0026lt; 2 { 0 } else { let mut max_area = 0; let mut hi = 0; let mut ti = len - 1; while ti \u0026gt; hi { let hd = height.get(hi).unwrap(); let td = height.get(ti).unwrap(); let a = ((ti - hi) as HeightType) * min(hd, td); max_area = max(max_area, a); if hd \u0026lt; td { hi += 1; } else { ti -= 1; } } max_area }; } } 两个版本做一个简单的比较：\n   size Racket(8.0 CS) Rust(1.50.0)     100000 49ms 60ms   1000000 560ms 550ms   10000000 5s 5.6s    两个版本的实现均未使用编译器优化,令人意外的是Racket的执行效率与Rust几乎没有差别，使用了CS编译器的Racket真是突飞猛进。 由于我的Rust经验并不是很多，或许有更好的写法。从测试可以看到Racket至少在CPU密集型应用中可堪大用。\n","id":33,"section":"posts","summary":"这是一个leet code出现的问题: 给 n 个非负整数 $a_1$，$a_2$，\u0026hellip;，$a_n$，每个数代表坐标中的一个点(i, $a_i$) 。在","tags":[],"title":"【盛最多水的容器】问题的求解","uri":"https://lvsq.net/2021/05/container-with-most-water/","year":"2021"},{"content":"神经科学家发现，解释代码可以激活通用的大脑网络，但不能激活语言处理中心。\n安妮·特拉夫顿 | 麻省理工学院新闻办公室 发布日期：2020年12月15日\n 在某些方面，学习计算机编程与学习新语言相似。它需要学习新的符号和术语，必须正确组织这些符号和术语以指导计算机该怎么做。计算机代码还必须足够清晰，以便其他程序员可以阅读和理解。\n尽管存在这些相似之处，麻省理工学院的神经科学家发现，阅读计算机代码并不能激活与语言处理有关的大脑区域。取而代之的是，它激活了一个称为多需求网络的分布式网络，该网络也被招募用于解决复杂的认知任务，例如解决数学问题或填字游戏。\n但是，尽管阅读计算机代码会激活多需求网络，但与数学或逻辑问题相比，它似乎更多地依赖于网络的不同部分，这表明编码也不能精确地复制数学的认知需求。\n“理解计算机代码似乎是自己的事。它与语言不同，数学与逻辑也不相同。”麻省理工学院研究生，该研究的主要作者安娜·伊凡诺娃（Anna Ivanova）说。\nEvelina Fedorenko，Frederick A.和Carole J. Middleton职业发展神经科学副教授，麦戈文脑科学研究所的成员，是该论文的高级作者，该论文今天发表在eLife上。麻省理工学院计算机科学与人工智能实验室和塔夫茨大学的研究人员也参与了这项研究。\n语言与认知 Fedorenko研究的主要重点是语言与其他认知功能之间的关系。特别是，她一直在研究其他功能是否依赖于大脑的语言网络（包括Broca区域和大脑左半球的其他区域）的问题。在先前的工作中，她的实验室表明，音乐和数学似乎并未激活该语言网络。\n“在这里，我们有兴趣探索语言和计算机编程之间的关系，部分原因是计算机编程是一个新发明，我们知道不可能有任何硬连线机制使我们成为优秀的程序员，”伊万诺娃说。\n她说，关于大脑如何学习编码，存在两种思想流派。有人认为，要精通编程，就必须精通数学。另一个建议认为，由于编码和语言之间的相似性，语言技能可能更相关。为了阐明这一问题，研究人员着手研究在阅读计算机代码时大脑活动模式是否会与语言相关的大脑活动重叠。\n研究人员在本研究中重点关注以可读性着称的两种编程语言——Python和ScratchJr。ScratchJr这是一种专为5岁及5岁以上儿童设计的可视化编程语言。研究对象均为精通测试语言的年轻人。当程序员躺在功能磁共振（fMRI）扫描仪中时，研究人员向他们展示了代码片段，并要求他们预测代码将产生什么动作。\n研究人员几乎看不到大脑语言区域对代码的反应。相反，他们发现编码任务主要激活了所谓的多需求网络。这个网络的活动遍布整个大脑的额叶和顶叶，通常是为需要同时记住许多信息的任务而招募的，它负责我们执行各种心理任务的能力。\n伊万诺娃说：“它所做的几乎所有在认知上都具有挑战性的事情，使您难以思考。”\n先前的研究表明，数学和逻辑问题似乎主要取决于左半球的多个需求区域，而涉及空间导航的任务比右半球更多地激活右半球。麻省理工学院的研究小组发现，读取计算机代码似乎可以激活多需求网络的左侧和右侧，而ScratchJr激活右侧的程度要比左侧高一些。这一发现违背了数学和编码依赖相同大脑机制的假设。\n经验的影响 研究人员说，尽管他们没有发现任何似乎专门用于编程的区域，但是这种具有特殊脑活动的区域可能会在具有更多编码经验的人中发展。\nFedorenko说：“如果您聘用了以30年或40年的特定语言编写代码的专业程序员的人，您可能会开始看到某些专业化知识，或者是多个需求系统某些部分的结晶”，Fedorenko说。“对于那些熟悉编码并且可以有效地完成这些任务，但经验相对有限的人来说，似乎您还看不到任何专业化知识。”\n约翰·霍普金斯大学的一组研究人员在同一期eLife上发表的一篇伴随论文中也报告说，解决代码问题可以激活多需求网络而不是语言区域。\n研究结果表明，对于编码应该以基于数学的技能还是基于语言的技能进行教授，尚无定论。研究人员说，部分原因是因为学习编程可能会同时依赖语言和多种需求系统，即使—一旦学会了编程，就不会依赖语言区域。\n伊万诺娃说：“两个阵营都宣称，它必须与数学结合在一起，必须与语言结合在一起。” “但是看来，计算机科学教育者将不得不开发自己的方法来最有效地教授代码。”\n全文完。\n 如果您想看原文，可以访问：链接\n","id":34,"section":"posts","summary":"神经科学家发现，解释代码可以激活通用的大脑网络，但不能激活语言处理中心。 安妮·特拉夫顿 | 麻省理工学院新闻办公室 发布日期：2020年12月15","tags":[],"title":"对大脑而言，阅读计算机代码与阅读语言不同","uri":"https://lvsq.net/2020/12/brain-reading-computer-code/","year":"2020"},{"content":"作者\nMATTHEW FLATT, University of Utah,USACANER DERICI, Indiana University, USAR. KENT DYBVIG, Cisco Systems, Inc., USAANDREW W. KEEP, Cisco Systems, Inc., USAGUSTAVO E. MASSACCESI, Universidad de Buenos Aires, ArgentinaSARAH SPALL, Indiana University, USASAM TOBIN-HOCHSTADT, Indiana University, USAJON ZEPPIERI, independent researcher, USA 概要\n我们在Chez Scheme上重建了Racket，并且运行良好——只要对Chez Scheme进行一些修补，就可以运行DrRacket。Racket发行版可以自行构建，并且几乎所有核心​​的Racket测试套件都可以通过。尽管仍有一些工作可以提高端到端的性能，但最终的实现还是不错的。我们评估的最不可预测的部分是，Racket和Chez Scheme之间的不同将变得多大，以及我们如何处理这些不同。我们希望Racket CS成为主要的Racket实现，并且我们鼓励其他语言实现者将Chez Scheme视为目标虚拟机。\n 该文详细地介绍了Racket CS是如何构建的，以及与Chez Scheme之间的差异， 完整内容见(https://dl.acm.org/doi/epdf/10.1145/3341642)\n","id":35,"section":"posts","summary":"作者 MATTHEW FLATT, University of Utah,USACANER DERICI, Indiana University, USAR. KENT DYBVIG, Cisco Systems, Inc., USAANDREW W. KEEP, Cisco Systems, Inc., USAGUSTAVO E. MASSACCESI, Universidad de Buenos Aires, ArgentinaSARAH SPALL, Indiana University, USASAM TOBIN-HOCHSTADT, Indiana University, USAJON ZEPPIERI, independent researcher, USA 概要 我们在Chez Scheme上重建了Racket，并且","tags":["pl"],"title":"基于Chez Scheme重建Racket","uri":"https://lvsq.net/2020/10/rebuilding-racket/","year":"2020"},{"content":"我相信每一位程序员在学习或者实践编程时，都会遇到作用域的问题。您可能觉得作用域很简单，甚至都不能当做一个问题来看待，我想原因可能是目前主流的计算机语言Java, Python, C等等几乎一致采用Lexical Scoping,程序员没有机会察觉到异样，从而掩盖了还有其他作用域的事实，许多教科书也很配合地一笔带过，当然还有一种可能是您已经洞察了不同作用域的差异和内涵，自觉地规避了问题。我衷心的希望所有程序员都是第二种可能。\n本文将浅显地描述两种作用域的特点及差异，希望可以解释地清楚一点，如果读完之后您更加模糊了，请记住，这并非我的本意。\n在计算机编程中，名称绑定的作用域（名称与实体的关联，比如变量）是程序中名称绑定有效的部分，也就是说，该名称可以被引用到一个实体。程序的其他部分，名称可能指向不同的实体（它可能具有不同的绑定），或者根本什么都没有（它可能是未绑定的）。作用域也称为实体的可见性， 尤其在较早的技术文献中可见，这是从所引用的实体的角度出发，而非引用的名称。\n术语\u0026quot;scope\u0026ldquo;也用于指代程序中有效的名称绑定的那部分集合，更加正确的称呼应该是上下文 或者 环境\n Lexical Scoping 词法作用域，某些书中也叫静态作用域，其在编写代码时或者说定义时就确定的，通过文本（源代码）就可以观察到名称与实体的关联，程序运行时会在距离被调用代码最近的环境中去查找绑定，如果存在多个环境，在优先从最里面一层的环境查找。\n来看一个例子：\n(setf x 1) ;; bind x to 1 (setq f (let ((x 2)) ;; bind x to 2 (lambda (y) (* x y)))) (funcall f 3) ;; result is 6 (format t \u0026#34;X = ~d \u0026#34; x) ;; X = 1 先绑定x为1，然后定义一个函数f，f中的变量x绑定为2，实际上f形成了一个闭包，由于两个x的环境不同，所以互不干扰，结果正是我们期望的，这就属于词法作用域。\nDynamic Scoping 动态作用域曾经让很多人深恶痛绝，以至于不愿意再提起它。早期的Lisp普遍使用了动态作用域，并带来了非常严重的问题，这也是Lisp Machine被Unix打败的除了商业因素之外的重要原因，Lisp至今未成为主流语言就不难理解了，尽管Lisp的语法最精炼、最优美，还具有最强悍的宏系统，还是世界上第一个使用GC的语言\u0026hellip;\n庆幸的是，Scheme, Common Lisp等Lisp方言已经都是用了Lexial Scoping（局部变量。所以某些时候我们可以把Lexical Scoping和Local Variable等价）, 我们无需再为一些莫名其妙的问题而烦恼，珍惜生命，不是吗？ 不过Scheme, Common Lisp还是保留了动态作用域的操作，Scheme可以参考Fluid Binding, Common Lisp的动态作用域将在后文举例说明，尽管如此，我们无需为这个保留担忧，因为基本上我们很少需要使用到这个功能。\n所谓dynamic scoping就是说，在函数定义中存在了“自由变量”（free variable）, 会在运行时随着函数的“调用位置”不同而发生变化，还是用上面的例子来说明，但是稍作变化：\n(defvar x 1) ;; bind x to 1, x is a free variable (setq f (let ((x 2)) ;; bind x to 2 (lambda (y) (* x y)))) (funcall f 3) (format t \u0026#34;X = ~d \u0026#34; x) (let ((x 100)) (format t \u0026#34;Inner X is ~d \u0026#34; x)) (defvar x 1)定义了x，值为1，但是这个x属于自由变量，处于动态作用域，因为Lisp自动将全局变量即由defvar、defparameter、special定义的变量自动声明为动态作用域。 x对于(lambda (y) (* x y))来说是“ **自由** ” 的，它可不会在意x绑定为2或者任何其他值，因为(let ((x 2)) \u0026hellip;)中指定的x已经不是(lambda \u0026hellip;)的参数了。\n所以当我们执行(funcall f 3) 时，其结果不像词法作用域那样等于6，而是3\n(format t \u0026ldquo;X = ~d \u0026quot; x) 依然输出： X = 1\n(let ((x 100)) (format t \u0026ldquo;Inner X is ~d \u0026quot; x)) 输出为：Inner X is 100。 等等，这里的x为什么又是100了？ 还记得上文提到的环境 吗？！\n如果将函数f放到不同的位置执行会发生什么？ 上面(funcall f 3)是在顶层执行的，我们换到let中执行会怎么样？\n(let ((x 2)) (funcall f 3)) 这次居然返回6，而不是3了。\n看到问题了吗？函数f的行为，会随着调用位置的一个名叫x的变量的值的不同而变化。虽然都叫x，但并不是同一个变量，只是名字相同而已。顺带提一句，现在可以理解Java中namespace的用处了吧。\n 词法作用域是通过搜索本地词法上下文解决的，而动态作用域是通过搜索本地执行上下文（即位置）解决的。这是编译器必须面对并解决的问题，或许编写程序时无需过多关注，但是多了解一下一定大有裨益。尽管动态作用域存在很大问题，但它并非洪水猛兽，它可以使全局变量更易于管理；假设您希望临时改变自由变量的值时，也可以声明为dynamic socping；另外在异常处理中也可以使用动态作用域将处理程序与异常相关联。\n","id":36,"section":"posts","summary":"我相信每一位程序员在学习或者实践编程时，都会遇到作用域的问题。您可能觉得作用域很简单，甚至都不能当做一个问题来看待，我想原因可能是目前主流的","tags":["lexical","scoping"],"title":"Lexical Scoping and Dynamic Scoping","uri":"https://lvsq.net/2020/09/lexical-dynamic-scoping/","year":"2020"},{"content":"快速排序是一种常见的排序手段，由C.A.R.Hoare在1960年提出。其基本思路为：\n  设定一个分界值，通常为第一个元素；\n  遍历列表，将所有小于分界值的元素集中到列表的左侧，所有大于或等于分界值的元素集中到右侧；\n  分别对左侧和右侧的元素进行快排；\n  重复上述的步骤，排序完成；\n  在平均状况下，排序n个元素需要$O(nlog n)$复杂度，最坏情况下需要$O(n^2)$,但一般很少出现这种情况。\n从算法的原理可以看出，需要多次执行重复的操作，自然采用递归可以减少很多代码，若问递归技术哪家强？首屈一指Lisp,下面给出CL版本的快排实现（简易版本，只支持数字类型的列表，其他类型的排序只需增加一个比较函数即可，本文不扩展）：\n(defun quickSort (lst) (let ( (len (list-length lst)) (st (lambda (l pk) ;; st函数实现上述第2步 (let ((left nil) (right nil)) (dolist (each l) (if (\u0026lt; each pk) (push each left) (push each right))) (values left right) ) ) ) ) (if (\u0026lt; len 2) lst (multiple-value-bind (l r) (st (cdr lst) (car lst)) (append (quickSort l) (cons (car lst) (quickSort r)))) ) ) ) (quickSort \u0026#39;(1 2 6 3 5 4)) =\u0026gt; (1 2 3 4 5 6) st函数可以用宏来实现：\n(defmacro st (lst pk) (let ((gslist (gensym))) `(let ((,gslist ,lst)) (let ((left nil) (right nil)) (dolist (each ,gslist) (if (\u0026lt; each ,pk) (push each left) (push each right))) (values left right) ) ) ) ) (defun quickSort (lst) (let ( (len (list-length lst)) ) (if (\u0026lt; len 2) lst (multiple-value-bind (l r) (st (cdr lst) (car lst)) (append (quickSort l) (cons (car lst) (quickSort r)))) ) ) ) ","id":37,"section":"posts","summary":"快速排序是一种常见的排序手段，由C.A.R.Hoare在1960年提出。其基本思路为： 设定一个分界值，通常为第一个元素； 遍历列表，将所有小于","tags":["lisp"],"title":"快速排序（Lisp版本）","uri":"https://lvsq.net/2020/07/quick-sort-in-cl/","year":"2020"},{"content":"讲故事并不是我擅长的事情，不过事情总有一个开始，诸位看官莫嫌我絮烦，只是希望可以讲述的更有条理一些。某日正读一本关于Erlang的书，书中出了一个关于八皇后的题目，这是计算机科学中经典的问题，当年上学时曾绞尽脑汁仍然云山雾罩，不得其解。如今再次相遇，岂能再坐壁上观？！更何况手边已有趁手的兵器。试看Erlang的实现：\n-module(queens). -export([queens/1]). queens(0) -\u0026gt; [[]]; queens(N) -\u0026gt; [[Row | Columns] || Columns \u0026lt;- queens(N - 1), Row \u0026lt;- lists:seq(1, 8) -- Columns, safe(Row, Columns, 1)]. safe(_Row, [], _N) -\u0026gt; true; safe(Row, [Column | Columns], N) -\u0026gt; (Row /= Column + N) andalso (Row /= Column - N) andalso safe(Row, Columns, (N + 1)). 从头至尾10行代码，如果不是为了使代码美观，6行足矣（这还包括了**-module** 和**-export** 两行声明语法，与算法本身无关的代码）。如此简短尽然可以清晰地实现复杂的**八皇后** 问题，如果采用命令式程序语言得写多少行？本文的重点不在于比较这个，Erlang是一门非常强大的语言，对于我来说Erlang好比探春，但是Scheme才是林黛玉呀，所以毫不迟疑用Scheme来实现：\n(define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence)))) ) (define (enumerate-interval low high) (if (\u0026gt; low high) \u0026#39;() (cons low (enumerate-interval (+ low 1) high))) ) (define (flatmap proc seq) (accumulate append \u0026#39;() (map proc seq)) ) (define empty-board \u0026#39;()) (define (safe? k position) (let loop ([new-queen (car position)] [rest-queens (cdr position)] [i 1]) (if (null? rest-queens) #t (let ([rest-current-queen (car rest-queens)]) (if (or (= new-queen rest-current-queen) (= new-queen (+ rest-current-queen i)) (= new-queen (- rest-current-queen i)) ) #f (loop new-queen (cdr rest-queens) (+ i 1)) ) ) ) ) ) (define (adjoin-position new-row k rest-of-queens) (cons new-row rest-of-queens) ) (define (queens board-size) (define (queen-cols k) (if (= k 0) (list empty-board) (filter (lambda (position) (safe? k position)) ;过滤无效的解 (flatmap (lambda (rest-of-queens) (map (lambda (new-row) ;扩充（k-1）个皇后的每一个解，给每个解都增加第k个皇后 (adjoin-position new-row k rest-of-queens)) (enumerate-interval 1 board-size) ) ) (queen-cols (- k 1)) ;前（k-1）个有效的皇后，虽然是太虚幻境，但可以认为是事实 ) ) ) ) (queen-cols board-size) ) Scheme版本比Erlang版本代码增加了不少，原因在于其没有模式匹配 和列表推导 这两大利器，不过我更喜欢Scheme强大的表现力，可以随心所欲地构造我需要的一切，而且S-表达式看起来十分优美自然。Scheme版本实际上解决了n-皇后，更进一步了。\n事情到这里并没有结束，原因在于我刚开始实现Scheme版本的八皇后时，选择翻译Erlang代码，最终失败了！一番挣扎之后，意识到该问题属于非确定性计算，猛然想起《SICP》中有一节专门介绍了此种计算，也即本文的主角——amb\n 非确定性计算 amb这个名字源于ambiguous ,其含义并不是很好理解。一番披肝沥胆之后，终于窥到了一些门径，趁机厘清很多知识点。我将尽力平铺直述，简要的介绍这种强大且十分有用的武器。\n首先，我们来观察一个问题：\n 假设有两个数组，数组中都是一些正整数，比如l1 = [1 2 3 4 5], l2 = [3 4 6 7 8]，我们分别从l1和l2中各取一个数字，相加之后，如果是素数，则满足要求。怎么办呢？\n 对于这个简单的问题，相信难不倒大家，采用回溯算法轻易就解决了，这里只是想引出“非确定性计算”的概念。非确定性计算和流处理类似，对于“生成和检测式”的应用特别有价值，它往往只描述问题，但没有描述问题的解决方法，这句话很有意思，如果暂时没有理解不用着急，继续往下看。\n对于非确定性计算，首先需要明确的一点是，表达式是允许存在多个值的，比如上面的问题的解至少有(1 4),(2 3)两个解吧。\n有一件很有教益的事情，那就是非确定性计算和流处理对于时间的不同看法。流处理利用了惰性求值，这会给我们一种错觉，仿佛所有可能的结果的出现没有时间顺序；对于非确定性的求值，一个表达式是对一个可能的世界的探索，每一个值都由一次选择所确定，某些选择会走入死胡同，而另一些会得到有用的值，所以非确定性计算给我们的感觉是，时间是有分支的。程序当中会保存所有可能的不同执行历史，在遇到一个死胡同时，总是可以回到以前的选择点，并沿着另一个分支继续下去。\n下面将要实现的非确定性求值器称为——amb求值器\namb求值器 假设目前已经扩充了Scheme以支持非确定性计算，引入了一种新的称为amb的新形式，表达式 $(amb \u0026lt;e_1\u0026gt; \u0026lt;e_2\u0026gt; \u0026hellip; \u0026lt;e_n\u0026gt;)$ 会“有歧义地”返回n个表达式之一的值，比如：\n(list (amb 1 2 3) (amb \u0026#39;a \u0026#39;b)) 可以有如下6个可能的值：(1 a) (1 b) (2 a) (2 b) (3 a) (3 b)\n对于没有选项的amb，即(amb) ——视为没有可接收值的表达式，这将导致求值“fail”。\namb求值器在每个选择点，总是选择第一个可能性，如果选择的结果失败，那么求值器自动地回溯到最近的选择点，去尝试下一个可能性。如果它用完了所以的可能性，则自动退回到上一个选择点，并从那里继续（这个“继续”很有意思，后文会看到，“继续”不但是结论，还是其实现的方式，一语双关）下去。从这个过程可以看出，这是一种深度优先 算法。\n逻辑谜题 在讨论amb求值器的实现之前，先看一道逻辑谜题：\n 曹操、孙权、刘备、袁绍、马超5人住在一栋5层的楼房里面，每人住一层。曹操不住顶层，孙权不住底层，刘备不住顶层也不住底层，袁绍比刘备高一层，马超与刘备不在相邻的楼层，刘备与孙权也不在相邻的楼层，请问他们各住在哪一层？\n 在没有amb时，代码怎么写呢？恐怕不容易吧。但是现在有了amb求值器，瞬间美好了：\n(define (multiple-dwelling) (let ( [caocao (amb 1 2 3 4 5)] [sunquan (amb 1 2 3 4 5)] [liubei (amb 1 2 3 4 5)] [yuanshao (amb 1 2 3 4 5)] [machao (amb 1 2 3 4 5)] ) (require (distinct? (list caocao sunquan liubei yuanshao machao))) (require (not (= caocao 5))) (require (not (= sunquan 1))) (require (not (= liubei 5))) (require (not (= liubei 1))) (require (\u0026gt; yuanshao liubei)) (require (not (= (abs (- machao liubei)) 1)) (require (not (= (abs (- sunquan liubei)) 1)) (list (list \u0026#39;caocao caocao) (list \u0026#39;sunquan sunquan) (list \u0026#39;liubei liubei) (list \u0026#39;yuanshao yuanshao) (list \u0026#39;machao machao)) ) ) 上述代码只是描述问题的关系，即各个require部分（先不考虑性能问题。还记得上文提到的“描述问题，但没有描述问题的解决方法”吗？），并没有添加什么“处理逻辑”，但是会产生下面结果：\n((caocao 3) (sunquan 2) (liubei 4) (yuanshao 5) (machao 1))\n居然得到了谜题的解，这是什么魔法？？？\namb轻而易举地解决了这种需要大量回溯的问题。\n实现 现在该谈一谈神奇的amb如何实现了吧。前文已经多次提到过，amb求值的过程可能会不断的回溯，这势必导致程序流程的跳转，程序跳转该怎么办呢？函数式语言可没有break,continue之类的语法，因为根本不需要，那么函数式语言有啥？答案是continuation(翻译成继续，或者延续都可以。还记得“一语双关”吗？)\nScheme内置了这个强大的控制抽象，过程名为：call-with-current-continuation， 名字略长，不过一般都是用其缩写：call/cc。囿于篇幅，本文不打算介绍continuation，如果想详细了解它，请自行搜索。\n常规求值器的执行过程有一个参数：执行环境env。amb求值器的执行过程有三个参数，除了执行环境env之外，还有两个continuation过程（一个成功延续、一个失败延续）。对一个表达式进行求值，结束后会调用这两个continuation过程之一：如果此次求值得到了一个结果，则调用成功延续；如果结果是遇到了死胡同，则调用失败延续。\n成功延续的工作是：接受一个值，并将计算进行去下，与这个值一起，成功延续过程还将得到一个另一个失败延续，如果使用该值时遇到了死胡同，则需要调用这个失败延续。\n失败延续的工作是：试探非确定性过程的另一个分支。非确定性计算的最关键的特征，在于表达式可以表示于不同可能性之间的选择。\n我承认有点烧脑，但还算清晰，让递归在脑海中奔涌吧。\n利用宏来简化amb的构造，代码参考这里：\n(define amb-fail \u0026#39;*) (define initialize-amb-fail (lambda () (set! amb-fail (lambda () (error \u0026#34;amb tree exhausted\u0026#34;))))) (initialize-amb-fail) (define-syntax amb (syntax-rules () ((amb alt ...) (let ((prev-amb-fail amb-fail)) ;保存前一个选择点 (call/cc (lambda (sk) ;对于整个amb表达式构造一个sk的contnuation (call/cc (lambda (fk) ;对于每一个amb的选项构造一个fk的continuation (set! amb-fail ;先把amb-fail设置为一个函数，该函数可将amb-fail恢复到进入amb前的值 (lambda () (set! amb-fail prev-amb-fail) (fk \u0026#39;fail)) ) (sk alt) ;立即返回自己的分支的值,从而引起amb表达式中途返回。注意，每一个分支执行时都会引起 amb 立即返回。后面的分支都还没有执行！ ) ) ... (prev-amb-fail) ) ) ) ) ) ) 第一个选项（也可以叫分支）会被立即返回，后面的暂时不执行。假设该值被认为是“无效的（比如应用该值后，执行到(amb)了）”，则执行(prev-amb-fail)，而prev-amb-fail在进入amb的时候被绑定到了amb-fail， 不过amb-fail已被设置成了一个函数：\n(lambda () (set! amb-fail prev-amb-fail) (fk \u0026#39;fail)) 它先把amb-fail设置成prev-amb-fail,也就是进入（amb alt \u0026hellip;）之前的值， 然后用(fk \u0026lsquo;fail)返回\u0026rsquo;fail到分支的continuation，即可以执行下一个分支（下一个选项）了。\n十分精巧的程序！！！\n上述的amb每次只能返回一个结果，如果需要返回所有有效的结果，可以用下面定义的宏：\n(define-syntax bag-of (syntax-rules () ((bag-of e) (let ((prev-amb-fail amb-fail) (results \u0026#39;())) (if (call/cc (lambda (k) (set! amb-fail (lambda () (k #f))) ;\u0026lt;-----+ (let ((v e)) ;amb-fail will be modified by e | (set! results (cons v results)) ;| (k #t)))) ;| (amb-fail)) ;so this amb-fail may not be ---+ (set! amb-fail prev-amb-fail) (reverse! results))))) (bag-of (let ([a (amb 1 2 3)] [b (amb 0 -1 2)]) (if (= (+ a b) 1) (list a b) (amb)) )) ;结果为：((1 0) (2 -1)) 回到n-皇后问题 到目前为止，我已手握amb这把利器，是时候重构一下n-皇后问题了。\n(define number-between (lambda (lo hi) (let loop ((i lo)) (if (\u0026gt; i hi) (amb) (amb i (loop (+ i 1))))))) ; (amb 1 (amb 2 (amb 3 ... ))) (define (n-queens n) (call/cc (lambda (return) (let add-queen ([i 0] [result \u0026#39;()]) (when (\u0026lt; i n) ;最多摆几个皇后 (let ([new-queen (number-between 1 n)]) (if (safe? n (append (list new-queen) result)) ;新加入的皇后必须是有效的 (add-queen (+ i 1) (append (list new-queen) result)) (amb)) ) ) (return result) ) ) ) ) (bag-of (n-queens 8)) ;8个皇后的所有解 该版本比之前的Scheme版本的实现改进了很多，现在只需要描述一下我的问题的关系即可，程序会自动选择所有正确的值，无需关心计算机内部到底发生了什么。在面对很多逻辑问题时，我们可以很轻松地解决了。\n也许有人会问，如果采用命令式语言来处理的话，可能几个嵌套的循环也能达到相同的结果，如此大费周章的介绍这个叫amb的技术，到底有什么价值呢？ 那就来聊一聊。\n有什么意义？ 在谈论意义之前，容许我提一个问题\n 为什么SQL语言要设计成这样？与命令式语言如此的不同？\n 首先需要明确的一点是，计算机科学处理的是命令式（怎样做）的知识，而数学处理的是说明式（是什么）的知识。 事实上，人类不可能只面临其中一种问题，程序设计中一个重要的分支就是逻辑程序设计，有很多问题或者数据之间存在着关联关系，难以观测到结论，描述它们的关系很简单，但是直接告诉计算机如何去做却不那么容易，或许我们可以为若干此类问题编写命令式代码，但是不可能对所有这样的问题都编写代码，显然信息之间的关系是多种多样的，那么代码就需要相应的变化，往往修改这样的代码是很困难的， 甚至需要重新设计并编码。另一方面，如果程序设计可以处理说明式的知识，岂不是大大减轻了程序员的工作了呢？函数式语言的设计是基于lambda理论，围绕着数学函数值的计算组织起来的，依靠其强大的表现力，在处理逻辑问题上更加得心应手，可以化繁为简。\n说到这里，是不是觉得，保存在数据库中的数据之间存在着种种联系呢？SQL正是描述了这种关系，我们只需要告诉数据库我们需要什么数据（select）, 数据在什么位置（from）, 哪些是有意义的（where）就行了，并不需要告诉数据库该如何具体操作，数据库可以根据我们的描述（SQL）就能够准确的返回结果，这真是关于非确定性计算的一个极好的例子，此时我们总该明白为什么数据库叫做关系型数据库 了吧。我们不妨设想一下，如果不采用描述的方式来查询数据，程序员们该怎么做？还能够轻易的查找到需要的数据吗？\n刚才我提出的问题，想必此刻应该有答案了。\n","id":38,"section":"posts","summary":"讲故事并不是我擅长的事情，不过事情总有一个开始，诸位看官莫嫌我絮烦，只是希望可以讲述的更有条理一些。某日正读一本关于Erlang的书，书中出","tags":["scheme"],"title":"从“八皇后”到amb","uri":"https://lvsq.net/2020/05/n-queens/","year":"2020"},{"content":"作者是 Francesco Cesarini \u0026amp; Gabor Olah\n 任何编程语言在Erlang生态系统中的成功都可以分为三个紧密耦合的组件。它们是：1）Erlang编程语言的语义，并在其上实现其他语言2）用于构建可伸缩和弹性并发系统的OTP库和中间件，以及3）与语言语义紧密耦合的BEAM虚拟机和OTP。单独使用这些组件中的任何一个，您将获得亚军。但是，将这三个因素放在一起，您将获得可伸缩，灵活的软实时系统的无可争议的赢家。引用Joe Armstrong的话：“您可以复制Erlang库，但是如果它不能在BEAM上运行，则无法模拟语义”。这是由罗伯特·维尔丁（Robert Virding）的《第一条编程规则》强制执行的，该条规定：“任何另一种足够复杂的并发程序都使用另一种语言，包含非正式的，临时指定的，bug缠身的缓慢的Erlang一半实现。”\n在本文中，我们想探索BEAM VM内部。我们将在适用的情况下将它们与JVM进行比较和对比，强调您为什么要注意它们并加以注意。长期以来，此组件一直被视为黑匣子，并且在不了解原因或含义的情况下被视为理所当然。现在该改变这种情况了！\nBEAM的亮点 发明Erlang和BEAM VM是解决特定问题的正确工具。它们是由爱立信开发的，旨在帮助实现处理移动和固定网络的电信基础设施。该基础架构本质上是高度并发和可伸缩的。它必须显示软实时属性，并且永远不会失败。我们不希望在手机上与祖母进行环聊通话时掉线或Fortnite的在线游戏体验不会受到系统升级，高用户负载或软件，硬件和网络中断的影响。BEAM VM通过提供可在可预测的并发编程模型之上运行的微调功能进行了优化，以解决许多挑战。\n它的秘诀是轻量级进程，它们不共享内存，由调度程序管理，该调度程序可以跨多个内核管理数百万个进程。它使用基于每个进程运行的垃圾收集器，并对其进行了高度优化以减少对其他进程的影响。结果，垃圾收集器不会影响系统的整体软实时属性。BEAM也是唯一使用规模广泛且具有内置分发模型的VM，它具有内置的分发模型，该模型允许程序透明地在多台计算机上运行。\nJVM的亮点 Java虚拟机（JVM）是​​由Sun Microsystem开发的，旨在提供一个可在任何地方运行的“一次写入”代码的平台。他们创建了一种类似于C++的面向对象的语言，但是内存安全，因为其运行时错误检测会检查数组范围和指针取消引用。在Internet时代，JVM生态系统变得非常流行，使其成为企业服务器应用程序的实际标准。满足广泛用例的虚拟机和可满足企业发展需求的令人印象深刻的库集使广泛的适用性成为可能。\nJVM设计时考虑了效率。它的大多数概念是流行操作系统中功能的抽象，例如映射到操作系统线程的线程模型。JVM是高度可定制的，包括垃圾收集器（GC）和类加载器。一些最先进的GC实现提供高度可调整的功能，以适应基于共享内存的编程模型。JVM允许您在程序运行时更改代码。而且，JIT编译器允许将字节码编译为本机代码，目的是加快应用程序的各个部分。\nJava世界中的并发性主要与在并行线程中运行应用程序有关，以确保它们是快速的。由于并发原语的共享内存模型带来了挑战，因此使用并发原语进行编程是一项艰巨的任务。为了克服这些困难，人们尝试简化和统一并发编程模型，最成功的尝试是Akka框架。\n并发与并行 如果部分代码在多个内核，处理器或计算机上同时运行，则我们谈论并行代码执行，而并发编程是指独立处理到达系统的事件。可以在单线程硬件上模拟并发执行，而并行执行则不能。尽管这种区别似乎很古怪，但这种差异导致需要解决的问题非常不同。想想很多厨师在做一盘Carbonara意大利面。在并行方法中，将任务分配给可用厨师的数量，并且只要完成这些厨师完成其特定任务的速度，就可以完成单个部分。在一个并发的世界中，每位厨师将获得一部分，每位厨师将完成所有任务。您将并行性用于速度，并发性用于规模。\n并行执行试图将问题的最佳分解解决为彼此独立的部分。将水煮沸，煮意大利面，混合鸡蛋，炸瓜里阿塞火腿，将佩克立诺奶酪磨碎1。共享数据（或在我们的示例中为餐盘）由锁，互斥锁和各种其他技术处理，以确保正确性。另一种看待这种情况的方式是存在数据（或成分），并且我们希望利用尽可能多的并行CPU资源来尽快完成工作。\n另一方面，并​​发编程处理许多事件，这些事件在不同的时间到达系统，并尝试在合理的时间内处理所有事件。在多核或分布式体系结构上，某些执行是并行运行的，但这不是必需的。另一种看待它的方法是，同一位厨师按照始终相同的顺序算法，将水煮沸，煮意大利面，混合鸡蛋等。跨过程（或做饭）的变化是要处理的数据（或成分），这些数据（或成分）存在于多个实例中。\nJVM是为并行而构建的，而BEAM是为并发构建的。它们是两个本质上不同的问题，需要不同的解决方案。\nBEAM和并发 BEAM提供轻量级流程为正在运行的代码提供上下文。这些进程也称为actor，不共享内存，而是通过消息传递进行通信，将数据从一个进程复制到另一个进程。消息传递是虚拟机通过各个进程拥有的邮箱实现的功能。消息传递是一种非阻塞操作，这意味着将消息发送到另一个进程几乎是即时的，并且不会阻塞发送者的执行。发送的消息采用不可变数据的形式，从发送过程的堆栈复制到接收者的邮箱。无需在进程之间使用锁和互斥锁即可实现此目的，而在多个进程并行将消息发送到同一收件人的情况下，只需对邮箱进行锁定即可。\n不变的数据和消息传递使程序员能够编写彼此独立工作的流程，并专注于功能而不是内存的低级管理和任务调度。事实证明，这种简单的设计不仅适用于单个线程，而且适用于在同一VM中运行的本地计算机上的多个线程，并使用内置的分发，在整个网络上通过VM和计算机集群运行。如果消息在进程之间是不可变的，则可以不加锁地将它们发送到另一个线程（或计算机），从而在分布式多核体系结构上几乎线性地扩展。进程在本地VM上的寻址方式与VM群集中的寻址方式相同，无论接收进程的位置如何，消息发送都是透明的。\n进程不共享内存，因此您可以复制数据以恢复弹性并分发数据以实现规模扩展。这意味着在两个不同的机器上具有相同进程的两个实例，彼此之间共享状态更新。如果一台计算机发生故障，则另一台计算机具有数据副本，并且可以继续处理该请求，从而使系统具有容错能力。如果两台计算机都可运行，则两个进程都可以处理请求，从而为您提供可伸缩性。BEAM为所有这些无缝集成提供了高度优化的原语，而OTP（“标准库”）则提供了更高级别的结构以简化程序员的生活。\nAkka在复制更高级别的结构方面做得很好，但是由于缺少JVM提供的原语而在一定程度上受到了限制，从而使其可以高度优化并发性。尽管JVM的原语支持更广泛的用例，但由于它们没有用于通信的内置原语且通常基于共享内存模型，因此它们使对分布式系统的编程变得更加困难。例如，您在分布式系统中的何处放置共享内存？以及访问它的成本是多少？\n调度器 我们提到过，BEAM的最强功能之一就是能够将程序分解为小的，轻量级的过程。管理这些过程是调度程序的任务。与JVM将其线程映射到OS线程并让操作系统调度它们不同，BEAM带有自己的调度程序。\n默认情况下，调度程序为每个内核启动一个OS线程，并优化它们之间的工作负载。每个过程都包含要执行的代码和随时间变化的状态。调度程序会选择运行队列中准备运行的第一个进程，并为其赋予定量的reductions（译者注：2000个），其中每次reduction都大致等同于一条指令。一旦进程用尽了reductions，会被I/O阻塞，等待消息或代码完成，调度程序就会在运行队列中选择下一个进程并将其分派（此句翻译有问题：原文是Once the process has either run out of reductions, is blocked by I/O, is waiting for a message or completes executing its code, the scheduler picks the next process in the run queue and dispatches it. 如果您有更好的翻译请不吝指教）。这种调度技术称为抢先式。\n我们多次提到Akka框架，因为它的最大缺点是需要在调度处添加注解，因为调度不是在JVM级别进行的。通过解除程序员的控制，可以保留和保证软实时属性，从而减低了导致进程饿死的风险。\n进程围绕着调度程序线程，并最大程度地利用CPU。有许多方法可以调整调度程序，但是它很少见，仅在边缘和边界情况下才需要，因为默认选项涵盖了大多数使用模式。\n关于调度程序，经常出现一个敏感的话题：如何处理本机实现的函数（NIF）。NIF是用C编写的代码片段，被编译为库并在与BEAM相同的内存空间中运行以提高速度。NIF的问题在于它们不是抢占式的，并且会影响调度程序。在最新的BEAM版本中，添加了一项新功能，即脏调度程序，以更好地控制NIF。肮脏的调度程序是在不同线程中运行的单独的调度程序，以最大程度地减少NIF对系统造成的中断。脏这个词是指这些调度程序运行的代码的性质。\n垃圾收集器 当今，现代的高级编程语言大多使用垃圾回收器进行内存管理。BEAM语言也不例外。当您要编写高级并发代码时，信任虚拟机来处理资源和管理内存非常方便，因为这可以简化任务。归功于基于不可变状态的内存模型，垃圾收集器的基础实现非常简单有效。数据被复制而不是突变，并且进程不共享内存这一事实消除了任何进程的相互依赖关系，因此不需要管理它们。\nBEAM的另一个功能是，仅在需要时才在每个进程的基础上运行垃圾回收，而不会影响在运行队列中等待的其他进程。结果，Erlang中的垃圾收集不会“stop-the-world”。它可以防止处理延迟高峰，因为VM不会从整体上停止——仅特定进程停止，并且绝不会同时停止所有进程。实际上，这只是流程的一部分，并且被视为另一种reduction。垃圾收集器收集过程将过程暂停很短的时间间隔，通常是微秒。代价是，将有许多小的爆发（bursts），仅在进程需要更多内存时才触发。单个进程通常不会分配大量内存，并且通常是短暂的，通过在终止时立即释放所有分配的内存，进一步降低了影响。JVM的一个功能是具备切换垃圾收集器的能力，因此，通过使用商用GC，还可以在JVM中实现不间断的GC。\nLukas Larsson在一篇出色的博客文章中讨论了垃圾收集器的功能。有许多复杂的细节，但已对其进行了优化以有效地处理不可变数据，并为每个进程在堆栈和堆之间分配了数据。最好的方法是在短暂的过程中完成大部分工作。\n这个主题上经常出现的一个问题是BEAM使用多少内存。虚拟机在后台分配了大块内存，并使用自定义分配器来有效地存储数据并最大程度地减少系统调用的开销。这有两个明显的效果：1）在不需要空间之后，已用内存逐渐减少2）重新分配大量数据可能意味着将当前工作内存加倍。如果确实需要，可以通过调整分配器策略来减轻第一个影响。如果您可以看到不同类型的内存使用情况，则第二个易于监视和计划。（WombatOAM就是这样一种提供开箱即用的系统指标的监视工具。）\n热代码加载 热代码加载可能是BEAM引用最多的独特功能。热代码加载意味着可以通过更改系统中的可运行代码来更新应用程序逻辑，同时保留内部流程状态。这是通过替换已加载的BEAM文件并指示VM替换正在运行的进程中的代码引用来实现的。\n对于电信基础架构无需停机代码升级而言，这是一项至关重要的功能，被裁减的硬件可用于处理高峰。如今，在容器化时代，其他技术也可以实现产线的更新。从未使用过它的人会认为它是不重要的功能，但是在开发工作流程中仍然有用。开发人员可以通过替换部分代码来加快迭代速度，而不必重新启动系统来对其进行测试。即使该应用程序并非设计为可在生产环境中进行升级，也可以减少重新编译和重新部署所需的时间。\n何时不使用BEAM 正确的工具非常重要。您需要一个速度极快的系统，但不关心并发性吗？并行处理一些事件，并且必须快速处理它们？是否需要计算图形，人工智能或分析数据？沿C ++，Python或Java路线走。电信基础设施不需要快速运行，因此速度从来都不是优先事项。在动态类型的辅助下，它必须在运行时进行所有类型检查，这意味着编译器时间优化并不那么简单。因此，数字运算最好留给JVM，Go或其他编译成本地语言的语言使用。毫不奇怪，在JVM上运行的Erlang版本Erjang上的浮点运算比BEAM快5000％。但是我们看到BEAM大放异彩的地方是利用它的并发来安排数字运算，将分析外包给C，Julia，Python或Rust。您可以在BEAM外部做map，而在BEAM内部做reduce(译者注：map-reduce思想)。\n口头禅总是很快。人类感知刺激（事件）并在大脑中进行处理需要几百毫秒，这意味着对于许多应用而言，微秒或纳秒的响应时间并不是必需的。您也不会将BEAM用于微控制器，这太浪费资源了。但是对于具有更多处理能力的嵌入式系统（多核已成为常态），您需要并发性，而BEAM令人眼前一亮。上世纪90年代，我们实现了电话交换机，以处理运行在具有16MB内存的嵌入式板上的成千上万的用户。RaspberryPi都有多少内存了？还有，硬实时系统，您可能不希望BEAM管理您的安全气囊控制系统。你需要硬保证 仅仅是硬实时操作系统，没有垃圾收集或异常的语言。在诸如GRiSP之类的裸机上运行的Erlang VM的实现将为您提供类似的保证。\n结论 使用正确的工具完成工作。如果您正在编写一个软实时系统，而该系统必须能够立即扩展并且永远不会失败，并且无需重新发明轮子就可以做到，那么BEAM是您正在寻找的经过验证的技术。对于许多人来说，它就像一个黑匣子。不知道它的工作原理类似于驾驶法拉利，无法获得最佳性能或无法理解奇怪声音来自马达的哪个部分。这就是为什么您应该更多地了解BEAM，了解其内部结构并准备对其进行微调和修复的原因。对于在实际任务中使用Erlang和Elixir的人（译者注：in anger 的意思是to do or use something in a real situation），我们开设了一天的讲师指导课程，该课程通俗易懂并解释您所看到的很多内容，同时为您准备大规模处理大规模并发做好准备。在这里了解更多。我们也推荐Erik Stenman撰写的关于BEAM的书和Dmytro Lytovchenko的文章集——BEAM Wisdoms。\n","id":39,"section":"posts","summary":"作者是 Francesco Cesarini \u0026amp; Gabor Olah 任何编程语言在Erlang生态系统中的成功都可以分为三个紧密耦合的组件。它们是：1）Erlang编程语言的语义，并在其上实现","tags":["erlang"],"title":"[译]BEAM vs JVM","uri":"https://lvsq.net/2020/05/beam-vs-jvm/","year":"2020"},{"content":"实现 下面将使用Scheme语言来实现“无重复字符的最长子串”，即，对于字符串\u0026quot;abbabcx\u0026quot;,其最长无重复字符的子串为\u0026quot;abcx\u0026quot;，长度4，详细描述可访问https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n(let* ( [s \u0026#34;abbabcx\u0026#34;] [arr-index 0] [ans 0] [d -1] [vec (make-vector 128 -1)] [keep-last-position (lambda (c pos-in-s) (vector-set! vec c pos-in-s))] [scan (lambda (c pos-in-s) (let* ([previous-pos (vector-ref vec c)] [len 0]) (begin (when (and (\u0026gt;= previous-pos 0) (\u0026gt; previous-pos d)) (set! d previous-pos) ) (set! len (- pos-in-s d)) (keep-last-position c pos-in-s) (when (\u0026gt; len ans) (set! ans len)) ) ) )] ) ( string-for-each (lambda (e) (scan (char-\u0026gt;integer e) arr-index) (set! arr-index (+ arr-index 1))) s ) ans ) 实现的思路为：\n由于字符可以有ASCII码表示，故可以用一个长度为128的向量vec来保存每个字符在给定的字符串中出现的最后一次的位置。维护一个变量d来记录最近一次出现重复的字符的起始位置。 如果：\n 判断某字符是否重复：1.1 某字符第一次出现，执行第2步1.2 某字符非第一次出现，如果该字符上次出现的位置，在d之后，则将d设置为该字符上次出现的位置。由于之前的最大长度已经由ans保存，所以只需要计算剩下的子串的长度能不能大于ans，这就是为什么d记录最近一次出现重复的字符串的起始位置就好了 计算当前位置和d的长度len 保存其位置到vec 如果len大于ans，改变ans为len  这种实现只需遍历一遍就可以计算出结果，性能非常棒。当然暴力计算或者滑动窗口也可以实现该功能，只是需要多次遍历，性能比不上。\n概要分析 上文说到性能问题，拿点数据出来证明一下吧。\n将上面的代码稍微改造一下，作为一个definition，并保存在longest_substr.ss文件中，\n(define longest-substr (lambda (str) (let* ( [s str] [arr-index 0] [ans 0] [d -1] [vec (make-vector 128 -1)] [keep-last-position (lambda (c pos-in-s) (vector-set! vec c pos-in-s))] [scan (lambda (c pos-in-s) (let* ([previous-pos (vector-ref vec c)] [len 0]) (begin (when (and (\u0026gt;= previous-pos 0) (\u0026gt; previous-pos d)) (set! d previous-pos) ) (set! len (- pos-in-s d)) (keep-last-position c pos-in-s) (when (\u0026gt; len ans) (set! ans len)) ) ) )] ) ( string-for-each (lambda (e) (scan (char-\u0026gt;integer e) arr-index) (set! arr-index (+ arr-index 1))) s ) ans ) ) ) Chez Scheme提供了一个概要分析工具，非常好用，来试用一下： 生成的html可以非常直观的看到该函数的执行情况 字符串越长，执行次数越多，执行时间是多少呢？选一个上面例子中最长的字符串来看看：\n\u0026gt; (time (longest-substr \u0026#34;abcabcxsfsdfw232sdfssdfsdfsdfsf1234567890\u0026#34;)) (time (longest-substr \u0026#34;abcabcxsfsdfw232sdfssdfsdfsdfsf1234567890\u0026#34;)) no collections 0.000003672s elapsed cpu time 0.000002000s elapsed real time 1792 bytes allocated 12 \u0026gt; 消耗的CPU时间0.000003672s，可以说非常短了，且分配的内存仅仅1792个字节。超乎寻常的性能，我想应该有两个方面原因：\n 算法 Scheme 和 Chez Scheme  ","id":40,"section":"posts","summary":"实现 下面将使用Scheme语言来实现“无重复字符的最长子串”，即，对于字符串\u0026quot;abbabcx\u0026quot;,其最长无重复字符的子串为","tags":["scheme"],"title":"无重复字符的最长子串-Scheme实现","uri":"https://lvsq.net/2020/03/longest-substr/","year":"2020"},{"content":"为什么要用Go练习函数式编程？简而言之，正是由于缺少状态和可变数据，函数式编程使您的代码更易读，更易于测试且不太复杂。如果遇到错误，只要不违反函数式编程规则，就可以快速调试应用程序。当函数被隔离时，您不必处理影响输出的隐藏状态的更改。\n软件工程师兼作者Eric Elliot定义了以下函数编程。\n 函数式编程是通过组合纯函数，避免共享状态，可变数据和副作用来构建软件的过程。函数式编程是声明性的，而不是命令性的，应用程序状态通过纯函数流动。与面向对象的编程相反，后者通常将应用程序状态与对象中的方法共享并放置在对象中。\n 我将更进一步：函数式编程（如面向对象和过程式编程）代表着范式的转变。它在编写代码时采用了独特的思维方式，并引入了一套全新的规则。\n4个重要概念 要完全掌握函数式编程，必须首先了解以下相关概念。\n 纯函数和幂等 副作用 函数构成 共享状态和不变数据  让我们快速回顾一下。\n纯函数和幂等 如果给纯函数提供相同的输入，则它总是会返回相同的输出。此属性也称为幂等。幂等意味着函数应始终返回相同的输出，而与调用次数无关。\n副作用 纯函数不能有任何副作用。换句话说，您的函数无法与外部环境进行交互。\n例如，函数式编程将API调用视为副作用。为什么？因为API调用被认为是不受您直接控制的外部环境。一个API可能有几个不一致的地方，例如超时或失败，或者甚至可能返回意外的值。它不适合纯函数的定义，因为每次调用API时都需要一致的结果。\n其他常见的副作用包括：\n 数据变化 DOM操作 请求有冲突的数据，例如当前时间time.Now()  函数构成 函数构成的基本思想很简单：将两个纯函数组合在一起以创建一个新函数。这意味着为相同输入产生相同输出的概念在这里仍然适用。因此，从简单的纯函数开始创建更高级的函数很重要。\n共享状态和不变数据 函数式编程的目的是创建不保持状态的函数。共享状态尤其会在纯函数中引入副作用或可变性问题，使它们变得不纯粹。\n但是，并非所有状态都不好。有时，必须有一个状态才能解决特定的软件问题。函数式编程的目的是使状态可见和显式，以消除任何副作用。程序使用不可变数据结构从纯函数中派生新数据。这样，就不需要可能引起副作用的可变数据。\n 现在我们已经涵盖了基础，让我们定义一些在Go中编写功能代码时要遵循的规则。\n功能编程规则 如前所述，函数式编程是一种范例。因此，很难为这种编程风格定义确切的规则。也不一定总是遵循这些规则。有时，您确实需要依赖拥有状态的功能。\n但是，为了尽可能严格地遵循函数式编程范例，我建议坚持以下准则。\n 没有可变数据以避免副作用 无状态（或者隐式状态，例如循环计数器） 给变量赋值后请勿修改 避免副作用，例如API调用  我们在函数式编程中经常遇到的一个好的“副作用”是强大的模块化。函数式编程不是自上而下地进行软件工程，而是鼓励自下而上的编程风格。首先定义模块，把将来可能使用的同类纯函数组合起来。接下来，开始编写那些小的，无状态的独立函数，以创建您的第一个模块。\n实质上我们是在创建黑匣子。稍后，我们将按照自下而上的方式将各个块捆绑在一起。这使您可以建立强大的测试基础，尤其是可以验证纯函数正确性的单元测试。\n一旦您可以信任您的模块，就可以将模块捆绑在一起了。开发过程中的这一步还涉及编写集成测试，以确保两个组件的正确集成。\n5个示例 为了更全面地描述Go函数编程的工作原理，让我们探索五个基本示例。\n 更新字符串  这是纯函数的最简单示例。通常，当您要更新字符串时，请执行以下操作。\nname：= \u0026#34;first name\u0026#34; name：= name + \u0026#34;last name\u0026#34; 上面的代码片段不符合函数式编程的规则，因为不能在函数内修改变量。因此，我们应该重写代码段，以便每个值都具有自己的变量。\n下面的代码段中的代码更具可读性。\nfirstname := \u0026#34;first\u0026#34; lastname := \u0026#34;last\u0026#34; fullname := firstname + \u0026#34; \u0026#34; + lastname 在查看非函数式代码段时，我们必须浏览程序以确定最新状态，才可以找到name变量的结果值。这需要更多的精力和时间来了解该功能的作用。\n避免更新数组  如前所述，函数式编程的目的是使用不变数据通过纯函数得出新的不变数据状态。我们可以在每次需要更新数组时创建一个新数组来实现\n在非函数式编程中，更新数组如下：\nnames := [3]string{\u0026#34;Tom\u0026#34;, \u0026#34;Ben\u0026#34;} // Add Lucas to the array \tnames[2] = \u0026#34;Lucas\u0026#34; 让我们根据功能编程范例进行尝试。\nnames := []string{\u0026#34;Tom\u0026#34;, \u0026#34;Ben\u0026#34;} allNames := append(names, \u0026#34;Lucas\u0026#34;) 避免更新map  这是函数编程的极端示例。想象一下，我们有一个带有字符串类型的键和整数类型的值的map。该map包含我们仍然留在家中的水果数量。但是，我们刚购买了苹果，并希望将其添加到列表中。\nfruits := map[string]int{\u0026#34;bananas\u0026#34;: 11} // Buy five apples \tfruits[\u0026#34;apples\u0026#34;] = 5 我们可以在功能编程范例下完成相同的功能。\nfruits := map[string]int{\u0026#34;bananas\u0026#34;: 11} newFruits := map[string]int{\u0026#34;apples\u0026#34;: 5} allFruits := make(map[string]int, len(fruits) + len(newFruits)) for k, v := range fruits { allFruits[k] = v } for k, v := range newFruits { allFruits[k] = v } 由于我们不想修改原始map，因此代码会遍历两个map，并将值添加到新map。这样，数据保持不变。\n正如您可能通过代码的长度可以看出的那样，此代码段的性能比对map进行简单的可变更新要差得多，因为我们要遍历两个map。这是您为代码性能交换更好的代码质量的时间。\n高阶函数和柯里化  大多数程序员在他们的代码中通常不会使用高阶函数，但是在函数式编程中柯里化很方便。\n假设我们有一个简单的函数，将两个整数相加。尽管这已经是一个纯粹的功能，但我们希望详细说明该示例，以展示如何通过curring创建更高级的功能。\n在这种情况下，我们只能接受一个参数。接下来，该函数返回另一个函数作为闭包。因为该函数返回一个闭包，所以它将记住外部范围，该范围包含初始输入参数。\nfunc add （x int）func （y int）int { return func（y int）int { return x + y } } 现在，让我们尝试currying并创建更多高级纯函数。\nfunc main() { // Create more variations \tadd10 := add(10) add20 := add(20) // Currying \tfmt.Println(add10(1)) // 11 \tfmt.Println(add20(1)) // 21 } 这种方法在函数式编程中很常见，尽管您通常不会在范式之外看到它。\n递归  递归是一种通常用于规避循环使用的软件模式。因为循环始终保持内部状态以明确循环在哪一轮，所以我们不能在函数式编程范式下使用循环。\n例如，下面的代码片段尝试计算数字的阶乘。阶乘是一个整数与其下所有整数的乘积。因此，阶乘4等于24（= 4 * 3 * 2 * 1）。\n通常，您将为此使用循环。\nfunc factorial(fac int) int { result := 1 for ; fac \u0026gt; 0; fac-- { result *= fac } return result } 为了在函数式编程范例中完成此任务，我们需要使用递归。换句话说，我们将一遍又一遍地调用相同的函数，直到达到阶乘的最低整数为止。\nfunc calculateFactorial(fac int) int { if fac == 0 { return 1 } return fac * calculateFactorial(fac - 1) } 结论 让我们总结一下我们从函数式编程中学到的知识：\n 尽管Golang支持函数式编程，但它并非为此目的而设计的，如缺少Map，Filter和Reduce函数。 函数式编程提高了代码的可读性，因为函数是纯粹的，因此易于理解 纯函数更易于测试，因为没有内部状态会改变输出  原文在此: https://blog.logrocket.com/functional-programming-in-go/\n","id":41,"section":"posts","summary":"为什么要用Go练习函数式编程？简而言之，正是由于缺少状态和可变数据，函数式编程使您的代码更易读，更易于测试且不太复杂。如果遇到错误，只要不违","tags":["functional"],"title":"使用Golang进行函数式编程","uri":"https://lvsq.net/2020/03/fp-in-go/","year":"2020"},{"content":"闲来无事，用Scheme实现一个FIFO队列，数据从末端插入，从前端删除或者查询。\n队列可以看成是由下面一组操作定义的结构：\n 构造函数  (make-queue)返回一个空队列\n 选择函数  (empty-queue? \u0026lt;queue\u0026gt; )检查队列是否为空(front-queue \u0026lt;queue\u0026gt; )返回最早进入队列的数据，其不会修改队列(length-queue \u0026lt;queue\u0026gt; )返回队列长度\n 改变函数  (insert-queue! \u0026lt;queue\u0026gt; \u0026lt;item\u0026gt; )将数据插入末端(delete-queue! \u0026lt;queue\u0026gt; )删除列头的数据\n 打印函数  (print-queue \u0026lt;queue\u0026gt;)\n(module FIFO-QUEUE (make-queue empty-queue? front-queue insert-queue! delete-queue! length-queue print-queue) (define front-ptr (lambda (q) (caar q))) (define set-front-ptr! (lambda (q item) (set-car! (car q) item))) (define rear-ptr (lambda (q) (cdar q))) (define set-rear-ptr! (lambda (q item) (set-cdr! (car q) item))) (define make-queue (lambda () (cons (cons \u0026#39;() \u0026#39;()) 0))) (define empty-queue? (lambda (q) (null? (front-ptr q)))) (define front-queue (lambda (q) (if (empty-queue? q) (error \u0026#34;FRONT called with an empty queue\u0026#34; q) (car (front-ptr q))))) (define (insert-queue! q item) (let ((new-pair (cons item \u0026#39;()))) (if (empty-queue? q) (begin (set-front-ptr! q new-pair) (set-rear-ptr! q new-pair) (set-cdr! q (+ 1 (cdr q))) q) (begin (set-cdr! (rear-ptr q) new-pair) (set-rear-ptr! q new-pair) (set-cdr! q ( + 1 (cdr q))) q) ) ) ) (define delete-queue! (lambda (q) (if (empty-queue? q) (error \u0026#34;DELETE! called with an empty queue\u0026#34; q) (begin (set-front-ptr! q (cdr (front-ptr q))) (set-cdr! q (- (cdr q) 1)) q) ) ) ) (define length-queue (lambda (q) (cdr q))) (define print-queue (lambda (q) (if (empty-queue? q) \u0026#39;() (front-ptr q)) )) ) 前4个过程是用于内部的帮助函数，队列维护两个指针，一个指向列头（front-ptr）,一个指向列尾（rear-ptr），这样可以弥补原生的set-car!和set-cdr!的不足。\n\u0026gt; (load \u0026#34;/path/to/FIFO-QUEUE.scm\u0026#34;) ;;加载FIFO-QUEUE模块 \u0026gt; (import FIFO-QUEUE) \u0026gt; (define q (make-queue)) \u0026gt; (insert-queue! q 1) ;; (((1) 1) . 1), 最后一个数字1表示队列长度, 在队列有删除或者插入时，及时修改该值，为了在取队列长度时减小开销，否则要遍历一次才行 \u0026gt; (insert-queue! q 2) ;; (((1 2) 2) . 2) \u0026gt; (insert-queue! q 3) ;; (((1 2 3) 3) . 3) \u0026gt; (insert-queue! q 4) ;; (((1 2 3 4) 4) . 4) \u0026gt; (delete-queue! q) ;; (((2 3 4) 4) . 3) \u0026gt; (delete-queue! q) ;; (((3 4) 4) . 2) \u0026gt; (front-queue q) ;; 3 \u0026gt; (length-queue q) ;; 2 ","id":42,"section":"posts","summary":"闲来无事，用Scheme实现一个FIFO队列，数据从末端插入，从前端删除或者查询。 队列可以看成是由下面一组操作定义的结构： 构造函数 (make","tags":["scheme"],"title":"Scheme实现一个FIFO队列","uri":"https://lvsq.net/2020/03/fifo-queue/","year":"2020"},{"content":"本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可能使用Scheme标准机制。\nHash Tables 略过。应使用标准hash table.\nExtend-Syntax Macros 本节介绍了extend-syntax，它是一种功能强大但易于使用的基于模式匹配的语法扩展工具。 使用extend-syntax编写的语法转换与使用define-syntax和syntax-case编写的语法转换相似，不同之处在于extend-syntax产生的转换不会自动遵循词法作用域。\n通常不可能将使用syntax-case编写的语法抽象与使用extend-syntax编写的语法抽象无缝地混合在一起。 通常尽可能只使用其中一种。 仅在迁移到syntax-case时提供了对syntax-case扩展器中extend-syntax的支持。\n (extend-syntax (name key \u0026hellip;) (pat fender template) \u0026hellip;)\n 标识符name 是要定义的句法扩展名或语法关键字。 当系统扩展器处理car为name 的任何list表达式时，将在该表达式上调用extend-syntax生成的语法转换过程。 其余的标识符key \u0026hellip; 是在扩展过程中要在输入表达式中识别的其他关键字（例如cond中的else或case）。\nkey列表之后的每个子句都包含一个模式pat ，一个可选的fender 和一个template 。 可选的fender 经常被省略。pat 指定了语法，用于匹配子句。模式中不是关键字（模式变量）的标识符绑定到输入表达式的相应部分。fender 如果存在，则是Scheme表达式，它指定输入表达式（通过模式变量访问）上的附加约束，必须选择这些约束才能选择子句。template 通常根据模式变量来指定输出采用什么形式。\n在扩展过程中，转换过程extend-syntax会尝试以给定的子句的顺序将输入表达式与每个模式进行匹配。如果输入表达式匹配了某个模式，则将模式变量绑定到输入表达式的相应部分，并对子句的fender （如果有）进行求值。如果fender 返回一个真值，则执行给定的扩展。 如果输入与模式不匹配，或者fender 返回错误值，则转换过程将尝试下一个子句。如果无法选择任何子句，则会引发条件类型**＆assertion**的异常。\n在模式内，省略号（\u0026hellip;）可用于指定零个或多个出现的前面的模式片段或原型。类似地，可以在输出中使用省略号来指定零个或多个扩展原型的结构。在这种情况下，扩展原型必须包含输入模式原型的一部分。\n第一个例子，定义了rec, 使用单个关键字，一个子句，且没有fender和省略号\n(extend-syntax (rec) [(rec id val) (let ([id #f]) (set! id val) id)]) 第二个例子，定义了when，展示了如何使用省略号\n(extend-syntax (when) [(when test exp1 exp2 ...) (if test (begin exp1 exp2 ...) #f)]) 下一个示例显示let的定义。 let的定义显示了多个省略号的使用，其中一个用于标识符/值序对，另一个用于body中的表达式。它还表明原型不必是单个标识符，并且在template中可以将原型的各个部分彼此分开。\n(extend-syntax (let) [(let ([x e] ...) b1 b2 ...) ((lambda (x ...) b1 b2 ...) e ...)]) 下一个示例显示let*，其语法与let相同，但是根据let以两个子句（一个用于基本情况，一个用于递归步骤）递归定义，因为它必须产生一个嵌套结构。\n(extend-syntax (let*) [(let* () b1 b2 ...) (let () b1 b2 ...)] [(let* ([x e] more ...) b1 b2 ...) (let ([x e]) (let* (more ...) b1 b2 ...))]) 定义式and需要3个子句。第一个子句对于识别**(and)**是必要的，后两个以递归方式定义所有其他**and**形式。\n(extend-syntax (and) [(and) #t] [(and x) x] [(and x y ...) (if x (and y ...) #f)]) cond的定义需要四个子句。 与let*一样，必须对cond进行递归描述，部分原因是它会产生嵌套的if表达式，部分原因是一个省略号原型不足以描述所有可能的cond子句。 cond的定义还要求除cond之外，我们还指定else作为关键字。 这是定义：\n(extend-syntax (cond else) [(cond) #f] [(cond (else e1 e2 ...)) (begin e1 e2 ...)] [(cond (test) more ...) (or test (cond more ...))] [(cond (test e1 e2 ...) more ...) (if test (begin e1 e2 ...) (cond more ...))]) 为了使let的语法绝对正确，我们实际上必须要求输入中的绑定标识符是符号。 如果我们输入类似**（let（[3 x]）x）**的内容，则不会从**let**中得到错误，因为它不会检查验证标识符位置中的对象是否为符号。 相反，lambda可能会抱怨，或者可能是扩展完成很久之后的求值程序。 这是*fenders* 起作用的地方。\n(extend-syntax (let) [(let ([x e] ...) b1 b2 ...) (andmap symbol? \u0026#39;(x ...)) ((lambda (x ...) b1 b2 ...) e ...)]) '（x \u0026hellip;）上的symbol?的andmap确保每个绑定标识符都是一个符号。 fender 仅仅是Scheme表达式。 在该表达式中，首先使用与子句的template 部分相同的规则来扩展引用的对象。 在这种情况下，将**'（x \u0026hellip;）**扩展到标识符/值对中的标识符列表。\nextend-syntax通常可以处理您的一切需求，但是某些语法扩展定义要求能够包含对任意Scheme表达式求值的结果。 该功能由with提供。\n (with ((pat expr) \u0026hellip;) template)\n with仅在extend-syntax内部的template 内有效。 with模式与extend-syntax模式相同，with表达式与extend-syntax的fenders 相同，with模板与extend-syntax模板相同。\nwith可用于引入新的模式标识符，该标识符绑定到extend-syntax模板中的任意Scheme表达式所生成的表达式。 也就是说，with允许从extend-syntax的声明式样式转为full Scheme的过程式样式。\nwith的一种常见用法是在模板中引入临时标识符或临时标识符列表。 如果在extend-syntax框架内执行，with也可用于执行可能笨拙或效率低下的复杂转换。\n例如，or需要使用临时标识符。 我们可以如下定义or：\n(extend-syntax (or) [(or) #f] [(or x) x] [(or x y ...) (let ([temp x]) (if temp temp (or y ...)))]) 这会一直有效，直到将or表达式放置在temp发生的范围内为止，在这种情况下，可能会发生奇怪的事情，因为extend-syntax不尊重词法作用域。 （这是define-syntax优于extend-syntax的原因之一。）\n(let ([temp #t]) (or #f temp)) ⇒ #f  如果将标识符temp换个名字，则一切正常。就可以理解\u0026quot;extend-syntax不尊重词法作用域\u0026quot;这句话了。 实际上，上述的(let \u0026hellip;)表达式，展开之后就变成了：\n (let ([temp #t]) (let ([temp #f]) (if temp temp (or temp)) ) ) 一种解决方案是，使用gensym和with来创建临时标识符，如下：\n(extend-syntax (or) [(or) #f] [(or x) x] [(or x y ...) (with ([temp (gensym)]) (let ([temp x]) (if temp temp (or y ...))))]) 而且，with可以以extend-syntax无法直接使用的方式来组合输入模式的元素，例如以下folding-plus示例:\n(extend-syntax (folding-plus) [(folding-plus x y) (and (number? \u0026#39;x) (number? \u0026#39;y)) (with ([val (+ \u0026#39;x \u0026#39;y)]) val)] [(folding-plus x y) (+ x y)]) 如果x和y均为数字常数，则folding-plus折叠为（+ x y）的值。 否则，folding-plus转换为（+ x y）以供以后评估。 fender在扩展时检查操作数是否为数字，并使用with进行求值。 与fender一样，扩展仅在带引号的表达式内执行，因为quote将数据与Scheme表达式的其余部分区分开。\n下面的示例利用with允许我们将模式绑定到表达式这一事实，将模式变量列表绑定到临时符号列表。 此临时列表帮助我们实现sigma语法扩展。 sigma与lambda相似，除了它在标识符列表中分配标识符而不是创建新绑定之外。 它可用于并行执行一系列分配。\n(extend-syntax (sigma) [(sigma (x ...) e1 e2 ...) (with ([(t ...) (map (lambda (x) (gensym)) \u0026#39;(x ...))]) (lambda (t ...) (set! x t) ... e1 e2 ...))]) (let ([x \u0026#39;a] [y \u0026#39;b]) ((sigma (x y) (list x y)) y x)) ⇒ (b a) 结构体 本节介绍一种机制，类似于第7.15节的record定义机制，该机制允许使用固定的命名字段集创建数据结构。 与record类型不同，结构体类型不是唯一类型，而是实现为向量。 具体而言，将结构体实现为向量，其长度比字段数大一倍，并且其第一个元素包含该结构体的符号名称。\n将结构体表示为向量可以在某种程度上简化结构体的读取和打印以及结构体定义工具的扩展。但是，它确实有一些缺点。 一个是在不适当的情况下，结构体可能会被错误地视为普通向量。当在程序中处理结构体和向量时，在检查更通用的向量类型之前，必须注意先寻找更具体的结构体类型，例如在一系列cond子句中。一个类似的缺点是，结构体实例容易被有意或无意地“伪造”。 也不可能控制如何打印和读取结构体。\n通过define-structure创建结构体。 每个结构体定义式都定义一个构造过程，一个类型谓词，每个字段的访问过程以及每个字段的分配过程。define-structure允许程序员控制哪些字段是构造函数过程的参数，以及哪些字段由构造函数过程显式初始化。define-structure非常简单，但对于大多数应用程序来说足够强大，如果还不足以应付应用程序的需求还可以很容易的扩展以满足之。 本节末尾给出的define-structure定义可以作为更复杂变体的起点。\n (define-structure (name id1 \u0026hellip;) ((id2 expr) \u0026hellip;))\n define-structure形式可以出现在任意位置。\ndefine-structure定义一个新的数据结构name ，并创建一组用于构造和操作该结构实例的过程。 标识符id1 \u0026hellip; 和id2 \u0026hellip; 命名数据结构的字段。\n下面的过程都有define-structure定义：\n 名为**make-**name 的构造过程 名为name? 的类型谓词 对于每一个字段id1 \u0026hellip; 和id2 \u0026hellip; ，都有名为name-field 的访问过程 对于每一个字段id1 \u0026hellip; 和id2 \u0026hellip; ，都有名为**set-**name-field! 的分配过程  标识符id1 \u0026hellip; 命名的字段由构造函数的参数初始化。 由标识符id2 \u0026hellip; 命名的字段被显式初始化为表达式expr \u0026hellip; 的值。每个表达式都在标识符id1 \u0026hellip; （绑定到相应的字段值）的范围内进行求值，并且在标识符id2 \u0026hellip; （绑定到相应的字段值）的范围内出现（类似let*） 。\n为了清晰起见，构造函数的行为就像定义为：\n(define make-name (lambda (id1 ...) (let* ([id2 expr ] ...) body ))) 其中body 根据标识符id1 \u0026hellip; 和id2 \u0026hellip; 的值构建结构体。\n如果不需要除构造函数过程的参数初始化的字段以外的其他字段，则可以省略第二个子表达式*( (id2 expr) \u0026hellip;)* 。\n以下简单示例演示了如何在Scheme中定义pair（如果它们不存在的话）。 这两个字段都由构造函数过程的参数初始化。\n(define-structure (pare car cdr)) (define p (make-pare ’a ’b)) (pare? p) ⇒ #t (pair? p) ⇒ #f (pare? ’(a . b)) ⇒ #f (pare-car p) ⇒ a (pare-cdr p) ⇒ b (set-pare-cdr! p (make-pare \u0026#39;b \u0026#39;c)) (pare-car (pare-cdr p)) ⇒ b (pare-cdr (pare-cdr p)) ⇒ c 以下示例定义了一个方便的字符串数据结构，称为strext-string ，该结构会根据需要增长。本例子中，会显式地初始化一个字段的值，该字段在构造函数中定义。\n(define-structure (stretch-string length fill) ([string (make-string length fill)])) (define stretch-string-ref (lambda (s i) (let ([n (stretch-string-length s)]) (when (\u0026gt;= i n) (stretch-stretch-string! s (+ i 1) n)) (string-ref (stretch-string-string s) i)))) (define stretch-string-set! (lambda (s i c) (let ([n (stretch-string-length s)]) (when (\u0026gt;= i n) (stretch-stretch-string! s (+ i 1) n)) (string-set! (stretch-string-string s) i c)))) (define stretch-string-fill! (lambda (s c) (string-fill! (stretch-string-string s) c) (set-stretch-string-fill! s c))) (define stretch-stretch-string! (lambda (s i n) (set-stretch-string-length! s i) (let ([str (stretch-string-string s)] [fill (stretch-string-fill s)]) (let ([xtra (make-string (- i n) fill)]) (set-stretch-string-string! s (string-append str xtra)))))) 通常，大多数自动定义的过程都用于定义更特殊的过程， 在这个例子中，说的就是stretch-string-ref ** 和stretch-string-set!。而stretch-string-length** 和 **stretch-string-string**是惟一直接使用的自动生成的过程。\n(define ss (make-stretch-string 2 #\\X)) (stretch-string-string ss) ⇒ \u0026#34;XX\u0026#34; (stretch-string-ref ss 3) ⇒ #\\X (stretch-string-length ss) ⇒ 4 (stretch-string-string ss) ⇒ \u0026#34;XXXX\u0026#34; (stretch-string-fill! ss #\\@) (stretch-string-string ss) ⇒ \u0026#34;@@@@\u0026#34; (stretch-string-ref ss 5) ⇒ #\\@ (stretch-string-string ss) ⇒ \u0026#34;@@@@@@\u0026#34; (stretch-string-set! ss 7 #\\=) (stretch-string-length ss) ⇒ 8 (stretch-string-string ss) ⇒ \u0026#34;@@@@@@@=\u0026#34; 《The Scheme Programming Language》（第4版）的8.4节定义了define-structure的简化变体，作为使用syntax-case的示例。 下面给出的定义实现了完整版本。\n(define-syntax define-structure (lambda (x) (define gen-id (lambda (template-id . args) (datum-\u0026gt;syntax template-id (string-\u0026gt;symbol (apply string-append (map (lambda (x) (if (string? x) x (symbol-\u0026gt;string (syntax-\u0026gt;datum x)))) args)))))) (syntax-case x () ((_ (name field1 ...)) (andmap identifier? #\u0026#39;(name field1 ...)) #\u0026#39;(define-structure (name field1 ...) ())) ((_ (name field1 ...) ((field2 init) ...)) (andmap identifier? #\u0026#39;(name field1 ... field2 ...)) (with-syntax ((constructor (gen-id #\u0026#39;name \u0026#34;make-\u0026#34; #\u0026#39;name)) (predicate (gen-id #\u0026#39;name #\u0026#39;name \u0026#34;?\u0026#34;)) ((access ...) (map (lambda (x) (gen-id x #\u0026#39;name \u0026#34;-\u0026#34; x)) #\u0026#39;(field1 ... field2 ...))) ((assign ...) (map (lambda (x) (gen-id x \u0026#34;set-\u0026#34; #\u0026#39;name \u0026#34;-\u0026#34; x \u0026#34;!\u0026#34;)) #\u0026#39;(field1 ... field2 ...))) (structure-length (+ (length #\u0026#39;(field1 ... field2 ...)) 1)) ((index ...) (let f ([i 1] [ids #\u0026#39;(field1 ... field2 ...)]) (if (null? ids) \u0026#39;() (cons i (f (+ i 1) (cdr ids))))))) #\u0026#39;(begin (define constructor (lambda (field1 ...) (let* ([field2 init] ...) (vector \u0026#39;name field1 ... field2 ...)))) (define predicate (lambda (x) (and (vector? x) (#3%fx= (vector-length x) structure-length) (eq? (vector-ref x 0) \u0026#39;name)))) (define access (lambda (x) (vector-ref x index))) ... (define assign (lambda (x update) (vector-set! x index update))) ...)))))) ","id":43,"section":"posts","summary":"本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可","tags":["scheme"],"title":"兼容性（Compatibility Features in Chez Scheme）","uri":"https://lvsq.net/2020/02/compatibility/","year":"2020"},{"content":"下面介绍Chez Scheme线程系统过程和语法形式。 除了锁，锁增量和锁减量之外，线程系统的功能在非基于Windows的系统上在Posix线程系统（pthreads）之上实现，并在基于Windows的系统上直接使用Windows API。 有关线程创建和交互的基本详细信息，请查阅系统上的相应文档。\n大多数原生的Scheme过程都是线程安全 的，这意味着可以从多个线程中同时调用它们。 这包括诸如cons和make-string之类的分配操作，诸如car和vector-ref之类的访问器，诸如**+**和**sqrt**之类的数字运算符以及诸如**append**和**map**之类的非破坏性的高级原生操作。\n简单的变动运算符（例如set-car！，vector-set！和record字段变动器）是线程安全的。 同样，对局部变量的分配，包括（未导出的）库和顶级程序变量的分配也是线程安全的。\n大多数I/O操作应被视为具有破坏性，因为它们可能会修改端口的内部结构。\n使用没有进行合适的同步策略的非线程安全的运算符可能会破坏它们所操作的对象。 这种损坏可能导致错误的行为，内存故障，甚至导致系统中止的不可恢复的错误。\n线程创建  (fork-thread thunk)\n thunk 必须是一个接受0个参数的过程。\nfork-thread在一个新线程中调用thunk ，并返回一个线程对象。\n除了打印它外，fork-thread返回的线程对象无法执行任何操作。\n除了使用fork-thread以外，可通过外部代码来创建的线程必须在触及任何Scheme数据或调用任何Scheme过程之前调用Sactivate_thread\n (thread? obj)\n 返回：如果obj 是一个线程对象，返回#t,否则返回#f\n (get-thread-id)\n 返回：当前线程的id\n线程id是由线程分配的线程号，并且与get-process-id返回的进程id没有关系，进程id在所有线程中都是相同的。\n互斥锁  (make-mutex)\n 返回：一个新的互斥锁对象\n (mutex? obj)\n 返回：如果obj 是互斥锁，返回#t\n (mutex-acquire mutex) | (mutex-acquire mutex block?)\n mutex 必须是一个互斥锁。\nmutex-acquire获取由mutex 标识的互斥锁。可选的bool参数block？ 默认为#t，指定线程是否应阻塞等待互斥锁。block？ 如果省略或为true，则线程将阻塞，直到获取了互斥锁为止，并返回未指定的值。\n如果block？ 为false并且互斥锁当前已属于其他线程，当前线程并不会阻塞，而是，mutex-acquire立即返回值**#f**，以指示互斥锁不可用。 如果*block？* 为false并且成功获取了互斥锁，**mutex-acquire**返回#t。\n互斥锁在Posix线程术语中是递归的，这意味着调用线程可以使用互斥锁获取（重新）获取它已经拥有的互斥锁（注：锁是可以重入的）。 在这种情况下，释放互斥锁需要执行相等数量的mutex-release。\n (mutex-release mutex)\n mutex 必须是一个互斥锁。\nmutex-release释放由mutex 标识的互斥锁。 如果mutex 不属于调用线程（即释放别人的互斥锁），则会导致无法预料的行为。\n (with-mutex mutex body1 body2 \u0026hellip;)\n with-mutex计算表达式mutex ，其必须可以计算为一个互斥锁，获取锁，并计算body1 body2 \u0026hellip; ,然后释放锁。无论body是正常返回还是通过控制操作（即可能由于错误而抛到continuation）释放互斥量，这都会导致with-mutex形式的非本地退出。如果控制随后通过continuation调用返回到body，则将重新获取互斥锁。\n与直接使用mutex-acquire和mutex-release相比，使用with-mutex通常更方便，更安全。\n条件  (make-condition)\n 返回：一个新的条件对象\n (thread-condition? obj)\n 返回：如果obj 是条件对象，返回#t\n (condition-wait cond mutex) | (condition-wait cond mutex timeout)\n 返回：如果调用线程被条件唤醒返回#t，如果调用线程超时等待返回#f\ncond 必须是条件对象，并且mutex 必须是互斥锁。 可选参数timeout 是类型为time-duration或time-utc或**#f**的时间记录，表示没有超时。 默认为**#f**。\ncondition-wait等待由cond 标识的条件，且等待指定的timeout时长。在调用condition-wait时，调用线程必须已获取互斥锁mutex 。由于调用condition-wait的副作用而释放了mutex 。当稍后通过下述的过程之一从条件变量释放线程或超时到期时，将重新获取mutex ，并返回condition-wait。\n (condition-signal cond)\n cond 必须是一个条件对象。\ncondition-signal释放所有等待cond 标识的条件对象的线程的其中一个。\n (condition-broadcast cond)\n cond 必须是一个条件对象。\ncondition-broadcast释放所有等待cond 标识的条件对象的线程\n锁 锁比互斥锁更原生，但是更加灵活和有效。\n只要锁在进程共享的内存中分配，它们还可以独立于线程系统使用（包括在Chez Scheme的非线程版本中）以在分离的Scheme进程中执行同步操作。锁只是一个字长的整数，即iptr或uptr外部类型，其中包含目标计算机的本机字节序，可能是使用define-ftype定义的大结构的一部分。必须在驻留于Scheme堆外部的内存中显式分配它，并在适当时显式释放。当仅涉及线程时（即，当不涉及多个进程时），可以通过foreign-alloc分配内存。 当涉及多个进程时，应在进程共享的某个区域中分配该锁。\n使用ftype-init-lock! 初始化后，进程或线程可以尝试通过**ftype-lock!或ftype-spin-lock!锁定lock 。一旦锁已被锁定并且在解锁之前，即使通过最近锁定它的进程或线程，再一次尝试锁定该锁也会失败。 任何进程或线程可以使用ftype-unlock!**来解锁lock，而不仅仅是通过最近锁定锁的进程或线程来解锁。\n锁机制提供的结构很少，并且分配和使用中的错误可能导致内存错误，死锁和其他问题。 因此，通常建议仅将锁用作更高级别抽象的一部分，以确保按规范方式使用锁。\n(define lock (make-ftype-pointer uptr (foreign-alloc (ftype-sizeof uptr)))) (ftype-init-lock! uptr () lock) (ftype-lock! uptr () lock) ⇒ #t (ftype-lock! uptr () lock) ⇒ #f (ftype-unlock! uptr () lock) (ftype-spin-lock! uptr () lock) (ftype-lock! uptr () lock) ⇒ #f (ftype-unlock! uptr () lock)  (ftype-init-lock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-init-lock! ftype-name (a \u0026hellip;) fptr-expr index)\n  (ftype-lock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-lock! ftype-name (a \u0026hellip;) fptr-expr index)\n  (ftype-spin-lock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-spin-lock! ftype-name (a \u0026hellip;) fptr-expr index)\n  (ftype-unlock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-unlock! ftype-name (a \u0026hellip;) fptr-expr index)\n 它们每个的语法都类似于ftype-set!，尽管带有隐式的val-expr 。 特别是，对fptr-expr 和访问器a \u0026hellip; 的限制和处理是相似的，但有一个重要的限制：最后一个访问器所指定的字段（该格式在其上进行操作）必须是一个字长的整数，即 ，iptr，uptr或具有本地字节序的等效项。\n**ftype-init-lock!**应该在使用任何其他运算符之前用于初始化锁； 如果不这样做，则其他操作符的行为是不确定的。\nftype-lock! 可用于加锁。如果发现在操作时锁已解锁，则将其锁定并返回#t；如果发现该锁已加锁，则返回#f且不更改该锁。\nftype-spin-lock! 也可以用来加锁。 如果在操作时发现该锁已解锁，则将其锁定并返回； 如果发现该锁已锁定，它将一直等待直到锁被解锁，然后再锁定并返回。如果没有其他进程或者线程来释放该锁，该操作不会返回且不能以正常的方式（包括GC）中断。也不保证公平，因此即使其他进程正在主动锁定和释放该锁，进程也可能无限期挂起。\nftype-unlock! 用于解锁。如果发现锁已被锁定，则将其解锁并返回。 否则，它将返回而不更改锁。\n原子操作Locked increment and decrement 当需要原子递增或递减时，可以使用此处描述的锁定操作。\n (ftype-locked-incr! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-locked-incr! ftype-name (a \u0026hellip;) fptr-expr index)\n 返回：如果更新的值为0，则为#t，否则为#f\n (ftype-locked-decr! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-locked-decr! ftype-name (a \u0026hellip;) fptr-expr index)\n 返回：如果更新的值为0，则为#t，否则为#f\n它们每个的语法都类似于ftype-set!，尽管带有隐式的val-expr 。 特别是，对fptr-expr 和访问器a \u0026hellip; 的限制和处理是相似的，但有一个重要的限制：最后一个访问器所指定的字段（该格式在其上进行操作）必须是一个字长的整数，即 ，iptr，uptr或具有本地字节序的等效项。\nftype-locked-incr! 自动读取指定字段的值，将值加1，然后将新值写回该字段。 同样，ftype-locked-decr! 原子读取指定字段的值，从该值中减去1，然后将新值写回到该字段中。 如果新值为0，则两者都返回#t，否则返回#f。\n引用计数 在Scheme堆之外管理内存的应用程序可以利用Scheme存储管理系统通过ftype guardians 执行引用计数。 在引用计数的内存管理系统中，每个对象都保存着指向它的指针计数。 当创建一个新的指针时，该计数增加；而在删除指针时，该计数减小。 当计数达到零时，不再需要该对象，并且可以将其占用的内存用于其他目的。\n (ftype-guardian ftype-name)\n ftype-name 必须命名一个ftype。 ftype的第一个基本字段（或在unions的情况下为第一个基本字段）必须是具有本地尾数的字长整数（iptr或uptr）。 假定此字段保存引用计数。\n返回新的ftype guardian g ，可以使用其注册ftype-name 类型（或ftype-nam e的某些子类型）的ftype-pointer。 通过使用ftype指针作为参数调用g ，可以向g 注册ftype指针。\nftype guardian不会像普通的guardian那样自动保护其注册的ftype指针免遭回收。而是，对于每个通过普通（非弱，非监护人指针）变得不可访问的已注册的ftype指针，guardian会减少ftype指针指向的对象的引用计数。如果引用计数值为0，则ftype指针将保留并可以从guardian中检索。 但是，如果生成的引用计数值非零，则不会保留ftype指针。假设回收器外部的代码正确维护了引用计数，则从ftype guardian检索的对象（通过不带参数的调用）将确保具有0引用计数。回收器使用等效的ftype-locked-decr!来减少引用计数，以支持由多个进程共享的内存中的非Scheme对象。在这样的系统中，程序本身应使用ftype-locked-incr! 和ftype-locked-decr! 或非Scheme等效项（例如，第4.8节中所述C语言的scheme.h中的 LOCKED_INCR和LOCKED_DECR宏）来维护引用计数。\n下面的示例为ftype对象定义了一个简单的ftype和一个分配器，该对象释放以前分配的且不再可访问的ftype对象。\nmodule (A make-A free-dropped-As) (define-ftype A (struct [refcount uptr] [data int])) (define g (ftype-guardian A)) (define free-dropped-As (lambda () (let ([a (g)]) (when a (printf \u0026#34;freeing ~s\\n\u0026#34; (ftype-ref A (data) a)) (foreign-free (ftype-pointer-address a)) (free-dropped-As))))) (define make-A (lambda (n) (free-dropped-As) (let ([a (make-ftype-pointer A (foreign-alloc (ftype-sizeof A)))]) (ftype-set! A (refcount) a 1) (ftype-set! A (data) a n) (g a) a)))) 我们可以通过分配，丢弃并立即回收指向A的ftype指针进行测试。\n\u0026gt; (do ([i 10 (fx- i 1)]) ((fx= i 0)) (make-A i) (collect)) freeing 10 freeing 9 freeing 8 freeing 7 freeing 6 freeing 5 freeing 4 freeing 3 freeing 2 \u0026gt; (free-dropped-As) freeing 1 由ftype guardian保护的对象可能包含指向其他对象的指针，这些其他对象的引用计数也应在分配包含对象时增加，并在释放包含对象时减少。\n线程参数  (make-thread-parameter object) | (make-thread-parameter object procedure)\n 创建线程参数后，将在每个当前线程和将来的线程中放置一个单独的位置，以保存参数的内部状态变量的值。 （当该参数变得不可访问时，存储管理器可以消除该位置。）一个线程中对线程参数的更改不会被其他任何线程看到。\n创建新线程时（请参阅fork-thread），每个线程参数的当前值（而非位置）都由新线程从派生线程继承。 类似地，当第一次激活通过其他方式创建的线程时（请参见4.8节中的Sactivate_thread），每个线程参数的当前值（而非位置）都由新线程从主（原始）线程继承。\n大多数内置参数是线程参数，但有些是全局的。 在他们定义的地方已经标注了是线程的还是全局的。 在非线程版本的Chez Scheme中，内置全局参数和线程参数之间没有区别。\nI/O 缓冲区 Chez Scheme为提高效率而缓冲文件I/O操作，但是缓冲的I/O不是线程安全的。 两个线程并发地读写同一个缓冲端口可能会破坏该端口，从而导致缓冲区溢出，并最终导致无效的内存引用。\n当以缓冲模式none打开时，可以禁用二进制输出端口上的缓冲。 但是，由于需要支持先行（lookahead），因此无法完全禁用输入端口上的缓冲，并且由于要在字符和字节之间进行转换的代码转换器有时需要先行输入，因此无法完全禁用文本端口（甚至是文本输出端口）上的缓冲。\n因此，除非在二进制输出端口开启缓冲模式为none的特殊情况下，否则两个线程绝不应该并发地读写同一个端口。替代方法包括指定一个线程为给定端口执行所有I / O，和为每个线程提供通用端口包装程序，仅在获取互斥量后才将请求转发到端口。\n初始的控制台以及当前的输入和输出端口以及transcript端口都是线程安全的，因此多个线程向控制台打印错误和/或调试消息是安全的。即使在同一行内，输出也可能是交错的，但是端口不会损坏。 这些端口的线程安全性是通过为每个I/O操作获取一个互斥锁的高成本来实现的。\n实例：有界队列 以下代码摘自文章“A Scheme for native threads1”，它使用许多线程系统功能实现了有界队列。 有界队列具有固定数量的可用插槽。 当队列已满时尝试入队会导致调用线程阻塞。 尝试从空队列中出队会导致调用线程阻塞。\n(define-record-type bq (fields (immutable data) (mutable head) (mutable tail) (immutable mutex) (immutable ready) (immutable room)) (protocol (lambda (new) (lambda (bound) (new (make-vector bound) 0 0 (make-mutex) (make-condition) (make-condition)))))) (define dequeue! (lambda (q) (with-mutex (bq-mutex q) (let loop () (let ([head (bq-head q)]) (cond [(= head (bq-tail q)) (condition-wait (bq-ready q) (bq-mutex q)) (loop)] [else (bq-head-set! q (incr q head)) (condition-signal (bq-room q)) (vector-ref (bq-data q) head)])))))) (define enqueue! (lambda (item q) (with-mutex (bq-mutex q) (let loop () (let* ([tail (bq-tail q)] [tail^ (incr q tail)]) (cond [(= tail^ (bq-head q)) (condition-wait (bq-room q) (bq-mutex q)) (loop)] [else (vector-set! (bq-data q) tail item) (bq-tail-set! q tail^) (condition-signal (bq-ready q))])))))) (define incr (lambda (q i) (modulo (+ i 1) (vector-length (bq-data q))))) 下面的代码演示了有界队列在一组线程中的应用，这些线程分别扮演数据的消费者和生产者。\n(define job-queue) (define die? #f) (define make-job (let ([count 0]) (define fib (lambda (n) (if (\u0026lt; n 2) n (+ (fib (- n 2)) (fib (- n 1)))))) (lambda (n) (set! count (+ count 1)) (printf \u0026#34;Adding job #~s = (lambda () (fib ~s))\\n\u0026#34; count n) (cons count (lambda () (fib n)))))) (define make-producer (lambda (n) (rec producer (lambda () (printf \u0026#34;producer ~s posting a job\\n\u0026#34; n) (enqueue! (make-job (+ 20 (random 10))) job-queue) (if die? (printf \u0026#34;producer ~s dying\\n\u0026#34; n) (producer)))))) (define make-consumer (lambda (n) (rec consumer (lambda () (printf \u0026#34;consumer ~s looking for a job~%\u0026#34; n) (let ([job (dequeue! job-queue)]) (if die? (printf \u0026#34;consumer ~s dying\\n\u0026#34; n) (begin (printf \u0026#34;consumer ~s executing job #~s~%\u0026#34; n (car job)) (printf \u0026#34;consumer ~s computed: ~s~%\u0026#34; n ((cdr job))) (consumer)))))))) (define (bq-test np nc) (set! job-queue (make-bq (max nc np))) (do ([np np (- np 1)]) ((\u0026lt;= np 0)) (fork-thread (make-producer np))) (do ([nc nc (- nc 1)]) ((\u0026lt;= nc 0)) (fork-thread (make-consumer nc)))) 这是示例程序运行后的可能的前几行输出：\n\u0026gt; (begin (bq-test 3 4) (system \u0026#34;sleep 3\u0026#34;) (set! die? #t)) producer 3 posting a job Adding job #1 = (lambda () (fib 29)) producer 3 posting a job Adding job #2 = (lambda () (fib 26)) producer 3 posting a job Adding job #3 = (lambda () (fib 22)) producer 3 posting a job Adding job #4 = (lambda () (fib 21)) producer 2 posting a job Adding job #5 = (lambda () (fib 29)) producer 1 posting a job Adding job #6 = (lambda () (fib 29)) consumer 4 looking for a job producer 3 posting a job Adding job #7 = (lambda () (fib 24)) consumer 4 executing job #1 consumer 3 looking for a job producer 2 posting a job Adding job #8 = (lambda () (fib 26)) consumer 3 executing job #2 consumer 3 computed: 121393 consumer 3 looking for a job producer 1 posting a job Adding job #9 = (lambda () (fib 26)) ... 在“A Scheme for native threads1”中给出了其他示例，包括可悬挂线程的定义和在无法访问时自动终止的线程。\n  R. Kent Dybvig. A Scheme for native threads. In Symposium in Honor of Mitchell Wand, August 2009. http://www.ccs.neu.edu/events/wand-symposium/.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","id":44,"section":"posts","summary":"下面介绍Chez Scheme线程系统过程和语法形式。 除了锁，锁增量和锁减量之外，线程系统的功能在非基于Windows的系统上在Posix线程","tags":["thread","scheme"],"title":"线程（Thread System in Chez Scheme）","uri":"https://lvsq.net/2020/02/thread/","year":"2020"},{"content":"垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。\n回收由默认的collect-request处理程序自动触发，该处理程序通过collect-request中断调用，该中断在分配了大约n个字节的存储空间后发生，其中n是参数collect-trip-bytes 的值。 默认的collect-request处理程序通过调用不带参数的collect程序来进行会睡。 可以通过更改参数collect-request-handler 的值来重新定义collect-request处理程序。 程序还可以通过直接调用collect来导致在collect-request中断之间发生回收。\nChez Scheme的回收器是基于分代 的。它根据对象的年龄（大致来说，回收幸存数）来对对象进行分类，且老对象比年轻对象回收的频率要低。由于年轻对象比老对象更快地变为不可访问，因此结果是大多数的回收花费的时间更少。系统还维护一个静态代（static generation, 类似Java的永久代），不会对此存储进行回收。仅当压缩堆（Scompact_heap）或要collect的target-generation 参数为static符号时，才将对象放入静态代中。\n非静态代的编号从最年轻的世代（开始于0）到collect-maximum-generation的当前值。存储管理器将新分配的对象放入第0代。在第0代的回收过程中，默认情况下，将第0代的对象挪到第1代，类似地，在第1代回收期间，存活的第0代和第1代对象移动到第2代，依此类推。在最大非静态对象回收的过程中，所有幸存的非静态对象都将移动（可能返回）到最大非静态代中。 通过这种机制，一个对象有可能跳过一个或多个世代，但这在许多对象上不太可能发生，并且如果这些对象变得不可访问，则最终将回收它们的存储。\n维护内部计数器gc-trip来控制何时回收每一代。 每次调用不带参数的collect 时（从默认的collect-request处理程序开始），gc-trip都会加1。在collect-generation基数为r 的情况下，回收的世代编号为g ，其gc-trip是$r^g$的倍数。 如果将collect-generation-radix设置为4，则系统将每次收集0代，每4次收集1代，每16次收集2代，依此类推。\n每次某个世代g 调用collect时，该世代g 被回收且gc-trip前进到下个$r^g$的边界，但是不会超过$r^{g+1}$的边界，r 不变还是collect-generation-radix的值。\n如果使用第二个参数tg 调用collect，则tg 确定目标代。 当g 是最大的非静态代时，tg 必须为g 或为static。 否则，tg 必须为g 或g + 1 。 当目标代是static符号时，非静态代中的所有数据都将移动到静态代中。静态代中的对象从不会被回收。 这在加载和初始化应用程序的永久代码和数据结构之后非常有用，以减少后续回收的开销。\n通过设置本节中描述的参数，可以对回收器的行为进行实质性的调整。通过重新定义collect-request处理程序且使用显式的g 和tg 参数调用collect，甚至有可能完全覆盖收集器的默认策略来确定何时回收每个世代。例如，程序员可以通过使用显式的g 和tg 参数调用collect来重新定义处理程序，以在长时间内将最大的非静态代视为静态代，该参数在该时间段内绝不等于最大的非静态代。\n (collect) | (collect g) | (collect g tg)\n g 必须是不大于最大非静态代（collect-maximum-generation返回的值）的非负确定编号。 如果g 已经是最大的非静态代编号，则tg 必须是一个等于g 的fixnum或static符号。 否则，tg 必须是一个等于g 或大于g 的fixnum。\n此过程使存储管理器执行垃圾回收。 collect是通过collect-request处理程序定期调用的，但是也可以显式调用它，以在特定时间（例如，在计时计算之前）强制进行回收。 在Chez Scheme的线程版本中，调用collect的线程必须是唯一的活动线程。\n系统将根据g 和tg （如果提供）确定回收哪些世代，如本节的介绍中所述。\n (collect-rendezvous)\n 请求垃圾回收的方式应该与由系统自动发起的GC的方式相一致。所有正在运行的线程经过协调，以便其中一个调用collect-request处理程序，而其他线程暂停直到处理程序返回。\n请注意，如果collect-request处理程序（请参阅collect-request-handler）没有调用collect，那么collect-rendezvous实际上不会执行垃圾回收。\n collect-notify\n 如果将collect-notify设置为true，则每当运行GC时，回收器都会打印一条消息。 默认情况下，collect-notify设置为#f。\n collect-trip-bytes\n Chez Scheme在内部以大块分配内存，并通过内联操作将这些块细分以提高效率。存储管理器确定是否为每个分配的大块仅请求一次回收。此外，在存储管理器请求回收和兑现回收请求之间可能会花费一些时间，尤其是如果通过with-interrupts-disabled或disable-interrupts临时禁用了中断时。因此，collect-trip-bytes仅是一种近似度量。\n collect-generation-radix\n 此参数确定默认情况下的collect-request处理程序调用不带参数的collect时回收每一代的频率。每$r^g$次发生一次对应世代的回收，其中r 是collect-generation-radix的值，g 是世代数。\n将collect-generation-radix设置为1会强制所有世代每次都被回收， 将collect-generation-radix设置为非常大的数目将无限期有效地延迟较早的一代的回收。\n collect-maximum-generation\n 此参数确定当前可以使用的最大非静态世代数,它的值是1到254范围内的精确整数。设置为1时，仅使用两个非静态生成。 设置为2时，将使用三个非静态世代，依此类推。 当设置为254时，将使用255个非静态代，再加上一个静态代，总共256个世代。增加世代数可以减少了收集旧对象的频率，潜在地减少了收集开销，但同时也潜在地增加了系统中保留的不可访问对象的数量，从而增加了所需的内存总量。\n collect-request-handler\n collect-request-handler的值必须是一个过程。当系统认为应该要进行GC时（即，自上次GC以来，系统分配了由参数collect-trip-bytes规定的存储量之后），该过程在不带参数的情况下被调用。\n默认情况下，collect-request-handler仅调用不带参数的collect。 可以通过将collect-request-handler设置为不执行任何操作的过程来禁用自动收集，例如：\n(collect-request-handler void) 也可以利用防止任何中断的critical-section来临时禁用GC\n release-minimum-generation\n 此参数的值必须介于0到collect-maximum-generation的值（包括）之间，并且默认为collect-maximum-generation的值。\n当分配新数据且进行GC时，storage-management会自动地从操作系统中请求额外的虚拟内存地址。相应地，在堆显著减小的情况下，系统尝试将先前从操作系统获得的某些虚拟内存返回给操作系统。默认情况下，系统仅在针对最大非静态时代的GC之后才这样做。也可以让系统在对更年轻的世代回收之后就执行此操作，方法是将release-minimum-generation的值更改为小于collect-maximum-generation的值。由参数指定的世代，或者任何较老的世代是GC的目标世代时，存储管理系统将在GC之后尝试将不需要的虚拟内存返回给操作系统。\n当collect-maximum-generation设置为一个新值g 时，release-minimum-generation也同时隐式地更改为g ，有两个前提：（a）修改前这两个参数具有相同的值；（b）release-minimum-generation的值大于g\n heap-reserve-ratio\n 此参数确定了保留的内存的大概数量（没有返回给OS，如release-minimum-generation所描述的）与当前已占用的内存量（不包含已变为静态的内存区域）的比例，它的值必须是不精确的非负整数值； 如果设置为精确的实数值，则精确的值将转换为不精确的值。默认值1.0，为每个当前占用的非静态页面保留一页内存。 将其设置为较小的值可能会导致较小的平均虚拟内存占用量，而将其设置为较大的值可能会导致较少的操作系统调用以请求和释放内存空间。\n弱序对，暂时序对和守护者Weak Pairs, Ephemeron Pairs, and Guardians weak pairs允许程序维护指向对象的弱指针。 指向对象的弱指针不会阻止存储管理系统回收该对象，但是只要该对象在系统中是可访问的，它仍然有效。\nephemeron pairs与weak pairs类似，但是ephemeron pairs拥有两个指针，其中仅仅在第一个指针存在的情况第二个指针才能存在\nguardians允许程序保护对象免遭垃圾回收器的重分配，并确定该对象何时被重新分配。\nweak paris, ephemeron pairs 和guardians允许程序将有关对象的信息保留在单独的数据结构（例如哈希表）中，而无需担心维护此信息将导致对象无限期地保留在系统中。\n另外，guardians允许无限期地从释放对象中保存对象，以便可以重用它们，或者可以使用存储在对象中的数据执行清理或其他操作。\n (weak-cons obj1 obj2)\n 返回：一个新的弱序对\nobj1 是新对的car, obj2构成了新对的cdr。弱序对和普通对是无法区分的，除了这两种方式：\n 弱序对可以使用**weak-pair?**这个谓词来区别普通对 弱序对维护了一个指向(car obj)的弱指针  弱序对的car中的弱指针就像普通指针一样，只要它指向的对象可以通过系统中某个地方的普通（非弱）指针访问即可。 但是，如果垃圾收集器在某个时候识别出不存在指向该对象的非弱指针，则它将每个指向该对象的弱指针替换为“ broken weak-pointer”对象**#!bwp**，并丢弃该对象。\n弱序对的cdr字段不是弱指针，因此可以使用弱序对来构造弱保持对象的列表。可以像使用普通的列表的处理操作（例如length，map和assv）来操作这些list。弱序对可以使用set-car!和set-cdr!来修改； 在set-car!之后，car字段包含指向新对象的弱指针，代替了旧对象。弱序对的打印方式与普通对相同。 弱序对没有reader语法。弱序对在被写入然后被读取时成为普通对。\n(define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x \u0026#39;())) (car p) ⇒ (a . b) (define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x \u0026#39;())) (set! x \u0026#39;*) (collect) (car p) ⇒ #!bwp  (weak-pair? obj)\n (weak-pair? (weak-cons ’a ’b)) ⇒ #t (weak-pair? (cons ’a ’b)) ⇒ #f (weak-pair? \u0026#34;oops\u0026#34;) ⇒ #f  (ephemeron-cons obj1 obj2)\n obj1 是新对的car, obj2构成了新对的cdr。暂时序对和普通对是无法区分的，除了这两种方式：\n 暂时序对可以使用**ephemeron-pair?**这个谓词来区别普通对 暂时序对维护了一个指向(car obj)的弱指针，并且仅仅在pair的car存在时cdr才能保留  暂时序对的行为与弱序对类似，不过cdr有特殊的处理：如果car被设置为**#!bwp**的同时也会将cdr设置为**#!bwp**。由于同时将car和cdr字段设置为为**#!bwp**，因此可以通过cdr对象引用car对象这一事实本身并不意味着必须保留car（与弱序对不同）。 相反，出于某种原因，car必须独立于cdr对象保存。\n与弱序对和其他对一样，暂时序对使用**set-car!和set-cdr!**来修改数据，暂时序对的打印方式与普通对一样，但没有reader语法\n(define x (cons \u0026#39;a \u0026#39;b)) (define p (ephemeron-cons x x)) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b) (define x (cons \u0026#39;a \u0026#39;b)) (define p (ephemeron-cons x x)) (set! x \u0026#39;*) (collect) (car p) ⇒ #!bwp (cdr p) ⇒ #!bwp (define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x x)) ; not an ephemeron pair (set! x \u0026#39;*) (collect) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b) 与弱序对一样，如果在将x设置为*之前进行了垃圾回收将该pair提升为较老的一代，则上面中间示例的最后两个表达式实际上可能返回（a . b）。 但是，在上面的最后一个示例中，最后两个表达式的结果将始终为（a . b），因为弱序对的cdr持有非弱引用，并且该非弱引用阻止car字段变** #!bwp**。\n (ephemeron-pair? obj)\n (ephemeron-pair? (ephemeron-cons \u0026#39;a \u0026#39;b)) ⇒ #t (ephemeron-pair? (cons \u0026#39;a \u0026#39;b)) ⇒ #f (ephemeron-pair? (weak-cons \u0026#39;a \u0026#39;b)) ⇒ #f (ephemeron-pair? \u0026#34;oops\u0026#34;) ⇒ #f  (bwp-object? obj)\n 返回：如果obj是断开的broken weak-pair对象，则返回#t，否则返回#f\n(bwp-object? #!bwp) ⇒ #t (bwp-object? \u0026#39;bwp) ⇒ #f (define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x \u0026#39;())) (set! x \u0026#39;*) (collect (collect-maximum-generation)) (car p) ⇒ #!bwp (bwp-object? (car p)) ⇒ #t  (make-guardian)\n Guardians由要保护的对象组的过程表示。创建guardian后，注册对象组为空。 通过将对象作为参数传递给守护者，可以向guardian注册对象：\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) x ⇒ (aaa . bbb) (G x) 注册对象时也可以指定“representative”（即，y）对象。 继续上面的示例：\n(define y (cons \u0026#39;ccc \u0026#39;ddd)) y ⇒ (ccc . ddd) (G y \u0026#39;rep) 与守护者关联的一组注册对象在逻辑上细分为两个不相交的子组：一个子组称为“可访问”对象，一个子组称为“不可访问”对象。不可访问的对象是已被证明无法访问的对象（通过guardian机制本身或通过弱序对或暂时序对的car字段除外），可访问的对象是未经证明的对象。“已证明”一词在这里很重要：可能是可访问组中的某些对象确实是不可访问的，但这尚未得到证明。 在某些情况下，直到对象实际上变得不可访问很久之后（在当前实现中，直到发生包含对象的世代的垃圾回收），才可能做出这种证明。\n向guardian注册的对象最初被放置在可访问组中，并在它们变得不可访问后的某个时刻移入不可访问组。 不可访问组中的对象是通过调用不带参数的guardian来检索的。 如果不可访问组中没有对象，则guardian返回#f。 继续上面的示例：\n(G) ⇒ #f (set! x #f) (set! y #f) (collect) (G) ⇒ (aaa . bbb) ; 也有可能这个后打印出来 (G) ⇒ rep ; 这个先打印出来 (G) ⇒ #f 对G的初始调用返回#f，因为绑定到x和y的对是向G注册的唯一对象，并且仍然可以通过这些绑定访问这些序对。调用collect时，对象将移入不可访问的组。 因此，对G的两个调用返回先前绑定到x的序对和先前绑定到y的序对的representative，尽管可能与所示顺序相反。 （如上所述，对于弱序对，如果对象已迁移到较老的一代，则调用collect实际上可能不足以证明该对象不可访问。）\n实际上，从guardian那里获取的对象在任何方面都没有特殊的地位。 此功能避免了共享或循环结构可能会出现的问题。 由不可访问对象组成的共享或循环结构将被完整保留，将注册由guardian保护的部分都放置在该guardian不可访问的集合中。 然后，程序员可以完全控制结构的处理顺序。\n一个对象可以在guardian处多次注册，在这种情况下，可以多次检索该对象：\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) (G x) (G x) (set! x #f) (collect) (G) ⇒ (aaa . bbb) (G) ⇒ (aaa . bbb) 它也可以向不止一个guardian注册，并且guardian本身也可以向其他guardian注册。 在没有“representative”的情况下向guardian注册的对象，并放置在一个弱序对或暂时对的car字段中，其直到从guardian处将返回并由程序丢弃，或者直到guardian本身被丢弃为止。\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) (define p (weak-cons x \u0026#39;())) (G x) (set! x #f) (collect) (set! y (G)) y ⇒ (aaa . bbb) (car p) ⇒ (aaa . bbb) (set! y #f) (collect 1) (car p) ⇒ #!bwp 另一方面，如果指定了representative（对象本身除外），则在从guardian处获得representative的同时，也会从弱序对或暂时序对的car字段中丢弃受保护的对象。\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) (define p (weak-cons x \u0026#39;())) (G x \u0026#39;rep) (set! x #f) (collect) (G) ⇒ rep ; 获得representative的值 (car p) ⇒ #!bwp ; 自动丢弃 下面的示例说明了当guardian本身丢弃时，该对象已被释放并且弱序对的car字段设置为#!bwp：\n(define G (make-guardian)) (define x (cons aaa \u0026#39;bbb)) (define p (weak-cons x \u0026#39;())) (G x) (set! x #f) (set! G #f) (collect) (car p) ⇒ #!bwp 下面的示例演示了如何使用guardian来释放外部存储，就像由C库“malloc”和“free”操作管理存储。\n(define malloc (let ([malloc-guardian (make-guardian)]) (lambda (size) ; first free any storage that has been dropped. to avoid long ; delays, it might be better to deallocate no more than, say, ; ten objects for each one allocated (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f)))) ; then allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x)))) do-malloc必须返回一个Scheme对象“header”，该header封装一个指向外部存储的指针（可能是无符号整数），并且必须通过此header对外部存储进行所有访问。特别是，必须注意在删除相应的header之后，在Scheme之外不存在指向外部存储的指针。 do-free必须使用封装的指针释放外部存储。这两个原语都可以使用外部分配和外部无关的定义，也可以作为外部过程导入的C库“malloc”和“free”运算符进行定义。\n如果不希望调用malloc来释放存储，则可以使用collect-request处理器来检查并释放已丢弃的存储，如下所示：\n(define malloc) (let ([malloc-guardian (make-guardian)]) (set! malloc (lambda (size) ; allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x))) (collect-request-handler (lambda () ; first, invoke the collector (collect) ; then free any storage that has been dropped (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f))))))) 通过一点重构，就有可能将封装的外部地址注册为带header的representative，在这种情况下，do-free将仅将外部地址作为参数。 这将使标头一旦变得不可访问，便可以将其从Scheme堆中删除。\n锁对象Locking Objects 来自C语言的变量或数据结构到Scheme对象的所有指针，通常应在输入（或重新输入）Scheme之前丢弃。 当无法遵循该准则时，可以通过锁定对象或等效的C库过程Slock_object锁定该对象。\n (lock-object obj)\n 锁定对象可防止存储管理器收回或重定位该对象。 应谨慎使用锁定，因为它会导致内存碎片并增加存储管理开销。\n如果未解锁对象，锁定也会导致意外保留存储空间。 可以通过解锁对象或等效的C库过程Sunlock_object来解锁对象。\n锁定立即数（例如，fixnum，布尔值和字符）或已被静态化的对象是不必要但无害的。\n (unlock-object obj)\n 通过连续调用lock-object，Slock_object或同时调用这两个对象，可以多次锁定对象，在这种情况下，必须先通过相等次数的对unlock-object或Sunlock_object的调用来将其解锁。\n除非存在指向对象的单独的C指针，否则也无需锁定包含在锁定对象中的对象（例如，锁定序对的car中的对象）。也就是说，如果仅允许通过外部对象来间接访问的内部对象，则应将其解锁，以便回收器在回收期间可以自由地重分配它。\n解锁立即值（例如，fixnum，布尔值和字符）或已设为静态的对象是不必要的，无效的，但无害。\n (locked-object? obj)\n 返回：如果obj是锁定的，立即的或静态的，返回#t\n如果回收器无法重分配或回收obj，则该谓词将返回true，包括立即值，例如fixnums，布尔值和字符以及已设为静态的对象。\n","id":45,"section":"posts","summary":"垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动","tags":["scheme"],"title":"存储管理(Storage Management in Chez Scheme)","uri":"https://lvsq.net/2020/02/storage-management/","year":"2020"},{"content":"异常  (warning who msg irritant \u0026hellip;)\n  返回：未指定\n 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止程序继续运行但可能在以后导致更严重问题的情况。通常最好是识别程序员已调用的过程，而不是程序员可能不知道的其他过程。 msg必须为字符串，并应描述异常情况。irritant可以是任何Scheme对象，并且应包含可能导致或严重涉及异常情况的值。\n (assertion-violationf who msg irritant \u0026hellip;) | (errorf who msg irritant \u0026hellip;) | (warningf who msg irritant \u0026hellip;)\n 这些过程类似于assertion-violation, error, warning, 所不同的在于 msg 设定为一个格式字符串\n中断 Chez Scheme允许程序在发生各种事件时控制Scheme系统的操作，这些事件包括键盘中断，由set-timer设置的内部计时器到期，由中断调用引发的断点或者来自存储管理器的请求启动GC。\n无论何时break被调用，系统都会立即启用中断处理程序\n (break who msg irritant \u0026hellip;) | (break who) | (break)\n break参数遵循上述errorf的协议。默认的中断处理程序（请参见break-handler）显示一条消息并调用调试器。可以省略格式字符串和对象，在这种情况下，默认中断处理程序发出的消息使用who参数标识中断，但不提供有关中断的更多信息。如果也省略了who参数，则不会生成任何消息。如果调试器正常退出，则默认的中断处理程序将正常返回。\n break-handler\n 此参数的值必须是一个过程。当前的中断处理程序由break调用，它传递其参数。有关默认中断处理程序的描述，请参见break。以下示例显示了如何禁用breaks。\n(break-handler (lambda args (void)))  (set-timer n)\n n 必须为非负整数。当n 为非零时，设置计时器启动一个内部计时器，其初始值为n。经过n个tick后，将发生计时器中断，从而导致计时器中断处理程序被调用。tick不是统一的时间单位，而是在很大程度上取决于每个过程调用要完成多少工作。\n当n为零时，设置计时器关闭计时器。\nengine机制建立在计时器中断之上，因此不应与engine共同使用。\n (register-signal-handler sig procedure)\n register-signal-handler用于为给定的底层信号建立信号处理程序。 sig必须是标识有效信号的精确整数，过程应接受一个参数。在注册了给定signal的处理程序之后，收到了给定的signal会调用该处理程序。signal编号会传递给该处理程序，从而允许同一处理程序用于不同的信号，同时区分它们。\n以这种方式处理的信号类似于键盘中断，因为在将信号传递到进程时不会立即调用处理程序，而是在信号传递后在某个过程调用边界处调用该处理程序。因此，为内存故障，非法指令等建立处理程序通常不是一个好主意，因为导致故障或非法指令的代码将在调用处理程序之前继续执行（可能是错误的）一段时间。\n另外，仅在基于Unix的系统上才支持register-signal-handler。\n环境 环境是包含标识符绑定的顶级（first-class）对象。它们类似于模块，但是与模块不同，它们可以在运行时进行操作。环境可以作为eval，expand以及过程的定义，分配或引用顶级值的可选参数。\n有几种内置环境，也可以通过复制现有环境或从现有环境中选择的绑定来创建新环境。\n环境可以是可变的或不变的。可变的环境可以使用新的绑定进行扩展，可以修改其现有绑定，还可以分配其变量。不变的环境不能以任何这些方式进行修改。\n 联想一下SICP中关于环境的内容   (environment? obj)\n (environment? (interaction-environment)) ⇒ #t (environment? \u0026#39;interaction-environment) ⇒ #f (environment? (copy-environment (scheme-environment))) ⇒ #t (environment? (environment \u0026#39;(prefix (rnrs) $rnrs-))) ⇒ #t  (environment-mutable? env)\n (environment-mutable? (interaction-environment)) ⇒ #t (environment-mutable? (scheme-environment)) ⇒ #f (environment-mutable? (copy-environment (scheme-environment))) ⇒ #t (environment-mutable? (environment \u0026#39;(prefix (rnrs) $rnrs-))) ⇒ #f  (scheme-environment)\n scheme-environment返回一个包含初始顶级绑定的环境。该环境对应于Scheme模块。此过程返回的环境是不可变的。\n(define cons 3) (top-level-value \u0026#39;cons (scheme-environment)) ⇒ #\u0026lt;procedure cons\u0026gt; (set-top-level-value! \u0026#39;cons 3 (scheme-environment)) ⇒ exception  (copy-environment env) | (copy-environment env mutable?) | (copy-environment env mutable? syms)\n copy-environment返回env的副本，即包含与env 相同绑定的新环境。mutable? 如果为true，则该environment是可变的，反之则不可变；\n从env 复制到新环境的绑定集由syms 确定，其默认值为（environment-symbols env）。每个syms 元素的绑定（如果有）都被复制到新环境中，并且新环境中不存在其他绑定。\n在当前的实现中，永远不会收集环境使用的存储空间，因此重复使用复制环境最终将导致系统内存不足。\n(define e (copy-environment (scheme-environment))) (eval \u0026#39;(define cons +) e) (eval \u0026#39;(cons 3 4) e) ⇒ 7 (eval \u0026#39;(cons 3 4) (scheme-environment)) ⇒ (3 . 4)  (environment-symbols env)\n 此过程返回代表环境env中绑定的标识符的符号列表。它主要用于构建要从一种环境复制到另一种环境的符号列表。\n(define listless-environment (copy-environment (scheme-environment) #t (remq \u0026#39;list (environment-symbols (scheme-environment))))) (eval \u0026#39;(let ([x (cons 3 4)]) x) listless-environment) ⇒ (3 . 4) (eval \u0026#39;(list 3 4) listless-environment) ⇒ exception 编译、求值和加载  (eval obj) | (eval obj env)\n eval将obj 视为表达式的表示形式。它在环境env中计算表达式并返回其值。如果未提供任何环境，则默认为由交互环境返回的环境。单参数求值是Chez Scheme的扩展。当环境可变时，Chez Scheme还允许obj表示非表达形式，比如一个definition。 Chez Scheme还允许obj作为一个annotation，默认求值程序利用注释将源文件信息合并到错误消息中，并将源文件信息与编译后的代码相关联。\n在Chez Scheme中，eval实际上是一个包装器，仅将其参数传递给当前求值器（请参阅current-eval）。默认的评估器是compile，它通过当前的扩展器（参阅current-expand）扩展表达式，对其进行编译，执行生成的代码，并返回其值。如果存在环境参数env ，则compile将其传递给当前的扩展器，默认情况下为sc-expand。\n (compile obj) | (compile obj env)\n obj 可以为Scheme表达式，在指定的环境（或交互环境，如果未提供环境）中使用当前扩展器（current-expand的值）进行扩展），编译为机器代码，然后执行。 compile是current-eval参数的默认值。\n(compile \u0026#39;(cons 1 2)) =\u0026gt; (1 . 2)  (interpret obj) | (interpret obj env)\n 解释类似于编译，只是表达式是解释的而不是编译的（the expression is interpreted rather than compiled）。解释可以用作编译的替代品，但有以下警告：\n 解释后的代码运行速度大大降低 解释后的代码不会生成检查器信息，因此检查器对于解释的代码不如在编译的代码中有用、 无法解释外部过程表达式，因此解释器需要为所有外部过程表达式调用编译器（这是透明完成的）  当求值形式运行时间较短时，解释有时比编译更快，因为它避免了在求值之前通过编译完成的某些工作。\n (load path) | (load path eval-proc)\n path 必须是字符串。 load读取并求值path 指定的文件的内容。该文件可能包含源代码或目标代码。默认情况下，load使用eval求值源文件中找到的每个源表达式。如果指定了eval-proc ，则load将使用此过程。 eval-proc 必须接受一个参数，即要求值的表达式。\neval-proc参数有助于实现嵌入的类似于Scheme的语言，并有助于使用用于Scheme程序的替代评估机制。 eval-proc也可以用于其他用途。例如，\n(load \u0026#34;myfile.ss\u0026#34; (lambda (x) (pretty-print (if (annotation? x) (annotation-stripped x) x)) (newline) (eval x))) 对每一个表达式求值之前使用pretty-print打印。\n参数source-directorys确定了搜索目录，以搜索未由绝对路径名标识的源文件。\n (load-library path) | (load-library path eval-proc)\n load-library与load相同，除了它会将输入文件视为由隐式**＃!r6rs**作为前缀。这有效地禁用了所有**非R6RS**词法语法，除非随后被**＃！chezscheme**覆盖\n (load-program path) | (load-program path eval-proc)\n path 必须是字符串。加载程序读取并求值path指定的文件的内容。该文件可能包含源代码或目标代码。如果包含源代码，则加载程序会将代码以顶级程序形式包装起来，以便将文件的内容视为RNRS顶级程序（Scheme编程语言，第4版的10.3节）。默认情况下，加载程序使用eval求值文件中找到的每个源表达式。如果指定了eval-proc，则装入程序将使用此过程。 eval-proc必须接受一个参数，即要评估的表达式。传递给eval-proc的表达式可能是注释或未注释的值。 参数source-directorys确定了搜索目录，以搜索未由绝对路径名标识的源文件。\n (load-compiled-from-port input-port)\n load-compiled-from-port读取并求值来自input-port的对象代码的内容，这些input-port是事先由诸如compile-file, compile-script, compile-library, compile-to-port创建的返回值是最后一个表达式的值，该表达式的编译形式为input-port。如果input-port为空，则结果值未指定。\n (compile-file input-filename) | (compile-file input-filename output-filename)\n input-filename 和output-filename 必须是字符串。input-filename 必须是已存在的可读文件。它必须包含零个或多个源表达式的序列；如果不是这种情况，则编译文件会引发条件类型为＆syntax的异常。\n正常求值过程分为两个步骤：编译和执行。 compile-file对整个源文件执行编译过程，从而生成目标文件。随后加载目标文件（请参见load）时，不需要编译过程，并且文件加载通常快几倍。\n (compile-script input-filename) | (compile-script input-filename output-filename)\n compile-script与compile-file类似，不同点在于，它会从源文件复制开头的**#!**行到目标文件，同时该行不会被压缩，尽管参数**compile-compressed**被设置为#t，其他代码会被压缩，这样会保证操作系统可以正确地解释。\ncompile-script允许从源脚本创建已编译的脚本文件，以减少脚本加载时间。与源代码脚本一样，可以使用**\u0026ndash;script**命令行选项运行已编译的脚本。\n (compile-library input-filename) | (compile-library input-filename oiutput-filename)\n compile-library与compile-file相同，不同之处在于，它会将输入文件视为由隐式**＃!r6rs**作为前缀。这有效地禁用了所有非R6RS词法语法，除非随后被＃!chezscheme覆盖。\n (compile-program input-filename) | (compile-program input-filename output-filename)\n compile-program类似于compile-script，但不同之处在于，它实现了RNRS顶级程序的语义，而compile-script则实现了交互式顶级程序的语义。与通过compile-file或compile-script进行编译相比，生成的已编译程序的运行速度也更快。\ncompile-program返回由编译的顶层程序直接调用的库的列表，不包括（rnrs）和（chezscheme）之类的内置库\n (compile-whole-program input-filename output-filename) | (compile-whole-program input-filename output-filename libs-visible?)\n compile-whole-program接受一个文件名作为名称输入，该文件名为顶级程序命名为“ whole program optimization”（wpo）文件，并生成一个包含该程序及其所依赖的每个库的目标文件，前提是需要一个可以找到库的wpo文件。\n如果wpo文件找不到所需库，但可以找到该库的目标文件，则该库不会合并到生成的目标文件中。这些库将在运行时加载。 compile-whole-program返回这些库的列表。如果没有这样的库，则生成的目标文件是自包含的，并且compile-whole-program返回空列表。\n如果libs-visible? 设置为非false，则库合并到目标文件是可见的（供environment和eval使用），任何合并到目标文件中并在运行时保留下来的目标文件所要求的库都是可见的。\n当generate-wpo-files参数设置为#t时，过程compile-file，compile-program，compile-library，compile-script和compile-whole-library会生成wpo文件以及普通目标文件。 （默认值为#f）。另外如果传递可选的wpo端口时，compile-port和compile-to-port也会这样做。\n (compile-whole-library input-filename output-filename)\n compile-whole-library类似于compile-whole-program，不同之处在于input-filename必须为库指定一个wpo文件，所有库自动显示，并生成一个新的wpo文件（当generate-wpo-files为#t时）以及用于生成的库组合的目标文件。\n (compile-port input-port output-port) | (compile-port input-port output-port sfd) | (compile-port input-port output-port sfd wpo-port)\n input-port 必须是文本输入端口。out-port 和wpo-port（如果存在）必须是二进制输出端口。如果存在sfd ,必须是源文件描述符。\n (make-boot-file output-filename base-boot-list input-filename \u0026hellip;)\n 所有参数都必须是字符串。\nmake-boot-file将引导标头（boot header）写入以output-filename 命名的文件，然后依次写入每个input-filename 的目标代码。如果尚未编译输入文件，make-boot-file将在对其进行编译。\n引导文件通过\u0026ndash;boot或-b命令行选项显式加载，或基于可执行文件的名称隐式加载。\n (make-boot-header output-filename base-boot1 base-boot2\u0026hellip;)\n 该过程已包含在make-boot-file中，并提供了向后兼容性。\n(make-boot-header output-filename base-boot1 base-boot2 \u0026hellip;)等价于：(make-boot-file output-filename ’(base-boot1 base-boot2 \u0026hellip;))源目录和文件  source-directories\n source-directories的值必须是一个字符串列表，每个字符串都命名一个目录路径。当通过load, load-library, load-program, include, visit, or revisit在交互式检查器中发生语法错误或打开源文件时，source-directory确定用于搜索源文件或目标文件的目录集。\n默认值为列表（“.”），这意味着仅在当前目录中或相对于当前目录才能找到源文件，除非使用绝对路径命名。\n (with-source-path who name procedure)\n 过程with-source-path依次搜索当前源目录路径，以查找具有指定名称的文件，并在结果上调用过程。如果未找到这样的文件，则引发**\u0026amp;assertion**和**\u0026amp;who**异常，**\u0026amp;who**的值为*who* 的值\n如果name 是绝对路径，或者以./（Windows下是./），或者../（Windows下是..\\），或者源目录列表中只包含“.”，或者默认值 \u0026ldquo;\u0026quot;，相当于 \u0026ldquo;.\u0026quot;，不执行搜索并返回name。\nwho 必须是符号，name 必须是字符串，procedure 应接受一个参数。\n以下示例假定文件“ pie”存在于目录“ ../spam”中，但不在“ ../ham”或当前目录中。\n(define find-file (lambda (fn) (with-source-path \u0026#39;find-file fn values))) (find-file \u0026#34;pie\u0026#34;) ⇒ \u0026#34;pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../ham\u0026#34;)) (find-file \u0026#34;pie\u0026#34;) ⇒ exception in find-file: pie not found (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../spam\u0026#34;)) (find-file \u0026#34;pie\u0026#34;) ⇒ \u0026#34;../spam/pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../ham\u0026#34;)) (find-file \u0026#34;/pie\u0026#34;) ⇒ \u0026#34;/pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../ham\u0026#34;)) (find-file \u0026#34;./pie\u0026#34;) ⇒ \u0026#34;./pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../spam\u0026#34;)) (find-file \u0026#34;../pie\u0026#34;) ⇒ \u0026#34;../ham/pie\u0026#34; 编译器管理  optimize-level\n 该参数可以是0，1，2，3这4个值中的一个。\n理论上，此参数控制编译器执行的优化量。 实际上，它只是间接执行此操作，唯一的区别在于优化级别3（编译器生成“不安全”代码）与优化级别0-2（编译器生成“安全”代码）之间。 安全代码会执行完整类型和范围检查，例如，尝试应用非过程，尝试对non-pair的car操作或尝试引用向量的末尾，均会导致 引发异常。 对于不安全的代码，相同的情况可能会导致无效的内存引用，Scheme堆损坏（这可能在以后引起看似无关的问题），系统崩溃或其他不良行为。不安全的代码通常会更快，但是应该谨慎使用优化级别3，并且仅运用在必须尽快运行且经过良好测试的代码中。\n尽管编译器为优化0至2级生成了相同的代码，但如果需要，用户定义的宏转换器可以区分不同的级别。\n一种使用优化级别的方法是在每个文件上，强制使用eval-when。 例如:\n(eval-when (compile) (optimize-level 3))  也可以通过\u0026ndash;optimize-level命令行选项设置优化级别。此选项对于通过\u0026ndash;program命令行选项在优化级别3运行RNRS顶层程序特别有用，因为eval-when对RNRS顶层程序无效。\n ($primitive variable) | ($primitive 2 variable) | ($primitive 3 variable)\n variable 必须是一个原始procedure的名字。** $primitive**语法形式允许以单个原始引用的粒度控制优化级别，并且它可以用于访问原始值。\n表达式（$primitive variable）可以缩写为**#%variable**。\n(#%car ’(a b c)) ⇒ a (let ([car cdr]) (car \u0026#39;(a b c))) ⇒ (b c) (let ([car cdr]) (#%car \u0026#39;(a b c))) ⇒ a (begin (set! car cdr) (#%car \u0026#39;(a b c))) ⇒ a  debug-level\n 该参数可以采用0、1、2和3这四个值之一。它用于告诉编译器保留调试信息的重要性，其中0的重要性最低，而3的重要性最高。 默认值是1。从9.0版开始，它仅用于确定在非尾部位置遇到的引起错误的调用是否被视为在尾部位置（因此，导致调用者的帧不出现在堆栈回溯中）。 这发生在低于2的调试级别。\n概要分析Profiling ChezScheme支持两种类型的配置文件：源代码概要分析和块概要分析。\n启用源概要分析后，编译器会对生成的代码进行检测，以计算每个源代码表达式的执行次数。 该信息可以HTML格式显示或打包在列表中，以进行任意用户定义的处理。 也可以将其转储到文件中，然后再加载到编译器的概要分析信息数据库中，以用于源代码级优化。\n源代码概要分析至少包含下面一些步骤：\n 编译代码且开启source profiling 运行编译后的代码生成源代码概要分析信息，且 转储概要分析信息  通过将参数compile-profile设置为符号源或布尔值#t，可以启用源概要分析。 可以通过以下方式转储概要分析信息：\nprofile-dump-html 以HTML格式显示，以便程序员可以直观地看到使用彩色编码系统执行每个表达式的频率，该系统可以轻松发现“热点”profile-dump-list 以适合用户定义的后处理的形式;profile-dump 以适合于通过上述方法之一或某些自定义方式进行离线处理的形式，或profile-dump-data 以适合加载到编译器数据库中的形式。\n由profile-dump-data转储的概要分析信息通过profile-load-data加载到编译器的profiling数据库中。 除非通过profile-dump-data显式转储并通过profile-load-data加载，否则分析信息对编译器不可用。\n当使用块概要文件信息进行优化时，步骤是相似的： 编译代码并开启block profiling 运行代码生成block-profiling信息 转储概要分析信息 加载概要信息，且 重新编译代码  通过将参数compile-profile设置为符号块或布尔值#t，可以启用块分析。 概要文件信息必须通过profile-dump-data转储，并通过profile-load-data加载。 与源配置文件信息一样，块配置文件信息可以与转储信息的加载过程相同或不同。\n对于块优化，要重新编译的代码必须相同。 通常，这意味着所涉及的文件必须未经修改，并且其他任何更改都不会间接影响编译器生成的代码。\n出于同样的原因，当要同时使用源概要分析和块概要分析信息进行优化时，必须先收集并加载源信息，然后再运行涉及块概要分析的第一次和第二次编译。 即，必须使用以下步骤：1. 编译代码并起开源代码概要分析 2. 运行代码生成source-profiling信息 2. 转储source-profiling 3. 加载source-profiling 3. 重新编译代码，并开启块概要分析 4. 运行代码生成block-profiling信息 4. 转储block-profiling 5. 加载source-和block-profiling 5. 重新编译代码  标记每个步骤的数字既指示步骤的顺序，又指示必须在同一计划过程中执行的顺序。 （如果需要，所有步骤都可以在同一Scheme流程中执行。） 当compile-profile设置为默认值#f时，将禁用源和块分析。\n假设文件/tmp/fatfib/fatfib.ss包含以下代码：\n(define fat+ (lambda (x y) (if (zero? y) x (fat+ (1+ x) (1- y))))) (define fatfib (lambda (x) (if (\u0026lt; x 2) 1 (fat+ (fatfib (1- x)) (fatfib (1- (1- x))))))) 我们可以像下面这样加载fatfib.ss并且开启概要分析：\n(parameterize ([compile-profile \u0026#39;source]) (load \u0026#34;/tmp/fatfib/fatfib.ss\u0026#34;)) 然后运行代码：\n(fatfib 20) ⇒ 10946 运行（或多次运行）之后，转储概要文件为一些html文件集合： 使用profile-dump-html\n(profile-dump-html) 这将创建一个名为profile.html的文件\n在图中，执行最频繁的代码以接近红色的颜色突出显示，而执行最不频繁的代码以接近紫色的颜色突出显示。\n compile-profile\n 当将此参数设置为符号source或布尔值**#t**时，编译器将使用指令对生成的代码进行检测，这些指令对源代码的每个部分执行的次数进行计数。 当设置为符号**block**时，编译器类似地使用指令对生成的代码进行检测，该指令对每个代码块的执行次数进行计数。 当设置为**#f**（默认值）时，编译器不会插入这些指令。\n当compile-profile为非false时生成的代码较大且效率较低，因此仅在需要概要分析信息时才应设置此参数。启用概要分析检测后编译的代码的概要文件计数器将无限期保留，即使与它们关联的代码已被垃圾收集器回收。 这样可以得到更完整和准确的概要分析数据，但会导致动态生成或加载代码的程序出现空间泄漏，程序可以通过profile-release-counters过程显式地释放计数器，从而避免潜在的空间泄漏。\n (profile-clear)\n 调用此过程会清空概要分析信息，代码每个部分关联的计数都被置为0\n (profile-release-counters)\n 调用此过程将丢弃概要分析\n (profile-dump)\n 此过程将生成自启动或上次调用profile-clear以来收集的所有配置文件信息的转储。 它返回一个pair的列表，其中每个pair的car是一个source-object，而cdr是一个精确的非负整数计数。\nprofile-dump优于profile-dump-list的优点在于，profile-dump仅执行最少的处理，并保留完整的源对象，包括其嵌入式源文件描述符。 例如，它可以用于将概要分析信息转储到一台计算机上的fasl文件中，以便在另一台计算机上进行后续处理。\n (profile-dump-html) | (profile-dump-html prefix) | (profile-dump-html prefix dump)\n 此过程将生成一个或多个HTML文件，包括profile.html（其中包含用颜色编码的摘要信息），以及一个文件source.html，其中每个源文件源都包含用源代码进行颜色编码的副本，如前导中所述： 在本节中。 如果指定了prefix ，则它必须是字符串，并且在生成的HTML文件的名称之前。 例如，如果前缀为**“ /tmp/”**，则生成的文件将放置在目录/tmp中。 原始概要分析信息是从转储获取的，默认为**profile-dump**返回的值\n (profile-palette)\n 此参数的值必须是至少三对的非空向量。 每个pair的car是背景色，而cdr是前景（文本）色。 每种颜色都必须是一个字符串，并且每个字符串都应包含HTML层叠样式表（CSS）颜色说明符。 第一组用于未配置的代码，第二对用于未执行的配置的代码。 第三个用于执行频率最低的代码，第四个用于执行频率倒数第二低的代码，以此类推，最后一个用于执行频率最高的代码。 程序员可能希望提供自己的调色板以增强可见性或更改所用颜色的数量。\n默认情况下，黑色背景用于未配置文件的代码，灰色背景用于未执行的配置文件的代码。 根据执行频率，紫色到红色的背景颜色用于执行的概要分析代码，而最频繁执行的代码使用红色。\n(profile-palette) ⇒ #((\u0026#34;#111111\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#607D8B\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#9C27B0\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#673AB7\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#3F51B5\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#2196F3\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#00BCD4\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#4CAF50\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#CDDC39\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FFEB3B\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FFC107\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FF9800\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#F44336\u0026#34; . \u0026#34;white\u0026#34;)) (profile-palette ; set palette with rainbow colors and black text ; for all but unprofiled or unexecuted code \u0026#39;#((\u0026#34;#000000\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#666666\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#8B00FF\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#6600FF\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#0000FF\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#00FF00\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FFFF00\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FF7F00\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FF0000\u0026#34; . \u0026#34;black\u0026#34;))) ; red  (profile-line-number-color)\n 此参数的值必须是字符串或#f。 如果是字符串，则该字符串应包含HTML层叠样式表（CSS）颜色说明符。 如果参数设置为字符串，则profile-dump-html使用指定的颜色在每个源文件的html呈现中包括行号。 如果参数设置为#f，则不包含行号。\n个性化（Waiter Customization）  (new-cafe) | (new-cafe eval-proc)\n Chez Scheme通过waiter 或read-eval-print循环（REPL）与用户进行交互。 waiter在称为caf́e的上下文中运行。 当系统启动时，将用户置于caf́e中并分配waiter 。 new-cafe在旧的caf́e之上开启了一个新的Scheme caf́e。 除了启动waiter 之外，new-cafe还设置了caf́e的重置和退出处理程序（请参阅reset-handler和exit-handler）。 退出caf́e会返回到创建该caf́e的caf́e。从最初的caf́e退出后会完全退出了Scheme。 caf́e可以通过显式调用exit或通过接收end-of-file（Unix系统上为“ control-D”）来退出。在前一种情况下，传递给exit的任何值都是从new-cafe返回的。\n\u0026gt; (define x 1) \u0026gt; x 1 \u0026gt; (new-cafe) \u0026gt;\u0026gt; x 1 \u0026gt;\u0026gt; (define y 2) \u0026gt;\u0026gt; y 2 \u0026gt;\u0026gt; (exit 1) 1 如果指定了可选的eval-proc 参数，则使用eval-proc 求值从控制台输入的程序。 否则，将使用参数current-eval 的值。 eval-proc必须接受一个参数，即要求值的表达式。\n\u0026gt; (new-cafe (lambda (x) x)) \u0026gt;\u0026gt; 3 3 \u0026gt;\u0026gt; (a . (b . (c . ()))) (a b c) \u0026gt; (define sum (lambda (ls) (if (null? ls) 0 (+ (car ls) (sum (cdr ls)))))) \u0026gt; (new-cafe sum) \u0026gt;\u0026gt; (1 2 3) 6 时间和日期 时间由时间对象表示。 时间对象记录特定时间或持续时间的纳秒和秒，以及标识时间对象性质的time type 。 时间类型是以下符号之一：time-utc: 从“纪元”1970年1月1日0点0分0秒以来的时间time-monotonic: 从过去某个任意时间点开始经过的时间，理想情况下无需进行调整。time-duration: 两个时间的间隔。当作为current-time的参数时，其行为与time-monotonic类似，但也可以用来表示两个时间对象相减的结果time-process: 当前进程使用的CPU时间量。time-thread: 当前线程使用的CPU时间量。 如果未运行线程，或者系统不允许确定单个线程时间，则该时间与time-process相同。time-collector-cpu: 当前进程用于垃圾回收的这部分CPU消耗的时间。time-collector-real: 当前进程用于垃圾回收的这部分实时消耗的时间日期由日期对象表示。 日期对象记录特定日期的纳秒，秒，分钟，小时，日，月和年，以及标识时区的偏移量。\n (current-time) | (current-time time-type)\n time-type 必须是上述的时间对象之一，默认为time-utc\n(current-time) ⇒ #\u0026lt;time-utc 1198815722.473668000\u0026gt; (current-time ’time-process) ⇒ #\u0026lt;time-process 0.120534264\u0026gt;  (make-time type nsec sec)\n type 必须是上面列出的时间类型符号之一。 nsec 表示纳秒，并且必须是小于$10^9$的精确非负整数。sec 表示秒，并且必须是精确的整数。\n(make-time \u0026#39;time-utc 787511000 1198783214) (make-time \u0026#39;time-duration 10 5) (make-time \u0026#39;time-duration 10 -5)  (time? obj)\n (time? (current-time)) ⇒ #t (time? (make-time ’time-utc 0 0)) ⇒ #t (time? \u0026#34;1400 hours\u0026#34;) ⇒ #f  (time-type time)\n 返回time 的时间类型\n (time-nanosecond time)\n 返回time 的纳秒\n (time-second time)\n 返回time 的秒\n (set-time-type! time type) | (set-time-nanosecond! time nsec) | (set-time-second! time sec)\n 每一个过程都会修改时间对象，只改变局部，而其他值则不受影响。 例如，set-time-nanosecond! 只更改纳秒时间，而不更改秒或类型。 特别地，当时间对象的类型改变时，值并不会更改。\n (time=? time1 time2) | (time\u0026lt;? time1 time2) | (time\u0026gt;? time1 time2) | (time\u0026lt;=? time1 time2) | (time\u0026gt;=? time1 time2)\n 时间比较。\n (copy-time time)\n 复制时间。\n(define t1 (current-time)) (define t2 (copy-time t1)) (eq? t2 t1) ⇒ #f (eqv? (time-second t2) (time-second t1)) ⇒ #t (eqv? (time-nanosecond t2) (time-nanosecond t1)) ⇒ #t  (time-difference time1 time2 ) | (time-difference! time1 time2 ) | (add-duration time timed) | (add-duration! time timed) | (subtract-duration time timed) | (subtract-duration! time timed)\n 对于time-difference，time1和time2必须具有相同的时间类型，结果是时间类型为time-duration的时间对象。 对于add-duration，add-duration！，subtract-duration和subtract-duration！，timed必须具有时间类型time-duration，并且结果是时间类型与时间相同的时间对象。 time-difference！，add-duration！和subtract-duration！ 可能具有破坏性，即每个对象都可能修改并返回其第一个参数，或者可能分配了新的时间对象\n(let ([delay (make-time \u0026#39;time-duration 0 1)]) (let ([t1 (current-time \u0026#39;time-monotonic)]) (sleep delay) (let ([t2 (current-time \u0026#39;time-monotonic)]) (let ([t3 (time-difference t2 t1)]) (and (eq? (time-type t3) \u0026#39;time-duration) (time\u0026gt;=? t3 delay) (time=? (add-duration t1 t3) t2) (time=? (subtract-duration t2 t3) t1)))))) ⇒ #t  (current-date) | (current-date offset)\n 如上所述，offset 表示UTC以东的时区偏移量（以秒为单位）。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 可以通过传递零偏移量来获得UTC.offset表示UTC以东以秒为单位的时区偏移量，如上所述。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 UTC可以通过传递零偏移来获得。\n如果未提供offset ，则使用当前时区的offset，以及date-dst？ 和date-zone-name报告有关时区的信息。 如果提供了偏移量，那么date-dst？ 和结果日期对象上的date-zone-name都是**#f**。\n(current-date) ⇒ #\u0026lt;date Thu Dec 27 23:23:20 2007\u0026gt; (current-date 0) ⇒ #\u0026lt;date Fri Dec 28 04:23:20 2007\u0026gt; (date-zone-name (current-date)) ⇒ \u0026#34;EST\u0026#34; or other system-provided string (date-zone-name (current-date 0)) ⇒ #f  (make-date nsec sec min hour day mon year) | (make-date nsec sec min hour day mon year offset)\n nsec代表纳秒，并且必须是小于$10^9$的精确非负整数。sec代表秒，并且必须是小于62的精确非负整数。min代表分钟，并且必须是小于60的精确非负整数。hour必须是精确的非负整数 小于24。day必须是一个精确的整数，1≤day≤31。（实际上限可能取决于月份和年份。）mon表示月份必须是一个精确的整数，1≤mon≤12。年必须 是一个精确的整数。 如上所述，它应至少为1970。offset表示UTC以东的时区偏移（以秒为单位）。 它必须是-86400到+86400（含）范围内的精确整数。 可以通过传递零偏移量来指定UTC。\n(make-date 0 0 0 0 1 1 1970 0) ⇒ #\u0026lt;date Thu Jan 1 00:00:00 1970\u0026gt; (make-date 0 30 7 9 23 9 2007 -14400) ⇒ #\u0026lt;date Sun Sep 23 09:07:30 2007\u0026gt; (date-zone-name (make-date 0 30 7 9 23 9 2007 -14400)) ⇒ #f (string? (date-zone-name (make-date 0 30 7 9 23 9 2007))) ⇒ #t  (date-nanosecond date) | (date-second date) | (date-minute date) | (date-hour date) | (date-day date) | (date-month date) | (date-year date) | (date-zone-offset date)\n 如字面的意思， 返回日期的对应的部分的值\n (date-week-day date) | (date-year-day date)\n 通过这些过程，可以确定以date 表示的日期是星期几还是每年的某天。 week-day是小于7的精确非负整数，其中0表示星期日，1表示星期一，依此类推。 year-day是小于367的精确非负整数，其中0代表一年的第一天（1月1日），1代表第二天，2代表第三天，依此类推。\n (time-utc-\u0026gt;date time) | (time-utc-\u0026gt;date time offset) | (date-\u0026gt;time-utc date)\n 这些过程用于在时间和日期对象之间进行转换。 time-utc-\u0026gt;date的时间参数必须具有time-type utc，date-\u0026gt;time-utc始终返回带有time-type utc的时间对象。\n对于time-utc-\u0026gt;date，offset 表示UTC以东的秒数中的时区偏移，如本节开头所述。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 UTC可以通过传递零偏移来获得。\n (date-and-time) | (date-and-time date)\n 字符串始终采用以下示例所示的格式，长度始终为24。\n(date-and-time) ⇒ \u0026#34;Fri Jul 13 13:13:13 2001\u0026#34; (defined (make-date 0 0 0 0 1 1 2007 0)) (date-and-time d) ⇒ \u0026#34;Mon Jan 01 00:00:00 2007\u0026#34;  (sleep time)\n time 必须是类型为time-duration的时间对象。 sleep 导致调用线程在大约由时间对象指示的时间量内暂停操作，除非该进程收到中断睡眠操作的信号。 实际睡眠时间取决于系统时钟的粒度以及系统运行其他线程和进程的繁忙程度。\n时间和统计  (time expr) time求值expr ，并且作为副作用，打印（到console-output端口）cpu时间量，实时时间量，分配的字节数以及与求值expr 相关的收集开销。\n \u0026gt; (time (collect)) (time (collect)) 1 collection 1 ms elapsed cpu time, including 1 ms collecting 1 ms elapsed real time, including 1 ms collecting 160 bytes allocated, including 8184 bytes reclaimed   (cpu-time)\n 返回：自系统启动以来消耗的cpu时间量。\n该量以毫秒为单位。 该数量包括“system”时间和“user”时间，即代表进程在内核中花费的时间以及在进程本身中花费的时间。\n (real-time)\n 返回：自系统启动以来经过的实时时间\n以毫秒为单位的时间总量\n (bytes-allocated) | (bytes-allocated g)\n 返回：当前分配的字节数\n如果提供了g ，则bytes-allocated返回指定generation中当前为Scheme对象分配的字节数。 g 必须为非负精确整数，且不得大于最大非静态generation，即，collect-maximum-generation返回的值或符号为static。 如果未提供g ，则bytes-allocated返回所有generation中分配的字节总数。\n (initial-bytes-allocated)\n 返回：加载启动文件后分配的总字节数\n (bytes-deallocated)\n 返回：垃圾回收器释放的总字节数\n通过将（bytes-deallocated）和（bytes-allocated）相加并减去（initial-bytes-allocated），可以获得当前进程分配的总字节数（无论是否仍在使用中）。\n (current-memory-bytes)\n 返回：当前分配的字节总数，包括开销.\ncurrent-memory-bytes返回堆的总大小（以字节为单位），不仅包括Scheme对象占用的字节，还包括各种形式的开销（包括碎片和保留但当前不占用的内存），因此，它是操作系统中当前进程的堆内存量的准确度量值\n (maximum-memory-bytes)\n 返回：分配过的最大字节数，包括开销\n (reset-maximum-memory-bytes!)\n 将堆内存的最大记录值重置为当前堆大小\n (collections)\n 返回：到目前为止的垃圾回收次数\n (statistics)\n 返回：包含当前统计信息的sstats记录\nstatistics将各种时间和分配统计信息打包在一起，形成一个sstats记录。 sstats记录具有以下字段：\n         cpu, 消耗的cpu时间   real, 经过的时间   bytes, 分配的字节数   gc-count, gc次数   gc-real, gc经历的时间   gc-bytes, gc回收的字节数    所有值都是从系统启动开始算\nstatistics可以像如下定义：\n(define statistics (lambda () (make-sstats (current-time ’time-thread) (current-time ’time-monotonic) (- (+ (bytes-allocated) (bytes-deallocated)) (initial-bytes-allocated)) (collections) (current-time ’time-collector-cpu) (current-time ’time-collector-real) (bytes-deallocated))))  (make-sstats cpu real bytes gc-count gc-cpu gc-real gc-bytes) 返回：sstats记录\n  (sstats-cpu s) | (sstats-real s) | (sstats-bytes s) | (sstats-gc-count s) | (sstats-gc-cpu s) | (sstats-gc-real s) | (sstats-gc-bytes s)\n 返回：s 对应的部分的值\n (set-sstats-cpu! s new-value) | (set-sstats-real! s new-value) | (set-sstats-bytes! s new-value) | (set-sstats-gc-count! s new-value) | (set-sstats-gc-cpu! s new-value) | (set-sstats-gc-real! s new-value) | (set-sstats-gc-bytes! s new-value)\n 设置对应部分的值\n (sstats-difference s1 s2)\n 比较两个sstats\n enable-object-counts\n enable-object-counts的值是一个布尔值，它确定收集器在运行时是否记录对象计数，从而确定过程对象计数返回的object-counts是否准确。 由于启用对象计数会增加收集的开销，因此默认情况下该参数设置为#f。\n (object-counts)\n 过程object-countsx返回一个嵌套的关联列表，该列表表示为一个或多个世代中至少有一个活动实例的每个堆分配的原始类型和记录类型分配的对象计数和字节。 （堆分配的基本类型包括，例如，pair和向量，但不包括，例如，fixnum或字符。）仅当enable-object-countsxx为#t时，收集器才会收集对象计数。\nobject-countsx返回的关联列表具有以下结构： ((type (generation count . bytes) \u0026hellip;) \u0026hellip;)\ntype是原始类型的名称，以符号（例如，对）表示，或者是record-type描述符（rtd）。 generation是介于0和（collect-maximum-generation）的值（包含在内）或表示静态生成的符号static之间的非负固定编号。 count和字节是非负的fixnum。\n(collect-request-handler void) (enable-object-counts #t) (define-record-type frob (fields x)) (define x (make-frob (make-frob #f))) (collect 3 3) (cdr (assoc 3 (cdr (assoc (record-type-descriptor frob) (object-counts))))) =\u0026gt; (2. 16) 成本中心 Cost Centers 成本中心用于在求值选定的代码段时跟踪分配的字节，执行的指令和/或经过的CPU时间。 成本中心是通过过程make-cost-center创建的，而成本是通过with-cost-center过程进行跟踪的。\n仅为此目的代码跟踪分配和指令计数。 该工具由两个参数控制：generate-allocation-counts和generate-instruction-counts。 默认情况下禁用检测。 内置程序没有检测，解释代码或非Scheme代码也没有。 仅当过程with-cost-center的可选参数*timed?*有值且不为false时才会跟踪经历的时间\nwith-cost-center过程即使在使用同一成本中心重新输入，在多个线程中同时使用并通过继续调用退出或重新输入一次或多次后，也要遵循上述注意事项来准确跟踪成本。\n generate-allocation-counts\n 当此参数为true时，编译器会在生成的代码的每个分配点插入一小段指令，以跟踪发生的分配量。此参数最初为false。\n generate-instruction-counts\n 当此参数为true时，编译器将在生成的代码的每个块中插入简短的指令序列，以跟踪该块执行的指令数。 此参数最初为false。\n (make-cost-center)\n 返回: 新的成本中心\n (with-cost-center cost-center thunk) | (with-cost-center timed? cost-center thunk)\n thunk 必须是一个接受零参数的过程。 with-cost-center调用不带参数的thunk 并返回其值。 它还可以动态计算分配的字节数，执行的指令以及在计算thunk 调用时所经过的cpu时间，并将跟踪的成本添加到成本中心记录中。\n如上所述，仅对于将参数generate-allocation-counts 设置为true的编译的代码跟踪分配计数，并且仅对将generate-instruction-counts 设置为true的编译的代码跟踪指令计数。 仅在提供timed? 且不为false的情况下，才会跟踪cpu时间，其中包括在已测量的代码，未测量代码和非Scheme代码中花费的cpu时间。\n (cost-center-instruction-count cost-center)\n 返回：成本中心跟踪的指令数\n (cost-center-allocation-count cost-center)\n 返回：成本中心跟踪的已分配字节数\n (cost-center-time cost-center)\n 返回：成本中心跟踪的CPU时间\n (reset-cost-center! cost-center)\n 此过程将成本中心记录的成本重置为零。\n参数 本节介绍了用于创建和操作参数的机制。 可以使用make-parameter方便地创建新参数。 但是，除了它们的行为外，没有什么能将参数与其他过程区分开。 如果调用参数时必须采取比通过make-parameter机制容易容纳的更为复杂的动作，则可以直接使用case-lambda定义该参数\n (make-parameter object) | (make-parameter object procudure)\n make-parameter接受一个或两个参数。 第一个参数是内部变量的初始值，第二个参数（如果存在）是应用于初始值和所有后续值的过滤器。 过滤器应接受一个参数。 如果该值不合适，则过滤器应引发异常或将值转换为更合适的形式。\n例如，print-length的默认定义如下：\n(define print-length (make-parameter #f (lambda (x) (unless (or (not x) (and (fixnum? x) (fx\u0026gt;= x 0))) (assertion-violationf ’print-length \u0026#34;~s is not a positive fixnum or #f\u0026#34; x)) x))) (print-length) ⇒ #f (print-length 3) (print-length) ⇒ 3 (format\u0026#34;~s\u0026#34;’(123456)) ⇒ \u0026#34;(123...)\u0026#34; (print-length #f) (format\u0026#34;~s\u0026#34;’(123456)) ⇒ \u0026#34;(123456)\u0026#34; make-parameter的定义使用case-lambda很简单：\n(define make-parameter (case-lambda [(init guard) (let ([v (guard init)]) (case-lambda [() v] [(u) (set! v (guard u))]))] [(init) (make-parameter init (lambda (x) x))]))  (parameterize ((param expr) \u0026hellip;) body1 body2 \u0026hellip;)\n 使用语法形式parameterize，可以以类似于普通变量的fluid-let的方式更改参数的值。 在计算body时，将每个param 设置为相应的expr 的值。\n(define test (make-parameter 0)) (test) ⇒ 0 (test 1) (test) ⇒ 1 (parameterize ([test 2]) (test)) ⇒ 2 (test) ⇒ 1 (parameterize ([test 2]) (test 3) (test)) ⇒ 3 (test) ⇒ 1 (define k (lambda (x) x)) (begin (set! k (call/cc k)) ’k) ⇒ k (parameterize ([test 2]) (test (call/cc k)) (test)) ⇒ k (test) ⇒ 1 (k3) ⇒3 (test) ⇒ 1 虚拟寄存器Virtual registers 编译器支持一组有限的虚拟寄存器 ，以供需要高速，全局和可变存储位置的程序使用。 引用或分配虚拟寄存器可能比访问可分配的局部变量或全局变量更快，并且访问时永远不会比它们更慢，而且这样做的代码序列通常更小。 分配可能会显著加快，因为不需要跟踪从虚拟寄存器到年轻对象的指针，因为可能存在于较早一世代中的可变位置。 在系统的线程版本上，虚拟寄存器是“每个线程”的，因此可以以比线程参数低廉的方式用作thread-local存储。\n该接口包含三个过程：virtual-register-count（返回虚拟寄存器的数量），set-virtual-register!（设置指定的虚拟寄存器的值）和virtual-register（获取指定虚拟寄存器的值）。\n虚拟寄存器由小于虚拟寄存器数量的非负fixnum索引指定。 为了获得set-virtual-register!和virtual-register的最佳性能，索引应该是直接嵌入在调用中的常量（或者可以通过对调用的优化来传播）。 为了避免将这些常量放在源代码中，程序员应考虑使用标识符宏为虚拟寄存器命名，例如：\n(define-syntax current-state (identifier-syntax [id (virtual-register 0)] [(set! id e) (set-virtual-register! 0 e)])) (set! current-state \u0026#39;start) current-state ⇒ start 虚拟寄存器必须被视为应用程序级资源，即，打算由多个应用程序使用的库通常不应使用虚拟寄存器，以避免与应用程序使用寄存器冲突。\n (virtual-register-count)\n 从9.0版开始，虚拟寄存器的数量设置为16。除非通过源重新编译Chez Scheme，否则无法更改。\n (set-virtual-register! k x)\n **set-virtual-register!**将x 存储在虚拟寄存器k 中。 k 必须是小于（virtual-register-count）的值的非负fixnum。\n (virtual-register k)\n virtual-register返回最后一次存储在虚拟寄存器k 中的值（在当前线程上）。\n环境查询和设置Environmental Queries and Settings  (scheme-version)\n Chez Scheme的版本\n (threaded?)\n 返回：#t（如果在系统为线程版本），否则返回#f\n (get-process-id)\n 返回：当前进程的PID\n (getenv key)\n 返回：环境中key 的值，或 #f\n(getenv \u0026#34;HOME\u0026#34;) ⇒ \u0026#34;/u/freddy\u0026#34;  (putenv key value)\n key 和 value 必须是字符串\n(putenv \u0026#34;SCHEME\u0026#34; \u0026#34;rocks!\u0026#34;) (getenv \u0026#34;SCHEME\u0026#34;) ⇒ \u0026#34;rocks!\u0026#34;  (get-registry key)\n 返回：key 的注册表值，或者**#f**\n (put-registry! key val) | (remove-registry! key)\n key 和 value 必须是字符串\n","id":46,"section":"posts","summary":"异常 (warning who msg irritant \u0026hellip;) 返回：未指定 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止","tags":["scheme"],"title":"系统操作(System Operations in Chez Scheme)","uri":"https://lvsq.net/2020/02/system-operations/","year":"2020"},{"content":"define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回true的谓词、以及每个字段的访问procedure和针对可变字段的赋值procedure。总的来说，与Java中的POJO类比较相似，不过不用自定义getter和setter方法，这与Kotlin倒为类似，例如：\n(define-record-type point (fields x y)) 创建了一个名为point的record类型，并且有两个字段x和y，和如下几个定义式（自动生成）：         (make-point x y) 构造函数   (point? obj) 谓词   (point-x p) 字段x的访问器   (point-y p) 字段y的访问器    默认下，字段是不可变的，但是可以声明为可变的（mutable）。如下定义point中，字段x是可变的，但y维持不变：\n(define-record-type point (fields (mutable x) y)) 当然亦可显式地将字段声明为不可变的：\n(define-record-type point (fields (mutable x) (immutable y))) 在这个例子中，define-record-type除了生成了上述的几个定义式之外，还为字段x增加了一个赋值过程：\n(point-x-set! p x)\n该赋值过程可以用于改变x的内容\n(define p (make-point 36 -17)) (point-x-set! p (- (point-x p) 12)) (point-x p) =\u0026gt; 24 自动生成的几个定义式是允许改变名称的，下面的point定义式，其构造函数名为mkpoint, 谓词为ispoint?，x和y的访问器分别为x-val和y-val, x的赋值器为set-x-val!\n(define-record-type (point mkpoint ispoint?) (fields (mutable x x-val set-x-val!) (immutable y y-val))) 默认情况下，每次一个record definition创建一个新类型（为方便理解，可以用Java来解释，即对于同一个POJO类new出两个实例，但这两个实例并不能equal），如下所示：\n(define (f p) (define-record-type point (fields x y)) (if (eq? p \u0026#39;make) (make-point 3 4) (point? p))) (f (f \u0026#39;make)) =\u0026gt; #f 第一个f的调用即(f \u0026lsquo;make)返回一个point类型的p，将p传递给第二个f，但p是由第一个调用生成的类型，所以point?返回#f。按照SICP的说法，这两个define-record-type并不在一个环境中，只是名字一样而已。\n默认的生产行为(generative behavior)或许可以由记录定义式中的nongenerative子句来重载：\n(define (f p) (define-record-type point (fields x y) (nongenerative)) (if (eq? p \u0026#39;make) (make-point 3 4) (point? p))) (f (f \u0026#39;make)) =\u0026gt; #t 以这种方式创建的记录类型仍然不同于由定义出现在程序的不同部分中创建的记录类型，即使这些定义在语法上是相同的：\n(define (f) (define-record-type point (fields x y) (nongenerative)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative)) (point? p)) (g (f)) =\u0026gt; #f 甚至可以通过在nongenerative子句中包含uid（唯一id）来覆盖它：\n(define (f) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (point? p)) (g (f)) =\u0026gt; #t 记录类型可以定义为有parent子句的子类型，即一个记录类型可以声明为某一个记录类型的子类型，如果指定了父类型，则子类型将继承父类型所有字段，且子类型的每个实例都被视为父类型的实例，因此可以直接使用父类型的访问器和字段等等。\n(define-record-type point (fields x y)) (define-record-type cpoint (parent point) (fields color)) (define cp (make-cpoint 3 4 \u0026#39;red)) (point? (make-cpoint 3 4 \u0026#39;red)) =\u0026gt;  #t (cpoint? (make-point 3 4)) =\u0026gt; #f (define cp (make-cpoint 3 4 \u0026#39;red)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (cpoint-color cp) =\u0026gt; red 到目前为止，define-record-type定义的默认构造函数接受record包含的字段一样多的参数，其实我们可以重写默认值，这里需要引入protocol子句，以下定义将创建一个具有三个字段的点记录：x，y和d，其中d表示距原点的位移。构造函数仍然只接受两个参数，即x和y值，并将d初始化为x和y平方和的平方根。\n(define-record-type point (fields x y d) (protocol (lambda (new) (lambda (x y) (new x y (sqrt (+ (* x x) (* y y)))))))) (define p (make-point 3 4)) (point-x p) =\u0026gt; 3 (point-y p) =\u0026gt; 4 (point-d p) =\u0026gt; 5 另外，子类型的构造函数中的参数顺序是不可改变的，即先是父类型构造函数的字段，然后才是子类型的参数，如果需要改变子类型的构造函数的参数顺序该如何呢？\n(define-record-type cpoint (parent point) (fields color) (protocol (lambda (pargs-\u0026gt;new) (lambda (x c y) ((pargs-\u0026gt;new x y) c))))) (define cp (make-cpoint 3 \u0026#39;red 4)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (point-d cp) =\u0026gt; 5 (cpoint-color cp) =\u0026gt; red 最后来看看define-record-type的语法形式：\n syntax: (define-record-type record-name clause \u0026hellip;)\n  syntax: (define-record-type (record-name constructor pred) clause \u0026hellip;)\n Fields clause语法形式:\n (fields field-spec \u0026hellip;)\n field-spec必须是下面5个中的一个:\n field-name (immmutable field-name) (mutable field-name) (immmutable field-name accessor-name) (mutable field-name accessor-name mutator-name)   define-record in Chez Scheme Chez Scheme依然支持$R^6RS$中传统的record类型的定义，另外还提供一个新的语法，即define-record，其语法形式与define-record-type一样，所不同的地方在于，define-record中的字段默认是可变的，这与$R^6RS$中的record相反，因此，创建一个记录类型时，同时会定义下列过程：\n(define-record point (x y)) (make-point x y) ;;\tconstructor (point? obj) ;;\tpredicate (point-x p) ;;\taccessor for field x (point-y p) ;;\taccessor for field y (set-point-x! p obj) ;;\tmutator for field x (set-point-y! p obj) ;;\tmutator for field y  通过对define-record-type的了解，可以发现其非常OO，smalltalk是否受其影响不得而知，至少经过纵向比较对于我们学习技术大有裨益。\n","id":47,"section":"posts","summary":"define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回tr","tags":["scheme"],"title":"Scheme语法define-record-type介绍","uri":"https://lvsq.net/2020/02/define-record-type/","year":"2020"},{"content":"Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以在 Chez Scheme 中以“微模块”级别使用，因为 Chez Scheme 中的模块和 import 形式属于定义，并且可以出现在定义可以出现的任意位置，包括在 lambda 表达式的程序体或其他局部作用域中。\n 微模块与函数孰好？？？还是视情况而定？？？\n 模块控制绑定的可见性，可以用作扩展词法作用域，以允许更精确地控制绑定的可见范围。模块导出标识符的绑定，即变量绑定、关键字绑定或模块名绑定。模块可以是具名的抑或匿名的。只要模块名可见，那么在具名模块出现处导入的绑定都可见。匿名模块中导出的绑定，在模块出现的地方被隐式地导入。匿名模块可用于隐藏一组绑定中的一些绑定，同时允许其余绑定可见。\n语法  (module name interface defn \u0026hellip; init \u0026hellip;)\n  (module interface defn \u0026hellip; init \u0026hellip;)\n name 是标识符，defn \u0026hellip; 是定义，init \u0026hellip; 是表达式。interface 是形如 (export \u0026hellip;) 的导出表，其中每个 export 都是标识符 identifier 抑或形式 (identifier export \u0026hellip;)。\n模块由一组（可能为空的）定义和一组（可能为空的）初始化表达式序列组成。模块中定义的标识符（可理解为变量或者状态，下同）在模块的程序体中可见，被导出的标识符在模块的导入作用域内亦可见。模块接口中列出的每个标识符必须在该模块中定义或被导入该到模块。module 形式是一种定义，因此可以出现在其他定义可以出现的任何位置，包括嵌套在 lambda 表达式的程序体、 library 形式、顶层程序，以及嵌套在其他模块中。此外，因为模块名的作用域与其他标识符相同，所以模块和库可以像变量和关键字那样导出模块名。\n模块名与其他标识符占用相同的名字空间，并遵循相同的作用域规则。除非被导出，否则模块中定义的标识符仅在该模块中可见。\n模块内的表达式可以引用在模块外部绑定的标识符。\n(let ([x 3]) (module m (plusx) (define plusx (lambda (y) (+ x y)))) (import m) (let ([x 4]) (plusx 5))) ; =\u0026gt; 8,注意不是9哦，可以将plusx视为：(define plusx (lambda (y) (+ 3 y)))) 同样，import不会阻止访问出现导入表单的可见标识符，但import标识符所覆盖的变量除外（啥叫覆盖，看下面两段代码）。\n(module m (y) (define y \u0026#39;m-y)) (let ([x \u0026#39;local-x] [y \u0026#39;local-y]) (import m) (list x y)) ; =\u0026gt; (local-x m-y) 模块m中定义了标识符y, 在其被import之后会覆盖let中的y；\n(module m (y) (define y \u0026#39;m-y)) (let () (import m) (let ([x \u0026#39;local-x] [y \u0026#39;local-y]) (list x y)) ; =\u0026gt; (local-x local-y) ) 先import m，之后再定义y，模块中定义的y不会覆盖let的y。\n另一方面，在模块中使用 import-only 会建立一个隔离的作用域，其中唯一可见的是被导入模块所导出的标识符，下面的代码中只有y可见。对于静态验证，有时不希望使用任何标识符，除了明确导入模块或本地范围的标识符外，这有时是合乎需要的。\n(module m (y) (define y \u0026#39;m-y)) (let ([x \u0026#39;local-x] [y \u0026#39;local-y]) (import-only m) x) ; =\u0026gt; Error: x is not visible 除非通过“import-only”导入的模块导出“import”或“import-only”以及至少一个模块的名称，否则无法在“import-only”范围内进行后续导入。 要创建一个包含多个模块导出的隔离范围而又不使“import”或“import-only”可见，必须以相同的“import-only”形式列出所有要导入的模块。\n另一种解决方案是创建一个包含每个其他模块的导出的模块。\n(module m2 (y) (define y \u0026#39;y)) (module m1 (x) (define x \u0026#39;x)) (module mega-module (cons x y) (import m1) (import m2) (import scheme)) (let ([y 3]) (import-only mega-module) (cons x y)) ; =\u0026gt; (x . y) 在它被编译之前，源程序被翻译成不含语法抽象、语法定义、库定义、模块定义以及 import 形式的核心语言程序。翻译由语法展开器负责，语法展开器以递归下降的方式处理源程序中的形式。\nmodule 和 import 特殊形式仅影响标识符(identifier)在源程序中的可见性，而不影响其含义。特别地，无论变量被绑定到在模块内部或外部定义的位置，import 都不会引入新位置。为了保持由模块和语法抽象建立的作用域关系，局部变量在必要时会被重命名。因此，表达式：\n(let ([x 1]) (module m (x setter) (define-syntax x (identifier-syntax z)) (define setter (lambda (x) (set! z x))) (define z 5)) (let ([y x] [z 0]) (import m) (setter 3) (+ x y z))) ; =\u0026gt; 4 等价于下面的表达式，其中标识符被统一地更名，并带上了下标：\n(let ([x0 1]) (define-syntax x1 (identifier-syntax z1)) (define setter1 (lambda (x2) (set! z1 x2))) (define z1 5) (let ([y3 x0] [z3 0]) (setter1 3) (+ x1 y3 z3))) 互递归module (module (a b) (module a (x) (define x (lambda () y))) (module b (y) (define y (lambda () x))) (import a) (import b)) 此模式的一般化语法定义如下，允许定义多个互递归的模块\n(define-syntax rec-modules (syntax-rules (module) [(_ (module m (id ...) form ...) ...) (module (m ...) (module m (id ...) form ...) ... (import m) ...)])) 组合module 由于模块可以重新导出所导入的绑定，所以很容易在单个模块上提供多个视图，就像下面的 s 和 t 为 r 提供的视图那样，或者将几个模块组合成一个复合，就像 r 那样。\n(module p (x y) (define x 1) (define y 2)) (module q (y z) (define y 3) (define z 4)) (module r (a b c d) (import* p (a x) (b y)) (import* q (c y) (d z))) (module s (a c) (import r)) (module t (b d) (import r)) import* 稍微解释一下import*, 其语法定义如下：\n(define-syntax import* (syntax-rules () [(_ m) (begin)] [(_ m (new old)) (module (new) (module (tmp) (import m) (alias tmp old)) (alias new tmp))] [(_ m id) (module (id) (import m))] [(_ m spec0 spec1 ...) (begin (import* m spec0) (import* m spec1 ...))])) 它支持重命名import的绑定和选择性导入特定的绑定，无需使用内置的import子形式来选择和重命名标识符，举例来说：\n(let () (import* scheme (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7) (let () (import* (rnrs) (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7) 元定义Meta Definitions  语法：(meta . definition)\n meta 关键字实际上是一个可以放在任何定义关键字前面的前缀，例如，\n (meta define x 3)\n 它告诉展开器，该定义式产生的任何变量定义都只是展开期定义，只能用于其他元定义的右侧，最主要是用在转换器表达式中。它用于定义展开期辅助函数，以及供一个或多个 syntax-case 转换器所使用的其他信息。\n元定义的语义类似于let*，它可以是自递归，但不是互递归的。\n元定义通过宏展开传播，因此可以编写，例如：\n(module (a) (meta define-record foo (x)) (define-syntax a (let ([q (make-foo #\u0026#39;\u0026#39;q)]) (lambda (x) (foo-x q))))) a ；=\u0026gt; q 条件展开Conditional expansion 可以通过 meta-cond 在展开期做出决策，这类似于 cond，但是是在展开期求值并测试表达式，并且可以在预期为定义的上下文中以及在表达式上下文中使用。\n 语法：(meta-cond clause1 clause2 \u0026hellip;)\n 除了最后一个 clause，其余的必须采取以下形式：\n (test expr1 expr2 \u0026hellip;)\n 最后一个 cluase 除可采取上述形式外，还可以使用下面的 else 子句形式：\n (else expr1 expr2 \u0026hellip;)\n 在展开期间，test 表达式会被顺序地求值，直到某条表达式求值为真或者求值完所有的表达式为止。如果一条 test 表达式求值为真，则 meta-cond 形式将展开为包含相应表达式 expr1 expr2 \u0026hellip; 所组成的 begin 形式。如果没有求值为真的 test 表达式，且存在 else 子句，则 meta-cond 形式将展开为由来自于 else 子句的表达式 expr1 expr2 \u0026hellip; 所组成的 begin 形式。否则，meta-cond 表达式展开为对 void 过程的调用。\nmeta-cond 可以按如下定义：\n(define-syntax meta-cond (syntax-rules () [(_ [a0 a1 a2 ...] [b0 b1 b2 ...] ...) (let-syntax ([expr (cond [a0 (identifier-syntax (begin a1 a2 ...))] [b0 (identifier-syntax (begin b1 b2 ...))] ...)]) expr)])) meta-cond 用于在展开期从一组可能的形式中进行选择。例如，程序员可以定义过程的安全（进行错误检查）和不安全（不进行错误检查）版本，并根据编译期优化级别决定调用版本，如下所示:\n(meta-cond [(= (optimize-level) 3) (unsafe-frob x)] [else (safe-frob x)]) 别名Aliases  语法：(alias id1 id2)\n alias 是一类定义，可以出现在其他定义可以出现的任何位置。它用于将绑定从一个标识符转移到另一个标识符。\n(let ([x 3]) (alias y x) (set! y 4) (list x y)) ; =\u0026gt; (4 4) 由于展开是由左至右进行的，别名应该出现在右侧的标识符的定义之后，例如：\n(let () (import-only (chezscheme)) (define y 3) (alias x y) x) ; =\u0026gt; 3 而不是：\n(let () (import-only (chezscheme)) (alias x y) (define y 3) x) ; =\u0026gt; exception: unbound identifier ","id":48,"section":"posts","summary":"Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以","tags":["modules"],"title":"Chez Scheme Modules","uri":"https://lvsq.net/2020/01/modules/","year":"2020"},{"content":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。\n (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_ ((a1 v1) (a2 v2) ...) bodys ...) (let ((a1 v1)) (my-let* ((a2 v2) ...) bodys ...)) ) ) ) 注意，my-let*是可以递归使用的，以及**\u0026hellip;**的用法。\n(define-syntax my-let* (syntax-rules () ( (_ () bodys ...) (let () bodys ...) ) ( (_ ((a1 v1) ...) bodys ...) (let () (define a1 v1) ... bodys ... ) ) ) ) 这个实现方式与上面的不同，上面的是嵌套let，这里将直接按顺序define内部变量，代码更短。注意此处的**\u0026hellip;**的用法。\n","id":49,"section":"posts","summary":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。 (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_","tags":["scheme"],"title":"自定义 Let*","uri":"https://lvsq.net/2020/01/my-let/","year":"2020"},{"content":"Fluid Keyword Bindings fluid-let-syntax  语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩展期间会暂时更改keyword的现有绑定，而不是引入keyword的新绑定。也就是说，在扩展form1 form2 \u0026hellip;的过程中，每个keyword的可见范围（或顶级）将会临时替换为新的绑定关系。\n (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 2 ) ) ) (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (fluid-let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 1 ) ) ) 对比上述两段代码，可知：两个表达式基本相同的，除了前者采用内部let-synctax语法，第二个采用fluid-let-syntax语法。在第一个表达式中，(g 1)扩展中的出现的f引用的是let-bound的变量f，而第二个表达式，f引用的是由fluid-let-syntax绑定的f\n","id":50,"section":"posts","summary":"Fluid Keyword Bindings fluid-let-syntax 语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩","tags":["module","syntactic"],"title":"Syntactic Extension and Modules in Chez Scheme","uri":"https://lvsq.net/2020/01/syntactic-extension-and-modules/","year":"2020"},{"content":"Chez Scheme中有一种Boxes结构，它是一个单元素对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构可以共享指向一个对象的引用，或指针。例如，在采用此种参数传递规则的语言的解释器中，可以用 boxes 实现 call-by-reference 的语义。解释有点绕，按我的理解boxes就相当于Golang的struct、Java中的类，将一些状态包装成一个整块，外界通过引用该整块的指针来访问内部的各个状态。\nBoxes 的字面形式带有前缀 #\u0026amp; (发音为 “hash-ampersand”). 例如， #\u0026amp;(a b c) 是一个 box，内容为列表 (a b c). 读取器若遇到 #!r6rs ，则会在其后的输入流中禁用 box 语法，除非在更近的位置遇到 #!chezscheme.\n所有 boxes 默认是可变的，包括常量。程序可以通过 box-immutable 创建不可变 boxes. 尝试修改不可变 box 会导致抛出异常。\n我们来看看一些用法：\n (box? obj) 如果 obj 是 box, 则为 #t, 否则为 #f.\n(box? \u0026#39;#\u0026amp;a) =\u0026gt; #t (box? \u0026#39;a) =\u0026gt; #f (box? (box 3)) =\u0026gt; #t (box obj) 创建一个由obj组成的box\n(box \u0026#39;a) =\u0026gt; #\u0026amp;a (box (box \u0026#39;(a b c))) =\u0026gt; #\u0026amp;#\u0026amp;(a b c) (unbox box) 返回box的内容\n(unbox #\u0026amp;a) =\u0026gt; a (unbox #\u0026amp;#\u0026amp;(a b c)) =\u0026gt; #\u0026amp;(a b c) (let ([b (box \u0026#34;hi\u0026#34;)]) (unbox b)) =\u0026gt; \u0026#34;hi\u0026#34; (set-box! box obj) box 必须是可变的。 set-box! 把 box 的内容设置为 obj.\n(let ([b (box \u0026#39;x)]) (set-box! b \u0026#39;y) b) =\u0026gt; #\u0026amp;y (let ([incr! (lambda (x) (set-box! x (+ (unbox x) 1)))]) (let ([b (box 3)]) (incr! b) (unbox b))) =\u0026gt; 4 (box-cas! box old-obj new-obj) 如果 box 被改变，则为 #t, 否则为 #f.box 必须是可变的。 若 box 待替换的内容和 old-obj 相同(基于 eq?), 则 box-cas! 自动将 box 的内容替换为 new-obj; 若不相同，则 box 保持不变。即CAS操作，原子的。\n(define b (box \u0026#39;old)) (box-cas! b \u0026#39;old \u0026#39;new) =\u0026gt; #t (unbox b) =\u0026gt; \u0026#39;new (box-cas! b \u0026#39;other \u0026#39;wrong) =\u0026gt; #f (unbox b) =\u0026gt; \u0026#39;new (mutable-box? obj) 如果 obj 是可变的 box ，则为 #t, 否则为 #f.\n(immutable-box? obj) 如果 obj 是不可变的 box ，则为 #t, 否则为 #f.\n(box-immutable obj) 返回一个内容为obj的不可变的box。Boxes 通常用来支持共享的，可变的结构，所以不可变的 box 一般没什么用。\n","id":51,"section":"posts","summary":"Chez Scheme中有一种Boxes结构，它是一个单元素对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构","tags":["scheme"],"title":"Chez Scheme中Boxes介绍","uri":"https://lvsq.net/2020/01/boxes-in-chez/","year":"2020"},{"content":"Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x)))\n(atom? \u0026#39;(a b c)) ⇒ #f (atom? \u0026#39;(3 . 4)) ⇒ #f (atom? \u0026#39;()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) n是一个非负整数，且小于等于list的长度；list-head和Scheme标准过程list-tail可能会同时使用来切割一个list，不同点在于，list-tail不会分配内存而只是返回源list的一个子列表，list-head总是返回源list前n个元素的副本\n(list-head \u0026#39;(a b c) 0) ⇒ () (list-head \u0026#39;(a b c) 2) ⇒ (a b) (list-head \u0026#39;(a b c) 3) ⇒ (a b c) (list-head \u0026#39;(a b c . d) 2) ⇒ (a b) (list-head \u0026#39;(a b c . d) 3) ⇒ (a b c) (list-head \u0026#39;#1=(a . #1#) 5) ⇒ (a a a a a) last-pair(Chez) 用法：(last-pair list) 列表不能为空。 last-pair返回列表的最后一对（pair）（不是最后一个元素）, list可能是不正确的列表，在这种情况下，最后一对是包含最后一个元素和终止对象的一个pair。\n(last-pair \u0026#39;(a b c d)) ⇒ (d) (last-pair \u0026#39;(a b c.d)) ⇒ (c . d) list-copy(Chez) 用法： (list-copy list) 返回一个list的副本，equal?（结构和值相同）判断为#t\nlist*(Chez) 用法：(list* obj \u0026hellip; final-obj)返回一个由obj \u0026hellip; final-obj 组成的list, 与R6RS的**cons***相同\nmake-list(Chez) 用法： (make-list n) 或者 (make-list n obj)返回n个对象的列表。n是一个正整数， 如果obj不指定，则返回的list是不确定的\n(make-list 0 \u0026#39;()) =\u0026gt; () (make-list 3 0) =\u0026gt; (0 0 0) (make-list 2 \u0026#34;hi\u0026#34;) =\u0026gt; (\u0026#34;hi\u0026#34; \u0026#34;hi\u0026#34;) iota(Chez) 用法：(iota n)返回从 0（包含）到 n（不包含）的整数列表，n须为精确的非负整数\n(iota 0) =\u0026gt; () (iota 5) =\u0026gt; (0 1 2 3 4) enumerate(Chez) 用法： (enumerate ls)返回: 从 0（包含）到长度 ls（不包含）的整数列表\n(enumerate \u0026#39;()) =\u0026gt; () (enumerate \u0026#39;(a b c)) =\u0026gt; (0 1 2) (let ([ls \u0026#39;(a b c)]) (map cons ls (enumerate ls))) =\u0026gt; ((a . 0) (b . 1) (c . 2)) remq! | remv! | remove!(Chez) 用法： (remq! obj list) | (remv! obj list) | (remove! obj list)返回: 列表中所有 obj 都被移除后的列表这些过程与 R6RS 中的 remq, remv, 及 remove 过程类似，只是 remq!, remv! 和 remove! 使用输入列表中的pair来构成输出列表。它们进行较少的空间分配，但并不一定比它们非破坏性的相应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(remq! \u0026#39;a \u0026#39;(a b a c a d)) ⇒ (b c d) (remv! #\\a \u0026#39;(#\\a #\\b #\\c)) =\u0026gt; (#\\b #\\c) (remove! \u0026#39;(c) \u0026#39;((a) (b) (c))) =\u0026gt; ((a) (b)) substq | substv | subst | substq! | substv! | subst!(Chez) 用法： (subs* new old tree)返回：在tree中将匹配到的old元素全部替换为new之后的tree.对于 substq 和 substq! ，相等性测试是基于 eq?, substv 和 substv! 是基于 eqv?, 而 subst 和 subst! 是基于 equal? substq!, substv!, 和 subst! 执行破坏性的替换。它们进行较少的空间分配，但并不一定比它们非破坏性的对应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(substq \u0026#39;a \u0026#39;b \u0026#39;((b c) b a)) =\u0026gt; ((a c) a a) (substv 2 1 \u0026#39;((1 . 2) (1 . 4) . 1)) =\u0026gt; ((2 . 2) (2 . 4) . 2) (subst \u0026#39;a \u0026#39;(a . b) \u0026#39;((a . b) (c a . b) . c)) =\u0026gt; (a (c . a) . c) (let ([tr \u0026#39;((b c) b a)]) (substq! \u0026#39;a \u0026#39;b tr) tr) =\u0026gt; ((a c) a a) reverse! 用法：(reverse! list)返回：将原list反向输出reverse! 通过反转其链接破坏性地反向排序列表。以 reverse! 取代 reverse 减少了空间分配，但并不一定比使用 reverse 更快。如果滥用，会很容易导致混乱或错误的结果。\n(reverse! \u0026#39;()) =\u0026gt; () (reverse! \u0026#39;(a b c)) =\u0026gt; (c b a) (let ([x \u0026#39;(a b c)]) (reverse! x) x) =\u0026gt; (a) (let ([x \u0026#39;(a b c)]) (set! x (reverse! x)) x) =\u0026gt; (c b a) append! 用法：(append! list \u0026hellip;)返回：将所有输入list串联起来的列表如同 append, append! 返回一个新的列表，其中元素依次为第一个列表中的元素，第二个列表中的元素，第三个列表中的元素，等等。不同之处在于， append! 重用所有参数中的点对以构造新列表。即，每一个列表参数的最后一个cdr, 其后一元素变为指向下一个列表参数。除最后一个参数外，如果任一参数为空列表，它实质上会被忽略。最后一个参数（并不一定得是列表）是不变的。\n相比于 append, append! 进行更少的空间分配（因为只修改指针，并没有数据拷贝），但并不一定更快。如果滥用，会很容易导致混乱或错误的结果。\n(append! \u0026#39;(a b) \u0026#39;(c d)) =\u0026gt; (a b c d) (let ([x \u0026#39;(a b)]) (append! x \u0026#39;(c d)) x) =\u0026gt; (a b c d) (append \u0026#39;(1 2 (3 4)) \u0026#39;(5 6)) =\u0026gt; (1 2 (3 4) 5 6) (append \u0026#39;(1 2 (3 4)) \u0026#39;() \u0026#39;(5 6)) =\u0026gt; (1 2 (3 4) 5 6) ","id":52,"section":"posts","summary":"Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x))) (atom? \u0026#39;(a b c)) ⇒ #f (atom? \u0026#39;(3 . 4)) ⇒ #f (atom? \u0026#39;()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) n是一个非负整数，且小于等于list的长度","tags":["scheme"],"title":"Scheme/Chez Scheme 对象操作","uri":"https://lvsq.net/2019/12/operations-on-objects/","year":"2019"},{"content":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。\n (make-engine thunk)\n 通过传递一个无参数的thunk(形实转换程序)给make-engine来创建一个engine。thunk的body是会被engine执行的计算，engine本身是带3个参数的过程： ticks： 一个正整数，指定提供给engine的执行时间片（原文用的是fuel这个单词，意思是燃料，正对应这engine的本意，十分贴切）的数量，engine将会执行到时间片用完或者计算完成为止； complete： 一个或多个参数的函数，用于指定计算完成后的操作。它的参数是剩余的时间片数量和计算产生的值； expire： 一个参数的函数，该函数指定如果在计算完成之前时间片用完了该怎么办。它的参数是一个能从中断点继续进行计算的新引擎。  将引擎应用于其参数时，它将开启一个时长为ticks的计时器，如果引擎计算在计时器执行之前完成，系统将调用complete，并将剩余的ticks和计算产生的值传递给它；\n另一方面，如果计时器在引擎计算完成之前耗尽了，则系统会从中断计算的continuation中创建一个新引擎，并使该引擎过期。complete和expire会被新引擎继续使用。If, on the other hand, the timer goes off before the engine computation completes, the system creates a new engine from the continuation of the in- terrupted computation and passes this engine to expire. complete and expire are invoked in the continuation of the engine invocation.\n 看看具体的例子：\n(define eng (make-engine (lambda () 3))) (eng 10 ;; ticks (lambda (ticks value) value) ;; complete (lambda (x) x) ;; expire ) ⇒ 3 通常将列表作为完整过程传递给引擎，使引擎完成时返回一个列表，该列表的第一个元素是剩余的ticks，另一个元素是计算返回的值，这通常很有用。\n(define eng (make-engine (lambda () 3))) (eng 10 list (lambda (x) x)) ⇒ (9 3) 在上面的示例中，计算值为3，还剩下9个时间片，即，需要一单位的时间片来计算出3。\n 再看一个复杂点的例子： 先定义一个计算裴波那切值的函数\n(define fibonacci (lambda (n) (let fib ([i n]) (cond [(= i 0) 0] [(= i 1) 1] [else (+ (fib (- i 1)) (fib (- i 2)))])))) 创建engine\n(define eng (make-engine (lambda () (fibonacci 10)))) (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ \u0026#34;expired\u0026#34; (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ \u0026#34;expired\u0026#34; (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ \u0026#34;expired\u0026#34; (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ (21 55) 每次时间片（燃料）用完时，到期程序都会将eng分配给新引擎。整个计算需要4个blocks，每个block包含50个ticks。最后50个燃料中，有21个都用掉了。因此，使用的燃料总量为179个。\n我们还可以统计一下消耗的ticks数量\n(define mileage (lambda (thunk) (let loop ([eng (make-engine thunk)] [total-ticks 0]) (eng 50 (lambda (ticks . values) (+ total-ticks (- 50 ticks))) (lambda (new-eng) (loop new-eng (+ total-ticks 50))))))) (mileage (lambda () (fibonacci 10))) ⇒ 179  再看看一个例子——round-robin:\n(define round-robin (lambda (engs) (if (null? engs) \u0026#39;() ((car engs) 1 ;;ticks (lambda (ticks value) (cons value (round-robin (cdr engs)))) ;;complete (lambda (eng) ;;expire (round-robin (append (cdr engs) (list eng)))))))) (round-robin (map (lambda (x) (make-engine (lambda () (fibonacci x)))) \u0026#39;(4 5 2 8 3 7 6 2))) ⇒ (1 1 2 3 5 8 13 21) 这段代码需要费些思量，首先map函数创建了8个engine, 然后代入round-robin函数，该函数依次执行各个engine，但是每个engine分配的时间片只有1，对于参数'(4 5 2 8 3 7 6 2)，数字越小，越先执行完成，所以越早执行complete函数，最终结果就是排好顺序的了，很棒的程序！\n","id":53,"section":"posts","summary":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。 (make-engine thunk) 通过传递一个无参数的thun","tags":["engine","scheme"],"title":"Engine in Scheme","uri":"https://lvsq.net/2019/12/engine-in-scheme/","year":"2019"},{"content":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Scheme提供了case语法来处理这种情况，这与Java中的switch语法非常相似。\n我们来看看case的语法：\n (case expr0 clause1 clause2 \u0026hellip;)\n 除了最后一个clause之外，每个子句都必须采用以下形式之一：\n ((key \u0026hellip;) expr1 expr2 \u0026hellip;) (key expr1 expr2 \u0026hellip;)  每一个key值都应该是不同的，最后一个子句要么是上述那种形式，或者是一个像下面这样的else子句\n (else expr1 expr2 \u0026hellip;)   那么返回值是什么呢？\n(define p (lambda (x) (case x [(\u0026#34;abc\u0026#34; \u0026#34;def\u0026#34;) \u0026#39;one \u0026#39;1] [((a b c)) \u0026#39;two] [else #f]))) (p (string #\\d #\\e #\\f)) ⇒ 1 (p \u0026#39;(a b c)) ⇒ two (p \u0026#34;eee\u0026#34;) ⇒ #f 上面的例子定义了一个函数p，接收一个参数x\n 如果x为字符串\u0026quot;abc\u0026quot;或者\u0026quot;def\u0026quot;，则返回1； 如果x为列表((a b c)，则返回two 其他情况返回#f  可见，有了case语法多条件判断写起来就方便很多，并且代码也容易读了，当然这里也可以用cond来写，这里只是为了描述case的语法而没有使用cond\n再看一个例子，就不用解释了：\n(let ([ls \u0026#39;(ii iv)]) (case (cadr ls) [i 1] [ii 2] [iii 3] [(iiii iv) 4] [else \u0026#39;out-of-range])) ⇒ 4  record-case 来看看另一个很类似的扩展，也十分有用，它就是record-case。它可以以record为单位来做条件判断并执行指令。语法格式：  (record-case expr clause1 clause2 \u0026hellip;)\n 除了最后一个子句之外，每个clause的格式如下：\n ((key \u0026hellip;) formals body1 body2 \u0026hellip;)\n 每一个key都不应该相同, 最后一个clause可能是上述的格式或者是一个else子句：\n (else body1 body2 \u0026hellip;)\n expr必须是一个pair。Chez会拿(car expr)与各个子句中的key进行比较（用eqv?）来确定哪一个clause匹配, 然后(cdr expr)将与formals绑定。\n来看换一个例子：\n(define calc (lambda (x) (record-case x [(add) (x y) (+ x y)] [(sub) (x y) (- x y)] [(mul) (x y) (* x y)] [(div) (x y) (/ x y)] [else (assertion-violationf 'calc \u0026quot;invalid expression ~s\u0026quot; x)]))) (calc '(add 3 4)) =\u0026gt; 7 (calc '(div 3 4)) =\u0026gt; 3/4 ","id":54,"section":"posts","summary":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Schem","tags":["chez","scheme"],"title":"Chez Scheme中的case扩展","uri":"https://lvsq.net/2019/12/case-in-chez-scheme/","year":"2019"},{"content":"  易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴至，克尽其用，上下一体，俱不倦而事可毕矣\n  周云成康，汉言文景。无有六十年与民休息，累藏蓄积，汉武开疆之功便是空文，此厚积薄发耳，俗语言，胳膊收回来，打出去才有力\n  武帝一代雄主，文治武功，奋高祖之余烈，承三王之圣绪，开万世不拔之基，吾国斯民之幸，铭记汉青\n  ","id":55,"section":"posts","summary":"易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴","tags":["随想"],"title":"继学录","uri":"https://lvsq.net/2019/12/think/","year":"2019"},{"content":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫易变绑定吧，如果有更好的翻译请在文后的评论中尽情发表。\n先看看该语法描述：(fluid-let ((var expr) \u0026hellip;) body1 body2 \u0026hellip;) returns: the values of the body body1 body2 \u0026hellip; libraries: (chezscheme)该Binding的作用类似局部变量，与set! 比较相似。由fluid-let定义的变量必须已绑定到顶层(top level)或者封闭的lambda内或者其他形式的绑定，这很关键！\n 请看代码：\n(let ([x 3]) (+ (fluid-let ([x 5]) x) x)) ⇒ 8 先定义变量x=3，然后在加法操作当中临时将x的值改为5，最后结果为8，如果将fluid-let中的x换个名字，比如y，将如何呢？会得到一个异常：\n Exception: variable y is not bound\n y没有绑定，是的，y即没有在顶层中被定义，也未在某个lambda中或者任何其他形式，这里只能是x\n 再学习下两个例子，加深印象：\n(let ([x \u0026#39;a]) (letrec ([f (lambda (y) (cons x y))]) (fluid-let ([x \u0026#39;b]) (f \u0026#39;c)) )) ⇒ (b . c) (let ([x \u0026#39;a]) (call/cc (lambda (k) (fluid-let ([x \u0026#39;b]) (letrec ([f (lambda (y) (k \u0026#39;*))]) (f \u0026#39;*))))) x) ⇒ a  Fluid Binding实际上是Scheme对Dynamic Scoping的保留，Scheme使用的是Lexical Scoping， 对于这两种Scoping更详细的描述可参考Lexical Scoping and Dynamic Scoping\n","id":56,"section":"posts","summary":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫易变绑定吧，如果有更好的翻译请在文后的评论中尽情发表。 先看看该语法描","tags":["fluid-let","Scheme"],"title":"Fluid Binding in Chez Scheme","uri":"https://lvsq.net/2019/12/fluid-binding/","year":"2019"},{"content":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。\n 这是语法描述：(rec var expr) syntaxreturns: value of exprlibraries: (chezscheme)The syntactic form rec creates a recursive object from expr by establishing a binding of var within expr to the value of expr. In essence, it is a special case of letrec for self-recursive objects.\nThis form is useful for creating recursive objects (especially procedures) that do not depend on external variables for the recursion, which are sometimes undesirable because the exter-nal bindings can change. For example, a recursive procedure defined at top level depends on the value of the top-level variable given as its name. If the value of this variable should change, the meaning of the procedure itself would change. If the procedure is defined instead with rec, its meaning is independent of the variable to which it is bound.\n简要翻译一下：语法rec 通过在expr中建立var与expr的值的绑定，创建一个递归对象。从本质上讲，这是letrec用于自递归对象的一种特殊情况。\n语法rec通过绑定expr中创建一个递归对象，用来 这种形式对于创建不依赖于外部变量进行递归的递归对象（尤其是过程）很有用，因为外部绑定可能会发生变化，所以有时这是不可取的。\n 看一个例子来感受一下：给定一个全是数字的list，对于每一个数字n，算出$1+2+\u0026hellip;+n$的和，最终返回和的list.\n(map (rec sum (lambda (x) (if (= x 0) 0 (+ x (sum (- x 1)))))) ’(0 1 2 3 4 5)) ⇒ (0 1 3 6 10 15) 如果没有rec语法，用letrec也是可以的，但是稍显麻烦，代码也多一些，所以rec还是很好用的\n 最后看一下rec语法的定义：\n(define-syntax rec (syntax-rules () [(_ x e) (letrec ((x e)) x)])) ","id":57,"section":"posts","summary":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。 这是语法描述：(","tags":["Scheme","Chez","rec"],"title":"Recursive Bindings in Chez Scheme","uri":"https://lvsq.net/2019/12/recursive-bindings/","year":"2019"},{"content":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些时间，动手写了一个，目前已经在公司内部运行了几年，效果良好，并且已经开源在Github上，以飨各位。\n 特点：\n  API简洁\n  支持3种事件：\n UP DOWN JOIN    基于Vert.X\n  引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lvsq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jgossip\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 一个简单的例子：\nint gossip_port = 60001; String cluster = \u0026#34;gossip_cluster\u0026#34;; GossipSettings settings = new GossipSettings(); settings.setGossipInterval(1000); try { String myIpAddress = InetAddress.getLocalHost().getHostAddress(); List\u0026lt;SeedMember\u0026gt; seedNodes = new ArrayList\u0026lt;\u0026gt;(); SeedMember seed = new SeedMember(); seed.setCluster(cluster); seed.setIpAddress(myIpAddress); seed.setPort(60001); seedNodes.add(seed); gossipService = new GossipService(cluster, myIpAddress, gossip_port, null, seedNodes, settings, (member, state) -\u0026gt;System.out.println(\u0026#34;member:\u0026#34; + member + \u0026#34; state: \u0026#34; + state)); } catch (Exception e) { e.printStackTrace(); } gossipService.start();  详细介绍请看 =\u0026gt; 项目地址\n欢迎大家fork， 如果觉得好请start ~~~\n","id":58,"section":"posts","summary":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些","tags":["jgossip","gossip"],"title":"Jgossip - gossip协议的开源实现","uri":"https://lvsq.net/2019/12/jgossip/","year":"2019"},{"content":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加\nGolang的实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} nodes := []*ListNode{} var carry = 0 for { node, c := add(l1, l2, carry) carry = c if node != nil { nodes = append(nodes, node) if l1 != nil \u0026amp;\u0026amp; l1.Next != nil { l1 = l1.Next } else { l1 = nil } if l2 != nil \u0026amp;\u0026amp; l2.Next != nil { l2 = l2.Next } else { l2 = nil } if carry \u0026gt; 0 \u0026amp;\u0026amp; (l1 == nil \u0026amp;\u0026amp; l2 == nil) { nodes = append(nodes, \u0026amp;ListNode{Val:carry}) } } else { break } } for i, n := range nodes{ if i == 0 { result = n } if i + 1 \u0026lt; len(nodes) { n.Next = nodes[i + 1] } } return result } func add (n1 *ListNode, n2 *ListNode, carry int) (*ListNode, int) { node := \u0026amp;ListNode{} if (n1 == nil \u0026amp;\u0026amp; n2 == nil) { return nil, 0 } if n1 == nil { n1 = \u0026amp;ListNode{Val : 0} } if n2 == nil { n2 = \u0026amp;ListNode{Val : 0} } sum := n1.Val + n2.Val + carry carry = 0 if sum \u0026gt; 9 { carry = 1 sum = sum - 10 } node.Val = sum return node, carry }  下面提供Scheme版本的实现【(1 0) + (9 1 2) = (0 2 2)】，为了简单起见，与题目要求稍有不同，这里采用list，而不是题目要求的链表，但实际上应是一样的。比较之下可以看出，相对而言，Scheme语言的实现更加简短优雅，得益于其强大的表达能力\n(letrec ( [Polishing (lambda (l num) (if (eq? num 0) l (Polishing (append l \u0026#39;(0)) (- num 1))) ) ] [Align (lambda (l1 l2) (let ([len1 (length l1)] [len2 (length l2)]) (if [eq? len1 len2] [list l1 l2] [if (\u0026gt; len1 len2) (list l1 (Polishing l2 (- len1 len2))) (list (Polishing l1 (- len2 len1)) l2)])) ) ] [Add (lambda (l1 l2) (let ([ l (Align l1 l2)]) (Carry (map (lambda (x y) (+ x y)) (car l) (cadr l)) 0) ) ) ] [Carry (lambda (l c) (if (null? l) (if [eq? c 0] \u0026#39;() [cons c l]) (cons (mod ( + (car l) c ) 10) (Carry (cdr l) (quotient ( + (car l) c) 10))) ) ) ]) (Add \u0026#39;(1 0) \u0026#39;(9 1 2)))  Golang版本和Scheme版本的实现思路不相同，简要描述一下后者：\n (1 0) + (9 1 2), 先进行补位： (1 0 0) + (9 1 2), 按顺序相加，得： (10 1 2), 再计算进位： (0 2 2)  ","id":59,"section":"posts","summary":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加 Golang的实现： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result","tags":["Scheme","leetcode"],"title":"两数相加","uri":"https://lvsq.net/2019/12/leetcode-2/","year":"2019"},{"content":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发。\n 问题描述 假设我们已经有足够多的1分，2分，5分钱币，任意给定金额比如1元，问有多少种组合方式？ 换言之，$$1x+2y+5z = 100$$ 求x,y,z的解有多少个\n 思路 组合方式的总和应为：\n  任意扣去一种钱币比如1分，1元采用2分，5分两种钱币的组合数，再加上：\n  总额为（1元-1分），采用1分，2分，5分三种钱币的组合数；\n  很明显这可以很容易用递归实现\n 稍作一点解释：\na. 上面两步的意思是：不带1分的组合数 + 带1分的组合数 = 全部的组合数； 这是显而易见的\nb. 上述第2步，（1元-1分）的意思是：这样可以保证任意一种组合方式再加1分都等于1元，保证至少有1个1分的钱币\n(letrec [ (A (lambda (n d) (if (= 0 (mod n d)) 1 0))) (B (lambda (n d) (cond [(not (pair? d)) 0] [(null? d) 0] [(= 0 n) 1] [(\u0026gt; 0 n) 0] [(= 1 (length d)) (A n (car d))] [else ( + (B n (cdr d)) (B (- n (car d)) d)) ] ) ) ) ] [B 100 \u0026#39;(1 2 5)] ) ","id":60,"section":"posts","summary":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发","tags":["Scheme","SICP"],"title":"钱币组合问题","uri":"https://lvsq.net/2019/12/count-coins/","year":"2019"},{"content":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026quot;x-\u0026quot;）该如何开发做紧要的介绍。\n一切开始之前，有一点需要keep in mind，即增加扩展的位置不同，所用的方法不同，所以需要对Swagger的标准有所了解，可参考官方文档  springfox目前只允许三种扩展实现:\n ListVendorExtension:列表的形式,该对象支持泛型，最终形式：”x-field”:[{field:value}] ObjectVendorExtension:对象的扩展形式,最终的扩展形式是：”x-field”:[{field:value}] StringVendorExtension:string类型的扩展实现，最终的扩展形式是”x-field”:”value”   Swagger根对象扩展 以在info中添加一个x-logo为例\n\u0026#34;info\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;\u0026lt;div style=\u0026#39;font-size:14px;color:red;\u0026#39;\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;swagger-bootstrap-ui！！！\u0026#34;, \u0026#34;termsOfService\u0026#34;: \u0026#34;http://www.xxx.com/\u0026#34;, \u0026#34;contact\u0026#34;: { \u0026#34;name\u0026#34;: pxxxx@domain.com\u0026#34; }, \u0026#34;x-logo\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#090807\u0026#34; } }, ... 后台代码：\nObjectVendorExtension logo = new ObjectVendorExtension(\u0026#34;x-logo\u0026#34;); logo.addProperty(new StringVendorExtension(\u0026#34;url\u0026#34;, \u0026#34;https://xxx.svg\u0026#34;)); logo.addProperty(new StringVendorExtension(\u0026#34;color\u0026#34;, \u0026#34;#090807\u0026#34;)); return new ApiInfoBuilder() .title(\u0026#34;swagger-bootstrap-ui！！\u0026#34;) .extensions(Lists.newArrayList(logo)) .description(\u0026#34;\u0026lt;div style=\u0026#39;font-size:14px;color:red;\u0026#39;\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026#34;) .termsOfServiceUrl(\u0026#34;http://www.xxx.com/\u0026#34;) .version(\u0026#34;1.0.0\u0026#34;) .build();  内部对象扩展 给Path添加一个扩展属性x-order为例\n@Component @Order(Ordered.HIGHEST_PRECEDENCE+100) public class OperationPositionBulderPlugin implements OperationBuilderPlugin { @Override public void apply(OperationContext context) { context.operationBuilder().extensions(Lists.newArrayList(new StringVendorExtension(\u0026#34;x-order\u0026#34;,\u0026#34;1\u0026#34;))); } @Override public boolean supports(DocumentationType delimiter) { return true; } } 详细介绍可以参考\n","id":61,"section":"posts","summary":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026quo","tags":["swagger","vendorExtensions"],"title":"Swagger 如何使用vendorExtensions进行扩展","uri":"https://lvsq.net/2019/11/swagger-vendor/","year":"2019"},{"content":" 秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁，如平原君广纳异国宾客；苏秦上书于七国；荀子遍游天下者皆可证各国文字并无大乖。 《史籀篇》文首盖云“太史籀书”，人多误以太史籀所作，如此便望文生义了。太史乃官职，王国维先生引《说文》解释，籀即读，读即籀书。另太史籀书乃周世之成语，绝非人名。  ","id":62,"section":"posts","summary":"秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁","tags":["文史"],"title":"历史不能碰","uri":"https://lvsq.net/2019/11/do-not-touch-history/","year":"2019"},{"content":"M -\u0026gt; Alt(option) S -\u0026gt; Shift    快捷键 用途     M-v 上（后）一屏   C-v 下（前）一屏   C-l 重绘屏幕，将光标所在行置于屏幕中央   C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符   C-x C-f  查找或者新建一个文件   C-x C-b 列出缓冲区。 C-x 1 关闭缓冲区列表   C-x C-q 开启或者关闭buffer的只读模式   C-x C-s 保存当前文件   C-x s 保存所有文件   C-x h 全选   M-w 复制   C-y 粘贴   C-w 剪切   C-s 往前搜索   C-r 往后搜索. DEL 也可以往后搜索，   C-/ undo   M-x calendar 打开日历。按 q 退出。【g d 到指定日期】【. 到今日（不居中）】【\u0026gt; 前一个月】【\u0026lt; 后一个月】   M-x *-mode 选择Major mode   M-x shell 运行一个shell   M-x eshell 运行一个eshell   C-a 移到行首   C-a C-k、C-S-backspace 删除整行   C-u 5 C-S-backspace、M-5 C-S-backspace 删除后5行，不加数字则删除4行（默认），如果数字为负数，则往前删   C-g 停止当前的命令   C-k 删除从光标位置到行尾所有字符    Org-Mode    快捷键 用途     C-c . 插入时间   C-c C-e 导出其它格式   C-c C-s 在标题下面插入一个带有“==SCHEDULED==”关键字的时间戳。   C-c C-d 在标题下面插入一个带有“==DEADLINE==”关键字的时间戳   C-c C-t 将当前项的状态在（unmarked）-\u0026gt;TODO-\u0026gt;DONE 之间循环切换   M-RET 插入一个同级标题   M-LEFT/RIGHT 将当前的标题提升/降低一个等级   C-c C-c 插入标签tag。 光标在标题中   C-c C-q 插入标签tag。光标在任意位置   C-c , 设置当前标题的优先级,’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的   C-c \\ 查找标签tag   S-Tab 展开所有标题   Tab 展开光标所在标题   C-c C-l 编辑链接   C-c C-o 打开链接    ","id":63,"section":"posts","summary":"M -\u0026gt; Alt(option) S -\u0026gt; Shift 快捷键 用途 M-v 上（后）一屏 C-v 下（前）一屏 C-l 重绘屏幕，将光标所在行置于屏幕中央 C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符 C-x C-f 查","tags":["emacs"],"title":"Emacs","uri":"https://lvsq.net/2019/11/emacs/","year":"2019"},{"content":"模块基础 一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set!\n通常，每个Racket模块驻留在自己的文件中，换句话说，可以认为一个.rkt 文件里的内容属于某一个模块，模块名就是文件名。\n在任意目录下创建一个子目录：mod_demo\n├── mod_demo\n│ ├── ext\n│ │ └── cake.rkt\n│ └── main.rkt\nmod_demo目录下有一个main.rkt模块，和一个ext目录，该目录下有一个cake.rkt的模块。\ncake.rkt的内容如下：\n#lang racket (provide print-cake) (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (provide print-cake) 意味着将函数print-cake导出，在模块外部就可以使用该函数了；还有一个私有的函数show, 该函数未导出，所以外部无法访问。 main.rkt的内容为：\n#lang racket (require \u0026#34;ext/cake.rkt\u0026#34;) (print-cake (random 30)) (require \u0026ldquo;ext/cake.rkt\u0026rdquo;) 将cake模块引入，引用路径符合Unix风格(但是，不能以文件分隔符即'/\u0026lsquo;作为开始或者结束)，也支持相对路径，(require \u0026ldquo;./ext/cake.rkt\u0026rdquo;) 也是完全可以的。\nCollections collection中的模块通过不带引号的、无后缀的路径引用。例如：以下模块引用了作为“racket” collection一部分的“date.rkt”库：\n#lang racket (require racket/date) (printf \u0026#34;Today is ~s\\n\u0026#34; (date-\u0026gt;string (seconds-\u0026gt;date (current-seconds)))) 注意，(require racket/date)没有带双引号。像racket/date这样的模块看起来像一个标识符，当require看到一个未加引号的模块引用时，它会将引用转换为基于collection的模块路径：\n 首先，如果未引用的路径不包含 /，然后 require会自动向引用添加一个“/main”。例如，( require slideshow )等效于( require slideshow/main )。 其次，require 向路径隐式添加了“.rkt”后缀。 最后，require通过在已安装的collection中搜索来解析路径，而不是将路径视为相对于封闭模块的路径。  Packages and Collections 一个package是一组通过Racket包管理器安装的库的集合。Racket 程序不直接引用包。相反，程序通过collections引用库，并且添加或删除包会更改可用的基于集合的库集。\n添加Collections library的旨在跨多个项目使用，因此将库的源文件保存在一个目录中并没有意义，更不能将库复制到不同的项目中使用。在这种情况下，最好的选择是新增一个collection，将lib放在collection中，这样就可以使用不带引号的路径引用它，就像Racket 发行版中包含的库一样。\n不用担心，创建一个包无需提交到公开的包服务器，可以安装到本地来使用。\n 采用raco pkg命令行工具： raco pkg install \u0026ndash;link /path/to/mod_demo\n 安装之后，在任何模块中使用(require mod_demo/ext/cake)都会从/path/to/mod_demo/ext/cake.rkt导入print-cake含函数。\n\u0026gt; (require mod_demo/ext/cake) \u0026gt; (print-cake 4) ...... .-||||||-. | | ------------ \u0026gt; 默认情况下，您安装的目录名称既用作包名称又用作包提供的collection\n将lib放入collection之后，仍然可以使用raco make来编译库的源文件，但是使用raco setup更加方便。尤其是修改了模块代码后，使用raco setup会重新编译所有库文件，并重新安装包。与raco make不同的是，raco setup 后面的参数是包名，即raco setup mod_demo, 而raco make后面是模块名，即raco make main.rkt。\n模块语法 模块文件开头处的#lang其实是模块形式的简写，但不能用于REPL。\n模块形式 普通形式的模块声明，可以工作于REPL\n (module name-id initial-module-path decl \u0026hellip;)\n name-id是模块的名字，initial-module-path 为初始化导入，每个decl可以是导入，或者导出，或者定义，或者表达式。\ninitial-module-path是必须的，模块内部也是一个环境（SICP中的环境，即上下文），内部使用的指令是需要通过initial-module-path引导的。常用的initial-module-path是racket, require/define/provide等等都来自racket。另一个常用的initial-module-path是racket-base,它提供的功能较少，但仍然是很常用。\n上一节中的“cake.rkt”也可以写成：\n(module cake racket (provide print-cake) (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline))) 这种模块形式是可以被REPL求值的（注意(require \u0026lsquo;cake)， 模块名cake需要被quote，因为这时cake是非文件的模块声明）：\n\u0026gt; (require \u0026#39;cake) \u0026gt; (print-cake 3) ... .-|||-. | | --------- 声明一个模块，其body不会被立刻求值，只有在显式地被require之后才会求值一次。\n\u0026gt; (module hi racket (printf \u0026#34;Hello\\n\u0026#34;)) \u0026gt; (require \u0026#39;hi) Hello \u0026gt; (require \u0026#39;hi) #lang #lang声明的模块的body没有特定的语法，因为其语法由#lang之后的名称所决定。\n比如，#lang racket的语法是：\n#lang racket decl ... 等同于：\n(module name racket decl ...) name是包含#lang形式的文件名\n子模块 一个模块可以嵌套在另一个模块中，父模块可以直接访问子模块导出的函数、定义、表达式。\n#lang racket (module zoo racket (provide tiger) (define tiger \u0026#34;Tony\u0026#34;)) (require \u0026#39;zoo) tiger module* module*形式类似module：\n(module* name-id initial-module-path-or-#f decl ...) module*与module的不同之处在于：\n 由module声明的子模块，可以被其父模块require, 但是子模块不能require父模块； 由module*声明的字模块，可以require父模块，但是父模块不能require该子模块；  此外，module*形式可以用#f代替initial-module-path，这意味着，子模块可以访问父模块所以绑定，包括未通过provide导出的绑定。\n因此，用module*和#f来声明一个模块的一个用途是，将某个模块未provide出去的绑定导出。\n#lang racket (provide print-cake) (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (module* extras #f (provide show)) 尽管show函数未导出，但是子模块extras却将其导出了，外部程序可以使用(require (submod \u0026ldquo;caske.rkt\u0026rdquo; extras))来访问隐藏的show函数。\nMain和Test子模块 #lang racket (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (module* main #f (print-cake 10)) 这个“cake.rkt”变体，包含了一个main子模块，并调用了print-cake函数。\n一般来说，运行一个模块时并不会运行其中由module*声明的子模块，但是main子模块除外。\nmain子模块并不一定由module*声明，如果不需要使用父模块的绑定，也可以由module来声明。 更常见的做法是由module+来声明\n(module+ name-id decl ...) module+声明的模块就像采用module*声明且使用#f作为initial-module-path的模块。此外，多个module+模块可以同名，同名的模块会组合成一个模块。这种组合特性可以用来定义一个test模块，在使用 raco test命令时就可以大显身手了。\n假设\u0026quot;physics.rkt\u0026quot; 为：\n#lang racket (module+ test (require rackunit) (define ε 1e-10)) (provide drop to-energy) (define (drop t) (* 1/2 9.8 t t)) (module+ test (check-= (drop 0) 0 ε) (check-= (drop 10) 490 ε)) (define (to-energy m) (* m (expt 299792458.0 2))) (module+ test (check-= (to-energy 0) 0 ε) (check-= (to-energy 1) 9e+16 1e+15)) 导入\u0026quot;physics.rkt\u0026quot; 时，并不会运行drop和to-energy的测试，不过运行raco test physics.rkt将会执行这些测试。\n这等价于使用module*:\n#lang racket (provide drop to-energy) (define (drop t) (* 1/2 49/5 t t)) (define (to-energy m) (* m (expt 299792458 2))) (module* test #f (require rackunit) (define ε 1e-10) (check-= (drop 0) 0 ε) (check-= (drop 10) 490 ε) (check-= (to-energy 0) 0 ε) (check-= (to-energy 1) 9e+16 1e+15)) module+的组合行为对main模块也有帮助，即使不需要组合， ( module+ main \u0026hellip;. )也是首选，因为它比( module* main #f \u0026hellip;. )更具可读性 。\nRequire require的定义为：\n (require require-spec \u0026hellip;)\n only-in 用来限制模块导出的绑定，也可重命名绑定\n\u0026gt; (module m (lib \u0026#34;racket\u0026#34;) (provide tastes-great? less-filling?) (define tastes-great? #t) (define less-filling? #t)) \u0026gt; (require (only-in \u0026#39;m tastes-great?)) \u0026gt; tastes-great? #t \u0026gt; less-filling? less-filling?: undefined; cannot reference an identifier before its definition in module: top-level \u0026gt; (require (only-in \u0026#39;m [less-filling? lite?])) \u0026gt; lite? #t except-in 是only-in的补充，用来排除某些绑定\n (except-in require-spec id \u0026hellip;)\n rename-in 与only-in类似。\n (rename-in require-spec [orig-id bind-id] \u0026hellip;)\n prefix-in  (prefix-in prefix-id require-spec) 给每一个require-spec的绑定添加前缀\n Provide  (provide provide-spec \u0026hellip;)\n provide-spec允许递归定义：\n id: 最简单的形式，上文中多次出现\n  (rename-out [orig-id export-id] \u0026hellip;): 重命名导出的绑定\n  (struct-out struct-id): 导出struct\n  (all-defined-out): 导出所有绑定，不推荐\n  (all-from-out module-path): 导出所有由module-path指定的绑定\n  (except-out provide-spec id \u0026hellip;): 排除id指定的绑定\n  (prefix-out prefix-id provide-spec)：给每个导出绑定添加一个前缀\n ","id":64,"section":"posts","summary":"模块基础 一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set! 通常，每个Racket模块驻留在自己的文件中，换句话说，可以","tags":["racket","module"],"title":"Racket Modules","uri":"https://lvsq.net/2021/07/racket-modules/","year":"2021"},{"content":"这是一个leet code出现的问题:\n 给 n 个非负整数 $a_1$，$a_2$，\u0026hellip;，$a_n$，每个数代表坐标中的一个点(i, $a_i$) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i, $a_i$) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n  说明：不能倾斜容器\n 更详细的描述请访问：https://leetcode-cn.com/problems/container-with-most-water/\n首先可以想到的最简单的方法，就是暴力求解，将所有的面积都计算出来，取最大值即可。下面给出(Racket)[https://racket-lang.org/]的代码，得益于函数式语言和S表达式强大的表现力，代码可以很短：\n(define/contract (max-area height) (-\u0026gt; (listof exact-integer?) exact-integer?) (define len (length height)) (cond ((\u0026lt; len 2) 0) ((= len 2) (area (list 1 (car height)) (list 2 (cadr height)))) (else (max (each-area height) (max-area (cdr height)))))) (define (area n1 n2) (* (- (car n2) (car n1)) (min (cadr n1) (cadr n2)))) (define (each-area height) (let ([first (list 1 (car height))]) (foldl max 0 (map (lambda (i h) (area first (list i h))) (range 2 (add1 (length height)) ) (cdr height))))) 上述解法虽然正确，但是效率很低, 如果有10000个整数，即n=10000，其执行时间超过了2秒：\n(time (max-area (build-list 10000 (lambda(x) (random 1000000))))) =\u0026gt; cpu time: 2387 real time: 2466 gc time: 137 那么有更好的解决方法吗？\n显然可以认为所有整数都保存在一个列表或者数组中，假设我们有两个指针，一个叫head，指向第一个整数, 表示为：head -\u0026gt; (i, $h_i$)，i为列表下标， $h_i$代表第i个整数值；另一个叫tail，指向最后一个整数，表示为tail -\u0026gt; (j, $h_j$)，我们可以仅仅利用这两个指针的移动，就能计算出最大的面积，其过程为：\n 计算由head和tail围成的矩形的面积$S_{ij}$, 矩形的长度x = j - i, 高度y = min ($h_i$, $h_j$); 将矩形收窄一格，即x减少1，那么有两种收窄方式：  将高度短的一侧收窄，那么，收窄后高度可能变大，则面积可能增大; 将高度长的一侧收窄，由于另一侧不变,但是长度变小了一格，则面积会变小;   因此，需要移动高度短的一侧，才有可能找到面积更大的矩形  很显然，使用双指针算法，时间复杂度降低到了$O(n)$。\nRacket 版本 ;;better solution (define/contract (max-area-pair-pointer height) (-\u0026gt; (listof exact-integer?) exact-integer?) (define (area n1 n2) (* (- (car n2) (car n1)) (min (cadr n1) (cadr n2)))) (let ([len (length height)]) (if (\u0026lt; len 2) 0 (let loop ([h height] [hindex (range 0 len)] [rheight (reverse height)] [rindex (reverse (range 0 len))] [maxa 0]) (let* ([head (list (car hindex) (car h))] [tail (list (car rindex) (car rheight))] [a (area head tail)]) (if (= (car head) (car tail)) maxa (if (\u0026gt; (cadr head) (cadr tail)) (loop h hindex (cdr rheight) (cdr rindex) (max maxa a)) (loop (cdr h) (cdr hindex) rheight rindex (max maxa a))) )))))) 如果使用这个方法计算10000个整数的面积，执行时间只需1毫秒，而且不需要GC（对照暴力破解版本，2+秒）\n(time (max-area-pair-pointer (build-list 10000 (lambda(x) (random 1000000))))) =\u0026gt; cpu time: 1 real time: 1 gc time: 0 Rust版本 同时提供一个Rust版本的实现，\nuse std::cmp::{max, min}; type HeightType = i64; #[derive(Debug)] struct Solution {} impl Solution { pub fn max_area(height: Vec\u0026lt;HeightType\u0026gt;) -\u0026gt; HeightType { let len = height.len(); return if len \u0026lt; 2 { 0 } else { let mut max_area = 0; let mut hi = 0; let mut ti = len - 1; while ti \u0026gt; hi { let hd = height.get(hi).unwrap(); let td = height.get(ti).unwrap(); let a = ((ti - hi) as HeightType) * min(hd, td); max_area = max(max_area, a); if hd \u0026lt; td { hi += 1; } else { ti -= 1; } } max_area }; } } 两个版本做一个简单的比较：\n   size Racket(8.0 CS) Rust(1.50.0)     100000 49ms 60ms   1000000 560ms 550ms   10000000 5s 5.6s    两个版本的实现均未使用编译器优化,令人意外的是Racket的执行效率与Rust几乎没有差别，使用了CS编译器的Racket真是突飞猛进。 由于我的Rust经验并不是很多，或许有更好的写法。从测试可以看到Racket至少在CPU密集型应用中可堪大用。\n","id":65,"section":"posts","summary":"这是一个leet code出现的问题: 给 n 个非负整数 $a_1$，$a_2$，\u0026hellip;，$a_n$，每个数代表坐标中的一个点(i, $a_i$) 。在","tags":[],"title":"【盛最多水的容器】问题的求解","uri":"https://lvsq.net/2021/05/container-with-most-water/","year":"2021"},{"content":"神经科学家发现，解释代码可以激活通用的大脑网络，但不能激活语言处理中心。\n安妮·特拉夫顿 | 麻省理工学院新闻办公室 发布日期：2020年12月15日\n 在某些方面，学习计算机编程与学习新语言相似。它需要学习新的符号和术语，必须正确组织这些符号和术语以指导计算机该怎么做。计算机代码还必须足够清晰，以便其他程序员可以阅读和理解。\n尽管存在这些相似之处，麻省理工学院的神经科学家发现，阅读计算机代码并不能激活与语言处理有关的大脑区域。取而代之的是，它激活了一个称为多需求网络的分布式网络，该网络也被招募用于解决复杂的认知任务，例如解决数学问题或填字游戏。\n但是，尽管阅读计算机代码会激活多需求网络，但与数学或逻辑问题相比，它似乎更多地依赖于网络的不同部分，这表明编码也不能精确地复制数学的认知需求。\n“理解计算机代码似乎是自己的事。它与语言不同，数学与逻辑也不相同。”麻省理工学院研究生，该研究的主要作者安娜·伊凡诺娃（Anna Ivanova）说。\nEvelina Fedorenko，Frederick A.和Carole J. Middleton职业发展神经科学副教授，麦戈文脑科学研究所的成员，是该论文的高级作者，该论文今天发表在eLife上。麻省理工学院计算机科学与人工智能实验室和塔夫茨大学的研究人员也参与了这项研究。\n语言与认知 Fedorenko研究的主要重点是语言与其他认知功能之间的关系。特别是，她一直在研究其他功能是否依赖于大脑的语言网络（包括Broca区域和大脑左半球的其他区域）的问题。在先前的工作中，她的实验室表明，音乐和数学似乎并未激活该语言网络。\n“在这里，我们有兴趣探索语言和计算机编程之间的关系，部分原因是计算机编程是一个新发明，我们知道不可能有任何硬连线机制使我们成为优秀的程序员，”伊万诺娃说。\n她说，关于大脑如何学习编码，存在两种思想流派。有人认为，要精通编程，就必须精通数学。另一个建议认为，由于编码和语言之间的相似性，语言技能可能更相关。为了阐明这一问题，研究人员着手研究在阅读计算机代码时大脑活动模式是否会与语言相关的大脑活动重叠。\n研究人员在本研究中重点关注以可读性着称的两种编程语言——Python和ScratchJr。ScratchJr这是一种专为5岁及5岁以上儿童设计的可视化编程语言。研究对象均为精通测试语言的年轻人。当程序员躺在功能磁共振（fMRI）扫描仪中时，研究人员向他们展示了代码片段，并要求他们预测代码将产生什么动作。\n研究人员几乎看不到大脑语言区域对代码的反应。相反，他们发现编码任务主要激活了所谓的多需求网络。这个网络的活动遍布整个大脑的额叶和顶叶，通常是为需要同时记住许多信息的任务而招募的，它负责我们执行各种心理任务的能力。\n伊万诺娃说：“它所做的几乎所有在认知上都具有挑战性的事情，使您难以思考。”\n先前的研究表明，数学和逻辑问题似乎主要取决于左半球的多个需求区域，而涉及空间导航的任务比右半球更多地激活右半球。麻省理工学院的研究小组发现，读取计算机代码似乎可以激活多需求网络的左侧和右侧，而ScratchJr激活右侧的程度要比左侧高一些。这一发现违背了数学和编码依赖相同大脑机制的假设。\n经验的影响 研究人员说，尽管他们没有发现任何似乎专门用于编程的区域，但是这种具有特殊脑活动的区域可能会在具有更多编码经验的人中发展。\nFedorenko说：“如果您聘用了以30年或40年的特定语言编写代码的专业程序员的人，您可能会开始看到某些专业化知识，或者是多个需求系统某些部分的结晶”，Fedorenko说。“对于那些熟悉编码并且可以有效地完成这些任务，但经验相对有限的人来说，似乎您还看不到任何专业化知识。”\n约翰·霍普金斯大学的一组研究人员在同一期eLife上发表的一篇伴随论文中也报告说，解决代码问题可以激活多需求网络而不是语言区域。\n研究结果表明，对于编码应该以基于数学的技能还是基于语言的技能进行教授，尚无定论。研究人员说，部分原因是因为学习编程可能会同时依赖语言和多种需求系统，即使—一旦学会了编程，就不会依赖语言区域。\n伊万诺娃说：“两个阵营都宣称，它必须与数学结合在一起，必须与语言结合在一起。” “但是看来，计算机科学教育者将不得不开发自己的方法来最有效地教授代码。”\n全文完。\n 如果您想看原文，可以访问：链接\n","id":66,"section":"posts","summary":"神经科学家发现，解释代码可以激活通用的大脑网络，但不能激活语言处理中心。 安妮·特拉夫顿 | 麻省理工学院新闻办公室 发布日期：2020年12月15","tags":[],"title":"对大脑而言，阅读计算机代码与阅读语言不同","uri":"https://lvsq.net/2020/12/brain-reading-computer-code/","year":"2020"},{"content":"作者\nMATTHEW FLATT, University of Utah,USACANER DERICI, Indiana University, USAR. KENT DYBVIG, Cisco Systems, Inc., USAANDREW W. KEEP, Cisco Systems, Inc., USAGUSTAVO E. MASSACCESI, Universidad de Buenos Aires, ArgentinaSARAH SPALL, Indiana University, USASAM TOBIN-HOCHSTADT, Indiana University, USAJON ZEPPIERI, independent researcher, USA 概要\n我们在Chez Scheme上重建了Racket，并且运行良好——只要对Chez Scheme进行一些修补，就可以运行DrRacket。Racket发行版可以自行构建，并且几乎所有核心​​的Racket测试套件都可以通过。尽管仍有一些工作可以提高端到端的性能，但最终的实现还是不错的。我们评估的最不可预测的部分是，Racket和Chez Scheme之间的不同将变得多大，以及我们如何处理这些不同。我们希望Racket CS成为主要的Racket实现，并且我们鼓励其他语言实现者将Chez Scheme视为目标虚拟机。\n 该文详细地介绍了Racket CS是如何构建的，以及与Chez Scheme之间的差异， 完整内容见(https://dl.acm.org/doi/epdf/10.1145/3341642)\n","id":67,"section":"posts","summary":"作者 MATTHEW FLATT, University of Utah,USACANER DERICI, Indiana University, USAR. KENT DYBVIG, Cisco Systems, Inc., USAANDREW W. KEEP, Cisco Systems, Inc., USAGUSTAVO E. MASSACCESI, Universidad de Buenos Aires, ArgentinaSARAH SPALL, Indiana University, USASAM TOBIN-HOCHSTADT, Indiana University, USAJON ZEPPIERI, independent researcher, USA 概要 我们在Chez Scheme上重建了Racket，并且","tags":["pl"],"title":"基于Chez Scheme重建Racket","uri":"https://lvsq.net/2020/10/rebuilding-racket/","year":"2020"},{"content":"我相信每一位程序员在学习或者实践编程时，都会遇到作用域的问题。您可能觉得作用域很简单，甚至都不能当做一个问题来看待，我想原因可能是目前主流的计算机语言Java, Python, C等等几乎一致采用Lexical Scoping,程序员没有机会察觉到异样，从而掩盖了还有其他作用域的事实，许多教科书也很配合地一笔带过，当然还有一种可能是您已经洞察了不同作用域的差异和内涵，自觉地规避了问题。我衷心的希望所有程序员都是第二种可能。\n本文将浅显地描述两种作用域的特点及差异，希望可以解释地清楚一点，如果读完之后您更加模糊了，请记住，这并非我的本意。\n在计算机编程中，名称绑定的作用域（名称与实体的关联，比如变量）是程序中名称绑定有效的部分，也就是说，该名称可以被引用到一个实体。程序的其他部分，名称可能指向不同的实体（它可能具有不同的绑定），或者根本什么都没有（它可能是未绑定的）。作用域也称为实体的可见性， 尤其在较早的技术文献中可见，这是从所引用的实体的角度出发，而非引用的名称。\n术语\u0026quot;scope\u0026ldquo;也用于指代程序中有效的名称绑定的那部分集合，更加正确的称呼应该是上下文 或者 环境\n Lexical Scoping 词法作用域，某些书中也叫静态作用域，其在编写代码时或者说定义时就确定的，通过文本（源代码）就可以观察到名称与实体的关联，程序运行时会在距离被调用代码最近的环境中去查找绑定，如果存在多个环境，在优先从最里面一层的环境查找。\n来看一个例子：\n(setf x 1) ;; bind x to 1 (setq f (let ((x 2)) ;; bind x to 2 (lambda (y) (* x y)))) (funcall f 3) ;; result is 6 (format t \u0026#34;X = ~d \u0026#34; x) ;; X = 1 先绑定x为1，然后定义一个函数f，f中的变量x绑定为2，实际上f形成了一个闭包，由于两个x的环境不同，所以互不干扰，结果正是我们期望的，这就属于词法作用域。\nDynamic Scoping 动态作用域曾经让很多人深恶痛绝，以至于不愿意再提起它。早期的Lisp普遍使用了动态作用域，并带来了非常严重的问题，这也是Lisp Machine被Unix打败的除了商业因素之外的重要原因，Lisp至今未成为主流语言就不难理解了，尽管Lisp的语法最精炼、最优美，还具有最强悍的宏系统，还是世界上第一个使用GC的语言\u0026hellip;\n庆幸的是，Scheme, Common Lisp等Lisp方言已经都是用了Lexial Scoping（局部变量。所以某些时候我们可以把Lexical Scoping和Local Variable等价）, 我们无需再为一些莫名其妙的问题而烦恼，珍惜生命，不是吗？ 不过Scheme, Common Lisp还是保留了动态作用域的操作，Scheme可以参考Fluid Binding, Common Lisp的动态作用域将在后文举例说明，尽管如此，我们无需为这个保留担忧，因为基本上我们很少需要使用到这个功能。\n所谓dynamic scoping就是说，在函数定义中存在了“自由变量”（free variable）, 会在运行时随着函数的“调用位置”不同而发生变化，还是用上面的例子来说明，但是稍作变化：\n(defvar x 1) ;; bind x to 1, x is a free variable (setq f (let ((x 2)) ;; bind x to 2 (lambda (y) (* x y)))) (funcall f 3) (format t \u0026#34;X = ~d \u0026#34; x) (let ((x 100)) (format t \u0026#34;Inner X is ~d \u0026#34; x)) (defvar x 1)定义了x，值为1，但是这个x属于自由变量，处于动态作用域，因为Lisp自动将全局变量即由defvar、defparameter、special定义的变量自动声明为动态作用域。 x对于(lambda (y) (* x y))来说是“ **自由** ” 的，它可不会在意x绑定为2或者任何其他值，因为(let ((x 2)) \u0026hellip;)中指定的x已经不是(lambda \u0026hellip;)的参数了。\n所以当我们执行(funcall f 3) 时，其结果不像词法作用域那样等于6，而是3\n(format t \u0026ldquo;X = ~d \u0026quot; x) 依然输出： X = 1\n(let ((x 100)) (format t \u0026ldquo;Inner X is ~d \u0026quot; x)) 输出为：Inner X is 100。 等等，这里的x为什么又是100了？ 还记得上文提到的环境 吗？！\n如果将函数f放到不同的位置执行会发生什么？ 上面(funcall f 3)是在顶层执行的，我们换到let中执行会怎么样？\n(let ((x 2)) (funcall f 3)) 这次居然返回6，而不是3了。\n看到问题了吗？函数f的行为，会随着调用位置的一个名叫x的变量的值的不同而变化。虽然都叫x，但并不是同一个变量，只是名字相同而已。顺带提一句，现在可以理解Java中namespace的用处了吧。\n 词法作用域是通过搜索本地词法上下文解决的，而动态作用域是通过搜索本地执行上下文（即位置）解决的。这是编译器必须面对并解决的问题，或许编写程序时无需过多关注，但是多了解一下一定大有裨益。尽管动态作用域存在很大问题，但它并非洪水猛兽，它可以使全局变量更易于管理；假设您希望临时改变自由变量的值时，也可以声明为dynamic socping；另外在异常处理中也可以使用动态作用域将处理程序与异常相关联。\n","id":68,"section":"posts","summary":"我相信每一位程序员在学习或者实践编程时，都会遇到作用域的问题。您可能觉得作用域很简单，甚至都不能当做一个问题来看待，我想原因可能是目前主流的","tags":["lexical","scoping"],"title":"Lexical Scoping and Dynamic Scoping","uri":"https://lvsq.net/2020/09/lexical-dynamic-scoping/","year":"2020"},{"content":"快速排序是一种常见的排序手段，由C.A.R.Hoare在1960年提出。其基本思路为：\n  设定一个分界值，通常为第一个元素；\n  遍历列表，将所有小于分界值的元素集中到列表的左侧，所有大于或等于分界值的元素集中到右侧；\n  分别对左侧和右侧的元素进行快排；\n  重复上述的步骤，排序完成；\n  在平均状况下，排序n个元素需要$O(nlog n)$复杂度，最坏情况下需要$O(n^2)$,但一般很少出现这种情况。\n从算法的原理可以看出，需要多次执行重复的操作，自然采用递归可以减少很多代码，若问递归技术哪家强？首屈一指Lisp,下面给出CL版本的快排实现（简易版本，只支持数字类型的列表，其他类型的排序只需增加一个比较函数即可，本文不扩展）：\n(defun quickSort (lst) (let ( (len (list-length lst)) (st (lambda (l pk) ;; st函数实现上述第2步 (let ((left nil) (right nil)) (dolist (each l) (if (\u0026lt; each pk) (push each left) (push each right))) (values left right) ) ) ) ) (if (\u0026lt; len 2) lst (multiple-value-bind (l r) (st (cdr lst) (car lst)) (append (quickSort l) (cons (car lst) (quickSort r)))) ) ) ) (quickSort \u0026#39;(1 2 6 3 5 4)) =\u0026gt; (1 2 3 4 5 6) st函数可以用宏来实现：\n(defmacro st (lst pk) (let ((gslist (gensym))) `(let ((,gslist ,lst)) (let ((left nil) (right nil)) (dolist (each ,gslist) (if (\u0026lt; each ,pk) (push each left) (push each right))) (values left right) ) ) ) ) (defun quickSort (lst) (let ( (len (list-length lst)) ) (if (\u0026lt; len 2) lst (multiple-value-bind (l r) (st (cdr lst) (car lst)) (append (quickSort l) (cons (car lst) (quickSort r)))) ) ) ) ","id":69,"section":"posts","summary":"快速排序是一种常见的排序手段，由C.A.R.Hoare在1960年提出。其基本思路为： 设定一个分界值，通常为第一个元素； 遍历列表，将所有小于","tags":["lisp"],"title":"快速排序（Lisp版本）","uri":"https://lvsq.net/2020/07/quick-sort-in-cl/","year":"2020"},{"content":"讲故事并不是我擅长的事情，不过事情总有一个开始，诸位看官莫嫌我絮烦，只是希望可以讲述的更有条理一些。某日正读一本关于Erlang的书，书中出了一个关于八皇后的题目，这是计算机科学中经典的问题，当年上学时曾绞尽脑汁仍然云山雾罩，不得其解。如今再次相遇，岂能再坐壁上观？！更何况手边已有趁手的兵器。试看Erlang的实现：\n-module(queens). -export([queens/1]). queens(0) -\u0026gt; [[]]; queens(N) -\u0026gt; [[Row | Columns] || Columns \u0026lt;- queens(N - 1), Row \u0026lt;- lists:seq(1, 8) -- Columns, safe(Row, Columns, 1)]. safe(_Row, [], _N) -\u0026gt; true; safe(Row, [Column | Columns], N) -\u0026gt; (Row /= Column + N) andalso (Row /= Column - N) andalso safe(Row, Columns, (N + 1)). 从头至尾10行代码，如果不是为了使代码美观，6行足矣（这还包括了**-module** 和**-export** 两行声明语法，与算法本身无关的代码）。如此简短尽然可以清晰地实现复杂的**八皇后** 问题，如果采用命令式程序语言得写多少行？本文的重点不在于比较这个，Erlang是一门非常强大的语言，对于我来说Erlang好比探春，但是Scheme才是林黛玉呀，所以毫不迟疑用Scheme来实现：\n(define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence)))) ) (define (enumerate-interval low high) (if (\u0026gt; low high) \u0026#39;() (cons low (enumerate-interval (+ low 1) high))) ) (define (flatmap proc seq) (accumulate append \u0026#39;() (map proc seq)) ) (define empty-board \u0026#39;()) (define (safe? k position) (let loop ([new-queen (car position)] [rest-queens (cdr position)] [i 1]) (if (null? rest-queens) #t (let ([rest-current-queen (car rest-queens)]) (if (or (= new-queen rest-current-queen) (= new-queen (+ rest-current-queen i)) (= new-queen (- rest-current-queen i)) ) #f (loop new-queen (cdr rest-queens) (+ i 1)) ) ) ) ) ) (define (adjoin-position new-row k rest-of-queens) (cons new-row rest-of-queens) ) (define (queens board-size) (define (queen-cols k) (if (= k 0) (list empty-board) (filter (lambda (position) (safe? k position)) ;过滤无效的解 (flatmap (lambda (rest-of-queens) (map (lambda (new-row) ;扩充（k-1）个皇后的每一个解，给每个解都增加第k个皇后 (adjoin-position new-row k rest-of-queens)) (enumerate-interval 1 board-size) ) ) (queen-cols (- k 1)) ;前（k-1）个有效的皇后，虽然是太虚幻境，但可以认为是事实 ) ) ) ) (queen-cols board-size) ) Scheme版本比Erlang版本代码增加了不少，原因在于其没有模式匹配 和列表推导 这两大利器，不过我更喜欢Scheme强大的表现力，可以随心所欲地构造我需要的一切，而且S-表达式看起来十分优美自然。Scheme版本实际上解决了n-皇后，更进一步了。\n事情到这里并没有结束，原因在于我刚开始实现Scheme版本的八皇后时，选择翻译Erlang代码，最终失败了！一番挣扎之后，意识到该问题属于非确定性计算，猛然想起《SICP》中有一节专门介绍了此种计算，也即本文的主角——amb\n 非确定性计算 amb这个名字源于ambiguous ,其含义并不是很好理解。一番披肝沥胆之后，终于窥到了一些门径，趁机厘清很多知识点。我将尽力平铺直述，简要的介绍这种强大且十分有用的武器。\n首先，我们来观察一个问题：\n 假设有两个数组，数组中都是一些正整数，比如l1 = [1 2 3 4 5], l2 = [3 4 6 7 8]，我们分别从l1和l2中各取一个数字，相加之后，如果是素数，则满足要求。怎么办呢？\n 对于这个简单的问题，相信难不倒大家，采用回溯算法轻易就解决了，这里只是想引出“非确定性计算”的概念。非确定性计算和流处理类似，对于“生成和检测式”的应用特别有价值，它往往只描述问题，但没有描述问题的解决方法，这句话很有意思，如果暂时没有理解不用着急，继续往下看。\n对于非确定性计算，首先需要明确的一点是，表达式是允许存在多个值的，比如上面的问题的解至少有(1 4),(2 3)两个解吧。\n有一件很有教益的事情，那就是非确定性计算和流处理对于时间的不同看法。流处理利用了惰性求值，这会给我们一种错觉，仿佛所有可能的结果的出现没有时间顺序；对于非确定性的求值，一个表达式是对一个可能的世界的探索，每一个值都由一次选择所确定，某些选择会走入死胡同，而另一些会得到有用的值，所以非确定性计算给我们的感觉是，时间是有分支的。程序当中会保存所有可能的不同执行历史，在遇到一个死胡同时，总是可以回到以前的选择点，并沿着另一个分支继续下去。\n下面将要实现的非确定性求值器称为——amb求值器\namb求值器 假设目前已经扩充了Scheme以支持非确定性计算，引入了一种新的称为amb的新形式，表达式 $(amb \u0026lt;e_1\u0026gt; \u0026lt;e_2\u0026gt; \u0026hellip; \u0026lt;e_n\u0026gt;)$ 会“有歧义地”返回n个表达式之一的值，比如：\n(list (amb 1 2 3) (amb \u0026#39;a \u0026#39;b)) 可以有如下6个可能的值：(1 a) (1 b) (2 a) (2 b) (3 a) (3 b)\n对于没有选项的amb，即(amb) ——视为没有可接收值的表达式，这将导致求值“fail”。\namb求值器在每个选择点，总是选择第一个可能性，如果选择的结果失败，那么求值器自动地回溯到最近的选择点，去尝试下一个可能性。如果它用完了所以的可能性，则自动退回到上一个选择点，并从那里继续（这个“继续”很有意思，后文会看到，“继续”不但是结论，还是其实现的方式，一语双关）下去。从这个过程可以看出，这是一种深度优先 算法。\n逻辑谜题 在讨论amb求值器的实现之前，先看一道逻辑谜题：\n 曹操、孙权、刘备、袁绍、马超5人住在一栋5层的楼房里面，每人住一层。曹操不住顶层，孙权不住底层，刘备不住顶层也不住底层，袁绍比刘备高一层，马超与刘备不在相邻的楼层，刘备与孙权也不在相邻的楼层，请问他们各住在哪一层？\n 在没有amb时，代码怎么写呢？恐怕不容易吧。但是现在有了amb求值器，瞬间美好了：\n(define (multiple-dwelling) (let ( [caocao (amb 1 2 3 4 5)] [sunquan (amb 1 2 3 4 5)] [liubei (amb 1 2 3 4 5)] [yuanshao (amb 1 2 3 4 5)] [machao (amb 1 2 3 4 5)] ) (require (distinct? (list caocao sunquan liubei yuanshao machao))) (require (not (= caocao 5))) (require (not (= sunquan 1))) (require (not (= liubei 5))) (require (not (= liubei 1))) (require (\u0026gt; yuanshao liubei)) (require (not (= (abs (- machao liubei)) 1)) (require (not (= (abs (- sunquan liubei)) 1)) (list (list \u0026#39;caocao caocao) (list \u0026#39;sunquan sunquan) (list \u0026#39;liubei liubei) (list \u0026#39;yuanshao yuanshao) (list \u0026#39;machao machao)) ) ) 上述代码只是描述问题的关系，即各个require部分（先不考虑性能问题。还记得上文提到的“描述问题，但没有描述问题的解决方法”吗？），并没有添加什么“处理逻辑”，但是会产生下面结果：\n((caocao 3) (sunquan 2) (liubei 4) (yuanshao 5) (machao 1))\n居然得到了谜题的解，这是什么魔法？？？\namb轻而易举地解决了这种需要大量回溯的问题。\n实现 现在该谈一谈神奇的amb如何实现了吧。前文已经多次提到过，amb求值的过程可能会不断的回溯，这势必导致程序流程的跳转，程序跳转该怎么办呢？函数式语言可没有break,continue之类的语法，因为根本不需要，那么函数式语言有啥？答案是continuation(翻译成继续，或者延续都可以。还记得“一语双关”吗？)\nScheme内置了这个强大的控制抽象，过程名为：call-with-current-continuation， 名字略长，不过一般都是用其缩写：call/cc。囿于篇幅，本文不打算介绍continuation，如果想详细了解它，请自行搜索。\n常规求值器的执行过程有一个参数：执行环境env。amb求值器的执行过程有三个参数，除了执行环境env之外，还有两个continuation过程（一个成功延续、一个失败延续）。对一个表达式进行求值，结束后会调用这两个continuation过程之一：如果此次求值得到了一个结果，则调用成功延续；如果结果是遇到了死胡同，则调用失败延续。\n成功延续的工作是：接受一个值，并将计算进行去下，与这个值一起，成功延续过程还将得到一个另一个失败延续，如果使用该值时遇到了死胡同，则需要调用这个失败延续。\n失败延续的工作是：试探非确定性过程的另一个分支。非确定性计算的最关键的特征，在于表达式可以表示于不同可能性之间的选择。\n我承认有点烧脑，但还算清晰，让递归在脑海中奔涌吧。\n利用宏来简化amb的构造，代码参考这里：\n(define amb-fail \u0026#39;*) (define initialize-amb-fail (lambda () (set! amb-fail (lambda () (error \u0026#34;amb tree exhausted\u0026#34;))))) (initialize-amb-fail) (define-syntax amb (syntax-rules () ((amb alt ...) (let ((prev-amb-fail amb-fail)) ;保存前一个选择点 (call/cc (lambda (sk) ;对于整个amb表达式构造一个sk的contnuation (call/cc (lambda (fk) ;对于每一个amb的选项构造一个fk的continuation (set! amb-fail ;先把amb-fail设置为一个函数，该函数可将amb-fail恢复到进入amb前的值 (lambda () (set! amb-fail prev-amb-fail) (fk \u0026#39;fail)) ) (sk alt) ;立即返回自己的分支的值,从而引起amb表达式中途返回。注意，每一个分支执行时都会引起 amb 立即返回。后面的分支都还没有执行！ ) ) ... (prev-amb-fail) ) ) ) ) ) ) 第一个选项（也可以叫分支）会被立即返回，后面的暂时不执行。假设该值被认为是“无效的（比如应用该值后，执行到(amb)了）”，则执行(prev-amb-fail)，而prev-amb-fail在进入amb的时候被绑定到了amb-fail， 不过amb-fail已被设置成了一个函数：\n(lambda () (set! amb-fail prev-amb-fail) (fk \u0026#39;fail)) 它先把amb-fail设置成prev-amb-fail,也就是进入（amb alt \u0026hellip;）之前的值， 然后用(fk \u0026lsquo;fail)返回\u0026rsquo;fail到分支的continuation，即可以执行下一个分支（下一个选项）了。\n十分精巧的程序！！！\n上述的amb每次只能返回一个结果，如果需要返回所有有效的结果，可以用下面定义的宏：\n(define-syntax bag-of (syntax-rules () ((bag-of e) (let ((prev-amb-fail amb-fail) (results \u0026#39;())) (if (call/cc (lambda (k) (set! amb-fail (lambda () (k #f))) ;\u0026lt;-----+ (let ((v e)) ;amb-fail will be modified by e | (set! results (cons v results)) ;| (k #t)))) ;| (amb-fail)) ;so this amb-fail may not be ---+ (set! amb-fail prev-amb-fail) (reverse! results))))) (bag-of (let ([a (amb 1 2 3)] [b (amb 0 -1 2)]) (if (= (+ a b) 1) (list a b) (amb)) )) ;结果为：((1 0) (2 -1)) 回到n-皇后问题 到目前为止，我已手握amb这把利器，是时候重构一下n-皇后问题了。\n(define number-between (lambda (lo hi) (let loop ((i lo)) (if (\u0026gt; i hi) (amb) (amb i (loop (+ i 1))))))) ; (amb 1 (amb 2 (amb 3 ... ))) (define (n-queens n) (call/cc (lambda (return) (let add-queen ([i 0] [result \u0026#39;()]) (when (\u0026lt; i n) ;最多摆几个皇后 (let ([new-queen (number-between 1 n)]) (if (safe? n (append (list new-queen) result)) ;新加入的皇后必须是有效的 (add-queen (+ i 1) (append (list new-queen) result)) (amb)) ) ) (return result) ) ) ) ) (bag-of (n-queens 8)) ;8个皇后的所有解 该版本比之前的Scheme版本的实现改进了很多，现在只需要描述一下我的问题的关系即可，程序会自动选择所有正确的值，无需关心计算机内部到底发生了什么。在面对很多逻辑问题时，我们可以很轻松地解决了。\n也许有人会问，如果采用命令式语言来处理的话，可能几个嵌套的循环也能达到相同的结果，如此大费周章的介绍这个叫amb的技术，到底有什么价值呢？ 那就来聊一聊。\n有什么意义？ 在谈论意义之前，容许我提一个问题\n 为什么SQL语言要设计成这样？与命令式语言如此的不同？\n 首先需要明确的一点是，计算机科学处理的是命令式（怎样做）的知识，而数学处理的是说明式（是什么）的知识。 事实上，人类不可能只面临其中一种问题，程序设计中一个重要的分支就是逻辑程序设计，有很多问题或者数据之间存在着关联关系，难以观测到结论，描述它们的关系很简单，但是直接告诉计算机如何去做却不那么容易，或许我们可以为若干此类问题编写命令式代码，但是不可能对所有这样的问题都编写代码，显然信息之间的关系是多种多样的，那么代码就需要相应的变化，往往修改这样的代码是很困难的， 甚至需要重新设计并编码。另一方面，如果程序设计可以处理说明式的知识，岂不是大大减轻了程序员的工作了呢？函数式语言的设计是基于lambda理论，围绕着数学函数值的计算组织起来的，依靠其强大的表现力，在处理逻辑问题上更加得心应手，可以化繁为简。\n说到这里，是不是觉得，保存在数据库中的数据之间存在着种种联系呢？SQL正是描述了这种关系，我们只需要告诉数据库我们需要什么数据（select）, 数据在什么位置（from）, 哪些是有意义的（where）就行了，并不需要告诉数据库该如何具体操作，数据库可以根据我们的描述（SQL）就能够准确的返回结果，这真是关于非确定性计算的一个极好的例子，此时我们总该明白为什么数据库叫做关系型数据库 了吧。我们不妨设想一下，如果不采用描述的方式来查询数据，程序员们该怎么做？还能够轻易的查找到需要的数据吗？\n刚才我提出的问题，想必此刻应该有答案了。\n","id":70,"section":"posts","summary":"讲故事并不是我擅长的事情，不过事情总有一个开始，诸位看官莫嫌我絮烦，只是希望可以讲述的更有条理一些。某日正读一本关于Erlang的书，书中出","tags":["scheme"],"title":"从“八皇后”到amb","uri":"https://lvsq.net/2020/05/n-queens/","year":"2020"},{"content":"作者是 Francesco Cesarini \u0026amp; Gabor Olah\n 任何编程语言在Erlang生态系统中的成功都可以分为三个紧密耦合的组件。它们是：1）Erlang编程语言的语义，并在其上实现其他语言2）用于构建可伸缩和弹性并发系统的OTP库和中间件，以及3）与语言语义紧密耦合的BEAM虚拟机和OTP。单独使用这些组件中的任何一个，您将获得亚军。但是，将这三个因素放在一起，您将获得可伸缩，灵活的软实时系统的无可争议的赢家。引用Joe Armstrong的话：“您可以复制Erlang库，但是如果它不能在BEAM上运行，则无法模拟语义”。这是由罗伯特·维尔丁（Robert Virding）的《第一条编程规则》强制执行的，该条规定：“任何另一种足够复杂的并发程序都使用另一种语言，包含非正式的，临时指定的，bug缠身的缓慢的Erlang一半实现。”\n在本文中，我们想探索BEAM VM内部。我们将在适用的情况下将它们与JVM进行比较和对比，强调您为什么要注意它们并加以注意。长期以来，此组件一直被视为黑匣子，并且在不了解原因或含义的情况下被视为理所当然。现在该改变这种情况了！\nBEAM的亮点 发明Erlang和BEAM VM是解决特定问题的正确工具。它们是由爱立信开发的，旨在帮助实现处理移动和固定网络的电信基础设施。该基础架构本质上是高度并发和可伸缩的。它必须显示软实时属性，并且永远不会失败。我们不希望在手机上与祖母进行环聊通话时掉线或Fortnite的在线游戏体验不会受到系统升级，高用户负载或软件，硬件和网络中断的影响。BEAM VM通过提供可在可预测的并发编程模型之上运行的微调功能进行了优化，以解决许多挑战。\n它的秘诀是轻量级进程，它们不共享内存，由调度程序管理，该调度程序可以跨多个内核管理数百万个进程。它使用基于每个进程运行的垃圾收集器，并对其进行了高度优化以减少对其他进程的影响。结果，垃圾收集器不会影响系统的整体软实时属性。BEAM也是唯一使用规模广泛且具有内置分发模型的VM，它具有内置的分发模型，该模型允许程序透明地在多台计算机上运行。\nJVM的亮点 Java虚拟机（JVM）是​​由Sun Microsystem开发的，旨在提供一个可在任何地方运行的“一次写入”代码的平台。他们创建了一种类似于C++的面向对象的语言，但是内存安全，因为其运行时错误检测会检查数组范围和指针取消引用。在Internet时代，JVM生态系统变得非常流行，使其成为企业服务器应用程序的实际标准。满足广泛用例的虚拟机和可满足企业发展需求的令人印象深刻的库集使广泛的适用性成为可能。\nJVM设计时考虑了效率。它的大多数概念是流行操作系统中功能的抽象，例如映射到操作系统线程的线程模型。JVM是高度可定制的，包括垃圾收集器（GC）和类加载器。一些最先进的GC实现提供高度可调整的功能，以适应基于共享内存的编程模型。JVM允许您在程序运行时更改代码。而且，JIT编译器允许将字节码编译为本机代码，目的是加快应用程序的各个部分。\nJava世界中的并发性主要与在并行线程中运行应用程序有关，以确保它们是快速的。由于并发原语的共享内存模型带来了挑战，因此使用并发原语进行编程是一项艰巨的任务。为了克服这些困难，人们尝试简化和统一并发编程模型，最成功的尝试是Akka框架。\n并发与并行 如果部分代码在多个内核，处理器或计算机上同时运行，则我们谈论并行代码执行，而并发编程是指独立处理到达系统的事件。可以在单线程硬件上模拟并发执行，而并行执行则不能。尽管这种区别似乎很古怪，但这种差异导致需要解决的问题非常不同。想想很多厨师在做一盘Carbonara意大利面。在并行方法中，将任务分配给可用厨师的数量，并且只要完成这些厨师完成其特定任务的速度，就可以完成单个部分。在一个并发的世界中，每位厨师将获得一部分，每位厨师将完成所有任务。您将并行性用于速度，并发性用于规模。\n并行执行试图将问题的最佳分解解决为彼此独立的部分。将水煮沸，煮意大利面，混合鸡蛋，炸瓜里阿塞火腿，将佩克立诺奶酪磨碎1。共享数据（或在我们的示例中为餐盘）由锁，互斥锁和各种其他技术处理，以确保正确性。另一种看待这种情况的方式是存在数据（或成分），并且我们希望利用尽可能多的并行CPU资源来尽快完成工作。\n另一方面，并​​发编程处理许多事件，这些事件在不同的时间到达系统，并尝试在合理的时间内处理所有事件。在多核或分布式体系结构上，某些执行是并行运行的，但这不是必需的。另一种看待它的方法是，同一位厨师按照始终相同的顺序算法，将水煮沸，煮意大利面，混合鸡蛋等。跨过程（或做饭）的变化是要处理的数据（或成分），这些数据（或成分）存在于多个实例中。\nJVM是为并行而构建的，而BEAM是为并发构建的。它们是两个本质上不同的问题，需要不同的解决方案。\nBEAM和并发 BEAM提供轻量级流程为正在运行的代码提供上下文。这些进程也称为actor，不共享内存，而是通过消息传递进行通信，将数据从一个进程复制到另一个进程。消息传递是虚拟机通过各个进程拥有的邮箱实现的功能。消息传递是一种非阻塞操作，这意味着将消息发送到另一个进程几乎是即时的，并且不会阻塞发送者的执行。发送的消息采用不可变数据的形式，从发送过程的堆栈复制到接收者的邮箱。无需在进程之间使用锁和互斥锁即可实现此目的，而在多个进程并行将消息发送到同一收件人的情况下，只需对邮箱进行锁定即可。\n不变的数据和消息传递使程序员能够编写彼此独立工作的流程，并专注于功能而不是内存的低级管理和任务调度。事实证明，这种简单的设计不仅适用于单个线程，而且适用于在同一VM中运行的本地计算机上的多个线程，并使用内置的分发，在整个网络上通过VM和计算机集群运行。如果消息在进程之间是不可变的，则可以不加锁地将它们发送到另一个线程（或计算机），从而在分布式多核体系结构上几乎线性地扩展。进程在本地VM上的寻址方式与VM群集中的寻址方式相同，无论接收进程的位置如何，消息发送都是透明的。\n进程不共享内存，因此您可以复制数据以恢复弹性并分发数据以实现规模扩展。这意味着在两个不同的机器上具有相同进程的两个实例，彼此之间共享状态更新。如果一台计算机发生故障，则另一台计算机具有数据副本，并且可以继续处理该请求，从而使系统具有容错能力。如果两台计算机都可运行，则两个进程都可以处理请求，从而为您提供可伸缩性。BEAM为所有这些无缝集成提供了高度优化的原语，而OTP（“标准库”）则提供了更高级别的结构以简化程序员的生活。\nAkka在复制更高级别的结构方面做得很好，但是由于缺少JVM提供的原语而在一定程度上受到了限制，从而使其可以高度优化并发性。尽管JVM的原语支持更广泛的用例，但由于它们没有用于通信的内置原语且通常基于共享内存模型，因此它们使对分布式系统的编程变得更加困难。例如，您在分布式系统中的何处放置共享内存？以及访问它的成本是多少？\n调度器 我们提到过，BEAM的最强功能之一就是能够将程序分解为小的，轻量级的过程。管理这些过程是调度程序的任务。与JVM将其线程映射到OS线程并让操作系统调度它们不同，BEAM带有自己的调度程序。\n默认情况下，调度程序为每个内核启动一个OS线程，并优化它们之间的工作负载。每个过程都包含要执行的代码和随时间变化的状态。调度程序会选择运行队列中准备运行的第一个进程，并为其赋予定量的reductions（译者注：2000个），其中每次reduction都大致等同于一条指令。一旦进程用尽了reductions，会被I/O阻塞，等待消息或代码完成，调度程序就会在运行队列中选择下一个进程并将其分派（此句翻译有问题：原文是Once the process has either run out of reductions, is blocked by I/O, is waiting for a message or completes executing its code, the scheduler picks the next process in the run queue and dispatches it. 如果您有更好的翻译请不吝指教）。这种调度技术称为抢先式。\n我们多次提到Akka框架，因为它的最大缺点是需要在调度处添加注解，因为调度不是在JVM级别进行的。通过解除程序员的控制，可以保留和保证软实时属性，从而减低了导致进程饿死的风险。\n进程围绕着调度程序线程，并最大程度地利用CPU。有许多方法可以调整调度程序，但是它很少见，仅在边缘和边界情况下才需要，因为默认选项涵盖了大多数使用模式。\n关于调度程序，经常出现一个敏感的话题：如何处理本机实现的函数（NIF）。NIF是用C编写的代码片段，被编译为库并在与BEAM相同的内存空间中运行以提高速度。NIF的问题在于它们不是抢占式的，并且会影响调度程序。在最新的BEAM版本中，添加了一项新功能，即脏调度程序，以更好地控制NIF。肮脏的调度程序是在不同线程中运行的单独的调度程序，以最大程度地减少NIF对系统造成的中断。脏这个词是指这些调度程序运行的代码的性质。\n垃圾收集器 当今，现代的高级编程语言大多使用垃圾回收器进行内存管理。BEAM语言也不例外。当您要编写高级并发代码时，信任虚拟机来处理资源和管理内存非常方便，因为这可以简化任务。归功于基于不可变状态的内存模型，垃圾收集器的基础实现非常简单有效。数据被复制而不是突变，并且进程不共享内存这一事实消除了任何进程的相互依赖关系，因此不需要管理它们。\nBEAM的另一个功能是，仅在需要时才在每个进程的基础上运行垃圾回收，而不会影响在运行队列中等待的其他进程。结果，Erlang中的垃圾收集不会“stop-the-world”。它可以防止处理延迟高峰，因为VM不会从整体上停止——仅特定进程停止，并且绝不会同时停止所有进程。实际上，这只是流程的一部分，并且被视为另一种reduction。垃圾收集器收集过程将过程暂停很短的时间间隔，通常是微秒。代价是，将有许多小的爆发（bursts），仅在进程需要更多内存时才触发。单个进程通常不会分配大量内存，并且通常是短暂的，通过在终止时立即释放所有分配的内存，进一步降低了影响。JVM的一个功能是具备切换垃圾收集器的能力，因此，通过使用商用GC，还可以在JVM中实现不间断的GC。\nLukas Larsson在一篇出色的博客文章中讨论了垃圾收集器的功能。有许多复杂的细节，但已对其进行了优化以有效地处理不可变数据，并为每个进程在堆栈和堆之间分配了数据。最好的方法是在短暂的过程中完成大部分工作。\n这个主题上经常出现的一个问题是BEAM使用多少内存。虚拟机在后台分配了大块内存，并使用自定义分配器来有效地存储数据并最大程度地减少系统调用的开销。这有两个明显的效果：1）在不需要空间之后，已用内存逐渐减少2）重新分配大量数据可能意味着将当前工作内存加倍。如果确实需要，可以通过调整分配器策略来减轻第一个影响。如果您可以看到不同类型的内存使用情况，则第二个易于监视和计划。（WombatOAM就是这样一种提供开箱即用的系统指标的监视工具。）\n热代码加载 热代码加载可能是BEAM引用最多的独特功能。热代码加载意味着可以通过更改系统中的可运行代码来更新应用程序逻辑，同时保留内部流程状态。这是通过替换已加载的BEAM文件并指示VM替换正在运行的进程中的代码引用来实现的。\n对于电信基础架构无需停机代码升级而言，这是一项至关重要的功能，被裁减的硬件可用于处理高峰。如今，在容器化时代，其他技术也可以实现产线的更新。从未使用过它的人会认为它是不重要的功能，但是在开发工作流程中仍然有用。开发人员可以通过替换部分代码来加快迭代速度，而不必重新启动系统来对其进行测试。即使该应用程序并非设计为可在生产环境中进行升级，也可以减少重新编译和重新部署所需的时间。\n何时不使用BEAM 正确的工具非常重要。您需要一个速度极快的系统，但不关心并发性吗？并行处理一些事件，并且必须快速处理它们？是否需要计算图形，人工智能或分析数据？沿C ++，Python或Java路线走。电信基础设施不需要快速运行，因此速度从来都不是优先事项。在动态类型的辅助下，它必须在运行时进行所有类型检查，这意味着编译器时间优化并不那么简单。因此，数字运算最好留给JVM，Go或其他编译成本地语言的语言使用。毫不奇怪，在JVM上运行的Erlang版本Erjang上的浮点运算比BEAM快5000％。但是我们看到BEAM大放异彩的地方是利用它的并发来安排数字运算，将分析外包给C，Julia，Python或Rust。您可以在BEAM外部做map，而在BEAM内部做reduce(译者注：map-reduce思想)。\n口头禅总是很快。人类感知刺激（事件）并在大脑中进行处理需要几百毫秒，这意味着对于许多应用而言，微秒或纳秒的响应时间并不是必需的。您也不会将BEAM用于微控制器，这太浪费资源了。但是对于具有更多处理能力的嵌入式系统（多核已成为常态），您需要并发性，而BEAM令人眼前一亮。上世纪90年代，我们实现了电话交换机，以处理运行在具有16MB内存的嵌入式板上的成千上万的用户。RaspberryPi都有多少内存了？还有，硬实时系统，您可能不希望BEAM管理您的安全气囊控制系统。你需要硬保证 仅仅是硬实时操作系统，没有垃圾收集或异常的语言。在诸如GRiSP之类的裸机上运行的Erlang VM的实现将为您提供类似的保证。\n结论 使用正确的工具完成工作。如果您正在编写一个软实时系统，而该系统必须能够立即扩展并且永远不会失败，并且无需重新发明轮子就可以做到，那么BEAM是您正在寻找的经过验证的技术。对于许多人来说，它就像一个黑匣子。不知道它的工作原理类似于驾驶法拉利，无法获得最佳性能或无法理解奇怪声音来自马达的哪个部分。这就是为什么您应该更多地了解BEAM，了解其内部结构并准备对其进行微调和修复的原因。对于在实际任务中使用Erlang和Elixir的人（译者注：in anger 的意思是to do or use something in a real situation），我们开设了一天的讲师指导课程，该课程通俗易懂并解释您所看到的很多内容，同时为您准备大规模处理大规模并发做好准备。在这里了解更多。我们也推荐Erik Stenman撰写的关于BEAM的书和Dmytro Lytovchenko的文章集——BEAM Wisdoms。\n","id":71,"section":"posts","summary":"作者是 Francesco Cesarini \u0026amp; Gabor Olah 任何编程语言在Erlang生态系统中的成功都可以分为三个紧密耦合的组件。它们是：1）Erlang编程语言的语义，并在其上实现","tags":["erlang"],"title":"[译]BEAM vs JVM","uri":"https://lvsq.net/2020/05/beam-vs-jvm/","year":"2020"},{"content":"实现 下面将使用Scheme语言来实现“无重复字符的最长子串”，即，对于字符串\u0026quot;abbabcx\u0026quot;,其最长无重复字符的子串为\u0026quot;abcx\u0026quot;，长度4，详细描述可访问https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n(let* ( [s \u0026#34;abbabcx\u0026#34;] [arr-index 0] [ans 0] [d -1] [vec (make-vector 128 -1)] [keep-last-position (lambda (c pos-in-s) (vector-set! vec c pos-in-s))] [scan (lambda (c pos-in-s) (let* ([previous-pos (vector-ref vec c)] [len 0]) (begin (when (and (\u0026gt;= previous-pos 0) (\u0026gt; previous-pos d)) (set! d previous-pos) ) (set! len (- pos-in-s d)) (keep-last-position c pos-in-s) (when (\u0026gt; len ans) (set! ans len)) ) ) )] ) ( string-for-each (lambda (e) (scan (char-\u0026gt;integer e) arr-index) (set! arr-index (+ arr-index 1))) s ) ans ) 实现的思路为：\n由于字符可以有ASCII码表示，故可以用一个长度为128的向量vec来保存每个字符在给定的字符串中出现的最后一次的位置。维护一个变量d来记录最近一次出现重复的字符的起始位置。 如果：\n 判断某字符是否重复：1.1 某字符第一次出现，执行第2步1.2 某字符非第一次出现，如果该字符上次出现的位置，在d之后，则将d设置为该字符上次出现的位置。由于之前的最大长度已经由ans保存，所以只需要计算剩下的子串的长度能不能大于ans，这就是为什么d记录最近一次出现重复的字符串的起始位置就好了 计算当前位置和d的长度len 保存其位置到vec 如果len大于ans，改变ans为len  这种实现只需遍历一遍就可以计算出结果，性能非常棒。当然暴力计算或者滑动窗口也可以实现该功能，只是需要多次遍历，性能比不上。\n概要分析 上文说到性能问题，拿点数据出来证明一下吧。\n将上面的代码稍微改造一下，作为一个definition，并保存在longest_substr.ss文件中，\n(define longest-substr (lambda (str) (let* ( [s str] [arr-index 0] [ans 0] [d -1] [vec (make-vector 128 -1)] [keep-last-position (lambda (c pos-in-s) (vector-set! vec c pos-in-s))] [scan (lambda (c pos-in-s) (let* ([previous-pos (vector-ref vec c)] [len 0]) (begin (when (and (\u0026gt;= previous-pos 0) (\u0026gt; previous-pos d)) (set! d previous-pos) ) (set! len (- pos-in-s d)) (keep-last-position c pos-in-s) (when (\u0026gt; len ans) (set! ans len)) ) ) )] ) ( string-for-each (lambda (e) (scan (char-\u0026gt;integer e) arr-index) (set! arr-index (+ arr-index 1))) s ) ans ) ) ) Chez Scheme提供了一个概要分析工具，非常好用，来试用一下： 生成的html可以非常直观的看到该函数的执行情况 字符串越长，执行次数越多，执行时间是多少呢？选一个上面例子中最长的字符串来看看：\n\u0026gt; (time (longest-substr \u0026#34;abcabcxsfsdfw232sdfssdfsdfsdfsf1234567890\u0026#34;)) (time (longest-substr \u0026#34;abcabcxsfsdfw232sdfssdfsdfsdfsf1234567890\u0026#34;)) no collections 0.000003672s elapsed cpu time 0.000002000s elapsed real time 1792 bytes allocated 12 \u0026gt; 消耗的CPU时间0.000003672s，可以说非常短了，且分配的内存仅仅1792个字节。超乎寻常的性能，我想应该有两个方面原因：\n 算法 Scheme 和 Chez Scheme  ","id":72,"section":"posts","summary":"实现 下面将使用Scheme语言来实现“无重复字符的最长子串”，即，对于字符串\u0026quot;abbabcx\u0026quot;,其最长无重复字符的子串为","tags":["scheme"],"title":"无重复字符的最长子串-Scheme实现","uri":"https://lvsq.net/2020/03/longest-substr/","year":"2020"},{"content":"为什么要用Go练习函数式编程？简而言之，正是由于缺少状态和可变数据，函数式编程使您的代码更易读，更易于测试且不太复杂。如果遇到错误，只要不违反函数式编程规则，就可以快速调试应用程序。当函数被隔离时，您不必处理影响输出的隐藏状态的更改。\n软件工程师兼作者Eric Elliot定义了以下函数编程。\n 函数式编程是通过组合纯函数，避免共享状态，可变数据和副作用来构建软件的过程。函数式编程是声明性的，而不是命令性的，应用程序状态通过纯函数流动。与面向对象的编程相反，后者通常将应用程序状态与对象中的方法共享并放置在对象中。\n 我将更进一步：函数式编程（如面向对象和过程式编程）代表着范式的转变。它在编写代码时采用了独特的思维方式，并引入了一套全新的规则。\n4个重要概念 要完全掌握函数式编程，必须首先了解以下相关概念。\n 纯函数和幂等 副作用 函数构成 共享状态和不变数据  让我们快速回顾一下。\n纯函数和幂等 如果给纯函数提供相同的输入，则它总是会返回相同的输出。此属性也称为幂等。幂等意味着函数应始终返回相同的输出，而与调用次数无关。\n副作用 纯函数不能有任何副作用。换句话说，您的函数无法与外部环境进行交互。\n例如，函数式编程将API调用视为副作用。为什么？因为API调用被认为是不受您直接控制的外部环境。一个API可能有几个不一致的地方，例如超时或失败，或者甚至可能返回意外的值。它不适合纯函数的定义，因为每次调用API时都需要一致的结果。\n其他常见的副作用包括：\n 数据变化 DOM操作 请求有冲突的数据，例如当前时间time.Now()  函数构成 函数构成的基本思想很简单：将两个纯函数组合在一起以创建一个新函数。这意味着为相同输入产生相同输出的概念在这里仍然适用。因此，从简单的纯函数开始创建更高级的函数很重要。\n共享状态和不变数据 函数式编程的目的是创建不保持状态的函数。共享状态尤其会在纯函数中引入副作用或可变性问题，使它们变得不纯粹。\n但是，并非所有状态都不好。有时，必须有一个状态才能解决特定的软件问题。函数式编程的目的是使状态可见和显式，以消除任何副作用。程序使用不可变数据结构从纯函数中派生新数据。这样，就不需要可能引起副作用的可变数据。\n 现在我们已经涵盖了基础，让我们定义一些在Go中编写功能代码时要遵循的规则。\n功能编程规则 如前所述，函数式编程是一种范例。因此，很难为这种编程风格定义确切的规则。也不一定总是遵循这些规则。有时，您确实需要依赖拥有状态的功能。\n但是，为了尽可能严格地遵循函数式编程范例，我建议坚持以下准则。\n 没有可变数据以避免副作用 无状态（或者隐式状态，例如循环计数器） 给变量赋值后请勿修改 避免副作用，例如API调用  我们在函数式编程中经常遇到的一个好的“副作用”是强大的模块化。函数式编程不是自上而下地进行软件工程，而是鼓励自下而上的编程风格。首先定义模块，把将来可能使用的同类纯函数组合起来。接下来，开始编写那些小的，无状态的独立函数，以创建您的第一个模块。\n实质上我们是在创建黑匣子。稍后，我们将按照自下而上的方式将各个块捆绑在一起。这使您可以建立强大的测试基础，尤其是可以验证纯函数正确性的单元测试。\n一旦您可以信任您的模块，就可以将模块捆绑在一起了。开发过程中的这一步还涉及编写集成测试，以确保两个组件的正确集成。\n5个示例 为了更全面地描述Go函数编程的工作原理，让我们探索五个基本示例。\n 更新字符串  这是纯函数的最简单示例。通常，当您要更新字符串时，请执行以下操作。\nname：= \u0026#34;first name\u0026#34; name：= name + \u0026#34;last name\u0026#34; 上面的代码片段不符合函数式编程的规则，因为不能在函数内修改变量。因此，我们应该重写代码段，以便每个值都具有自己的变量。\n下面的代码段中的代码更具可读性。\nfirstname := \u0026#34;first\u0026#34; lastname := \u0026#34;last\u0026#34; fullname := firstname + \u0026#34; \u0026#34; + lastname 在查看非函数式代码段时，我们必须浏览程序以确定最新状态，才可以找到name变量的结果值。这需要更多的精力和时间来了解该功能的作用。\n避免更新数组  如前所述，函数式编程的目的是使用不变数据通过纯函数得出新的不变数据状态。我们可以在每次需要更新数组时创建一个新数组来实现\n在非函数式编程中，更新数组如下：\nnames := [3]string{\u0026#34;Tom\u0026#34;, \u0026#34;Ben\u0026#34;} // Add Lucas to the array \tnames[2] = \u0026#34;Lucas\u0026#34; 让我们根据功能编程范例进行尝试。\nnames := []string{\u0026#34;Tom\u0026#34;, \u0026#34;Ben\u0026#34;} allNames := append(names, \u0026#34;Lucas\u0026#34;) 避免更新map  这是函数编程的极端示例。想象一下，我们有一个带有字符串类型的键和整数类型的值的map。该map包含我们仍然留在家中的水果数量。但是，我们刚购买了苹果，并希望将其添加到列表中。\nfruits := map[string]int{\u0026#34;bananas\u0026#34;: 11} // Buy five apples \tfruits[\u0026#34;apples\u0026#34;] = 5 我们可以在功能编程范例下完成相同的功能。\nfruits := map[string]int{\u0026#34;bananas\u0026#34;: 11} newFruits := map[string]int{\u0026#34;apples\u0026#34;: 5} allFruits := make(map[string]int, len(fruits) + len(newFruits)) for k, v := range fruits { allFruits[k] = v } for k, v := range newFruits { allFruits[k] = v } 由于我们不想修改原始map，因此代码会遍历两个map，并将值添加到新map。这样，数据保持不变。\n正如您可能通过代码的长度可以看出的那样，此代码段的性能比对map进行简单的可变更新要差得多，因为我们要遍历两个map。这是您为代码性能交换更好的代码质量的时间。\n高阶函数和柯里化  大多数程序员在他们的代码中通常不会使用高阶函数，但是在函数式编程中柯里化很方便。\n假设我们有一个简单的函数，将两个整数相加。尽管这已经是一个纯粹的功能，但我们希望详细说明该示例，以展示如何通过curring创建更高级的功能。\n在这种情况下，我们只能接受一个参数。接下来，该函数返回另一个函数作为闭包。因为该函数返回一个闭包，所以它将记住外部范围，该范围包含初始输入参数。\nfunc add （x int）func （y int）int { return func（y int）int { return x + y } } 现在，让我们尝试currying并创建更多高级纯函数。\nfunc main() { // Create more variations \tadd10 := add(10) add20 := add(20) // Currying \tfmt.Println(add10(1)) // 11 \tfmt.Println(add20(1)) // 21 } 这种方法在函数式编程中很常见，尽管您通常不会在范式之外看到它。\n递归  递归是一种通常用于规避循环使用的软件模式。因为循环始终保持内部状态以明确循环在哪一轮，所以我们不能在函数式编程范式下使用循环。\n例如，下面的代码片段尝试计算数字的阶乘。阶乘是一个整数与其下所有整数的乘积。因此，阶乘4等于24（= 4 * 3 * 2 * 1）。\n通常，您将为此使用循环。\nfunc factorial(fac int) int { result := 1 for ; fac \u0026gt; 0; fac-- { result *= fac } return result } 为了在函数式编程范例中完成此任务，我们需要使用递归。换句话说，我们将一遍又一遍地调用相同的函数，直到达到阶乘的最低整数为止。\nfunc calculateFactorial(fac int) int { if fac == 0 { return 1 } return fac * calculateFactorial(fac - 1) } 结论 让我们总结一下我们从函数式编程中学到的知识：\n 尽管Golang支持函数式编程，但它并非为此目的而设计的，如缺少Map，Filter和Reduce函数。 函数式编程提高了代码的可读性，因为函数是纯粹的，因此易于理解 纯函数更易于测试，因为没有内部状态会改变输出  原文在此: https://blog.logrocket.com/functional-programming-in-go/\n","id":73,"section":"posts","summary":"为什么要用Go练习函数式编程？简而言之，正是由于缺少状态和可变数据，函数式编程使您的代码更易读，更易于测试且不太复杂。如果遇到错误，只要不违","tags":["functional"],"title":"使用Golang进行函数式编程","uri":"https://lvsq.net/2020/03/fp-in-go/","year":"2020"},{"content":"闲来无事，用Scheme实现一个FIFO队列，数据从末端插入，从前端删除或者查询。\n队列可以看成是由下面一组操作定义的结构：\n 构造函数  (make-queue)返回一个空队列\n 选择函数  (empty-queue? \u0026lt;queue\u0026gt; )检查队列是否为空(front-queue \u0026lt;queue\u0026gt; )返回最早进入队列的数据，其不会修改队列(length-queue \u0026lt;queue\u0026gt; )返回队列长度\n 改变函数  (insert-queue! \u0026lt;queue\u0026gt; \u0026lt;item\u0026gt; )将数据插入末端(delete-queue! \u0026lt;queue\u0026gt; )删除列头的数据\n 打印函数  (print-queue \u0026lt;queue\u0026gt;)\n(module FIFO-QUEUE (make-queue empty-queue? front-queue insert-queue! delete-queue! length-queue print-queue) (define front-ptr (lambda (q) (caar q))) (define set-front-ptr! (lambda (q item) (set-car! (car q) item))) (define rear-ptr (lambda (q) (cdar q))) (define set-rear-ptr! (lambda (q item) (set-cdr! (car q) item))) (define make-queue (lambda () (cons (cons \u0026#39;() \u0026#39;()) 0))) (define empty-queue? (lambda (q) (null? (front-ptr q)))) (define front-queue (lambda (q) (if (empty-queue? q) (error \u0026#34;FRONT called with an empty queue\u0026#34; q) (car (front-ptr q))))) (define (insert-queue! q item) (let ((new-pair (cons item \u0026#39;()))) (if (empty-queue? q) (begin (set-front-ptr! q new-pair) (set-rear-ptr! q new-pair) (set-cdr! q (+ 1 (cdr q))) q) (begin (set-cdr! (rear-ptr q) new-pair) (set-rear-ptr! q new-pair) (set-cdr! q ( + 1 (cdr q))) q) ) ) ) (define delete-queue! (lambda (q) (if (empty-queue? q) (error \u0026#34;DELETE! called with an empty queue\u0026#34; q) (begin (set-front-ptr! q (cdr (front-ptr q))) (set-cdr! q (- (cdr q) 1)) q) ) ) ) (define length-queue (lambda (q) (cdr q))) (define print-queue (lambda (q) (if (empty-queue? q) \u0026#39;() (front-ptr q)) )) ) 前4个过程是用于内部的帮助函数，队列维护两个指针，一个指向列头（front-ptr）,一个指向列尾（rear-ptr），这样可以弥补原生的set-car!和set-cdr!的不足。\n\u0026gt; (load \u0026#34;/path/to/FIFO-QUEUE.scm\u0026#34;) ;;加载FIFO-QUEUE模块 \u0026gt; (import FIFO-QUEUE) \u0026gt; (define q (make-queue)) \u0026gt; (insert-queue! q 1) ;; (((1) 1) . 1), 最后一个数字1表示队列长度, 在队列有删除或者插入时，及时修改该值，为了在取队列长度时减小开销，否则要遍历一次才行 \u0026gt; (insert-queue! q 2) ;; (((1 2) 2) . 2) \u0026gt; (insert-queue! q 3) ;; (((1 2 3) 3) . 3) \u0026gt; (insert-queue! q 4) ;; (((1 2 3 4) 4) . 4) \u0026gt; (delete-queue! q) ;; (((2 3 4) 4) . 3) \u0026gt; (delete-queue! q) ;; (((3 4) 4) . 2) \u0026gt; (front-queue q) ;; 3 \u0026gt; (length-queue q) ;; 2 ","id":74,"section":"posts","summary":"闲来无事，用Scheme实现一个FIFO队列，数据从末端插入，从前端删除或者查询。 队列可以看成是由下面一组操作定义的结构： 构造函数 (make","tags":["scheme"],"title":"Scheme实现一个FIFO队列","uri":"https://lvsq.net/2020/03/fifo-queue/","year":"2020"},{"content":"本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可能使用Scheme标准机制。\nHash Tables 略过。应使用标准hash table.\nExtend-Syntax Macros 本节介绍了extend-syntax，它是一种功能强大但易于使用的基于模式匹配的语法扩展工具。 使用extend-syntax编写的语法转换与使用define-syntax和syntax-case编写的语法转换相似，不同之处在于extend-syntax产生的转换不会自动遵循词法作用域。\n通常不可能将使用syntax-case编写的语法抽象与使用extend-syntax编写的语法抽象无缝地混合在一起。 通常尽可能只使用其中一种。 仅在迁移到syntax-case时提供了对syntax-case扩展器中extend-syntax的支持。\n (extend-syntax (name key \u0026hellip;) (pat fender template) \u0026hellip;)\n 标识符name 是要定义的句法扩展名或语法关键字。 当系统扩展器处理car为name 的任何list表达式时，将在该表达式上调用extend-syntax生成的语法转换过程。 其余的标识符key \u0026hellip; 是在扩展过程中要在输入表达式中识别的其他关键字（例如cond中的else或case）。\nkey列表之后的每个子句都包含一个模式pat ，一个可选的fender 和一个template 。 可选的fender 经常被省略。pat 指定了语法，用于匹配子句。模式中不是关键字（模式变量）的标识符绑定到输入表达式的相应部分。fender 如果存在，则是Scheme表达式，它指定输入表达式（通过模式变量访问）上的附加约束，必须选择这些约束才能选择子句。template 通常根据模式变量来指定输出采用什么形式。\n在扩展过程中，转换过程extend-syntax会尝试以给定的子句的顺序将输入表达式与每个模式进行匹配。如果输入表达式匹配了某个模式，则将模式变量绑定到输入表达式的相应部分，并对子句的fender （如果有）进行求值。如果fender 返回一个真值，则执行给定的扩展。 如果输入与模式不匹配，或者fender 返回错误值，则转换过程将尝试下一个子句。如果无法选择任何子句，则会引发条件类型**＆assertion**的异常。\n在模式内，省略号（\u0026hellip;）可用于指定零个或多个出现的前面的模式片段或原型。类似地，可以在输出中使用省略号来指定零个或多个扩展原型的结构。在这种情况下，扩展原型必须包含输入模式原型的一部分。\n第一个例子，定义了rec, 使用单个关键字，一个子句，且没有fender和省略号\n(extend-syntax (rec) [(rec id val) (let ([id #f]) (set! id val) id)]) 第二个例子，定义了when，展示了如何使用省略号\n(extend-syntax (when) [(when test exp1 exp2 ...) (if test (begin exp1 exp2 ...) #f)]) 下一个示例显示let的定义。 let的定义显示了多个省略号的使用，其中一个用于标识符/值序对，另一个用于body中的表达式。它还表明原型不必是单个标识符，并且在template中可以将原型的各个部分彼此分开。\n(extend-syntax (let) [(let ([x e] ...) b1 b2 ...) ((lambda (x ...) b1 b2 ...) e ...)]) 下一个示例显示let*，其语法与let相同，但是根据let以两个子句（一个用于基本情况，一个用于递归步骤）递归定义，因为它必须产生一个嵌套结构。\n(extend-syntax (let*) [(let* () b1 b2 ...) (let () b1 b2 ...)] [(let* ([x e] more ...) b1 b2 ...) (let ([x e]) (let* (more ...) b1 b2 ...))]) 定义式and需要3个子句。第一个子句对于识别**(and)**是必要的，后两个以递归方式定义所有其他**and**形式。\n(extend-syntax (and) [(and) #t] [(and x) x] [(and x y ...) (if x (and y ...) #f)]) cond的定义需要四个子句。 与let*一样，必须对cond进行递归描述，部分原因是它会产生嵌套的if表达式，部分原因是一个省略号原型不足以描述所有可能的cond子句。 cond的定义还要求除cond之外，我们还指定else作为关键字。 这是定义：\n(extend-syntax (cond else) [(cond) #f] [(cond (else e1 e2 ...)) (begin e1 e2 ...)] [(cond (test) more ...) (or test (cond more ...))] [(cond (test e1 e2 ...) more ...) (if test (begin e1 e2 ...) (cond more ...))]) 为了使let的语法绝对正确，我们实际上必须要求输入中的绑定标识符是符号。 如果我们输入类似**（let（[3 x]）x）**的内容，则不会从**let**中得到错误，因为它不会检查验证标识符位置中的对象是否为符号。 相反，lambda可能会抱怨，或者可能是扩展完成很久之后的求值程序。 这是*fenders* 起作用的地方。\n(extend-syntax (let) [(let ([x e] ...) b1 b2 ...) (andmap symbol? \u0026#39;(x ...)) ((lambda (x ...) b1 b2 ...) e ...)]) '（x \u0026hellip;）上的symbol?的andmap确保每个绑定标识符都是一个符号。 fender 仅仅是Scheme表达式。 在该表达式中，首先使用与子句的template 部分相同的规则来扩展引用的对象。 在这种情况下，将**'（x \u0026hellip;）**扩展到标识符/值对中的标识符列表。\nextend-syntax通常可以处理您的一切需求，但是某些语法扩展定义要求能够包含对任意Scheme表达式求值的结果。 该功能由with提供。\n (with ((pat expr) \u0026hellip;) template)\n with仅在extend-syntax内部的template 内有效。 with模式与extend-syntax模式相同，with表达式与extend-syntax的fenders 相同，with模板与extend-syntax模板相同。\nwith可用于引入新的模式标识符，该标识符绑定到extend-syntax模板中的任意Scheme表达式所生成的表达式。 也就是说，with允许从extend-syntax的声明式样式转为full Scheme的过程式样式。\nwith的一种常见用法是在模板中引入临时标识符或临时标识符列表。 如果在extend-syntax框架内执行，with也可用于执行可能笨拙或效率低下的复杂转换。\n例如，or需要使用临时标识符。 我们可以如下定义or：\n(extend-syntax (or) [(or) #f] [(or x) x] [(or x y ...) (let ([temp x]) (if temp temp (or y ...)))]) 这会一直有效，直到将or表达式放置在temp发生的范围内为止，在这种情况下，可能会发生奇怪的事情，因为extend-syntax不尊重词法作用域。 （这是define-syntax优于extend-syntax的原因之一。）\n(let ([temp #t]) (or #f temp)) ⇒ #f  如果将标识符temp换个名字，则一切正常。就可以理解\u0026quot;extend-syntax不尊重词法作用域\u0026quot;这句话了。 实际上，上述的(let \u0026hellip;)表达式，展开之后就变成了：\n (let ([temp #t]) (let ([temp #f]) (if temp temp (or temp)) ) ) 一种解决方案是，使用gensym和with来创建临时标识符，如下：\n(extend-syntax (or) [(or) #f] [(or x) x] [(or x y ...) (with ([temp (gensym)]) (let ([temp x]) (if temp temp (or y ...))))]) 而且，with可以以extend-syntax无法直接使用的方式来组合输入模式的元素，例如以下folding-plus示例:\n(extend-syntax (folding-plus) [(folding-plus x y) (and (number? \u0026#39;x) (number? \u0026#39;y)) (with ([val (+ \u0026#39;x \u0026#39;y)]) val)] [(folding-plus x y) (+ x y)]) 如果x和y均为数字常数，则folding-plus折叠为（+ x y）的值。 否则，folding-plus转换为（+ x y）以供以后评估。 fender在扩展时检查操作数是否为数字，并使用with进行求值。 与fender一样，扩展仅在带引号的表达式内执行，因为quote将数据与Scheme表达式的其余部分区分开。\n下面的示例利用with允许我们将模式绑定到表达式这一事实，将模式变量列表绑定到临时符号列表。 此临时列表帮助我们实现sigma语法扩展。 sigma与lambda相似，除了它在标识符列表中分配标识符而不是创建新绑定之外。 它可用于并行执行一系列分配。\n(extend-syntax (sigma) [(sigma (x ...) e1 e2 ...) (with ([(t ...) (map (lambda (x) (gensym)) \u0026#39;(x ...))]) (lambda (t ...) (set! x t) ... e1 e2 ...))]) (let ([x \u0026#39;a] [y \u0026#39;b]) ((sigma (x y) (list x y)) y x)) ⇒ (b a) 结构体 本节介绍一种机制，类似于第7.15节的record定义机制，该机制允许使用固定的命名字段集创建数据结构。 与record类型不同，结构体类型不是唯一类型，而是实现为向量。 具体而言，将结构体实现为向量，其长度比字段数大一倍，并且其第一个元素包含该结构体的符号名称。\n将结构体表示为向量可以在某种程度上简化结构体的读取和打印以及结构体定义工具的扩展。但是，它确实有一些缺点。 一个是在不适当的情况下，结构体可能会被错误地视为普通向量。当在程序中处理结构体和向量时，在检查更通用的向量类型之前，必须注意先寻找更具体的结构体类型，例如在一系列cond子句中。一个类似的缺点是，结构体实例容易被有意或无意地“伪造”。 也不可能控制如何打印和读取结构体。\n通过define-structure创建结构体。 每个结构体定义式都定义一个构造过程，一个类型谓词，每个字段的访问过程以及每个字段的分配过程。define-structure允许程序员控制哪些字段是构造函数过程的参数，以及哪些字段由构造函数过程显式初始化。define-structure非常简单，但对于大多数应用程序来说足够强大，如果还不足以应付应用程序的需求还可以很容易的扩展以满足之。 本节末尾给出的define-structure定义可以作为更复杂变体的起点。\n (define-structure (name id1 \u0026hellip;) ((id2 expr) \u0026hellip;))\n define-structure形式可以出现在任意位置。\ndefine-structure定义一个新的数据结构name ，并创建一组用于构造和操作该结构实例的过程。 标识符id1 \u0026hellip; 和id2 \u0026hellip; 命名数据结构的字段。\n下面的过程都有define-structure定义：\n 名为**make-**name 的构造过程 名为name? 的类型谓词 对于每一个字段id1 \u0026hellip; 和id2 \u0026hellip; ，都有名为name-field 的访问过程 对于每一个字段id1 \u0026hellip; 和id2 \u0026hellip; ，都有名为**set-**name-field! 的分配过程  标识符id1 \u0026hellip; 命名的字段由构造函数的参数初始化。 由标识符id2 \u0026hellip; 命名的字段被显式初始化为表达式expr \u0026hellip; 的值。每个表达式都在标识符id1 \u0026hellip; （绑定到相应的字段值）的范围内进行求值，并且在标识符id2 \u0026hellip; （绑定到相应的字段值）的范围内出现（类似let*） 。\n为了清晰起见，构造函数的行为就像定义为：\n(define make-name (lambda (id1 ...) (let* ([id2 expr ] ...) body ))) 其中body 根据标识符id1 \u0026hellip; 和id2 \u0026hellip; 的值构建结构体。\n如果不需要除构造函数过程的参数初始化的字段以外的其他字段，则可以省略第二个子表达式*( (id2 expr) \u0026hellip;)* 。\n以下简单示例演示了如何在Scheme中定义pair（如果它们不存在的话）。 这两个字段都由构造函数过程的参数初始化。\n(define-structure (pare car cdr)) (define p (make-pare ’a ’b)) (pare? p) ⇒ #t (pair? p) ⇒ #f (pare? ’(a . b)) ⇒ #f (pare-car p) ⇒ a (pare-cdr p) ⇒ b (set-pare-cdr! p (make-pare \u0026#39;b \u0026#39;c)) (pare-car (pare-cdr p)) ⇒ b (pare-cdr (pare-cdr p)) ⇒ c 以下示例定义了一个方便的字符串数据结构，称为strext-string ，该结构会根据需要增长。本例子中，会显式地初始化一个字段的值，该字段在构造函数中定义。\n(define-structure (stretch-string length fill) ([string (make-string length fill)])) (define stretch-string-ref (lambda (s i) (let ([n (stretch-string-length s)]) (when (\u0026gt;= i n) (stretch-stretch-string! s (+ i 1) n)) (string-ref (stretch-string-string s) i)))) (define stretch-string-set! (lambda (s i c) (let ([n (stretch-string-length s)]) (when (\u0026gt;= i n) (stretch-stretch-string! s (+ i 1) n)) (string-set! (stretch-string-string s) i c)))) (define stretch-string-fill! (lambda (s c) (string-fill! (stretch-string-string s) c) (set-stretch-string-fill! s c))) (define stretch-stretch-string! (lambda (s i n) (set-stretch-string-length! s i) (let ([str (stretch-string-string s)] [fill (stretch-string-fill s)]) (let ([xtra (make-string (- i n) fill)]) (set-stretch-string-string! s (string-append str xtra)))))) 通常，大多数自动定义的过程都用于定义更特殊的过程， 在这个例子中，说的就是stretch-string-ref ** 和stretch-string-set!。而stretch-string-length** 和 **stretch-string-string**是惟一直接使用的自动生成的过程。\n(define ss (make-stretch-string 2 #\\X)) (stretch-string-string ss) ⇒ \u0026#34;XX\u0026#34; (stretch-string-ref ss 3) ⇒ #\\X (stretch-string-length ss) ⇒ 4 (stretch-string-string ss) ⇒ \u0026#34;XXXX\u0026#34; (stretch-string-fill! ss #\\@) (stretch-string-string ss) ⇒ \u0026#34;@@@@\u0026#34; (stretch-string-ref ss 5) ⇒ #\\@ (stretch-string-string ss) ⇒ \u0026#34;@@@@@@\u0026#34; (stretch-string-set! ss 7 #\\=) (stretch-string-length ss) ⇒ 8 (stretch-string-string ss) ⇒ \u0026#34;@@@@@@@=\u0026#34; 《The Scheme Programming Language》（第4版）的8.4节定义了define-structure的简化变体，作为使用syntax-case的示例。 下面给出的定义实现了完整版本。\n(define-syntax define-structure (lambda (x) (define gen-id (lambda (template-id . args) (datum-\u0026gt;syntax template-id (string-\u0026gt;symbol (apply string-append (map (lambda (x) (if (string? x) x (symbol-\u0026gt;string (syntax-\u0026gt;datum x)))) args)))))) (syntax-case x () ((_ (name field1 ...)) (andmap identifier? #\u0026#39;(name field1 ...)) #\u0026#39;(define-structure (name field1 ...) ())) ((_ (name field1 ...) ((field2 init) ...)) (andmap identifier? #\u0026#39;(name field1 ... field2 ...)) (with-syntax ((constructor (gen-id #\u0026#39;name \u0026#34;make-\u0026#34; #\u0026#39;name)) (predicate (gen-id #\u0026#39;name #\u0026#39;name \u0026#34;?\u0026#34;)) ((access ...) (map (lambda (x) (gen-id x #\u0026#39;name \u0026#34;-\u0026#34; x)) #\u0026#39;(field1 ... field2 ...))) ((assign ...) (map (lambda (x) (gen-id x \u0026#34;set-\u0026#34; #\u0026#39;name \u0026#34;-\u0026#34; x \u0026#34;!\u0026#34;)) #\u0026#39;(field1 ... field2 ...))) (structure-length (+ (length #\u0026#39;(field1 ... field2 ...)) 1)) ((index ...) (let f ([i 1] [ids #\u0026#39;(field1 ... field2 ...)]) (if (null? ids) \u0026#39;() (cons i (f (+ i 1) (cdr ids))))))) #\u0026#39;(begin (define constructor (lambda (field1 ...) (let* ([field2 init] ...) (vector \u0026#39;name field1 ... field2 ...)))) (define predicate (lambda (x) (and (vector? x) (#3%fx= (vector-length x) structure-length) (eq? (vector-ref x 0) \u0026#39;name)))) (define access (lambda (x) (vector-ref x index))) ... (define assign (lambda (x update) (vector-set! x index update))) ...)))))) ","id":75,"section":"posts","summary":"本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可","tags":["scheme"],"title":"兼容性（Compatibility Features in Chez Scheme）","uri":"https://lvsq.net/2020/02/compatibility/","year":"2020"},{"content":"下面介绍Chez Scheme线程系统过程和语法形式。 除了锁，锁增量和锁减量之外，线程系统的功能在非基于Windows的系统上在Posix线程系统（pthreads）之上实现，并在基于Windows的系统上直接使用Windows API。 有关线程创建和交互的基本详细信息，请查阅系统上的相应文档。\n大多数原生的Scheme过程都是线程安全 的，这意味着可以从多个线程中同时调用它们。 这包括诸如cons和make-string之类的分配操作，诸如car和vector-ref之类的访问器，诸如**+**和**sqrt**之类的数字运算符以及诸如**append**和**map**之类的非破坏性的高级原生操作。\n简单的变动运算符（例如set-car！，vector-set！和record字段变动器）是线程安全的。 同样，对局部变量的分配，包括（未导出的）库和顶级程序变量的分配也是线程安全的。\n大多数I/O操作应被视为具有破坏性，因为它们可能会修改端口的内部结构。\n使用没有进行合适的同步策略的非线程安全的运算符可能会破坏它们所操作的对象。 这种损坏可能导致错误的行为，内存故障，甚至导致系统中止的不可恢复的错误。\n线程创建  (fork-thread thunk)\n thunk 必须是一个接受0个参数的过程。\nfork-thread在一个新线程中调用thunk ，并返回一个线程对象。\n除了打印它外，fork-thread返回的线程对象无法执行任何操作。\n除了使用fork-thread以外，可通过外部代码来创建的线程必须在触及任何Scheme数据或调用任何Scheme过程之前调用Sactivate_thread\n (thread? obj)\n 返回：如果obj 是一个线程对象，返回#t,否则返回#f\n (get-thread-id)\n 返回：当前线程的id\n线程id是由线程分配的线程号，并且与get-process-id返回的进程id没有关系，进程id在所有线程中都是相同的。\n互斥锁  (make-mutex)\n 返回：一个新的互斥锁对象\n (mutex? obj)\n 返回：如果obj 是互斥锁，返回#t\n (mutex-acquire mutex) | (mutex-acquire mutex block?)\n mutex 必须是一个互斥锁。\nmutex-acquire获取由mutex 标识的互斥锁。可选的bool参数block？ 默认为#t，指定线程是否应阻塞等待互斥锁。block？ 如果省略或为true，则线程将阻塞，直到获取了互斥锁为止，并返回未指定的值。\n如果block？ 为false并且互斥锁当前已属于其他线程，当前线程并不会阻塞，而是，mutex-acquire立即返回值**#f**，以指示互斥锁不可用。 如果*block？* 为false并且成功获取了互斥锁，**mutex-acquire**返回#t。\n互斥锁在Posix线程术语中是递归的，这意味着调用线程可以使用互斥锁获取（重新）获取它已经拥有的互斥锁（注：锁是可以重入的）。 在这种情况下，释放互斥锁需要执行相等数量的mutex-release。\n (mutex-release mutex)\n mutex 必须是一个互斥锁。\nmutex-release释放由mutex 标识的互斥锁。 如果mutex 不属于调用线程（即释放别人的互斥锁），则会导致无法预料的行为。\n (with-mutex mutex body1 body2 \u0026hellip;)\n with-mutex计算表达式mutex ，其必须可以计算为一个互斥锁，获取锁，并计算body1 body2 \u0026hellip; ,然后释放锁。无论body是正常返回还是通过控制操作（即可能由于错误而抛到continuation）释放互斥量，这都会导致with-mutex形式的非本地退出。如果控制随后通过continuation调用返回到body，则将重新获取互斥锁。\n与直接使用mutex-acquire和mutex-release相比，使用with-mutex通常更方便，更安全。\n条件  (make-condition)\n 返回：一个新的条件对象\n (thread-condition? obj)\n 返回：如果obj 是条件对象，返回#t\n (condition-wait cond mutex) | (condition-wait cond mutex timeout)\n 返回：如果调用线程被条件唤醒返回#t，如果调用线程超时等待返回#f\ncond 必须是条件对象，并且mutex 必须是互斥锁。 可选参数timeout 是类型为time-duration或time-utc或**#f**的时间记录，表示没有超时。 默认为**#f**。\ncondition-wait等待由cond 标识的条件，且等待指定的timeout时长。在调用condition-wait时，调用线程必须已获取互斥锁mutex 。由于调用condition-wait的副作用而释放了mutex 。当稍后通过下述的过程之一从条件变量释放线程或超时到期时，将重新获取mutex ，并返回condition-wait。\n (condition-signal cond)\n cond 必须是一个条件对象。\ncondition-signal释放所有等待cond 标识的条件对象的线程的其中一个。\n (condition-broadcast cond)\n cond 必须是一个条件对象。\ncondition-broadcast释放所有等待cond 标识的条件对象的线程\n锁 锁比互斥锁更原生，但是更加灵活和有效。\n只要锁在进程共享的内存中分配，它们还可以独立于线程系统使用（包括在Chez Scheme的非线程版本中）以在分离的Scheme进程中执行同步操作。锁只是一个字长的整数，即iptr或uptr外部类型，其中包含目标计算机的本机字节序，可能是使用define-ftype定义的大结构的一部分。必须在驻留于Scheme堆外部的内存中显式分配它，并在适当时显式释放。当仅涉及线程时（即，当不涉及多个进程时），可以通过foreign-alloc分配内存。 当涉及多个进程时，应在进程共享的某个区域中分配该锁。\n使用ftype-init-lock! 初始化后，进程或线程可以尝试通过**ftype-lock!或ftype-spin-lock!锁定lock 。一旦锁已被锁定并且在解锁之前，即使通过最近锁定它的进程或线程，再一次尝试锁定该锁也会失败。 任何进程或线程可以使用ftype-unlock!**来解锁lock，而不仅仅是通过最近锁定锁的进程或线程来解锁。\n锁机制提供的结构很少，并且分配和使用中的错误可能导致内存错误，死锁和其他问题。 因此，通常建议仅将锁用作更高级别抽象的一部分，以确保按规范方式使用锁。\n(define lock (make-ftype-pointer uptr (foreign-alloc (ftype-sizeof uptr)))) (ftype-init-lock! uptr () lock) (ftype-lock! uptr () lock) ⇒ #t (ftype-lock! uptr () lock) ⇒ #f (ftype-unlock! uptr () lock) (ftype-spin-lock! uptr () lock) (ftype-lock! uptr () lock) ⇒ #f (ftype-unlock! uptr () lock)  (ftype-init-lock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-init-lock! ftype-name (a \u0026hellip;) fptr-expr index)\n  (ftype-lock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-lock! ftype-name (a \u0026hellip;) fptr-expr index)\n  (ftype-spin-lock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-spin-lock! ftype-name (a \u0026hellip;) fptr-expr index)\n  (ftype-unlock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-unlock! ftype-name (a \u0026hellip;) fptr-expr index)\n 它们每个的语法都类似于ftype-set!，尽管带有隐式的val-expr 。 特别是，对fptr-expr 和访问器a \u0026hellip; 的限制和处理是相似的，但有一个重要的限制：最后一个访问器所指定的字段（该格式在其上进行操作）必须是一个字长的整数，即 ，iptr，uptr或具有本地字节序的等效项。\n**ftype-init-lock!**应该在使用任何其他运算符之前用于初始化锁； 如果不这样做，则其他操作符的行为是不确定的。\nftype-lock! 可用于加锁。如果发现在操作时锁已解锁，则将其锁定并返回#t；如果发现该锁已加锁，则返回#f且不更改该锁。\nftype-spin-lock! 也可以用来加锁。 如果在操作时发现该锁已解锁，则将其锁定并返回； 如果发现该锁已锁定，它将一直等待直到锁被解锁，然后再锁定并返回。如果没有其他进程或者线程来释放该锁，该操作不会返回且不能以正常的方式（包括GC）中断。也不保证公平，因此即使其他进程正在主动锁定和释放该锁，进程也可能无限期挂起。\nftype-unlock! 用于解锁。如果发现锁已被锁定，则将其解锁并返回。 否则，它将返回而不更改锁。\n原子操作Locked increment and decrement 当需要原子递增或递减时，可以使用此处描述的锁定操作。\n (ftype-locked-incr! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-locked-incr! ftype-name (a \u0026hellip;) fptr-expr index)\n 返回：如果更新的值为0，则为#t，否则为#f\n (ftype-locked-decr! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-locked-decr! ftype-name (a \u0026hellip;) fptr-expr index)\n 返回：如果更新的值为0，则为#t，否则为#f\n它们每个的语法都类似于ftype-set!，尽管带有隐式的val-expr 。 特别是，对fptr-expr 和访问器a \u0026hellip; 的限制和处理是相似的，但有一个重要的限制：最后一个访问器所指定的字段（该格式在其上进行操作）必须是一个字长的整数，即 ，iptr，uptr或具有本地字节序的等效项。\nftype-locked-incr! 自动读取指定字段的值，将值加1，然后将新值写回该字段。 同样，ftype-locked-decr! 原子读取指定字段的值，从该值中减去1，然后将新值写回到该字段中。 如果新值为0，则两者都返回#t，否则返回#f。\n引用计数 在Scheme堆之外管理内存的应用程序可以利用Scheme存储管理系统通过ftype guardians 执行引用计数。 在引用计数的内存管理系统中，每个对象都保存着指向它的指针计数。 当创建一个新的指针时，该计数增加；而在删除指针时，该计数减小。 当计数达到零时，不再需要该对象，并且可以将其占用的内存用于其他目的。\n (ftype-guardian ftype-name)\n ftype-name 必须命名一个ftype。 ftype的第一个基本字段（或在unions的情况下为第一个基本字段）必须是具有本地尾数的字长整数（iptr或uptr）。 假定此字段保存引用计数。\n返回新的ftype guardian g ，可以使用其注册ftype-name 类型（或ftype-nam e的某些子类型）的ftype-pointer。 通过使用ftype指针作为参数调用g ，可以向g 注册ftype指针。\nftype guardian不会像普通的guardian那样自动保护其注册的ftype指针免遭回收。而是，对于每个通过普通（非弱，非监护人指针）变得不可访问的已注册的ftype指针，guardian会减少ftype指针指向的对象的引用计数。如果引用计数值为0，则ftype指针将保留并可以从guardian中检索。 但是，如果生成的引用计数值非零，则不会保留ftype指针。假设回收器外部的代码正确维护了引用计数，则从ftype guardian检索的对象（通过不带参数的调用）将确保具有0引用计数。回收器使用等效的ftype-locked-decr!来减少引用计数，以支持由多个进程共享的内存中的非Scheme对象。在这样的系统中，程序本身应使用ftype-locked-incr! 和ftype-locked-decr! 或非Scheme等效项（例如，第4.8节中所述C语言的scheme.h中的 LOCKED_INCR和LOCKED_DECR宏）来维护引用计数。\n下面的示例为ftype对象定义了一个简单的ftype和一个分配器，该对象释放以前分配的且不再可访问的ftype对象。\nmodule (A make-A free-dropped-As) (define-ftype A (struct [refcount uptr] [data int])) (define g (ftype-guardian A)) (define free-dropped-As (lambda () (let ([a (g)]) (when a (printf \u0026#34;freeing ~s\\n\u0026#34; (ftype-ref A (data) a)) (foreign-free (ftype-pointer-address a)) (free-dropped-As))))) (define make-A (lambda (n) (free-dropped-As) (let ([a (make-ftype-pointer A (foreign-alloc (ftype-sizeof A)))]) (ftype-set! A (refcount) a 1) (ftype-set! A (data) a n) (g a) a)))) 我们可以通过分配，丢弃并立即回收指向A的ftype指针进行测试。\n\u0026gt; (do ([i 10 (fx- i 1)]) ((fx= i 0)) (make-A i) (collect)) freeing 10 freeing 9 freeing 8 freeing 7 freeing 6 freeing 5 freeing 4 freeing 3 freeing 2 \u0026gt; (free-dropped-As) freeing 1 由ftype guardian保护的对象可能包含指向其他对象的指针，这些其他对象的引用计数也应在分配包含对象时增加，并在释放包含对象时减少。\n线程参数  (make-thread-parameter object) | (make-thread-parameter object procedure)\n 创建线程参数后，将在每个当前线程和将来的线程中放置一个单独的位置，以保存参数的内部状态变量的值。 （当该参数变得不可访问时，存储管理器可以消除该位置。）一个线程中对线程参数的更改不会被其他任何线程看到。\n创建新线程时（请参阅fork-thread），每个线程参数的当前值（而非位置）都由新线程从派生线程继承。 类似地，当第一次激活通过其他方式创建的线程时（请参见4.8节中的Sactivate_thread），每个线程参数的当前值（而非位置）都由新线程从主（原始）线程继承。\n大多数内置参数是线程参数，但有些是全局的。 在他们定义的地方已经标注了是线程的还是全局的。 在非线程版本的Chez Scheme中，内置全局参数和线程参数之间没有区别。\nI/O 缓冲区 Chez Scheme为提高效率而缓冲文件I/O操作，但是缓冲的I/O不是线程安全的。 两个线程并发地读写同一个缓冲端口可能会破坏该端口，从而导致缓冲区溢出，并最终导致无效的内存引用。\n当以缓冲模式none打开时，可以禁用二进制输出端口上的缓冲。 但是，由于需要支持先行（lookahead），因此无法完全禁用输入端口上的缓冲，并且由于要在字符和字节之间进行转换的代码转换器有时需要先行输入，因此无法完全禁用文本端口（甚至是文本输出端口）上的缓冲。\n因此，除非在二进制输出端口开启缓冲模式为none的特殊情况下，否则两个线程绝不应该并发地读写同一个端口。替代方法包括指定一个线程为给定端口执行所有I / O，和为每个线程提供通用端口包装程序，仅在获取互斥量后才将请求转发到端口。\n初始的控制台以及当前的输入和输出端口以及transcript端口都是线程安全的，因此多个线程向控制台打印错误和/或调试消息是安全的。即使在同一行内，输出也可能是交错的，但是端口不会损坏。 这些端口的线程安全性是通过为每个I/O操作获取一个互斥锁的高成本来实现的。\n实例：有界队列 以下代码摘自文章“A Scheme for native threads1”，它使用许多线程系统功能实现了有界队列。 有界队列具有固定数量的可用插槽。 当队列已满时尝试入队会导致调用线程阻塞。 尝试从空队列中出队会导致调用线程阻塞。\n(define-record-type bq (fields (immutable data) (mutable head) (mutable tail) (immutable mutex) (immutable ready) (immutable room)) (protocol (lambda (new) (lambda (bound) (new (make-vector bound) 0 0 (make-mutex) (make-condition) (make-condition)))))) (define dequeue! (lambda (q) (with-mutex (bq-mutex q) (let loop () (let ([head (bq-head q)]) (cond [(= head (bq-tail q)) (condition-wait (bq-ready q) (bq-mutex q)) (loop)] [else (bq-head-set! q (incr q head)) (condition-signal (bq-room q)) (vector-ref (bq-data q) head)])))))) (define enqueue! (lambda (item q) (with-mutex (bq-mutex q) (let loop () (let* ([tail (bq-tail q)] [tail^ (incr q tail)]) (cond [(= tail^ (bq-head q)) (condition-wait (bq-room q) (bq-mutex q)) (loop)] [else (vector-set! (bq-data q) tail item) (bq-tail-set! q tail^) (condition-signal (bq-ready q))])))))) (define incr (lambda (q i) (modulo (+ i 1) (vector-length (bq-data q))))) 下面的代码演示了有界队列在一组线程中的应用，这些线程分别扮演数据的消费者和生产者。\n(define job-queue) (define die? #f) (define make-job (let ([count 0]) (define fib (lambda (n) (if (\u0026lt; n 2) n (+ (fib (- n 2)) (fib (- n 1)))))) (lambda (n) (set! count (+ count 1)) (printf \u0026#34;Adding job #~s = (lambda () (fib ~s))\\n\u0026#34; count n) (cons count (lambda () (fib n)))))) (define make-producer (lambda (n) (rec producer (lambda () (printf \u0026#34;producer ~s posting a job\\n\u0026#34; n) (enqueue! (make-job (+ 20 (random 10))) job-queue) (if die? (printf \u0026#34;producer ~s dying\\n\u0026#34; n) (producer)))))) (define make-consumer (lambda (n) (rec consumer (lambda () (printf \u0026#34;consumer ~s looking for a job~%\u0026#34; n) (let ([job (dequeue! job-queue)]) (if die? (printf \u0026#34;consumer ~s dying\\n\u0026#34; n) (begin (printf \u0026#34;consumer ~s executing job #~s~%\u0026#34; n (car job)) (printf \u0026#34;consumer ~s computed: ~s~%\u0026#34; n ((cdr job))) (consumer)))))))) (define (bq-test np nc) (set! job-queue (make-bq (max nc np))) (do ([np np (- np 1)]) ((\u0026lt;= np 0)) (fork-thread (make-producer np))) (do ([nc nc (- nc 1)]) ((\u0026lt;= nc 0)) (fork-thread (make-consumer nc)))) 这是示例程序运行后的可能的前几行输出：\n\u0026gt; (begin (bq-test 3 4) (system \u0026#34;sleep 3\u0026#34;) (set! die? #t)) producer 3 posting a job Adding job #1 = (lambda () (fib 29)) producer 3 posting a job Adding job #2 = (lambda () (fib 26)) producer 3 posting a job Adding job #3 = (lambda () (fib 22)) producer 3 posting a job Adding job #4 = (lambda () (fib 21)) producer 2 posting a job Adding job #5 = (lambda () (fib 29)) producer 1 posting a job Adding job #6 = (lambda () (fib 29)) consumer 4 looking for a job producer 3 posting a job Adding job #7 = (lambda () (fib 24)) consumer 4 executing job #1 consumer 3 looking for a job producer 2 posting a job Adding job #8 = (lambda () (fib 26)) consumer 3 executing job #2 consumer 3 computed: 121393 consumer 3 looking for a job producer 1 posting a job Adding job #9 = (lambda () (fib 26)) ... 在“A Scheme for native threads1”中给出了其他示例，包括可悬挂线程的定义和在无法访问时自动终止的线程。\n  R. Kent Dybvig. A Scheme for native threads. In Symposium in Honor of Mitchell Wand, August 2009. http://www.ccs.neu.edu/events/wand-symposium/.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","id":76,"section":"posts","summary":"下面介绍Chez Scheme线程系统过程和语法形式。 除了锁，锁增量和锁减量之外，线程系统的功能在非基于Windows的系统上在Posix线程","tags":["thread","scheme"],"title":"线程（Thread System in Chez Scheme）","uri":"https://lvsq.net/2020/02/thread/","year":"2020"},{"content":"垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。\n回收由默认的collect-request处理程序自动触发，该处理程序通过collect-request中断调用，该中断在分配了大约n个字节的存储空间后发生，其中n是参数collect-trip-bytes 的值。 默认的collect-request处理程序通过调用不带参数的collect程序来进行会睡。 可以通过更改参数collect-request-handler 的值来重新定义collect-request处理程序。 程序还可以通过直接调用collect来导致在collect-request中断之间发生回收。\nChez Scheme的回收器是基于分代 的。它根据对象的年龄（大致来说，回收幸存数）来对对象进行分类，且老对象比年轻对象回收的频率要低。由于年轻对象比老对象更快地变为不可访问，因此结果是大多数的回收花费的时间更少。系统还维护一个静态代（static generation, 类似Java的永久代），不会对此存储进行回收。仅当压缩堆（Scompact_heap）或要collect的target-generation 参数为static符号时，才将对象放入静态代中。\n非静态代的编号从最年轻的世代（开始于0）到collect-maximum-generation的当前值。存储管理器将新分配的对象放入第0代。在第0代的回收过程中，默认情况下，将第0代的对象挪到第1代，类似地，在第1代回收期间，存活的第0代和第1代对象移动到第2代，依此类推。在最大非静态对象回收的过程中，所有幸存的非静态对象都将移动（可能返回）到最大非静态代中。 通过这种机制，一个对象有可能跳过一个或多个世代，但这在许多对象上不太可能发生，并且如果这些对象变得不可访问，则最终将回收它们的存储。\n维护内部计数器gc-trip来控制何时回收每一代。 每次调用不带参数的collect 时（从默认的collect-request处理程序开始），gc-trip都会加1。在collect-generation基数为r 的情况下，回收的世代编号为g ，其gc-trip是$r^g$的倍数。 如果将collect-generation-radix设置为4，则系统将每次收集0代，每4次收集1代，每16次收集2代，依此类推。\n每次某个世代g 调用collect时，该世代g 被回收且gc-trip前进到下个$r^g$的边界，但是不会超过$r^{g+1}$的边界，r 不变还是collect-generation-radix的值。\n如果使用第二个参数tg 调用collect，则tg 确定目标代。 当g 是最大的非静态代时，tg 必须为g 或为static。 否则，tg 必须为g 或g + 1 。 当目标代是static符号时，非静态代中的所有数据都将移动到静态代中。静态代中的对象从不会被回收。 这在加载和初始化应用程序的永久代码和数据结构之后非常有用，以减少后续回收的开销。\n通过设置本节中描述的参数，可以对回收器的行为进行实质性的调整。通过重新定义collect-request处理程序且使用显式的g 和tg 参数调用collect，甚至有可能完全覆盖收集器的默认策略来确定何时回收每个世代。例如，程序员可以通过使用显式的g 和tg 参数调用collect来重新定义处理程序，以在长时间内将最大的非静态代视为静态代，该参数在该时间段内绝不等于最大的非静态代。\n (collect) | (collect g) | (collect g tg)\n g 必须是不大于最大非静态代（collect-maximum-generation返回的值）的非负确定编号。 如果g 已经是最大的非静态代编号，则tg 必须是一个等于g 的fixnum或static符号。 否则，tg 必须是一个等于g 或大于g 的fixnum。\n此过程使存储管理器执行垃圾回收。 collect是通过collect-request处理程序定期调用的，但是也可以显式调用它，以在特定时间（例如，在计时计算之前）强制进行回收。 在Chez Scheme的线程版本中，调用collect的线程必须是唯一的活动线程。\n系统将根据g 和tg （如果提供）确定回收哪些世代，如本节的介绍中所述。\n (collect-rendezvous)\n 请求垃圾回收的方式应该与由系统自动发起的GC的方式相一致。所有正在运行的线程经过协调，以便其中一个调用collect-request处理程序，而其他线程暂停直到处理程序返回。\n请注意，如果collect-request处理程序（请参阅collect-request-handler）没有调用collect，那么collect-rendezvous实际上不会执行垃圾回收。\n collect-notify\n 如果将collect-notify设置为true，则每当运行GC时，回收器都会打印一条消息。 默认情况下，collect-notify设置为#f。\n collect-trip-bytes\n Chez Scheme在内部以大块分配内存，并通过内联操作将这些块细分以提高效率。存储管理器确定是否为每个分配的大块仅请求一次回收。此外，在存储管理器请求回收和兑现回收请求之间可能会花费一些时间，尤其是如果通过with-interrupts-disabled或disable-interrupts临时禁用了中断时。因此，collect-trip-bytes仅是一种近似度量。\n collect-generation-radix\n 此参数确定默认情况下的collect-request处理程序调用不带参数的collect时回收每一代的频率。每$r^g$次发生一次对应世代的回收，其中r 是collect-generation-radix的值，g 是世代数。\n将collect-generation-radix设置为1会强制所有世代每次都被回收， 将collect-generation-radix设置为非常大的数目将无限期有效地延迟较早的一代的回收。\n collect-maximum-generation\n 此参数确定当前可以使用的最大非静态世代数,它的值是1到254范围内的精确整数。设置为1时，仅使用两个非静态生成。 设置为2时，将使用三个非静态世代，依此类推。 当设置为254时，将使用255个非静态代，再加上一个静态代，总共256个世代。增加世代数可以减少了收集旧对象的频率，潜在地减少了收集开销，但同时也潜在地增加了系统中保留的不可访问对象的数量，从而增加了所需的内存总量。\n collect-request-handler\n collect-request-handler的值必须是一个过程。当系统认为应该要进行GC时（即，自上次GC以来，系统分配了由参数collect-trip-bytes规定的存储量之后），该过程在不带参数的情况下被调用。\n默认情况下，collect-request-handler仅调用不带参数的collect。 可以通过将collect-request-handler设置为不执行任何操作的过程来禁用自动收集，例如：\n(collect-request-handler void) 也可以利用防止任何中断的critical-section来临时禁用GC\n release-minimum-generation\n 此参数的值必须介于0到collect-maximum-generation的值（包括）之间，并且默认为collect-maximum-generation的值。\n当分配新数据且进行GC时，storage-management会自动地从操作系统中请求额外的虚拟内存地址。相应地，在堆显著减小的情况下，系统尝试将先前从操作系统获得的某些虚拟内存返回给操作系统。默认情况下，系统仅在针对最大非静态时代的GC之后才这样做。也可以让系统在对更年轻的世代回收之后就执行此操作，方法是将release-minimum-generation的值更改为小于collect-maximum-generation的值。由参数指定的世代，或者任何较老的世代是GC的目标世代时，存储管理系统将在GC之后尝试将不需要的虚拟内存返回给操作系统。\n当collect-maximum-generation设置为一个新值g 时，release-minimum-generation也同时隐式地更改为g ，有两个前提：（a）修改前这两个参数具有相同的值；（b）release-minimum-generation的值大于g\n heap-reserve-ratio\n 此参数确定了保留的内存的大概数量（没有返回给OS，如release-minimum-generation所描述的）与当前已占用的内存量（不包含已变为静态的内存区域）的比例，它的值必须是不精确的非负整数值； 如果设置为精确的实数值，则精确的值将转换为不精确的值。默认值1.0，为每个当前占用的非静态页面保留一页内存。 将其设置为较小的值可能会导致较小的平均虚拟内存占用量，而将其设置为较大的值可能会导致较少的操作系统调用以请求和释放内存空间。\n弱序对，暂时序对和守护者Weak Pairs, Ephemeron Pairs, and Guardians weak pairs允许程序维护指向对象的弱指针。 指向对象的弱指针不会阻止存储管理系统回收该对象，但是只要该对象在系统中是可访问的，它仍然有效。\nephemeron pairs与weak pairs类似，但是ephemeron pairs拥有两个指针，其中仅仅在第一个指针存在的情况第二个指针才能存在\nguardians允许程序保护对象免遭垃圾回收器的重分配，并确定该对象何时被重新分配。\nweak paris, ephemeron pairs 和guardians允许程序将有关对象的信息保留在单独的数据结构（例如哈希表）中，而无需担心维护此信息将导致对象无限期地保留在系统中。\n另外，guardians允许无限期地从释放对象中保存对象，以便可以重用它们，或者可以使用存储在对象中的数据执行清理或其他操作。\n (weak-cons obj1 obj2)\n 返回：一个新的弱序对\nobj1 是新对的car, obj2构成了新对的cdr。弱序对和普通对是无法区分的，除了这两种方式：\n 弱序对可以使用**weak-pair?**这个谓词来区别普通对 弱序对维护了一个指向(car obj)的弱指针  弱序对的car中的弱指针就像普通指针一样，只要它指向的对象可以通过系统中某个地方的普通（非弱）指针访问即可。 但是，如果垃圾收集器在某个时候识别出不存在指向该对象的非弱指针，则它将每个指向该对象的弱指针替换为“ broken weak-pointer”对象**#!bwp**，并丢弃该对象。\n弱序对的cdr字段不是弱指针，因此可以使用弱序对来构造弱保持对象的列表。可以像使用普通的列表的处理操作（例如length，map和assv）来操作这些list。弱序对可以使用set-car!和set-cdr!来修改； 在set-car!之后，car字段包含指向新对象的弱指针，代替了旧对象。弱序对的打印方式与普通对相同。 弱序对没有reader语法。弱序对在被写入然后被读取时成为普通对。\n(define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x \u0026#39;())) (car p) ⇒ (a . b) (define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x \u0026#39;())) (set! x \u0026#39;*) (collect) (car p) ⇒ #!bwp  (weak-pair? obj)\n (weak-pair? (weak-cons ’a ’b)) ⇒ #t (weak-pair? (cons ’a ’b)) ⇒ #f (weak-pair? \u0026#34;oops\u0026#34;) ⇒ #f  (ephemeron-cons obj1 obj2)\n obj1 是新对的car, obj2构成了新对的cdr。暂时序对和普通对是无法区分的，除了这两种方式：\n 暂时序对可以使用**ephemeron-pair?**这个谓词来区别普通对 暂时序对维护了一个指向(car obj)的弱指针，并且仅仅在pair的car存在时cdr才能保留  暂时序对的行为与弱序对类似，不过cdr有特殊的处理：如果car被设置为**#!bwp**的同时也会将cdr设置为**#!bwp**。由于同时将car和cdr字段设置为为**#!bwp**，因此可以通过cdr对象引用car对象这一事实本身并不意味着必须保留car（与弱序对不同）。 相反，出于某种原因，car必须独立于cdr对象保存。\n与弱序对和其他对一样，暂时序对使用**set-car!和set-cdr!**来修改数据，暂时序对的打印方式与普通对一样，但没有reader语法\n(define x (cons \u0026#39;a \u0026#39;b)) (define p (ephemeron-cons x x)) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b) (define x (cons \u0026#39;a \u0026#39;b)) (define p (ephemeron-cons x x)) (set! x \u0026#39;*) (collect) (car p) ⇒ #!bwp (cdr p) ⇒ #!bwp (define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x x)) ; not an ephemeron pair (set! x \u0026#39;*) (collect) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b) 与弱序对一样，如果在将x设置为*之前进行了垃圾回收将该pair提升为较老的一代，则上面中间示例的最后两个表达式实际上可能返回（a . b）。 但是，在上面的最后一个示例中，最后两个表达式的结果将始终为（a . b），因为弱序对的cdr持有非弱引用，并且该非弱引用阻止car字段变** #!bwp**。\n (ephemeron-pair? obj)\n (ephemeron-pair? (ephemeron-cons \u0026#39;a \u0026#39;b)) ⇒ #t (ephemeron-pair? (cons \u0026#39;a \u0026#39;b)) ⇒ #f (ephemeron-pair? (weak-cons \u0026#39;a \u0026#39;b)) ⇒ #f (ephemeron-pair? \u0026#34;oops\u0026#34;) ⇒ #f  (bwp-object? obj)\n 返回：如果obj是断开的broken weak-pair对象，则返回#t，否则返回#f\n(bwp-object? #!bwp) ⇒ #t (bwp-object? \u0026#39;bwp) ⇒ #f (define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x \u0026#39;())) (set! x \u0026#39;*) (collect (collect-maximum-generation)) (car p) ⇒ #!bwp (bwp-object? (car p)) ⇒ #t  (make-guardian)\n Guardians由要保护的对象组的过程表示。创建guardian后，注册对象组为空。 通过将对象作为参数传递给守护者，可以向guardian注册对象：\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) x ⇒ (aaa . bbb) (G x) 注册对象时也可以指定“representative”（即，y）对象。 继续上面的示例：\n(define y (cons \u0026#39;ccc \u0026#39;ddd)) y ⇒ (ccc . ddd) (G y \u0026#39;rep) 与守护者关联的一组注册对象在逻辑上细分为两个不相交的子组：一个子组称为“可访问”对象，一个子组称为“不可访问”对象。不可访问的对象是已被证明无法访问的对象（通过guardian机制本身或通过弱序对或暂时序对的car字段除外），可访问的对象是未经证明的对象。“已证明”一词在这里很重要：可能是可访问组中的某些对象确实是不可访问的，但这尚未得到证明。 在某些情况下，直到对象实际上变得不可访问很久之后（在当前实现中，直到发生包含对象的世代的垃圾回收），才可能做出这种证明。\n向guardian注册的对象最初被放置在可访问组中，并在它们变得不可访问后的某个时刻移入不可访问组。 不可访问组中的对象是通过调用不带参数的guardian来检索的。 如果不可访问组中没有对象，则guardian返回#f。 继续上面的示例：\n(G) ⇒ #f (set! x #f) (set! y #f) (collect) (G) ⇒ (aaa . bbb) ; 也有可能这个后打印出来 (G) ⇒ rep ; 这个先打印出来 (G) ⇒ #f 对G的初始调用返回#f，因为绑定到x和y的对是向G注册的唯一对象，并且仍然可以通过这些绑定访问这些序对。调用collect时，对象将移入不可访问的组。 因此，对G的两个调用返回先前绑定到x的序对和先前绑定到y的序对的representative，尽管可能与所示顺序相反。 （如上所述，对于弱序对，如果对象已迁移到较老的一代，则调用collect实际上可能不足以证明该对象不可访问。）\n实际上，从guardian那里获取的对象在任何方面都没有特殊的地位。 此功能避免了共享或循环结构可能会出现的问题。 由不可访问对象组成的共享或循环结构将被完整保留，将注册由guardian保护的部分都放置在该guardian不可访问的集合中。 然后，程序员可以完全控制结构的处理顺序。\n一个对象可以在guardian处多次注册，在这种情况下，可以多次检索该对象：\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) (G x) (G x) (set! x #f) (collect) (G) ⇒ (aaa . bbb) (G) ⇒ (aaa . bbb) 它也可以向不止一个guardian注册，并且guardian本身也可以向其他guardian注册。 在没有“representative”的情况下向guardian注册的对象，并放置在一个弱序对或暂时对的car字段中，其直到从guardian处将返回并由程序丢弃，或者直到guardian本身被丢弃为止。\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) (define p (weak-cons x \u0026#39;())) (G x) (set! x #f) (collect) (set! y (G)) y ⇒ (aaa . bbb) (car p) ⇒ (aaa . bbb) (set! y #f) (collect 1) (car p) ⇒ #!bwp 另一方面，如果指定了representative（对象本身除外），则在从guardian处获得representative的同时，也会从弱序对或暂时序对的car字段中丢弃受保护的对象。\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) (define p (weak-cons x \u0026#39;())) (G x \u0026#39;rep) (set! x #f) (collect) (G) ⇒ rep ; 获得representative的值 (car p) ⇒ #!bwp ; 自动丢弃 下面的示例说明了当guardian本身丢弃时，该对象已被释放并且弱序对的car字段设置为#!bwp：\n(define G (make-guardian)) (define x (cons aaa \u0026#39;bbb)) (define p (weak-cons x \u0026#39;())) (G x) (set! x #f) (set! G #f) (collect) (car p) ⇒ #!bwp 下面的示例演示了如何使用guardian来释放外部存储，就像由C库“malloc”和“free”操作管理存储。\n(define malloc (let ([malloc-guardian (make-guardian)]) (lambda (size) ; first free any storage that has been dropped. to avoid long ; delays, it might be better to deallocate no more than, say, ; ten objects for each one allocated (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f)))) ; then allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x)))) do-malloc必须返回一个Scheme对象“header”，该header封装一个指向外部存储的指针（可能是无符号整数），并且必须通过此header对外部存储进行所有访问。特别是，必须注意在删除相应的header之后，在Scheme之外不存在指向外部存储的指针。 do-free必须使用封装的指针释放外部存储。这两个原语都可以使用外部分配和外部无关的定义，也可以作为外部过程导入的C库“malloc”和“free”运算符进行定义。\n如果不希望调用malloc来释放存储，则可以使用collect-request处理器来检查并释放已丢弃的存储，如下所示：\n(define malloc) (let ([malloc-guardian (make-guardian)]) (set! malloc (lambda (size) ; allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x))) (collect-request-handler (lambda () ; first, invoke the collector (collect) ; then free any storage that has been dropped (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f))))))) 通过一点重构，就有可能将封装的外部地址注册为带header的representative，在这种情况下，do-free将仅将外部地址作为参数。 这将使标头一旦变得不可访问，便可以将其从Scheme堆中删除。\n锁对象Locking Objects 来自C语言的变量或数据结构到Scheme对象的所有指针，通常应在输入（或重新输入）Scheme之前丢弃。 当无法遵循该准则时，可以通过锁定对象或等效的C库过程Slock_object锁定该对象。\n (lock-object obj)\n 锁定对象可防止存储管理器收回或重定位该对象。 应谨慎使用锁定，因为它会导致内存碎片并增加存储管理开销。\n如果未解锁对象，锁定也会导致意外保留存储空间。 可以通过解锁对象或等效的C库过程Sunlock_object来解锁对象。\n锁定立即数（例如，fixnum，布尔值和字符）或已被静态化的对象是不必要但无害的。\n (unlock-object obj)\n 通过连续调用lock-object，Slock_object或同时调用这两个对象，可以多次锁定对象，在这种情况下，必须先通过相等次数的对unlock-object或Sunlock_object的调用来将其解锁。\n除非存在指向对象的单独的C指针，否则也无需锁定包含在锁定对象中的对象（例如，锁定序对的car中的对象）。也就是说，如果仅允许通过外部对象来间接访问的内部对象，则应将其解锁，以便回收器在回收期间可以自由地重分配它。\n解锁立即值（例如，fixnum，布尔值和字符）或已设为静态的对象是不必要的，无效的，但无害。\n (locked-object? obj)\n 返回：如果obj是锁定的，立即的或静态的，返回#t\n如果回收器无法重分配或回收obj，则该谓词将返回true，包括立即值，例如fixnums，布尔值和字符以及已设为静态的对象。\n","id":77,"section":"posts","summary":"垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动","tags":["scheme"],"title":"存储管理(Storage Management in Chez Scheme)","uri":"https://lvsq.net/2020/02/storage-management/","year":"2020"},{"content":"异常  (warning who msg irritant \u0026hellip;)\n  返回：未指定\n 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止程序继续运行但可能在以后导致更严重问题的情况。通常最好是识别程序员已调用的过程，而不是程序员可能不知道的其他过程。 msg必须为字符串，并应描述异常情况。irritant可以是任何Scheme对象，并且应包含可能导致或严重涉及异常情况的值。\n (assertion-violationf who msg irritant \u0026hellip;) | (errorf who msg irritant \u0026hellip;) | (warningf who msg irritant \u0026hellip;)\n 这些过程类似于assertion-violation, error, warning, 所不同的在于 msg 设定为一个格式字符串\n中断 Chez Scheme允许程序在发生各种事件时控制Scheme系统的操作，这些事件包括键盘中断，由set-timer设置的内部计时器到期，由中断调用引发的断点或者来自存储管理器的请求启动GC。\n无论何时break被调用，系统都会立即启用中断处理程序\n (break who msg irritant \u0026hellip;) | (break who) | (break)\n break参数遵循上述errorf的协议。默认的中断处理程序（请参见break-handler）显示一条消息并调用调试器。可以省略格式字符串和对象，在这种情况下，默认中断处理程序发出的消息使用who参数标识中断，但不提供有关中断的更多信息。如果也省略了who参数，则不会生成任何消息。如果调试器正常退出，则默认的中断处理程序将正常返回。\n break-handler\n 此参数的值必须是一个过程。当前的中断处理程序由break调用，它传递其参数。有关默认中断处理程序的描述，请参见break。以下示例显示了如何禁用breaks。\n(break-handler (lambda args (void)))  (set-timer n)\n n 必须为非负整数。当n 为非零时，设置计时器启动一个内部计时器，其初始值为n。经过n个tick后，将发生计时器中断，从而导致计时器中断处理程序被调用。tick不是统一的时间单位，而是在很大程度上取决于每个过程调用要完成多少工作。\n当n为零时，设置计时器关闭计时器。\nengine机制建立在计时器中断之上，因此不应与engine共同使用。\n (register-signal-handler sig procedure)\n register-signal-handler用于为给定的底层信号建立信号处理程序。 sig必须是标识有效信号的精确整数，过程应接受一个参数。在注册了给定signal的处理程序之后，收到了给定的signal会调用该处理程序。signal编号会传递给该处理程序，从而允许同一处理程序用于不同的信号，同时区分它们。\n以这种方式处理的信号类似于键盘中断，因为在将信号传递到进程时不会立即调用处理程序，而是在信号传递后在某个过程调用边界处调用该处理程序。因此，为内存故障，非法指令等建立处理程序通常不是一个好主意，因为导致故障或非法指令的代码将在调用处理程序之前继续执行（可能是错误的）一段时间。\n另外，仅在基于Unix的系统上才支持register-signal-handler。\n环境 环境是包含标识符绑定的顶级（first-class）对象。它们类似于模块，但是与模块不同，它们可以在运行时进行操作。环境可以作为eval，expand以及过程的定义，分配或引用顶级值的可选参数。\n有几种内置环境，也可以通过复制现有环境或从现有环境中选择的绑定来创建新环境。\n环境可以是可变的或不变的。可变的环境可以使用新的绑定进行扩展，可以修改其现有绑定，还可以分配其变量。不变的环境不能以任何这些方式进行修改。\n 联想一下SICP中关于环境的内容   (environment? obj)\n (environment? (interaction-environment)) ⇒ #t (environment? \u0026#39;interaction-environment) ⇒ #f (environment? (copy-environment (scheme-environment))) ⇒ #t (environment? (environment \u0026#39;(prefix (rnrs) $rnrs-))) ⇒ #t  (environment-mutable? env)\n (environment-mutable? (interaction-environment)) ⇒ #t (environment-mutable? (scheme-environment)) ⇒ #f (environment-mutable? (copy-environment (scheme-environment))) ⇒ #t (environment-mutable? (environment \u0026#39;(prefix (rnrs) $rnrs-))) ⇒ #f  (scheme-environment)\n scheme-environment返回一个包含初始顶级绑定的环境。该环境对应于Scheme模块。此过程返回的环境是不可变的。\n(define cons 3) (top-level-value \u0026#39;cons (scheme-environment)) ⇒ #\u0026lt;procedure cons\u0026gt; (set-top-level-value! \u0026#39;cons 3 (scheme-environment)) ⇒ exception  (copy-environment env) | (copy-environment env mutable?) | (copy-environment env mutable? syms)\n copy-environment返回env的副本，即包含与env 相同绑定的新环境。mutable? 如果为true，则该environment是可变的，反之则不可变；\n从env 复制到新环境的绑定集由syms 确定，其默认值为（environment-symbols env）。每个syms 元素的绑定（如果有）都被复制到新环境中，并且新环境中不存在其他绑定。\n在当前的实现中，永远不会收集环境使用的存储空间，因此重复使用复制环境最终将导致系统内存不足。\n(define e (copy-environment (scheme-environment))) (eval \u0026#39;(define cons +) e) (eval \u0026#39;(cons 3 4) e) ⇒ 7 (eval \u0026#39;(cons 3 4) (scheme-environment)) ⇒ (3 . 4)  (environment-symbols env)\n 此过程返回代表环境env中绑定的标识符的符号列表。它主要用于构建要从一种环境复制到另一种环境的符号列表。\n(define listless-environment (copy-environment (scheme-environment) #t (remq \u0026#39;list (environment-symbols (scheme-environment))))) (eval \u0026#39;(let ([x (cons 3 4)]) x) listless-environment) ⇒ (3 . 4) (eval \u0026#39;(list 3 4) listless-environment) ⇒ exception 编译、求值和加载  (eval obj) | (eval obj env)\n eval将obj 视为表达式的表示形式。它在环境env中计算表达式并返回其值。如果未提供任何环境，则默认为由交互环境返回的环境。单参数求值是Chez Scheme的扩展。当环境可变时，Chez Scheme还允许obj表示非表达形式，比如一个definition。 Chez Scheme还允许obj作为一个annotation，默认求值程序利用注释将源文件信息合并到错误消息中，并将源文件信息与编译后的代码相关联。\n在Chez Scheme中，eval实际上是一个包装器，仅将其参数传递给当前求值器（请参阅current-eval）。默认的评估器是compile，它通过当前的扩展器（参阅current-expand）扩展表达式，对其进行编译，执行生成的代码，并返回其值。如果存在环境参数env ，则compile将其传递给当前的扩展器，默认情况下为sc-expand。\n (compile obj) | (compile obj env)\n obj 可以为Scheme表达式，在指定的环境（或交互环境，如果未提供环境）中使用当前扩展器（current-expand的值）进行扩展），编译为机器代码，然后执行。 compile是current-eval参数的默认值。\n(compile \u0026#39;(cons 1 2)) =\u0026gt; (1 . 2)  (interpret obj) | (interpret obj env)\n 解释类似于编译，只是表达式是解释的而不是编译的（the expression is interpreted rather than compiled）。解释可以用作编译的替代品，但有以下警告：\n 解释后的代码运行速度大大降低 解释后的代码不会生成检查器信息，因此检查器对于解释的代码不如在编译的代码中有用、 无法解释外部过程表达式，因此解释器需要为所有外部过程表达式调用编译器（这是透明完成的）  当求值形式运行时间较短时，解释有时比编译更快，因为它避免了在求值之前通过编译完成的某些工作。\n (load path) | (load path eval-proc)\n path 必须是字符串。 load读取并求值path 指定的文件的内容。该文件可能包含源代码或目标代码。默认情况下，load使用eval求值源文件中找到的每个源表达式。如果指定了eval-proc ，则load将使用此过程。 eval-proc 必须接受一个参数，即要求值的表达式。\neval-proc参数有助于实现嵌入的类似于Scheme的语言，并有助于使用用于Scheme程序的替代评估机制。 eval-proc也可以用于其他用途。例如，\n(load \u0026#34;myfile.ss\u0026#34; (lambda (x) (pretty-print (if (annotation? x) (annotation-stripped x) x)) (newline) (eval x))) 对每一个表达式求值之前使用pretty-print打印。\n参数source-directorys确定了搜索目录，以搜索未由绝对路径名标识的源文件。\n (load-library path) | (load-library path eval-proc)\n load-library与load相同，除了它会将输入文件视为由隐式**＃!r6rs**作为前缀。这有效地禁用了所有**非R6RS**词法语法，除非随后被**＃！chezscheme**覆盖\n (load-program path) | (load-program path eval-proc)\n path 必须是字符串。加载程序读取并求值path指定的文件的内容。该文件可能包含源代码或目标代码。如果包含源代码，则加载程序会将代码以顶级程序形式包装起来，以便将文件的内容视为RNRS顶级程序（Scheme编程语言，第4版的10.3节）。默认情况下，加载程序使用eval求值文件中找到的每个源表达式。如果指定了eval-proc，则装入程序将使用此过程。 eval-proc必须接受一个参数，即要评估的表达式。传递给eval-proc的表达式可能是注释或未注释的值。 参数source-directorys确定了搜索目录，以搜索未由绝对路径名标识的源文件。\n (load-compiled-from-port input-port)\n load-compiled-from-port读取并求值来自input-port的对象代码的内容，这些input-port是事先由诸如compile-file, compile-script, compile-library, compile-to-port创建的返回值是最后一个表达式的值，该表达式的编译形式为input-port。如果input-port为空，则结果值未指定。\n (compile-file input-filename) | (compile-file input-filename output-filename)\n input-filename 和output-filename 必须是字符串。input-filename 必须是已存在的可读文件。它必须包含零个或多个源表达式的序列；如果不是这种情况，则编译文件会引发条件类型为＆syntax的异常。\n正常求值过程分为两个步骤：编译和执行。 compile-file对整个源文件执行编译过程，从而生成目标文件。随后加载目标文件（请参见load）时，不需要编译过程，并且文件加载通常快几倍。\n (compile-script input-filename) | (compile-script input-filename output-filename)\n compile-script与compile-file类似，不同点在于，它会从源文件复制开头的**#!**行到目标文件，同时该行不会被压缩，尽管参数**compile-compressed**被设置为#t，其他代码会被压缩，这样会保证操作系统可以正确地解释。\ncompile-script允许从源脚本创建已编译的脚本文件，以减少脚本加载时间。与源代码脚本一样，可以使用**\u0026ndash;script**命令行选项运行已编译的脚本。\n (compile-library input-filename) | (compile-library input-filename oiutput-filename)\n compile-library与compile-file相同，不同之处在于，它会将输入文件视为由隐式**＃!r6rs**作为前缀。这有效地禁用了所有非R6RS词法语法，除非随后被＃!chezscheme覆盖。\n (compile-program input-filename) | (compile-program input-filename output-filename)\n compile-program类似于compile-script，但不同之处在于，它实现了RNRS顶级程序的语义，而compile-script则实现了交互式顶级程序的语义。与通过compile-file或compile-script进行编译相比，生成的已编译程序的运行速度也更快。\ncompile-program返回由编译的顶层程序直接调用的库的列表，不包括（rnrs）和（chezscheme）之类的内置库\n (compile-whole-program input-filename output-filename) | (compile-whole-program input-filename output-filename libs-visible?)\n compile-whole-program接受一个文件名作为名称输入，该文件名为顶级程序命名为“ whole program optimization”（wpo）文件，并生成一个包含该程序及其所依赖的每个库的目标文件，前提是需要一个可以找到库的wpo文件。\n如果wpo文件找不到所需库，但可以找到该库的目标文件，则该库不会合并到生成的目标文件中。这些库将在运行时加载。 compile-whole-program返回这些库的列表。如果没有这样的库，则生成的目标文件是自包含的，并且compile-whole-program返回空列表。\n如果libs-visible? 设置为非false，则库合并到目标文件是可见的（供environment和eval使用），任何合并到目标文件中并在运行时保留下来的目标文件所要求的库都是可见的。\n当generate-wpo-files参数设置为#t时，过程compile-file，compile-program，compile-library，compile-script和compile-whole-library会生成wpo文件以及普通目标文件。 （默认值为#f）。另外如果传递可选的wpo端口时，compile-port和compile-to-port也会这样做。\n (compile-whole-library input-filename output-filename)\n compile-whole-library类似于compile-whole-program，不同之处在于input-filename必须为库指定一个wpo文件，所有库自动显示，并生成一个新的wpo文件（当generate-wpo-files为#t时）以及用于生成的库组合的目标文件。\n (compile-port input-port output-port) | (compile-port input-port output-port sfd) | (compile-port input-port output-port sfd wpo-port)\n input-port 必须是文本输入端口。out-port 和wpo-port（如果存在）必须是二进制输出端口。如果存在sfd ,必须是源文件描述符。\n (make-boot-file output-filename base-boot-list input-filename \u0026hellip;)\n 所有参数都必须是字符串。\nmake-boot-file将引导标头（boot header）写入以output-filename 命名的文件，然后依次写入每个input-filename 的目标代码。如果尚未编译输入文件，make-boot-file将在对其进行编译。\n引导文件通过\u0026ndash;boot或-b命令行选项显式加载，或基于可执行文件的名称隐式加载。\n (make-boot-header output-filename base-boot1 base-boot2\u0026hellip;)\n 该过程已包含在make-boot-file中，并提供了向后兼容性。\n(make-boot-header output-filename base-boot1 base-boot2 \u0026hellip;)等价于：(make-boot-file output-filename ’(base-boot1 base-boot2 \u0026hellip;))源目录和文件  source-directories\n source-directories的值必须是一个字符串列表，每个字符串都命名一个目录路径。当通过load, load-library, load-program, include, visit, or revisit在交互式检查器中发生语法错误或打开源文件时，source-directory确定用于搜索源文件或目标文件的目录集。\n默认值为列表（“.”），这意味着仅在当前目录中或相对于当前目录才能找到源文件，除非使用绝对路径命名。\n (with-source-path who name procedure)\n 过程with-source-path依次搜索当前源目录路径，以查找具有指定名称的文件，并在结果上调用过程。如果未找到这样的文件，则引发**\u0026amp;assertion**和**\u0026amp;who**异常，**\u0026amp;who**的值为*who* 的值\n如果name 是绝对路径，或者以./（Windows下是./），或者../（Windows下是..\\），或者源目录列表中只包含“.”，或者默认值 \u0026ldquo;\u0026quot;，相当于 \u0026ldquo;.\u0026quot;，不执行搜索并返回name。\nwho 必须是符号，name 必须是字符串，procedure 应接受一个参数。\n以下示例假定文件“ pie”存在于目录“ ../spam”中，但不在“ ../ham”或当前目录中。\n(define find-file (lambda (fn) (with-source-path \u0026#39;find-file fn values))) (find-file \u0026#34;pie\u0026#34;) ⇒ \u0026#34;pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../ham\u0026#34;)) (find-file \u0026#34;pie\u0026#34;) ⇒ exception in find-file: pie not found (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../spam\u0026#34;)) (find-file \u0026#34;pie\u0026#34;) ⇒ \u0026#34;../spam/pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../ham\u0026#34;)) (find-file \u0026#34;/pie\u0026#34;) ⇒ \u0026#34;/pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../ham\u0026#34;)) (find-file \u0026#34;./pie\u0026#34;) ⇒ \u0026#34;./pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../spam\u0026#34;)) (find-file \u0026#34;../pie\u0026#34;) ⇒ \u0026#34;../ham/pie\u0026#34; 编译器管理  optimize-level\n 该参数可以是0，1，2，3这4个值中的一个。\n理论上，此参数控制编译器执行的优化量。 实际上，它只是间接执行此操作，唯一的区别在于优化级别3（编译器生成“不安全”代码）与优化级别0-2（编译器生成“安全”代码）之间。 安全代码会执行完整类型和范围检查，例如，尝试应用非过程，尝试对non-pair的car操作或尝试引用向量的末尾，均会导致 引发异常。 对于不安全的代码，相同的情况可能会导致无效的内存引用，Scheme堆损坏（这可能在以后引起看似无关的问题），系统崩溃或其他不良行为。不安全的代码通常会更快，但是应该谨慎使用优化级别3，并且仅运用在必须尽快运行且经过良好测试的代码中。\n尽管编译器为优化0至2级生成了相同的代码，但如果需要，用户定义的宏转换器可以区分不同的级别。\n一种使用优化级别的方法是在每个文件上，强制使用eval-when。 例如:\n(eval-when (compile) (optimize-level 3))  也可以通过\u0026ndash;optimize-level命令行选项设置优化级别。此选项对于通过\u0026ndash;program命令行选项在优化级别3运行RNRS顶层程序特别有用，因为eval-when对RNRS顶层程序无效。\n ($primitive variable) | ($primitive 2 variable) | ($primitive 3 variable)\n variable 必须是一个原始procedure的名字。** $primitive**语法形式允许以单个原始引用的粒度控制优化级别，并且它可以用于访问原始值。\n表达式（$primitive variable）可以缩写为**#%variable**。\n(#%car ’(a b c)) ⇒ a (let ([car cdr]) (car \u0026#39;(a b c))) ⇒ (b c) (let ([car cdr]) (#%car \u0026#39;(a b c))) ⇒ a (begin (set! car cdr) (#%car \u0026#39;(a b c))) ⇒ a  debug-level\n 该参数可以采用0、1、2和3这四个值之一。它用于告诉编译器保留调试信息的重要性，其中0的重要性最低，而3的重要性最高。 默认值是1。从9.0版开始，它仅用于确定在非尾部位置遇到的引起错误的调用是否被视为在尾部位置（因此，导致调用者的帧不出现在堆栈回溯中）。 这发生在低于2的调试级别。\n概要分析Profiling ChezScheme支持两种类型的配置文件：源代码概要分析和块概要分析。\n启用源概要分析后，编译器会对生成的代码进行检测，以计算每个源代码表达式的执行次数。 该信息可以HTML格式显示或打包在列表中，以进行任意用户定义的处理。 也可以将其转储到文件中，然后再加载到编译器的概要分析信息数据库中，以用于源代码级优化。\n源代码概要分析至少包含下面一些步骤：\n 编译代码且开启source profiling 运行编译后的代码生成源代码概要分析信息，且 转储概要分析信息  通过将参数compile-profile设置为符号源或布尔值#t，可以启用源概要分析。 可以通过以下方式转储概要分析信息：\nprofile-dump-html 以HTML格式显示，以便程序员可以直观地看到使用彩色编码系统执行每个表达式的频率，该系统可以轻松发现“热点”profile-dump-list 以适合用户定义的后处理的形式;profile-dump 以适合于通过上述方法之一或某些自定义方式进行离线处理的形式，或profile-dump-data 以适合加载到编译器数据库中的形式。\n由profile-dump-data转储的概要分析信息通过profile-load-data加载到编译器的profiling数据库中。 除非通过profile-dump-data显式转储并通过profile-load-data加载，否则分析信息对编译器不可用。\n当使用块概要文件信息进行优化时，步骤是相似的： 编译代码并开启block profiling 运行代码生成block-profiling信息 转储概要分析信息 加载概要信息，且 重新编译代码  通过将参数compile-profile设置为符号块或布尔值#t，可以启用块分析。 概要文件信息必须通过profile-dump-data转储，并通过profile-load-data加载。 与源配置文件信息一样，块配置文件信息可以与转储信息的加载过程相同或不同。\n对于块优化，要重新编译的代码必须相同。 通常，这意味着所涉及的文件必须未经修改，并且其他任何更改都不会间接影响编译器生成的代码。\n出于同样的原因，当要同时使用源概要分析和块概要分析信息进行优化时，必须先收集并加载源信息，然后再运行涉及块概要分析的第一次和第二次编译。 即，必须使用以下步骤：1. 编译代码并起开源代码概要分析 2. 运行代码生成source-profiling信息 2. 转储source-profiling 3. 加载source-profiling 3. 重新编译代码，并开启块概要分析 4. 运行代码生成block-profiling信息 4. 转储block-profiling 5. 加载source-和block-profiling 5. 重新编译代码  标记每个步骤的数字既指示步骤的顺序，又指示必须在同一计划过程中执行的顺序。 （如果需要，所有步骤都可以在同一Scheme流程中执行。） 当compile-profile设置为默认值#f时，将禁用源和块分析。\n假设文件/tmp/fatfib/fatfib.ss包含以下代码：\n(define fat+ (lambda (x y) (if (zero? y) x (fat+ (1+ x) (1- y))))) (define fatfib (lambda (x) (if (\u0026lt; x 2) 1 (fat+ (fatfib (1- x)) (fatfib (1- (1- x))))))) 我们可以像下面这样加载fatfib.ss并且开启概要分析：\n(parameterize ([compile-profile \u0026#39;source]) (load \u0026#34;/tmp/fatfib/fatfib.ss\u0026#34;)) 然后运行代码：\n(fatfib 20) ⇒ 10946 运行（或多次运行）之后，转储概要文件为一些html文件集合： 使用profile-dump-html\n(profile-dump-html) 这将创建一个名为profile.html的文件\n在图中，执行最频繁的代码以接近红色的颜色突出显示，而执行最不频繁的代码以接近紫色的颜色突出显示。\n compile-profile\n 当将此参数设置为符号source或布尔值**#t**时，编译器将使用指令对生成的代码进行检测，这些指令对源代码的每个部分执行的次数进行计数。 当设置为符号**block**时，编译器类似地使用指令对生成的代码进行检测，该指令对每个代码块的执行次数进行计数。 当设置为**#f**（默认值）时，编译器不会插入这些指令。\n当compile-profile为非false时生成的代码较大且效率较低，因此仅在需要概要分析信息时才应设置此参数。启用概要分析检测后编译的代码的概要文件计数器将无限期保留，即使与它们关联的代码已被垃圾收集器回收。 这样可以得到更完整和准确的概要分析数据，但会导致动态生成或加载代码的程序出现空间泄漏，程序可以通过profile-release-counters过程显式地释放计数器，从而避免潜在的空间泄漏。\n (profile-clear)\n 调用此过程会清空概要分析信息，代码每个部分关联的计数都被置为0\n (profile-release-counters)\n 调用此过程将丢弃概要分析\n (profile-dump)\n 此过程将生成自启动或上次调用profile-clear以来收集的所有配置文件信息的转储。 它返回一个pair的列表，其中每个pair的car是一个source-object，而cdr是一个精确的非负整数计数。\nprofile-dump优于profile-dump-list的优点在于，profile-dump仅执行最少的处理，并保留完整的源对象，包括其嵌入式源文件描述符。 例如，它可以用于将概要分析信息转储到一台计算机上的fasl文件中，以便在另一台计算机上进行后续处理。\n (profile-dump-html) | (profile-dump-html prefix) | (profile-dump-html prefix dump)\n 此过程将生成一个或多个HTML文件，包括profile.html（其中包含用颜色编码的摘要信息），以及一个文件source.html，其中每个源文件源都包含用源代码进行颜色编码的副本，如前导中所述： 在本节中。 如果指定了prefix ，则它必须是字符串，并且在生成的HTML文件的名称之前。 例如，如果前缀为**“ /tmp/”**，则生成的文件将放置在目录/tmp中。 原始概要分析信息是从转储获取的，默认为**profile-dump**返回的值\n (profile-palette)\n 此参数的值必须是至少三对的非空向量。 每个pair的car是背景色，而cdr是前景（文本）色。 每种颜色都必须是一个字符串，并且每个字符串都应包含HTML层叠样式表（CSS）颜色说明符。 第一组用于未配置的代码，第二对用于未执行的配置的代码。 第三个用于执行频率最低的代码，第四个用于执行频率倒数第二低的代码，以此类推，最后一个用于执行频率最高的代码。 程序员可能希望提供自己的调色板以增强可见性或更改所用颜色的数量。\n默认情况下，黑色背景用于未配置文件的代码，灰色背景用于未执行的配置文件的代码。 根据执行频率，紫色到红色的背景颜色用于执行的概要分析代码，而最频繁执行的代码使用红色。\n(profile-palette) ⇒ #((\u0026#34;#111111\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#607D8B\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#9C27B0\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#673AB7\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#3F51B5\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#2196F3\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#00BCD4\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#4CAF50\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#CDDC39\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FFEB3B\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FFC107\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FF9800\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#F44336\u0026#34; . \u0026#34;white\u0026#34;)) (profile-palette ; set palette with rainbow colors and black text ; for all but unprofiled or unexecuted code \u0026#39;#((\u0026#34;#000000\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#666666\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#8B00FF\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#6600FF\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#0000FF\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#00FF00\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FFFF00\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FF7F00\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FF0000\u0026#34; . \u0026#34;black\u0026#34;))) ; red  (profile-line-number-color)\n 此参数的值必须是字符串或#f。 如果是字符串，则该字符串应包含HTML层叠样式表（CSS）颜色说明符。 如果参数设置为字符串，则profile-dump-html使用指定的颜色在每个源文件的html呈现中包括行号。 如果参数设置为#f，则不包含行号。\n个性化（Waiter Customization）  (new-cafe) | (new-cafe eval-proc)\n Chez Scheme通过waiter 或read-eval-print循环（REPL）与用户进行交互。 waiter在称为caf́e的上下文中运行。 当系统启动时，将用户置于caf́e中并分配waiter 。 new-cafe在旧的caf́e之上开启了一个新的Scheme caf́e。 除了启动waiter 之外，new-cafe还设置了caf́e的重置和退出处理程序（请参阅reset-handler和exit-handler）。 退出caf́e会返回到创建该caf́e的caf́e。从最初的caf́e退出后会完全退出了Scheme。 caf́e可以通过显式调用exit或通过接收end-of-file（Unix系统上为“ control-D”）来退出。在前一种情况下，传递给exit的任何值都是从new-cafe返回的。\n\u0026gt; (define x 1) \u0026gt; x 1 \u0026gt; (new-cafe) \u0026gt;\u0026gt; x 1 \u0026gt;\u0026gt; (define y 2) \u0026gt;\u0026gt; y 2 \u0026gt;\u0026gt; (exit 1) 1 如果指定了可选的eval-proc 参数，则使用eval-proc 求值从控制台输入的程序。 否则，将使用参数current-eval 的值。 eval-proc必须接受一个参数，即要求值的表达式。\n\u0026gt; (new-cafe (lambda (x) x)) \u0026gt;\u0026gt; 3 3 \u0026gt;\u0026gt; (a . (b . (c . ()))) (a b c) \u0026gt; (define sum (lambda (ls) (if (null? ls) 0 (+ (car ls) (sum (cdr ls)))))) \u0026gt; (new-cafe sum) \u0026gt;\u0026gt; (1 2 3) 6 时间和日期 时间由时间对象表示。 时间对象记录特定时间或持续时间的纳秒和秒，以及标识时间对象性质的time type 。 时间类型是以下符号之一：time-utc: 从“纪元”1970年1月1日0点0分0秒以来的时间time-monotonic: 从过去某个任意时间点开始经过的时间，理想情况下无需进行调整。time-duration: 两个时间的间隔。当作为current-time的参数时，其行为与time-monotonic类似，但也可以用来表示两个时间对象相减的结果time-process: 当前进程使用的CPU时间量。time-thread: 当前线程使用的CPU时间量。 如果未运行线程，或者系统不允许确定单个线程时间，则该时间与time-process相同。time-collector-cpu: 当前进程用于垃圾回收的这部分CPU消耗的时间。time-collector-real: 当前进程用于垃圾回收的这部分实时消耗的时间日期由日期对象表示。 日期对象记录特定日期的纳秒，秒，分钟，小时，日，月和年，以及标识时区的偏移量。\n (current-time) | (current-time time-type)\n time-type 必须是上述的时间对象之一，默认为time-utc\n(current-time) ⇒ #\u0026lt;time-utc 1198815722.473668000\u0026gt; (current-time ’time-process) ⇒ #\u0026lt;time-process 0.120534264\u0026gt;  (make-time type nsec sec)\n type 必须是上面列出的时间类型符号之一。 nsec 表示纳秒，并且必须是小于$10^9$的精确非负整数。sec 表示秒，并且必须是精确的整数。\n(make-time \u0026#39;time-utc 787511000 1198783214) (make-time \u0026#39;time-duration 10 5) (make-time \u0026#39;time-duration 10 -5)  (time? obj)\n (time? (current-time)) ⇒ #t (time? (make-time ’time-utc 0 0)) ⇒ #t (time? \u0026#34;1400 hours\u0026#34;) ⇒ #f  (time-type time)\n 返回time 的时间类型\n (time-nanosecond time)\n 返回time 的纳秒\n (time-second time)\n 返回time 的秒\n (set-time-type! time type) | (set-time-nanosecond! time nsec) | (set-time-second! time sec)\n 每一个过程都会修改时间对象，只改变局部，而其他值则不受影响。 例如，set-time-nanosecond! 只更改纳秒时间，而不更改秒或类型。 特别地，当时间对象的类型改变时，值并不会更改。\n (time=? time1 time2) | (time\u0026lt;? time1 time2) | (time\u0026gt;? time1 time2) | (time\u0026lt;=? time1 time2) | (time\u0026gt;=? time1 time2)\n 时间比较。\n (copy-time time)\n 复制时间。\n(define t1 (current-time)) (define t2 (copy-time t1)) (eq? t2 t1) ⇒ #f (eqv? (time-second t2) (time-second t1)) ⇒ #t (eqv? (time-nanosecond t2) (time-nanosecond t1)) ⇒ #t  (time-difference time1 time2 ) | (time-difference! time1 time2 ) | (add-duration time timed) | (add-duration! time timed) | (subtract-duration time timed) | (subtract-duration! time timed)\n 对于time-difference，time1和time2必须具有相同的时间类型，结果是时间类型为time-duration的时间对象。 对于add-duration，add-duration！，subtract-duration和subtract-duration！，timed必须具有时间类型time-duration，并且结果是时间类型与时间相同的时间对象。 time-difference！，add-duration！和subtract-duration！ 可能具有破坏性，即每个对象都可能修改并返回其第一个参数，或者可能分配了新的时间对象\n(let ([delay (make-time \u0026#39;time-duration 0 1)]) (let ([t1 (current-time \u0026#39;time-monotonic)]) (sleep delay) (let ([t2 (current-time \u0026#39;time-monotonic)]) (let ([t3 (time-difference t2 t1)]) (and (eq? (time-type t3) \u0026#39;time-duration) (time\u0026gt;=? t3 delay) (time=? (add-duration t1 t3) t2) (time=? (subtract-duration t2 t3) t1)))))) ⇒ #t  (current-date) | (current-date offset)\n 如上所述，offset 表示UTC以东的时区偏移量（以秒为单位）。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 可以通过传递零偏移量来获得UTC.offset表示UTC以东以秒为单位的时区偏移量，如上所述。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 UTC可以通过传递零偏移来获得。\n如果未提供offset ，则使用当前时区的offset，以及date-dst？ 和date-zone-name报告有关时区的信息。 如果提供了偏移量，那么date-dst？ 和结果日期对象上的date-zone-name都是**#f**。\n(current-date) ⇒ #\u0026lt;date Thu Dec 27 23:23:20 2007\u0026gt; (current-date 0) ⇒ #\u0026lt;date Fri Dec 28 04:23:20 2007\u0026gt; (date-zone-name (current-date)) ⇒ \u0026#34;EST\u0026#34; or other system-provided string (date-zone-name (current-date 0)) ⇒ #f  (make-date nsec sec min hour day mon year) | (make-date nsec sec min hour day mon year offset)\n nsec代表纳秒，并且必须是小于$10^9$的精确非负整数。sec代表秒，并且必须是小于62的精确非负整数。min代表分钟，并且必须是小于60的精确非负整数。hour必须是精确的非负整数 小于24。day必须是一个精确的整数，1≤day≤31。（实际上限可能取决于月份和年份。）mon表示月份必须是一个精确的整数，1≤mon≤12。年必须 是一个精确的整数。 如上所述，它应至少为1970。offset表示UTC以东的时区偏移（以秒为单位）。 它必须是-86400到+86400（含）范围内的精确整数。 可以通过传递零偏移量来指定UTC。\n(make-date 0 0 0 0 1 1 1970 0) ⇒ #\u0026lt;date Thu Jan 1 00:00:00 1970\u0026gt; (make-date 0 30 7 9 23 9 2007 -14400) ⇒ #\u0026lt;date Sun Sep 23 09:07:30 2007\u0026gt; (date-zone-name (make-date 0 30 7 9 23 9 2007 -14400)) ⇒ #f (string? (date-zone-name (make-date 0 30 7 9 23 9 2007))) ⇒ #t  (date-nanosecond date) | (date-second date) | (date-minute date) | (date-hour date) | (date-day date) | (date-month date) | (date-year date) | (date-zone-offset date)\n 如字面的意思， 返回日期的对应的部分的值\n (date-week-day date) | (date-year-day date)\n 通过这些过程，可以确定以date 表示的日期是星期几还是每年的某天。 week-day是小于7的精确非负整数，其中0表示星期日，1表示星期一，依此类推。 year-day是小于367的精确非负整数，其中0代表一年的第一天（1月1日），1代表第二天，2代表第三天，依此类推。\n (time-utc-\u0026gt;date time) | (time-utc-\u0026gt;date time offset) | (date-\u0026gt;time-utc date)\n 这些过程用于在时间和日期对象之间进行转换。 time-utc-\u0026gt;date的时间参数必须具有time-type utc，date-\u0026gt;time-utc始终返回带有time-type utc的时间对象。\n对于time-utc-\u0026gt;date，offset 表示UTC以东的秒数中的时区偏移，如本节开头所述。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 UTC可以通过传递零偏移来获得。\n (date-and-time) | (date-and-time date)\n 字符串始终采用以下示例所示的格式，长度始终为24。\n(date-and-time) ⇒ \u0026#34;Fri Jul 13 13:13:13 2001\u0026#34; (defined (make-date 0 0 0 0 1 1 2007 0)) (date-and-time d) ⇒ \u0026#34;Mon Jan 01 00:00:00 2007\u0026#34;  (sleep time)\n time 必须是类型为time-duration的时间对象。 sleep 导致调用线程在大约由时间对象指示的时间量内暂停操作，除非该进程收到中断睡眠操作的信号。 实际睡眠时间取决于系统时钟的粒度以及系统运行其他线程和进程的繁忙程度。\n时间和统计  (time expr) time求值expr ，并且作为副作用，打印（到console-output端口）cpu时间量，实时时间量，分配的字节数以及与求值expr 相关的收集开销。\n \u0026gt; (time (collect)) (time (collect)) 1 collection 1 ms elapsed cpu time, including 1 ms collecting 1 ms elapsed real time, including 1 ms collecting 160 bytes allocated, including 8184 bytes reclaimed   (cpu-time)\n 返回：自系统启动以来消耗的cpu时间量。\n该量以毫秒为单位。 该数量包括“system”时间和“user”时间，即代表进程在内核中花费的时间以及在进程本身中花费的时间。\n (real-time)\n 返回：自系统启动以来经过的实时时间\n以毫秒为单位的时间总量\n (bytes-allocated) | (bytes-allocated g)\n 返回：当前分配的字节数\n如果提供了g ，则bytes-allocated返回指定generation中当前为Scheme对象分配的字节数。 g 必须为非负精确整数，且不得大于最大非静态generation，即，collect-maximum-generation返回的值或符号为static。 如果未提供g ，则bytes-allocated返回所有generation中分配的字节总数。\n (initial-bytes-allocated)\n 返回：加载启动文件后分配的总字节数\n (bytes-deallocated)\n 返回：垃圾回收器释放的总字节数\n通过将（bytes-deallocated）和（bytes-allocated）相加并减去（initial-bytes-allocated），可以获得当前进程分配的总字节数（无论是否仍在使用中）。\n (current-memory-bytes)\n 返回：当前分配的字节总数，包括开销.\ncurrent-memory-bytes返回堆的总大小（以字节为单位），不仅包括Scheme对象占用的字节，还包括各种形式的开销（包括碎片和保留但当前不占用的内存），因此，它是操作系统中当前进程的堆内存量的准确度量值\n (maximum-memory-bytes)\n 返回：分配过的最大字节数，包括开销\n (reset-maximum-memory-bytes!)\n 将堆内存的最大记录值重置为当前堆大小\n (collections)\n 返回：到目前为止的垃圾回收次数\n (statistics)\n 返回：包含当前统计信息的sstats记录\nstatistics将各种时间和分配统计信息打包在一起，形成一个sstats记录。 sstats记录具有以下字段：\n         cpu, 消耗的cpu时间   real, 经过的时间   bytes, 分配的字节数   gc-count, gc次数   gc-real, gc经历的时间   gc-bytes, gc回收的字节数    所有值都是从系统启动开始算\nstatistics可以像如下定义：\n(define statistics (lambda () (make-sstats (current-time ’time-thread) (current-time ’time-monotonic) (- (+ (bytes-allocated) (bytes-deallocated)) (initial-bytes-allocated)) (collections) (current-time ’time-collector-cpu) (current-time ’time-collector-real) (bytes-deallocated))))  (make-sstats cpu real bytes gc-count gc-cpu gc-real gc-bytes) 返回：sstats记录\n  (sstats-cpu s) | (sstats-real s) | (sstats-bytes s) | (sstats-gc-count s) | (sstats-gc-cpu s) | (sstats-gc-real s) | (sstats-gc-bytes s)\n 返回：s 对应的部分的值\n (set-sstats-cpu! s new-value) | (set-sstats-real! s new-value) | (set-sstats-bytes! s new-value) | (set-sstats-gc-count! s new-value) | (set-sstats-gc-cpu! s new-value) | (set-sstats-gc-real! s new-value) | (set-sstats-gc-bytes! s new-value)\n 设置对应部分的值\n (sstats-difference s1 s2)\n 比较两个sstats\n enable-object-counts\n enable-object-counts的值是一个布尔值，它确定收集器在运行时是否记录对象计数，从而确定过程对象计数返回的object-counts是否准确。 由于启用对象计数会增加收集的开销，因此默认情况下该参数设置为#f。\n (object-counts)\n 过程object-countsx返回一个嵌套的关联列表，该列表表示为一个或多个世代中至少有一个活动实例的每个堆分配的原始类型和记录类型分配的对象计数和字节。 （堆分配的基本类型包括，例如，pair和向量，但不包括，例如，fixnum或字符。）仅当enable-object-countsxx为#t时，收集器才会收集对象计数。\nobject-countsx返回的关联列表具有以下结构： ((type (generation count . bytes) \u0026hellip;) \u0026hellip;)\ntype是原始类型的名称，以符号（例如，对）表示，或者是record-type描述符（rtd）。 generation是介于0和（collect-maximum-generation）的值（包含在内）或表示静态生成的符号static之间的非负固定编号。 count和字节是非负的fixnum。\n(collect-request-handler void) (enable-object-counts #t) (define-record-type frob (fields x)) (define x (make-frob (make-frob #f))) (collect 3 3) (cdr (assoc 3 (cdr (assoc (record-type-descriptor frob) (object-counts))))) =\u0026gt; (2. 16) 成本中心 Cost Centers 成本中心用于在求值选定的代码段时跟踪分配的字节，执行的指令和/或经过的CPU时间。 成本中心是通过过程make-cost-center创建的，而成本是通过with-cost-center过程进行跟踪的。\n仅为此目的代码跟踪分配和指令计数。 该工具由两个参数控制：generate-allocation-counts和generate-instruction-counts。 默认情况下禁用检测。 内置程序没有检测，解释代码或非Scheme代码也没有。 仅当过程with-cost-center的可选参数*timed?*有值且不为false时才会跟踪经历的时间\nwith-cost-center过程即使在使用同一成本中心重新输入，在多个线程中同时使用并通过继续调用退出或重新输入一次或多次后，也要遵循上述注意事项来准确跟踪成本。\n generate-allocation-counts\n 当此参数为true时，编译器会在生成的代码的每个分配点插入一小段指令，以跟踪发生的分配量。此参数最初为false。\n generate-instruction-counts\n 当此参数为true时，编译器将在生成的代码的每个块中插入简短的指令序列，以跟踪该块执行的指令数。 此参数最初为false。\n (make-cost-center)\n 返回: 新的成本中心\n (with-cost-center cost-center thunk) | (with-cost-center timed? cost-center thunk)\n thunk 必须是一个接受零参数的过程。 with-cost-center调用不带参数的thunk 并返回其值。 它还可以动态计算分配的字节数，执行的指令以及在计算thunk 调用时所经过的cpu时间，并将跟踪的成本添加到成本中心记录中。\n如上所述，仅对于将参数generate-allocation-counts 设置为true的编译的代码跟踪分配计数，并且仅对将generate-instruction-counts 设置为true的编译的代码跟踪指令计数。 仅在提供timed? 且不为false的情况下，才会跟踪cpu时间，其中包括在已测量的代码，未测量代码和非Scheme代码中花费的cpu时间。\n (cost-center-instruction-count cost-center)\n 返回：成本中心跟踪的指令数\n (cost-center-allocation-count cost-center)\n 返回：成本中心跟踪的已分配字节数\n (cost-center-time cost-center)\n 返回：成本中心跟踪的CPU时间\n (reset-cost-center! cost-center)\n 此过程将成本中心记录的成本重置为零。\n参数 本节介绍了用于创建和操作参数的机制。 可以使用make-parameter方便地创建新参数。 但是，除了它们的行为外，没有什么能将参数与其他过程区分开。 如果调用参数时必须采取比通过make-parameter机制容易容纳的更为复杂的动作，则可以直接使用case-lambda定义该参数\n (make-parameter object) | (make-parameter object procudure)\n make-parameter接受一个或两个参数。 第一个参数是内部变量的初始值，第二个参数（如果存在）是应用于初始值和所有后续值的过滤器。 过滤器应接受一个参数。 如果该值不合适，则过滤器应引发异常或将值转换为更合适的形式。\n例如，print-length的默认定义如下：\n(define print-length (make-parameter #f (lambda (x) (unless (or (not x) (and (fixnum? x) (fx\u0026gt;= x 0))) (assertion-violationf ’print-length \u0026#34;~s is not a positive fixnum or #f\u0026#34; x)) x))) (print-length) ⇒ #f (print-length 3) (print-length) ⇒ 3 (format\u0026#34;~s\u0026#34;’(123456)) ⇒ \u0026#34;(123...)\u0026#34; (print-length #f) (format\u0026#34;~s\u0026#34;’(123456)) ⇒ \u0026#34;(123456)\u0026#34; make-parameter的定义使用case-lambda很简单：\n(define make-parameter (case-lambda [(init guard) (let ([v (guard init)]) (case-lambda [() v] [(u) (set! v (guard u))]))] [(init) (make-parameter init (lambda (x) x))]))  (parameterize ((param expr) \u0026hellip;) body1 body2 \u0026hellip;)\n 使用语法形式parameterize，可以以类似于普通变量的fluid-let的方式更改参数的值。 在计算body时，将每个param 设置为相应的expr 的值。\n(define test (make-parameter 0)) (test) ⇒ 0 (test 1) (test) ⇒ 1 (parameterize ([test 2]) (test)) ⇒ 2 (test) ⇒ 1 (parameterize ([test 2]) (test 3) (test)) ⇒ 3 (test) ⇒ 1 (define k (lambda (x) x)) (begin (set! k (call/cc k)) ’k) ⇒ k (parameterize ([test 2]) (test (call/cc k)) (test)) ⇒ k (test) ⇒ 1 (k3) ⇒3 (test) ⇒ 1 虚拟寄存器Virtual registers 编译器支持一组有限的虚拟寄存器 ，以供需要高速，全局和可变存储位置的程序使用。 引用或分配虚拟寄存器可能比访问可分配的局部变量或全局变量更快，并且访问时永远不会比它们更慢，而且这样做的代码序列通常更小。 分配可能会显著加快，因为不需要跟踪从虚拟寄存器到年轻对象的指针，因为可能存在于较早一世代中的可变位置。 在系统的线程版本上，虚拟寄存器是“每个线程”的，因此可以以比线程参数低廉的方式用作thread-local存储。\n该接口包含三个过程：virtual-register-count（返回虚拟寄存器的数量），set-virtual-register!（设置指定的虚拟寄存器的值）和virtual-register（获取指定虚拟寄存器的值）。\n虚拟寄存器由小于虚拟寄存器数量的非负fixnum索引指定。 为了获得set-virtual-register!和virtual-register的最佳性能，索引应该是直接嵌入在调用中的常量（或者可以通过对调用的优化来传播）。 为了避免将这些常量放在源代码中，程序员应考虑使用标识符宏为虚拟寄存器命名，例如：\n(define-syntax current-state (identifier-syntax [id (virtual-register 0)] [(set! id e) (set-virtual-register! 0 e)])) (set! current-state \u0026#39;start) current-state ⇒ start 虚拟寄存器必须被视为应用程序级资源，即，打算由多个应用程序使用的库通常不应使用虚拟寄存器，以避免与应用程序使用寄存器冲突。\n (virtual-register-count)\n 从9.0版开始，虚拟寄存器的数量设置为16。除非通过源重新编译Chez Scheme，否则无法更改。\n (set-virtual-register! k x)\n **set-virtual-register!**将x 存储在虚拟寄存器k 中。 k 必须是小于（virtual-register-count）的值的非负fixnum。\n (virtual-register k)\n virtual-register返回最后一次存储在虚拟寄存器k 中的值（在当前线程上）。\n环境查询和设置Environmental Queries and Settings  (scheme-version)\n Chez Scheme的版本\n (threaded?)\n 返回：#t（如果在系统为线程版本），否则返回#f\n (get-process-id)\n 返回：当前进程的PID\n (getenv key)\n 返回：环境中key 的值，或 #f\n(getenv \u0026#34;HOME\u0026#34;) ⇒ \u0026#34;/u/freddy\u0026#34;  (putenv key value)\n key 和 value 必须是字符串\n(putenv \u0026#34;SCHEME\u0026#34; \u0026#34;rocks!\u0026#34;) (getenv \u0026#34;SCHEME\u0026#34;) ⇒ \u0026#34;rocks!\u0026#34;  (get-registry key)\n 返回：key 的注册表值，或者**#f**\n (put-registry! key val) | (remove-registry! key)\n key 和 value 必须是字符串\n","id":78,"section":"posts","summary":"异常 (warning who msg irritant \u0026hellip;) 返回：未指定 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止","tags":["scheme"],"title":"系统操作(System Operations in Chez Scheme)","uri":"https://lvsq.net/2020/02/system-operations/","year":"2020"},{"content":"define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回true的谓词、以及每个字段的访问procedure和针对可变字段的赋值procedure。总的来说，与Java中的POJO类比较相似，不过不用自定义getter和setter方法，这与Kotlin倒为类似，例如：\n(define-record-type point (fields x y)) 创建了一个名为point的record类型，并且有两个字段x和y，和如下几个定义式（自动生成）：         (make-point x y) 构造函数   (point? obj) 谓词   (point-x p) 字段x的访问器   (point-y p) 字段y的访问器    默认下，字段是不可变的，但是可以声明为可变的（mutable）。如下定义point中，字段x是可变的，但y维持不变：\n(define-record-type point (fields (mutable x) y)) 当然亦可显式地将字段声明为不可变的：\n(define-record-type point (fields (mutable x) (immutable y))) 在这个例子中，define-record-type除了生成了上述的几个定义式之外，还为字段x增加了一个赋值过程：\n(point-x-set! p x)\n该赋值过程可以用于改变x的内容\n(define p (make-point 36 -17)) (point-x-set! p (- (point-x p) 12)) (point-x p) =\u0026gt; 24 自动生成的几个定义式是允许改变名称的，下面的point定义式，其构造函数名为mkpoint, 谓词为ispoint?，x和y的访问器分别为x-val和y-val, x的赋值器为set-x-val!\n(define-record-type (point mkpoint ispoint?) (fields (mutable x x-val set-x-val!) (immutable y y-val))) 默认情况下，每次一个record definition创建一个新类型（为方便理解，可以用Java来解释，即对于同一个POJO类new出两个实例，但这两个实例并不能equal），如下所示：\n(define (f p) (define-record-type point (fields x y)) (if (eq? p \u0026#39;make) (make-point 3 4) (point? p))) (f (f \u0026#39;make)) =\u0026gt; #f 第一个f的调用即(f \u0026lsquo;make)返回一个point类型的p，将p传递给第二个f，但p是由第一个调用生成的类型，所以point?返回#f。按照SICP的说法，这两个define-record-type并不在一个环境中，只是名字一样而已。\n默认的生产行为(generative behavior)或许可以由记录定义式中的nongenerative子句来重载：\n(define (f p) (define-record-type point (fields x y) (nongenerative)) (if (eq? p \u0026#39;make) (make-point 3 4) (point? p))) (f (f \u0026#39;make)) =\u0026gt; #t 以这种方式创建的记录类型仍然不同于由定义出现在程序的不同部分中创建的记录类型，即使这些定义在语法上是相同的：\n(define (f) (define-record-type point (fields x y) (nongenerative)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative)) (point? p)) (g (f)) =\u0026gt; #f 甚至可以通过在nongenerative子句中包含uid（唯一id）来覆盖它：\n(define (f) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (point? p)) (g (f)) =\u0026gt; #t 记录类型可以定义为有parent子句的子类型，即一个记录类型可以声明为某一个记录类型的子类型，如果指定了父类型，则子类型将继承父类型所有字段，且子类型的每个实例都被视为父类型的实例，因此可以直接使用父类型的访问器和字段等等。\n(define-record-type point (fields x y)) (define-record-type cpoint (parent point) (fields color)) (define cp (make-cpoint 3 4 \u0026#39;red)) (point? (make-cpoint 3 4 \u0026#39;red)) =\u0026gt;  #t (cpoint? (make-point 3 4)) =\u0026gt; #f (define cp (make-cpoint 3 4 \u0026#39;red)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (cpoint-color cp) =\u0026gt; red 到目前为止，define-record-type定义的默认构造函数接受record包含的字段一样多的参数，其实我们可以重写默认值，这里需要引入protocol子句，以下定义将创建一个具有三个字段的点记录：x，y和d，其中d表示距原点的位移。构造函数仍然只接受两个参数，即x和y值，并将d初始化为x和y平方和的平方根。\n(define-record-type point (fields x y d) (protocol (lambda (new) (lambda (x y) (new x y (sqrt (+ (* x x) (* y y)))))))) (define p (make-point 3 4)) (point-x p) =\u0026gt; 3 (point-y p) =\u0026gt; 4 (point-d p) =\u0026gt; 5 另外，子类型的构造函数中的参数顺序是不可改变的，即先是父类型构造函数的字段，然后才是子类型的参数，如果需要改变子类型的构造函数的参数顺序该如何呢？\n(define-record-type cpoint (parent point) (fields color) (protocol (lambda (pargs-\u0026gt;new) (lambda (x c y) ((pargs-\u0026gt;new x y) c))))) (define cp (make-cpoint 3 \u0026#39;red 4)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (point-d cp) =\u0026gt; 5 (cpoint-color cp) =\u0026gt; red 最后来看看define-record-type的语法形式：\n syntax: (define-record-type record-name clause \u0026hellip;)\n  syntax: (define-record-type (record-name constructor pred) clause \u0026hellip;)\n Fields clause语法形式:\n (fields field-spec \u0026hellip;)\n field-spec必须是下面5个中的一个:\n field-name (immmutable field-name) (mutable field-name) (immmutable field-name accessor-name) (mutable field-name accessor-name mutator-name)   define-record in Chez Scheme Chez Scheme依然支持$R^6RS$中传统的record类型的定义，另外还提供一个新的语法，即define-record，其语法形式与define-record-type一样，所不同的地方在于，define-record中的字段默认是可变的，这与$R^6RS$中的record相反，因此，创建一个记录类型时，同时会定义下列过程：\n(define-record point (x y)) (make-point x y) ;;\tconstructor (point? obj) ;;\tpredicate (point-x p) ;;\taccessor for field x (point-y p) ;;\taccessor for field y (set-point-x! p obj) ;;\tmutator for field x (set-point-y! p obj) ;;\tmutator for field y  通过对define-record-type的了解，可以发现其非常OO，smalltalk是否受其影响不得而知，至少经过纵向比较对于我们学习技术大有裨益。\n","id":79,"section":"posts","summary":"define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回tr","tags":["scheme"],"title":"Scheme语法define-record-type介绍","uri":"https://lvsq.net/2020/02/define-record-type/","year":"2020"},{"content":"Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以在 Chez Scheme 中以“微模块”级别使用，因为 Chez Scheme 中的模块和 import 形式属于定义，并且可以出现在定义可以出现的任意位置，包括在 lambda 表达式的程序体或其他局部作用域中。\n 微模块与函数孰好？？？还是视情况而定？？？\n 模块控制绑定的可见性，可以用作扩展词法作用域，以允许更精确地控制绑定的可见范围。模块导出标识符的绑定，即变量绑定、关键字绑定或模块名绑定。模块可以是具名的抑或匿名的。只要模块名可见，那么在具名模块出现处导入的绑定都可见。匿名模块中导出的绑定，在模块出现的地方被隐式地导入。匿名模块可用于隐藏一组绑定中的一些绑定，同时允许其余绑定可见。\n语法  (module name interface defn \u0026hellip; init \u0026hellip;)\n  (module interface defn \u0026hellip; init \u0026hellip;)\n name 是标识符，defn \u0026hellip; 是定义，init \u0026hellip; 是表达式。interface 是形如 (export \u0026hellip;) 的导出表，其中每个 export 都是标识符 identifier 抑或形式 (identifier export \u0026hellip;)。\n模块由一组（可能为空的）定义和一组（可能为空的）初始化表达式序列组成。模块中定义的标识符（可理解为变量或者状态，下同）在模块的程序体中可见，被导出的标识符在模块的导入作用域内亦可见。模块接口中列出的每个标识符必须在该模块中定义或被导入该到模块。module 形式是一种定义，因此可以出现在其他定义可以出现的任何位置，包括嵌套在 lambda 表达式的程序体、 library 形式、顶层程序，以及嵌套在其他模块中。此外，因为模块名的作用域与其他标识符相同，所以模块和库可以像变量和关键字那样导出模块名。\n模块名与其他标识符占用相同的名字空间，并遵循相同的作用域规则。除非被导出，否则模块中定义的标识符仅在该模块中可见。\n模块内的表达式可以引用在模块外部绑定的标识符。\n(let ([x 3]) (module m (plusx) (define plusx (lambda (y) (+ x y)))) (import m) (let ([x 4]) (plusx 5))) ; =\u0026gt; 8,注意不是9哦，可以将plusx视为：(define plusx (lambda (y) (+ 3 y)))) 同样，import不会阻止访问出现导入表单的可见标识符，但import标识符所覆盖的变量除外（啥叫覆盖，看下面两段代码）。\n(module m (y) (define y \u0026#39;m-y)) (let ([x \u0026#39;local-x] [y \u0026#39;local-y]) (import m) (list x y)) ; =\u0026gt; (local-x m-y) 模块m中定义了标识符y, 在其被import之后会覆盖let中的y；\n(module m (y) (define y \u0026#39;m-y)) (let () (import m) (let ([x \u0026#39;local-x] [y \u0026#39;local-y]) (list x y)) ; =\u0026gt; (local-x local-y) ) 先import m，之后再定义y，模块中定义的y不会覆盖let的y。\n另一方面，在模块中使用 import-only 会建立一个隔离的作用域，其中唯一可见的是被导入模块所导出的标识符，下面的代码中只有y可见。对于静态验证，有时不希望使用任何标识符，除了明确导入模块或本地范围的标识符外，这有时是合乎需要的。\n(module m (y) (define y \u0026#39;m-y)) (let ([x \u0026#39;local-x] [y \u0026#39;local-y]) (import-only m) x) ; =\u0026gt; Error: x is not visible 除非通过“import-only”导入的模块导出“import”或“import-only”以及至少一个模块的名称，否则无法在“import-only”范围内进行后续导入。 要创建一个包含多个模块导出的隔离范围而又不使“import”或“import-only”可见，必须以相同的“import-only”形式列出所有要导入的模块。\n另一种解决方案是创建一个包含每个其他模块的导出的模块。\n(module m2 (y) (define y \u0026#39;y)) (module m1 (x) (define x \u0026#39;x)) (module mega-module (cons x y) (import m1) (import m2) (import scheme)) (let ([y 3]) (import-only mega-module) (cons x y)) ; =\u0026gt; (x . y) 在它被编译之前，源程序被翻译成不含语法抽象、语法定义、库定义、模块定义以及 import 形式的核心语言程序。翻译由语法展开器负责，语法展开器以递归下降的方式处理源程序中的形式。\nmodule 和 import 特殊形式仅影响标识符(identifier)在源程序中的可见性，而不影响其含义。特别地，无论变量被绑定到在模块内部或外部定义的位置，import 都不会引入新位置。为了保持由模块和语法抽象建立的作用域关系，局部变量在必要时会被重命名。因此，表达式：\n(let ([x 1]) (module m (x setter) (define-syntax x (identifier-syntax z)) (define setter (lambda (x) (set! z x))) (define z 5)) (let ([y x] [z 0]) (import m) (setter 3) (+ x y z))) ; =\u0026gt; 4 等价于下面的表达式，其中标识符被统一地更名，并带上了下标：\n(let ([x0 1]) (define-syntax x1 (identifier-syntax z1)) (define setter1 (lambda (x2) (set! z1 x2))) (define z1 5) (let ([y3 x0] [z3 0]) (setter1 3) (+ x1 y3 z3))) 互递归module (module (a b) (module a (x) (define x (lambda () y))) (module b (y) (define y (lambda () x))) (import a) (import b)) 此模式的一般化语法定义如下，允许定义多个互递归的模块\n(define-syntax rec-modules (syntax-rules (module) [(_ (module m (id ...) form ...) ...) (module (m ...) (module m (id ...) form ...) ... (import m) ...)])) 组合module 由于模块可以重新导出所导入的绑定，所以很容易在单个模块上提供多个视图，就像下面的 s 和 t 为 r 提供的视图那样，或者将几个模块组合成一个复合，就像 r 那样。\n(module p (x y) (define x 1) (define y 2)) (module q (y z) (define y 3) (define z 4)) (module r (a b c d) (import* p (a x) (b y)) (import* q (c y) (d z))) (module s (a c) (import r)) (module t (b d) (import r)) import* 稍微解释一下import*, 其语法定义如下：\n(define-syntax import* (syntax-rules () [(_ m) (begin)] [(_ m (new old)) (module (new) (module (tmp) (import m) (alias tmp old)) (alias new tmp))] [(_ m id) (module (id) (import m))] [(_ m spec0 spec1 ...) (begin (import* m spec0) (import* m spec1 ...))])) 它支持重命名import的绑定和选择性导入特定的绑定，无需使用内置的import子形式来选择和重命名标识符，举例来说：\n(let () (import* scheme (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7) (let () (import* (rnrs) (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7) 元定义Meta Definitions  语法：(meta . definition)\n meta 关键字实际上是一个可以放在任何定义关键字前面的前缀，例如，\n (meta define x 3)\n 它告诉展开器，该定义式产生的任何变量定义都只是展开期定义，只能用于其他元定义的右侧，最主要是用在转换器表达式中。它用于定义展开期辅助函数，以及供一个或多个 syntax-case 转换器所使用的其他信息。\n元定义的语义类似于let*，它可以是自递归，但不是互递归的。\n元定义通过宏展开传播，因此可以编写，例如：\n(module (a) (meta define-record foo (x)) (define-syntax a (let ([q (make-foo #\u0026#39;\u0026#39;q)]) (lambda (x) (foo-x q))))) a ；=\u0026gt; q 条件展开Conditional expansion 可以通过 meta-cond 在展开期做出决策，这类似于 cond，但是是在展开期求值并测试表达式，并且可以在预期为定义的上下文中以及在表达式上下文中使用。\n 语法：(meta-cond clause1 clause2 \u0026hellip;)\n 除了最后一个 clause，其余的必须采取以下形式：\n (test expr1 expr2 \u0026hellip;)\n 最后一个 cluase 除可采取上述形式外，还可以使用下面的 else 子句形式：\n (else expr1 expr2 \u0026hellip;)\n 在展开期间，test 表达式会被顺序地求值，直到某条表达式求值为真或者求值完所有的表达式为止。如果一条 test 表达式求值为真，则 meta-cond 形式将展开为包含相应表达式 expr1 expr2 \u0026hellip; 所组成的 begin 形式。如果没有求值为真的 test 表达式，且存在 else 子句，则 meta-cond 形式将展开为由来自于 else 子句的表达式 expr1 expr2 \u0026hellip; 所组成的 begin 形式。否则，meta-cond 表达式展开为对 void 过程的调用。\nmeta-cond 可以按如下定义：\n(define-syntax meta-cond (syntax-rules () [(_ [a0 a1 a2 ...] [b0 b1 b2 ...] ...) (let-syntax ([expr (cond [a0 (identifier-syntax (begin a1 a2 ...))] [b0 (identifier-syntax (begin b1 b2 ...))] ...)]) expr)])) meta-cond 用于在展开期从一组可能的形式中进行选择。例如，程序员可以定义过程的安全（进行错误检查）和不安全（不进行错误检查）版本，并根据编译期优化级别决定调用版本，如下所示:\n(meta-cond [(= (optimize-level) 3) (unsafe-frob x)] [else (safe-frob x)]) 别名Aliases  语法：(alias id1 id2)\n alias 是一类定义，可以出现在其他定义可以出现的任何位置。它用于将绑定从一个标识符转移到另一个标识符。\n(let ([x 3]) (alias y x) (set! y 4) (list x y)) ; =\u0026gt; (4 4) 由于展开是由左至右进行的，别名应该出现在右侧的标识符的定义之后，例如：\n(let () (import-only (chezscheme)) (define y 3) (alias x y) x) ; =\u0026gt; 3 而不是：\n(let () (import-only (chezscheme)) (alias x y) (define y 3) x) ; =\u0026gt; exception: unbound identifier ","id":80,"section":"posts","summary":"Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以","tags":["modules"],"title":"Chez Scheme Modules","uri":"https://lvsq.net/2020/01/modules/","year":"2020"},{"content":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。\n (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_ ((a1 v1) (a2 v2) ...) bodys ...) (let ((a1 v1)) (my-let* ((a2 v2) ...) bodys ...)) ) ) ) 注意，my-let*是可以递归使用的，以及**\u0026hellip;**的用法。\n(define-syntax my-let* (syntax-rules () ( (_ () bodys ...) (let () bodys ...) ) ( (_ ((a1 v1) ...) bodys ...) (let () (define a1 v1) ... bodys ... ) ) ) ) 这个实现方式与上面的不同，上面的是嵌套let，这里将直接按顺序define内部变量，代码更短。注意此处的**\u0026hellip;**的用法。\n","id":81,"section":"posts","summary":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。 (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_","tags":["scheme"],"title":"自定义 Let*","uri":"https://lvsq.net/2020/01/my-let/","year":"2020"},{"content":"Fluid Keyword Bindings fluid-let-syntax  语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩展期间会暂时更改keyword的现有绑定，而不是引入keyword的新绑定。也就是说，在扩展form1 form2 \u0026hellip;的过程中，每个keyword的可见范围（或顶级）将会临时替换为新的绑定关系。\n (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 2 ) ) ) (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (fluid-let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 1 ) ) ) 对比上述两段代码，可知：两个表达式基本相同的，除了前者采用内部let-synctax语法，第二个采用fluid-let-syntax语法。在第一个表达式中，(g 1)扩展中的出现的f引用的是let-bound的变量f，而第二个表达式，f引用的是由fluid-let-syntax绑定的f\n","id":82,"section":"posts","summary":"Fluid Keyword Bindings fluid-let-syntax 语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩","tags":["module","syntactic"],"title":"Syntactic Extension and Modules in Chez Scheme","uri":"https://lvsq.net/2020/01/syntactic-extension-and-modules/","year":"2020"},{"content":"Chez Scheme中有一种Boxes结构，它是一个单元素对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构可以共享指向一个对象的引用，或指针。例如，在采用此种参数传递规则的语言的解释器中，可以用 boxes 实现 call-by-reference 的语义。解释有点绕，按我的理解boxes就相当于Golang的struct、Java中的类，将一些状态包装成一个整块，外界通过引用该整块的指针来访问内部的各个状态。\nBoxes 的字面形式带有前缀 #\u0026amp; (发音为 “hash-ampersand”). 例如， #\u0026amp;(a b c) 是一个 box，内容为列表 (a b c). 读取器若遇到 #!r6rs ，则会在其后的输入流中禁用 box 语法，除非在更近的位置遇到 #!chezscheme.\n所有 boxes 默认是可变的，包括常量。程序可以通过 box-immutable 创建不可变 boxes. 尝试修改不可变 box 会导致抛出异常。\n我们来看看一些用法：\n (box? obj) 如果 obj 是 box, 则为 #t, 否则为 #f.\n(box? \u0026#39;#\u0026amp;a) =\u0026gt; #t (box? \u0026#39;a) =\u0026gt; #f (box? (box 3)) =\u0026gt; #t (box obj) 创建一个由obj组成的box\n(box \u0026#39;a) =\u0026gt; #\u0026amp;a (box (box \u0026#39;(a b c))) =\u0026gt; #\u0026amp;#\u0026amp;(a b c) (unbox box) 返回box的内容\n(unbox #\u0026amp;a) =\u0026gt; a (unbox #\u0026amp;#\u0026amp;(a b c)) =\u0026gt; #\u0026amp;(a b c) (let ([b (box \u0026#34;hi\u0026#34;)]) (unbox b)) =\u0026gt; \u0026#34;hi\u0026#34; (set-box! box obj) box 必须是可变的。 set-box! 把 box 的内容设置为 obj.\n(let ([b (box \u0026#39;x)]) (set-box! b \u0026#39;y) b) =\u0026gt; #\u0026amp;y (let ([incr! (lambda (x) (set-box! x (+ (unbox x) 1)))]) (let ([b (box 3)]) (incr! b) (unbox b))) =\u0026gt; 4 (box-cas! box old-obj new-obj) 如果 box 被改变，则为 #t, 否则为 #f.box 必须是可变的。 若 box 待替换的内容和 old-obj 相同(基于 eq?), 则 box-cas! 自动将 box 的内容替换为 new-obj; 若不相同，则 box 保持不变。即CAS操作，原子的。\n(define b (box \u0026#39;old)) (box-cas! b \u0026#39;old \u0026#39;new) =\u0026gt; #t (unbox b) =\u0026gt; \u0026#39;new (box-cas! b \u0026#39;other \u0026#39;wrong) =\u0026gt; #f (unbox b) =\u0026gt; \u0026#39;new (mutable-box? obj) 如果 obj 是可变的 box ，则为 #t, 否则为 #f.\n(immutable-box? obj) 如果 obj 是不可变的 box ，则为 #t, 否则为 #f.\n(box-immutable obj) 返回一个内容为obj的不可变的box。Boxes 通常用来支持共享的，可变的结构，所以不可变的 box 一般没什么用。\n","id":83,"section":"posts","summary":"Chez Scheme中有一种Boxes结构，它是一个单元素对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构","tags":["scheme"],"title":"Chez Scheme中Boxes介绍","uri":"https://lvsq.net/2020/01/boxes-in-chez/","year":"2020"},{"content":"Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x)))\n(atom? \u0026#39;(a b c)) ⇒ #f (atom? \u0026#39;(3 . 4)) ⇒ #f (atom? \u0026#39;()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) n是一个非负整数，且小于等于list的长度；list-head和Scheme标准过程list-tail可能会同时使用来切割一个list，不同点在于，list-tail不会分配内存而只是返回源list的一个子列表，list-head总是返回源list前n个元素的副本\n(list-head \u0026#39;(a b c) 0) ⇒ () (list-head \u0026#39;(a b c) 2) ⇒ (a b) (list-head \u0026#39;(a b c) 3) ⇒ (a b c) (list-head \u0026#39;(a b c . d) 2) ⇒ (a b) (list-head \u0026#39;(a b c . d) 3) ⇒ (a b c) (list-head \u0026#39;#1=(a . #1#) 5) ⇒ (a a a a a) last-pair(Chez) 用法：(last-pair list) 列表不能为空。 last-pair返回列表的最后一对（pair）（不是最后一个元素）, list可能是不正确的列表，在这种情况下，最后一对是包含最后一个元素和终止对象的一个pair。\n(last-pair \u0026#39;(a b c d)) ⇒ (d) (last-pair \u0026#39;(a b c.d)) ⇒ (c . d) list-copy(Chez) 用法： (list-copy list) 返回一个list的副本，equal?（结构和值相同）判断为#t\nlist*(Chez) 用法：(list* obj \u0026hellip; final-obj)返回一个由obj \u0026hellip; final-obj 组成的list, 与R6RS的**cons***相同\nmake-list(Chez) 用法： (make-list n) 或者 (make-list n obj)返回n个对象的列表。n是一个正整数， 如果obj不指定，则返回的list是不确定的\n(make-list 0 \u0026#39;()) =\u0026gt; () (make-list 3 0) =\u0026gt; (0 0 0) (make-list 2 \u0026#34;hi\u0026#34;) =\u0026gt; (\u0026#34;hi\u0026#34; \u0026#34;hi\u0026#34;) iota(Chez) 用法：(iota n)返回从 0（包含）到 n（不包含）的整数列表，n须为精确的非负整数\n(iota 0) =\u0026gt; () (iota 5) =\u0026gt; (0 1 2 3 4) enumerate(Chez) 用法： (enumerate ls)返回: 从 0（包含）到长度 ls（不包含）的整数列表\n(enumerate \u0026#39;()) =\u0026gt; () (enumerate \u0026#39;(a b c)) =\u0026gt; (0 1 2) (let ([ls \u0026#39;(a b c)]) (map cons ls (enumerate ls))) =\u0026gt; ((a . 0) (b . 1) (c . 2)) remq! | remv! | remove!(Chez) 用法： (remq! obj list) | (remv! obj list) | (remove! obj list)返回: 列表中所有 obj 都被移除后的列表这些过程与 R6RS 中的 remq, remv, 及 remove 过程类似，只是 remq!, remv! 和 remove! 使用输入列表中的pair来构成输出列表。它们进行较少的空间分配，但并不一定比它们非破坏性的相应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(remq! \u0026#39;a \u0026#39;(a b a c a d)) ⇒ (b c d) (remv! #\\a \u0026#39;(#\\a #\\b #\\c)) =\u0026gt; (#\\b #\\c) (remove! \u0026#39;(c) \u0026#39;((a) (b) (c))) =\u0026gt; ((a) (b)) substq | substv | subst | substq! | substv! | subst!(Chez) 用法： (subs* new old tree)返回：在tree中将匹配到的old元素全部替换为new之后的tree.对于 substq 和 substq! ，相等性测试是基于 eq?, substv 和 substv! 是基于 eqv?, 而 subst 和 subst! 是基于 equal? substq!, substv!, 和 subst! 执行破坏性的替换。它们进行较少的空间分配，但并不一定比它们非破坏性的对应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(substq \u0026#39;a \u0026#39;b \u0026#39;((b c) b a)) =\u0026gt; ((a c) a a) (substv 2 1 \u0026#39;((1 . 2) (1 . 4) . 1)) =\u0026gt; ((2 . 2) (2 . 4) . 2) (subst \u0026#39;a \u0026#39;(a . b) \u0026#39;((a . b) (c a . b) . c)) =\u0026gt; (a (c . a) . c) (let ([tr \u0026#39;((b c) b a)]) (substq! \u0026#39;a \u0026#39;b tr) tr) =\u0026gt; ((a c) a a) reverse! 用法：(reverse! list)返回：将原list反向输出reverse! 通过反转其链接破坏性地反向排序列表。以 reverse! 取代 reverse 减少了空间分配，但并不一定比使用 reverse 更快。如果滥用，会很容易导致混乱或错误的结果。\n(reverse! \u0026#39;()) =\u0026gt; () (reverse! \u0026#39;(a b c)) =\u0026gt; (c b a) (let ([x \u0026#39;(a b c)]) (reverse! x) x) =\u0026gt; (a) (let ([x \u0026#39;(a b c)]) (set! x (reverse! x)) x) =\u0026gt; (c b a) append! 用法：(append! list \u0026hellip;)返回：将所有输入list串联起来的列表如同 append, append! 返回一个新的列表，其中元素依次为第一个列表中的元素，第二个列表中的元素，第三个列表中的元素，等等。不同之处在于， append! 重用所有参数中的点对以构造新列表。即，每一个列表参数的最后一个cdr, 其后一元素变为指向下一个列表参数。除最后一个参数外，如果任一参数为空列表，它实质上会被忽略。最后一个参数（并不一定得是列表）是不变的。\n相比于 append, append! 进行更少的空间分配（因为只修改指针，并没有数据拷贝），但并不一定更快。如果滥用，会很容易导致混乱或错误的结果。\n(append! \u0026#39;(a b) \u0026#39;(c d)) =\u0026gt; (a b c d) (let ([x \u0026#39;(a b)]) (append! x \u0026#39;(c d)) x) =\u0026gt; (a b c d) (append \u0026#39;(1 2 (3 4)) \u0026#39;(5 6)) =\u0026gt; (1 2 (3 4) 5 6) (append \u0026#39;(1 2 (3 4)) \u0026#39;() \u0026#39;(5 6)) =\u0026gt; (1 2 (3 4) 5 6) ","id":84,"section":"posts","summary":"Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x))) (atom? \u0026#39;(a b c)) ⇒ #f (atom? \u0026#39;(3 . 4)) ⇒ #f (atom? \u0026#39;()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) n是一个非负整数，且小于等于list的长度","tags":["scheme"],"title":"Scheme/Chez Scheme 对象操作","uri":"https://lvsq.net/2019/12/operations-on-objects/","year":"2019"},{"content":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。\n (make-engine thunk)\n 通过传递一个无参数的thunk(形实转换程序)给make-engine来创建一个engine。thunk的body是会被engine执行的计算，engine本身是带3个参数的过程： ticks： 一个正整数，指定提供给engine的执行时间片（原文用的是fuel这个单词，意思是燃料，正对应这engine的本意，十分贴切）的数量，engine将会执行到时间片用完或者计算完成为止； complete： 一个或多个参数的函数，用于指定计算完成后的操作。它的参数是剩余的时间片数量和计算产生的值； expire： 一个参数的函数，该函数指定如果在计算完成之前时间片用完了该怎么办。它的参数是一个能从中断点继续进行计算的新引擎。  将引擎应用于其参数时，它将开启一个时长为ticks的计时器，如果引擎计算在计时器执行之前完成，系统将调用complete，并将剩余的ticks和计算产生的值传递给它；\n另一方面，如果计时器在引擎计算完成之前耗尽了，则系统会从中断计算的continuation中创建一个新引擎，并使该引擎过期。complete和expire会被新引擎继续使用。If, on the other hand, the timer goes off before the engine computation completes, the system creates a new engine from the continuation of the in- terrupted computation and passes this engine to expire. complete and expire are invoked in the continuation of the engine invocation.\n 看看具体的例子：\n(define eng (make-engine (lambda () 3))) (eng 10 ;; ticks (lambda (ticks value) value) ;; complete (lambda (x) x) ;; expire ) ⇒ 3 通常将列表作为完整过程传递给引擎，使引擎完成时返回一个列表，该列表的第一个元素是剩余的ticks，另一个元素是计算返回的值，这通常很有用。\n(define eng (make-engine (lambda () 3))) (eng 10 list (lambda (x) x)) ⇒ (9 3) 在上面的示例中，计算值为3，还剩下9个时间片，即，需要一单位的时间片来计算出3。\n 再看一个复杂点的例子： 先定义一个计算裴波那切值的函数\n(define fibonacci (lambda (n) (let fib ([i n]) (cond [(= i 0) 0] [(= i 1) 1] [else (+ (fib (- i 1)) (fib (- i 2)))])))) 创建engine\n(define eng (make-engine (lambda () (fibonacci 10)))) (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ \u0026#34;expired\u0026#34; (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ \u0026#34;expired\u0026#34; (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ \u0026#34;expired\u0026#34; (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ (21 55) 每次时间片（燃料）用完时，到期程序都会将eng分配给新引擎。整个计算需要4个blocks，每个block包含50个ticks。最后50个燃料中，有21个都用掉了。因此，使用的燃料总量为179个。\n我们还可以统计一下消耗的ticks数量\n(define mileage (lambda (thunk) (let loop ([eng (make-engine thunk)] [total-ticks 0]) (eng 50 (lambda (ticks . values) (+ total-ticks (- 50 ticks))) (lambda (new-eng) (loop new-eng (+ total-ticks 50))))))) (mileage (lambda () (fibonacci 10))) ⇒ 179  再看看一个例子——round-robin:\n(define round-robin (lambda (engs) (if (null? engs) \u0026#39;() ((car engs) 1 ;;ticks (lambda (ticks value) (cons value (round-robin (cdr engs)))) ;;complete (lambda (eng) ;;expire (round-robin (append (cdr engs) (list eng)))))))) (round-robin (map (lambda (x) (make-engine (lambda () (fibonacci x)))) \u0026#39;(4 5 2 8 3 7 6 2))) ⇒ (1 1 2 3 5 8 13 21) 这段代码需要费些思量，首先map函数创建了8个engine, 然后代入round-robin函数，该函数依次执行各个engine，但是每个engine分配的时间片只有1，对于参数'(4 5 2 8 3 7 6 2)，数字越小，越先执行完成，所以越早执行complete函数，最终结果就是排好顺序的了，很棒的程序！\n","id":85,"section":"posts","summary":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。 (make-engine thunk) 通过传递一个无参数的thun","tags":["engine","scheme"],"title":"Engine in Scheme","uri":"https://lvsq.net/2019/12/engine-in-scheme/","year":"2019"},{"content":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Scheme提供了case语法来处理这种情况，这与Java中的switch语法非常相似。\n我们来看看case的语法：\n (case expr0 clause1 clause2 \u0026hellip;)\n 除了最后一个clause之外，每个子句都必须采用以下形式之一：\n ((key \u0026hellip;) expr1 expr2 \u0026hellip;) (key expr1 expr2 \u0026hellip;)  每一个key值都应该是不同的，最后一个子句要么是上述那种形式，或者是一个像下面这样的else子句\n (else expr1 expr2 \u0026hellip;)   那么返回值是什么呢？\n(define p (lambda (x) (case x [(\u0026#34;abc\u0026#34; \u0026#34;def\u0026#34;) \u0026#39;one \u0026#39;1] [((a b c)) \u0026#39;two] [else #f]))) (p (string #\\d #\\e #\\f)) ⇒ 1 (p \u0026#39;(a b c)) ⇒ two (p \u0026#34;eee\u0026#34;) ⇒ #f 上面的例子定义了一个函数p，接收一个参数x\n 如果x为字符串\u0026quot;abc\u0026quot;或者\u0026quot;def\u0026quot;，则返回1； 如果x为列表((a b c)，则返回two 其他情况返回#f  可见，有了case语法多条件判断写起来就方便很多，并且代码也容易读了，当然这里也可以用cond来写，这里只是为了描述case的语法而没有使用cond\n再看一个例子，就不用解释了：\n(let ([ls \u0026#39;(ii iv)]) (case (cadr ls) [i 1] [ii 2] [iii 3] [(iiii iv) 4] [else \u0026#39;out-of-range])) ⇒ 4  record-case 来看看另一个很类似的扩展，也十分有用，它就是record-case。它可以以record为单位来做条件判断并执行指令。语法格式：  (record-case expr clause1 clause2 \u0026hellip;)\n 除了最后一个子句之外，每个clause的格式如下：\n ((key \u0026hellip;) formals body1 body2 \u0026hellip;)\n 每一个key都不应该相同, 最后一个clause可能是上述的格式或者是一个else子句：\n (else body1 body2 \u0026hellip;)\n expr必须是一个pair。Chez会拿(car expr)与各个子句中的key进行比较（用eqv?）来确定哪一个clause匹配, 然后(cdr expr)将与formals绑定。\n来看换一个例子：\n(define calc (lambda (x) (record-case x [(add) (x y) (+ x y)] [(sub) (x y) (- x y)] [(mul) (x y) (* x y)] [(div) (x y) (/ x y)] [else (assertion-violationf 'calc \u0026quot;invalid expression ~s\u0026quot; x)]))) (calc '(add 3 4)) =\u0026gt; 7 (calc '(div 3 4)) =\u0026gt; 3/4 ","id":86,"section":"posts","summary":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Schem","tags":["chez","scheme"],"title":"Chez Scheme中的case扩展","uri":"https://lvsq.net/2019/12/case-in-chez-scheme/","year":"2019"},{"content":"  易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴至，克尽其用，上下一体，俱不倦而事可毕矣\n  周云成康，汉言文景。无有六十年与民休息，累藏蓄积，汉武开疆之功便是空文，此厚积薄发耳，俗语言，胳膊收回来，打出去才有力\n  武帝一代雄主，文治武功，奋高祖之余烈，承三王之圣绪，开万世不拔之基，吾国斯民之幸，铭记汉青\n  ","id":87,"section":"posts","summary":"易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴","tags":["随想"],"title":"继学录","uri":"https://lvsq.net/2019/12/think/","year":"2019"},{"content":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫易变绑定吧，如果有更好的翻译请在文后的评论中尽情发表。\n先看看该语法描述：(fluid-let ((var expr) \u0026hellip;) body1 body2 \u0026hellip;) returns: the values of the body body1 body2 \u0026hellip; libraries: (chezscheme)该Binding的作用类似局部变量，与set! 比较相似。由fluid-let定义的变量必须已绑定到顶层(top level)或者封闭的lambda内或者其他形式的绑定，这很关键！\n 请看代码：\n(let ([x 3]) (+ (fluid-let ([x 5]) x) x)) ⇒ 8 先定义变量x=3，然后在加法操作当中临时将x的值改为5，最后结果为8，如果将fluid-let中的x换个名字，比如y，将如何呢？会得到一个异常：\n Exception: variable y is not bound\n y没有绑定，是的，y即没有在顶层中被定义，也未在某个lambda中或者任何其他形式，这里只能是x\n 再学习下两个例子，加深印象：\n(let ([x \u0026#39;a]) (letrec ([f (lambda (y) (cons x y))]) (fluid-let ([x \u0026#39;b]) (f \u0026#39;c)) )) ⇒ (b . c) (let ([x \u0026#39;a]) (call/cc (lambda (k) (fluid-let ([x \u0026#39;b]) (letrec ([f (lambda (y) (k \u0026#39;*))]) (f \u0026#39;*))))) x) ⇒ a  Fluid Binding实际上是Scheme对Dynamic Scoping的保留，Scheme使用的是Lexical Scoping， 对于这两种Scoping更详细的描述可参考Lexical Scoping and Dynamic Scoping\n","id":88,"section":"posts","summary":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫易变绑定吧，如果有更好的翻译请在文后的评论中尽情发表。 先看看该语法描","tags":["fluid-let","Scheme"],"title":"Fluid Binding in Chez Scheme","uri":"https://lvsq.net/2019/12/fluid-binding/","year":"2019"},{"content":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。\n 这是语法描述：(rec var expr) syntaxreturns: value of exprlibraries: (chezscheme)The syntactic form rec creates a recursive object from expr by establishing a binding of var within expr to the value of expr. In essence, it is a special case of letrec for self-recursive objects.\nThis form is useful for creating recursive objects (especially procedures) that do not depend on external variables for the recursion, which are sometimes undesirable because the exter-nal bindings can change. For example, a recursive procedure defined at top level depends on the value of the top-level variable given as its name. If the value of this variable should change, the meaning of the procedure itself would change. If the procedure is defined instead with rec, its meaning is independent of the variable to which it is bound.\n简要翻译一下：语法rec 通过在expr中建立var与expr的值的绑定，创建一个递归对象。从本质上讲，这是letrec用于自递归对象的一种特殊情况。\n语法rec通过绑定expr中创建一个递归对象，用来 这种形式对于创建不依赖于外部变量进行递归的递归对象（尤其是过程）很有用，因为外部绑定可能会发生变化，所以有时这是不可取的。\n 看一个例子来感受一下：给定一个全是数字的list，对于每一个数字n，算出$1+2+\u0026hellip;+n$的和，最终返回和的list.\n(map (rec sum (lambda (x) (if (= x 0) 0 (+ x (sum (- x 1)))))) ’(0 1 2 3 4 5)) ⇒ (0 1 3 6 10 15) 如果没有rec语法，用letrec也是可以的，但是稍显麻烦，代码也多一些，所以rec还是很好用的\n 最后看一下rec语法的定义：\n(define-syntax rec (syntax-rules () [(_ x e) (letrec ((x e)) x)])) ","id":89,"section":"posts","summary":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。 这是语法描述：(","tags":["Scheme","Chez","rec"],"title":"Recursive Bindings in Chez Scheme","uri":"https://lvsq.net/2019/12/recursive-bindings/","year":"2019"},{"content":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些时间，动手写了一个，目前已经在公司内部运行了几年，效果良好，并且已经开源在Github上，以飨各位。\n 特点：\n  API简洁\n  支持3种事件：\n UP DOWN JOIN    基于Vert.X\n  引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lvsq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jgossip\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 一个简单的例子：\nint gossip_port = 60001; String cluster = \u0026#34;gossip_cluster\u0026#34;; GossipSettings settings = new GossipSettings(); settings.setGossipInterval(1000); try { String myIpAddress = InetAddress.getLocalHost().getHostAddress(); List\u0026lt;SeedMember\u0026gt; seedNodes = new ArrayList\u0026lt;\u0026gt;(); SeedMember seed = new SeedMember(); seed.setCluster(cluster); seed.setIpAddress(myIpAddress); seed.setPort(60001); seedNodes.add(seed); gossipService = new GossipService(cluster, myIpAddress, gossip_port, null, seedNodes, settings, (member, state) -\u0026gt;System.out.println(\u0026#34;member:\u0026#34; + member + \u0026#34; state: \u0026#34; + state)); } catch (Exception e) { e.printStackTrace(); } gossipService.start();  详细介绍请看 =\u0026gt; 项目地址\n欢迎大家fork， 如果觉得好请start ~~~\n","id":90,"section":"posts","summary":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些","tags":["jgossip","gossip"],"title":"Jgossip - gossip协议的开源实现","uri":"https://lvsq.net/2019/12/jgossip/","year":"2019"},{"content":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加\nGolang的实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} nodes := []*ListNode{} var carry = 0 for { node, c := add(l1, l2, carry) carry = c if node != nil { nodes = append(nodes, node) if l1 != nil \u0026amp;\u0026amp; l1.Next != nil { l1 = l1.Next } else { l1 = nil } if l2 != nil \u0026amp;\u0026amp; l2.Next != nil { l2 = l2.Next } else { l2 = nil } if carry \u0026gt; 0 \u0026amp;\u0026amp; (l1 == nil \u0026amp;\u0026amp; l2 == nil) { nodes = append(nodes, \u0026amp;ListNode{Val:carry}) } } else { break } } for i, n := range nodes{ if i == 0 { result = n } if i + 1 \u0026lt; len(nodes) { n.Next = nodes[i + 1] } } return result } func add (n1 *ListNode, n2 *ListNode, carry int) (*ListNode, int) { node := \u0026amp;ListNode{} if (n1 == nil \u0026amp;\u0026amp; n2 == nil) { return nil, 0 } if n1 == nil { n1 = \u0026amp;ListNode{Val : 0} } if n2 == nil { n2 = \u0026amp;ListNode{Val : 0} } sum := n1.Val + n2.Val + carry carry = 0 if sum \u0026gt; 9 { carry = 1 sum = sum - 10 } node.Val = sum return node, carry }  下面提供Scheme版本的实现【(1 0) + (9 1 2) = (0 2 2)】，为了简单起见，与题目要求稍有不同，这里采用list，而不是题目要求的链表，但实际上应是一样的。比较之下可以看出，相对而言，Scheme语言的实现更加简短优雅，得益于其强大的表达能力\n(letrec ( [Polishing (lambda (l num) (if (eq? num 0) l (Polishing (append l \u0026#39;(0)) (- num 1))) ) ] [Align (lambda (l1 l2) (let ([len1 (length l1)] [len2 (length l2)]) (if [eq? len1 len2] [list l1 l2] [if (\u0026gt; len1 len2) (list l1 (Polishing l2 (- len1 len2))) (list (Polishing l1 (- len2 len1)) l2)])) ) ] [Add (lambda (l1 l2) (let ([ l (Align l1 l2)]) (Carry (map (lambda (x y) (+ x y)) (car l) (cadr l)) 0) ) ) ] [Carry (lambda (l c) (if (null? l) (if [eq? c 0] \u0026#39;() [cons c l]) (cons (mod ( + (car l) c ) 10) (Carry (cdr l) (quotient ( + (car l) c) 10))) ) ) ]) (Add \u0026#39;(1 0) \u0026#39;(9 1 2)))  Golang版本和Scheme版本的实现思路不相同，简要描述一下后者：\n (1 0) + (9 1 2), 先进行补位： (1 0 0) + (9 1 2), 按顺序相加，得： (10 1 2), 再计算进位： (0 2 2)  ","id":91,"section":"posts","summary":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加 Golang的实现： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result","tags":["Scheme","leetcode"],"title":"两数相加","uri":"https://lvsq.net/2019/12/leetcode-2/","year":"2019"},{"content":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发。\n 问题描述 假设我们已经有足够多的1分，2分，5分钱币，任意给定金额比如1元，问有多少种组合方式？ 换言之，$$1x+2y+5z = 100$$ 求x,y,z的解有多少个\n 思路 组合方式的总和应为：\n  任意扣去一种钱币比如1分，1元采用2分，5分两种钱币的组合数，再加上：\n  总额为（1元-1分），采用1分，2分，5分三种钱币的组合数；\n  很明显这可以很容易用递归实现\n 稍作一点解释：\na. 上面两步的意思是：不带1分的组合数 + 带1分的组合数 = 全部的组合数； 这是显而易见的\nb. 上述第2步，（1元-1分）的意思是：这样可以保证任意一种组合方式再加1分都等于1元，保证至少有1个1分的钱币\n(letrec [ (A (lambda (n d) (if (= 0 (mod n d)) 1 0))) (B (lambda (n d) (cond [(not (pair? d)) 0] [(null? d) 0] [(= 0 n) 1] [(\u0026gt; 0 n) 0] [(= 1 (length d)) (A n (car d))] [else ( + (B n (cdr d)) (B (- n (car d)) d)) ] ) ) ) ] [B 100 \u0026#39;(1 2 5)] ) ","id":92,"section":"posts","summary":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发","tags":["Scheme","SICP"],"title":"钱币组合问题","uri":"https://lvsq.net/2019/12/count-coins/","year":"2019"},{"content":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026quot;x-\u0026quot;）该如何开发做紧要的介绍。\n一切开始之前，有一点需要keep in mind，即增加扩展的位置不同，所用的方法不同，所以需要对Swagger的标准有所了解，可参考官方文档  springfox目前只允许三种扩展实现:\n ListVendorExtension:列表的形式,该对象支持泛型，最终形式：”x-field”:[{field:value}] ObjectVendorExtension:对象的扩展形式,最终的扩展形式是：”x-field”:[{field:value}] StringVendorExtension:string类型的扩展实现，最终的扩展形式是”x-field”:”value”   Swagger根对象扩展 以在info中添加一个x-logo为例\n\u0026#34;info\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;\u0026lt;div style=\u0026#39;font-size:14px;color:red;\u0026#39;\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;swagger-bootstrap-ui！！！\u0026#34;, \u0026#34;termsOfService\u0026#34;: \u0026#34;http://www.xxx.com/\u0026#34;, \u0026#34;contact\u0026#34;: { \u0026#34;name\u0026#34;: pxxxx@domain.com\u0026#34; }, \u0026#34;x-logo\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#090807\u0026#34; } }, ... 后台代码：\nObjectVendorExtension logo = new ObjectVendorExtension(\u0026#34;x-logo\u0026#34;); logo.addProperty(new StringVendorExtension(\u0026#34;url\u0026#34;, \u0026#34;https://xxx.svg\u0026#34;)); logo.addProperty(new StringVendorExtension(\u0026#34;color\u0026#34;, \u0026#34;#090807\u0026#34;)); return new ApiInfoBuilder() .title(\u0026#34;swagger-bootstrap-ui！！\u0026#34;) .extensions(Lists.newArrayList(logo)) .description(\u0026#34;\u0026lt;div style=\u0026#39;font-size:14px;color:red;\u0026#39;\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026#34;) .termsOfServiceUrl(\u0026#34;http://www.xxx.com/\u0026#34;) .version(\u0026#34;1.0.0\u0026#34;) .build();  内部对象扩展 给Path添加一个扩展属性x-order为例\n@Component @Order(Ordered.HIGHEST_PRECEDENCE+100) public class OperationPositionBulderPlugin implements OperationBuilderPlugin { @Override public void apply(OperationContext context) { context.operationBuilder().extensions(Lists.newArrayList(new StringVendorExtension(\u0026#34;x-order\u0026#34;,\u0026#34;1\u0026#34;))); } @Override public boolean supports(DocumentationType delimiter) { return true; } } 详细介绍可以参考\n","id":93,"section":"posts","summary":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026quo","tags":["swagger","vendorExtensions"],"title":"Swagger 如何使用vendorExtensions进行扩展","uri":"https://lvsq.net/2019/11/swagger-vendor/","year":"2019"},{"content":" 秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁，如平原君广纳异国宾客；苏秦上书于七国；荀子遍游天下者皆可证各国文字并无大乖。 《史籀篇》文首盖云“太史籀书”，人多误以太史籀所作，如此便望文生义了。太史乃官职，王国维先生引《说文》解释，籀即读，读即籀书。另太史籀书乃周世之成语，绝非人名。  ","id":94,"section":"posts","summary":"秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁","tags":["文史"],"title":"历史不能碰","uri":"https://lvsq.net/2019/11/do-not-touch-history/","year":"2019"},{"content":"M -\u0026gt; Alt(option) S -\u0026gt; Shift    快捷键 用途     M-v 上（后）一屏   C-v 下（前）一屏   C-l 重绘屏幕，将光标所在行置于屏幕中央   C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符   C-x C-f  查找或者新建一个文件   C-x C-b 列出缓冲区。 C-x 1 关闭缓冲区列表   C-x C-q 开启或者关闭buffer的只读模式   C-x C-s 保存当前文件   C-x s 保存所有文件   C-x h 全选   M-w 复制   C-y 粘贴   C-w 剪切   C-s 往前搜索   C-r 往后搜索. DEL 也可以往后搜索，   C-/ undo   M-x calendar 打开日历。按 q 退出。【g d 到指定日期】【. 到今日（不居中）】【\u0026gt; 前一个月】【\u0026lt; 后一个月】   M-x *-mode 选择Major mode   M-x shell 运行一个shell   M-x eshell 运行一个eshell   C-a 移到行首   C-a C-k、C-S-backspace 删除整行   C-u 5 C-S-backspace、M-5 C-S-backspace 删除后5行，不加数字则删除4行（默认），如果数字为负数，则往前删   C-g 停止当前的命令   C-k 删除从光标位置到行尾所有字符    Org-Mode    快捷键 用途     C-c . 插入时间   C-c C-e 导出其它格式   C-c C-s 在标题下面插入一个带有“==SCHEDULED==”关键字的时间戳。   C-c C-d 在标题下面插入一个带有“==DEADLINE==”关键字的时间戳   C-c C-t 将当前项的状态在（unmarked）-\u0026gt;TODO-\u0026gt;DONE 之间循环切换   M-RET 插入一个同级标题   M-LEFT/RIGHT 将当前的标题提升/降低一个等级   C-c C-c 插入标签tag。 光标在标题中   C-c C-q 插入标签tag。光标在任意位置   C-c , 设置当前标题的优先级,’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的   C-c \\ 查找标签tag   S-Tab 展开所有标题   Tab 展开光标所在标题   C-c C-l 编辑链接   C-c C-o 打开链接    ","id":95,"section":"posts","summary":"M -\u0026gt; Alt(option) S -\u0026gt; Shift 快捷键 用途 M-v 上（后）一屏 C-v 下（前）一屏 C-l 重绘屏幕，将光标所在行置于屏幕中央 C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符 C-x C-f 查","tags":["emacs"],"title":"Emacs","uri":"https://lvsq.net/2019/11/emacs/","year":"2019"},{"content":"模块基础 一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set!\n通常，每个Racket模块驻留在自己的文件中，换句话说，可以认为一个.rkt 文件里的内容属于某一个模块，模块名就是文件名。\n在任意目录下创建一个子目录：mod_demo\n├── mod_demo\n│ ├── ext\n│ │ └── cake.rkt\n│ └── main.rkt\nmod_demo目录下有一个main.rkt模块，和一个ext目录，该目录下有一个cake.rkt的模块。\ncake.rkt的内容如下：\n#lang racket (provide print-cake) (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (provide print-cake) 意味着将函数print-cake导出，在模块外部就可以使用该函数了；还有一个私有的函数show, 该函数未导出，所以外部无法访问。 main.rkt的内容为：\n#lang racket (require \u0026#34;ext/cake.rkt\u0026#34;) (print-cake (random 30)) (require \u0026ldquo;ext/cake.rkt\u0026rdquo;) 将cake模块引入，引用路径符合Unix风格(但是，不能以文件分隔符即'/\u0026lsquo;作为开始或者结束)，也支持相对路径，(require \u0026ldquo;./ext/cake.rkt\u0026rdquo;) 也是完全可以的。\nCollections collection中的模块通过不带引号的、无后缀的路径引用。例如：以下模块引用了作为“racket” collection一部分的“date.rkt”库：\n#lang racket (require racket/date) (printf \u0026#34;Today is ~s\\n\u0026#34; (date-\u0026gt;string (seconds-\u0026gt;date (current-seconds)))) 注意，(require racket/date)没有带双引号。像racket/date这样的模块看起来像一个标识符，当require看到一个未加引号的模块引用时，它会将引用转换为基于collection的模块路径：\n 首先，如果未引用的路径不包含 /，然后 require会自动向引用添加一个“/main”。例如，( require slideshow )等效于( require slideshow/main )。 其次，require 向路径隐式添加了“.rkt”后缀。 最后，require通过在已安装的collection中搜索来解析路径，而不是将路径视为相对于封闭模块的路径。  Packages and Collections 一个package是一组通过Racket包管理器安装的库的集合。Racket 程序不直接引用包。相反，程序通过collections引用库，并且添加或删除包会更改可用的基于集合的库集。\n添加Collections library的旨在跨多个项目使用，因此将库的源文件保存在一个目录中并没有意义，更不能将库复制到不同的项目中使用。在这种情况下，最好的选择是新增一个collection，将lib放在collection中，这样就可以使用不带引号的路径引用它，就像Racket 发行版中包含的库一样。\n不用担心，创建一个包无需提交到公开的包服务器，可以安装到本地来使用。\n 采用raco pkg命令行工具： raco pkg install \u0026ndash;link /path/to/mod_demo\n 安装之后，在任何模块中使用(require mod_demo/ext/cake)都会从/path/to/mod_demo/ext/cake.rkt导入print-cake含函数。\n\u0026gt; (require mod_demo/ext/cake) \u0026gt; (print-cake 4) ...... .-||||||-. | | ------------ \u0026gt; 默认情况下，您安装的目录名称既用作包名称又用作包提供的collection\n将lib放入collection之后，仍然可以使用raco make来编译库的源文件，但是使用raco setup更加方便。尤其是修改了模块代码后，使用raco setup会重新编译所有库文件，并重新安装包。与raco make不同的是，raco setup 后面的参数是包名，即raco setup mod_demo, 而raco make后面是模块名，即raco make main.rkt。\n模块语法 模块文件开头处的#lang其实是模块形式的简写，但不能用于REPL。\n模块形式 普通形式的模块声明，可以工作于REPL\n (module name-id initial-module-path decl \u0026hellip;)\n name-id是模块的名字，initial-module-path 为初始化导入，每个decl可以是导入，或者导出，或者定义，或者表达式。\ninitial-module-path是必须的，模块内部也是一个环境（SICP中的环境，即上下文），内部使用的指令是需要通过initial-module-path引导的。常用的initial-module-path是racket, require/define/provide等等都来自racket。另一个常用的initial-module-path是racket-base,它提供的功能较少，但仍然是很常用。\n上一节中的“cake.rkt”也可以写成：\n(module cake racket (provide print-cake) (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline))) 这种模块形式是可以被REPL求值的（注意(require \u0026lsquo;cake)， 模块名cake需要被quote，因为这时cake是非文件的模块声明）：\n\u0026gt; (require \u0026#39;cake) \u0026gt; (print-cake 3) ... .-|||-. | | --------- 声明一个模块，其body不会被立刻求值，只有在显式地被require之后才会求值一次。\n\u0026gt; (module hi racket (printf \u0026#34;Hello\\n\u0026#34;)) \u0026gt; (require \u0026#39;hi) Hello \u0026gt; (require \u0026#39;hi) #lang #lang声明的模块的body没有特定的语法，因为其语法由#lang之后的名称所决定。\n比如，#lang racket的语法是：\n#lang racket decl ... 等同于：\n(module name racket decl ...) name是包含#lang形式的文件名\n子模块 一个模块可以嵌套在另一个模块中，父模块可以直接访问子模块导出的函数、定义、表达式。\n#lang racket (module zoo racket (provide tiger) (define tiger \u0026#34;Tony\u0026#34;)) (require \u0026#39;zoo) tiger module* module*形式类似module：\n(module* name-id initial-module-path-or-#f decl ...) module*与module的不同之处在于：\n 由module声明的子模块，可以被其父模块require, 但是子模块不能require父模块； 由module*声明的字模块，可以require父模块，但是父模块不能require该子模块；  此外，module*形式可以用#f代替initial-module-path，这意味着，子模块可以访问父模块所以绑定，包括未通过provide导出的绑定。\n因此，用module*和#f来声明一个模块的一个用途是，将某个模块未provide出去的绑定导出。\n#lang racket (provide print-cake) (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (module* extras #f (provide show)) 尽管show函数未导出，但是子模块extras却将其导出了，外部程序可以使用(require (submod \u0026ldquo;caske.rkt\u0026rdquo; extras))来访问隐藏的show函数。\nMain和Test子模块 #lang racket (define (print-cake n) (show \u0026#34; ~a \u0026#34; n #\\.) (show \u0026#34; .-~a-. \u0026#34; n #\\|) (show \u0026#34; | ~a | \u0026#34; n #\\space) (show \u0026#34;---~a---\u0026#34; n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (module* main #f (print-cake 10)) 这个“cake.rkt”变体，包含了一个main子模块，并调用了print-cake函数。\n一般来说，运行一个模块时并不会运行其中由module*声明的子模块，但是main子模块除外。\nmain子模块并不一定由module*声明，如果不需要使用父模块的绑定，也可以由module来声明。 更常见的做法是由module+来声明\n(module+ name-id decl ...) module+声明的模块就像采用module*声明且使用#f作为initial-module-path的模块。此外，多个module+模块可以同名，同名的模块会组合成一个模块。这种组合特性可以用来定义一个test模块，在使用 raco test命令时就可以大显身手了。\n假设\u0026quot;physics.rkt\u0026quot; 为：\n#lang racket (module+ test (require rackunit) (define ε 1e-10)) (provide drop to-energy) (define (drop t) (* 1/2 9.8 t t)) (module+ test (check-= (drop 0) 0 ε) (check-= (drop 10) 490 ε)) (define (to-energy m) (* m (expt 299792458.0 2))) (module+ test (check-= (to-energy 0) 0 ε) (check-= (to-energy 1) 9e+16 1e+15)) 导入\u0026quot;physics.rkt\u0026quot; 时，并不会运行drop和to-energy的测试，不过运行raco test physics.rkt将会执行这些测试。\n这等价于使用module*:\n#lang racket (provide drop to-energy) (define (drop t) (* 1/2 49/5 t t)) (define (to-energy m) (* m (expt 299792458 2))) (module* test #f (require rackunit) (define ε 1e-10) (check-= (drop 0) 0 ε) (check-= (drop 10) 490 ε) (check-= (to-energy 0) 0 ε) (check-= (to-energy 1) 9e+16 1e+15)) module+的组合行为对main模块也有帮助，即使不需要组合， ( module+ main \u0026hellip;. )也是首选，因为它比( module* main #f \u0026hellip;. )更具可读性 。\nRequire require的定义为：\n (require require-spec \u0026hellip;)\n only-in 用来限制模块导出的绑定，也可重命名绑定\n\u0026gt; (module m (lib \u0026#34;racket\u0026#34;) (provide tastes-great? less-filling?) (define tastes-great? #t) (define less-filling? #t)) \u0026gt; (require (only-in \u0026#39;m tastes-great?)) \u0026gt; tastes-great? #t \u0026gt; less-filling? less-filling?: undefined; cannot reference an identifier before its definition in module: top-level \u0026gt; (require (only-in \u0026#39;m [less-filling? lite?])) \u0026gt; lite? #t except-in 是only-in的补充，用来排除某些绑定\n (except-in require-spec id \u0026hellip;)\n rename-in 与only-in类似。\n (rename-in require-spec [orig-id bind-id] \u0026hellip;)\n prefix-in  (prefix-in prefix-id require-spec) 给每一个require-spec的绑定添加前缀\n Provide  (provide provide-spec \u0026hellip;)\n provide-spec允许递归定义：\n id: 最简单的形式，上文中多次出现\n  (rename-out [orig-id export-id] \u0026hellip;): 重命名导出的绑定\n  (struct-out struct-id): 导出struct\n  (all-defined-out): 导出所有绑定，不推荐\n  (all-from-out module-path): 导出所有由module-path指定的绑定\n  (except-out provide-spec id \u0026hellip;): 排除id指定的绑定\n  (prefix-out prefix-id provide-spec)：给每个导出绑定添加一个前缀\n ","id":96,"section":"posts","summary":"模块基础 一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set! 通常，每个Racket模块驻留在自己的文件中，换句话说，可以","tags":["racket","module"],"title":"Racket Modules","uri":"https://lvsq.net/2021/07/racket-modules/","year":"2021"},{"content":"这是一个leet code出现的问题:\n 给 n 个非负整数 $a_1$，$a_2$，\u0026hellip;，$a_n$，每个数代表坐标中的一个点(i, $a_i$) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i, $a_i$) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n  说明：不能倾斜容器\n 更详细的描述请访问：https://leetcode-cn.com/problems/container-with-most-water/\n首先可以想到的最简单的方法，就是暴力求解，将所有的面积都计算出来，取最大值即可。下面给出(Racket)[https://racket-lang.org/]的代码，得益于函数式语言和S表达式强大的表现力，代码可以很短：\n(define/contract (max-area height) (-\u0026gt; (listof exact-integer?) exact-integer?) (define len (length height)) (cond ((\u0026lt; len 2) 0) ((= len 2) (area (list 1 (car height)) (list 2 (cadr height)))) (else (max (each-area height) (max-area (cdr height)))))) (define (area n1 n2) (* (- (car n2) (car n1)) (min (cadr n1) (cadr n2)))) (define (each-area height) (let ([first (list 1 (car height))]) (foldl max 0 (map (lambda (i h) (area first (list i h))) (range 2 (add1 (length height)) ) (cdr height))))) 上述解法虽然正确，但是效率很低, 如果有10000个整数，即n=10000，其执行时间超过了2秒：\n(time (max-area (build-list 10000 (lambda(x) (random 1000000))))) =\u0026gt; cpu time: 2387 real time: 2466 gc time: 137 那么有更好的解决方法吗？\n显然可以认为所有整数都保存在一个列表或者数组中，假设我们有两个指针，一个叫head，指向第一个整数, 表示为：head -\u0026gt; (i, $h_i$)，i为列表下标， $h_i$代表第i个整数值；另一个叫tail，指向最后一个整数，表示为tail -\u0026gt; (j, $h_j$)，我们可以仅仅利用这两个指针的移动，就能计算出最大的面积，其过程为：\n 计算由head和tail围成的矩形的面积$S_{ij}$, 矩形的长度x = j - i, 高度y = min ($h_i$, $h_j$); 将矩形收窄一格，即x减少1，那么有两种收窄方式：  将高度短的一侧收窄，那么，收窄后高度可能变大，则面积可能增大; 将高度长的一侧收窄，由于另一侧不变,但是长度变小了一格，则面积会变小;   因此，需要移动高度短的一侧，才有可能找到面积更大的矩形  很显然，使用双指针算法，时间复杂度降低到了$O(n)$。\nRacket 版本 ;;better solution (define/contract (max-area-pair-pointer height) (-\u0026gt; (listof exact-integer?) exact-integer?) (define (area n1 n2) (* (- (car n2) (car n1)) (min (cadr n1) (cadr n2)))) (let ([len (length height)]) (if (\u0026lt; len 2) 0 (let loop ([h height] [hindex (range 0 len)] [rheight (reverse height)] [rindex (reverse (range 0 len))] [maxa 0]) (let* ([head (list (car hindex) (car h))] [tail (list (car rindex) (car rheight))] [a (area head tail)]) (if (= (car head) (car tail)) maxa (if (\u0026gt; (cadr head) (cadr tail)) (loop h hindex (cdr rheight) (cdr rindex) (max maxa a)) (loop (cdr h) (cdr hindex) rheight rindex (max maxa a))) )))))) 如果使用这个方法计算10000个整数的面积，执行时间只需1毫秒，而且不需要GC（对照暴力破解版本，2+秒）\n(time (max-area-pair-pointer (build-list 10000 (lambda(x) (random 1000000))))) =\u0026gt; cpu time: 1 real time: 1 gc time: 0 Rust版本 同时提供一个Rust版本的实现，\nuse std::cmp::{max, min}; type HeightType = i64; #[derive(Debug)] struct Solution {} impl Solution { pub fn max_area(height: Vec\u0026lt;HeightType\u0026gt;) -\u0026gt; HeightType { let len = height.len(); return if len \u0026lt; 2 { 0 } else { let mut max_area = 0; let mut hi = 0; let mut ti = len - 1; while ti \u0026gt; hi { let hd = height.get(hi).unwrap(); let td = height.get(ti).unwrap(); let a = ((ti - hi) as HeightType) * min(hd, td); max_area = max(max_area, a); if hd \u0026lt; td { hi += 1; } else { ti -= 1; } } max_area }; } } 两个版本做一个简单的比较：\n   size Racket(8.0 CS) Rust(1.50.0)     100000 49ms 60ms   1000000 560ms 550ms   10000000 5s 5.6s    两个版本的实现均未使用编译器优化,令人意外的是Racket的执行效率与Rust几乎没有差别，使用了CS编译器的Racket真是突飞猛进。 由于我的Rust经验并不是很多，或许有更好的写法。从测试可以看到Racket至少在CPU密集型应用中可堪大用。\n","id":97,"section":"posts","summary":"这是一个leet code出现的问题: 给 n 个非负整数 $a_1$，$a_2$，\u0026hellip;，$a_n$，每个数代表坐标中的一个点(i, $a_i$) 。在","tags":[],"title":"【盛最多水的容器】问题的求解","uri":"https://lvsq.net/2021/05/container-with-most-water/","year":"2021"},{"content":"神经科学家发现，解释代码可以激活通用的大脑网络，但不能激活语言处理中心。\n安妮·特拉夫顿 | 麻省理工学院新闻办公室 发布日期：2020年12月15日\n 在某些方面，学习计算机编程与学习新语言相似。它需要学习新的符号和术语，必须正确组织这些符号和术语以指导计算机该怎么做。计算机代码还必须足够清晰，以便其他程序员可以阅读和理解。\n尽管存在这些相似之处，麻省理工学院的神经科学家发现，阅读计算机代码并不能激活与语言处理有关的大脑区域。取而代之的是，它激活了一个称为多需求网络的分布式网络，该网络也被招募用于解决复杂的认知任务，例如解决数学问题或填字游戏。\n但是，尽管阅读计算机代码会激活多需求网络，但与数学或逻辑问题相比，它似乎更多地依赖于网络的不同部分，这表明编码也不能精确地复制数学的认知需求。\n“理解计算机代码似乎是自己的事。它与语言不同，数学与逻辑也不相同。”麻省理工学院研究生，该研究的主要作者安娜·伊凡诺娃（Anna Ivanova）说。\nEvelina Fedorenko，Frederick A.和Carole J. Middleton职业发展神经科学副教授，麦戈文脑科学研究所的成员，是该论文的高级作者，该论文今天发表在eLife上。麻省理工学院计算机科学与人工智能实验室和塔夫茨大学的研究人员也参与了这项研究。\n语言与认知 Fedorenko研究的主要重点是语言与其他认知功能之间的关系。特别是，她一直在研究其他功能是否依赖于大脑的语言网络（包括Broca区域和大脑左半球的其他区域）的问题。在先前的工作中，她的实验室表明，音乐和数学似乎并未激活该语言网络。\n“在这里，我们有兴趣探索语言和计算机编程之间的关系，部分原因是计算机编程是一个新发明，我们知道不可能有任何硬连线机制使我们成为优秀的程序员，”伊万诺娃说。\n她说，关于大脑如何学习编码，存在两种思想流派。有人认为，要精通编程，就必须精通数学。另一个建议认为，由于编码和语言之间的相似性，语言技能可能更相关。为了阐明这一问题，研究人员着手研究在阅读计算机代码时大脑活动模式是否会与语言相关的大脑活动重叠。\n研究人员在本研究中重点关注以可读性着称的两种编程语言——Python和ScratchJr。ScratchJr这是一种专为5岁及5岁以上儿童设计的可视化编程语言。研究对象均为精通测试语言的年轻人。当程序员躺在功能磁共振（fMRI）扫描仪中时，研究人员向他们展示了代码片段，并要求他们预测代码将产生什么动作。\n研究人员几乎看不到大脑语言区域对代码的反应。相反，他们发现编码任务主要激活了所谓的多需求网络。这个网络的活动遍布整个大脑的额叶和顶叶，通常是为需要同时记住许多信息的任务而招募的，它负责我们执行各种心理任务的能力。\n伊万诺娃说：“它所做的几乎所有在认知上都具有挑战性的事情，使您难以思考。”\n先前的研究表明，数学和逻辑问题似乎主要取决于左半球的多个需求区域，而涉及空间导航的任务比右半球更多地激活右半球。麻省理工学院的研究小组发现，读取计算机代码似乎可以激活多需求网络的左侧和右侧，而ScratchJr激活右侧的程度要比左侧高一些。这一发现违背了数学和编码依赖相同大脑机制的假设。\n经验的影响 研究人员说，尽管他们没有发现任何似乎专门用于编程的区域，但是这种具有特殊脑活动的区域可能会在具有更多编码经验的人中发展。\nFedorenko说：“如果您聘用了以30年或40年的特定语言编写代码的专业程序员的人，您可能会开始看到某些专业化知识，或者是多个需求系统某些部分的结晶”，Fedorenko说。“对于那些熟悉编码并且可以有效地完成这些任务，但经验相对有限的人来说，似乎您还看不到任何专业化知识。”\n约翰·霍普金斯大学的一组研究人员在同一期eLife上发表的一篇伴随论文中也报告说，解决代码问题可以激活多需求网络而不是语言区域。\n研究结果表明，对于编码应该以基于数学的技能还是基于语言的技能进行教授，尚无定论。研究人员说，部分原因是因为学习编程可能会同时依赖语言和多种需求系统，即使—一旦学会了编程，就不会依赖语言区域。\n伊万诺娃说：“两个阵营都宣称，它必须与数学结合在一起，必须与语言结合在一起。” “但是看来，计算机科学教育者将不得不开发自己的方法来最有效地教授代码。”\n全文完。\n 如果您想看原文，可以访问：链接\n","id":98,"section":"posts","summary":"神经科学家发现，解释代码可以激活通用的大脑网络，但不能激活语言处理中心。 安妮·特拉夫顿 | 麻省理工学院新闻办公室 发布日期：2020年12月15","tags":[],"title":"对大脑而言，阅读计算机代码与阅读语言不同","uri":"https://lvsq.net/2020/12/brain-reading-computer-code/","year":"2020"},{"content":"作者\nMATTHEW FLATT, University of Utah,USACANER DERICI, Indiana University, USAR. KENT DYBVIG, Cisco Systems, Inc., USAANDREW W. KEEP, Cisco Systems, Inc., USAGUSTAVO E. MASSACCESI, Universidad de Buenos Aires, ArgentinaSARAH SPALL, Indiana University, USASAM TOBIN-HOCHSTADT, Indiana University, USAJON ZEPPIERI, independent researcher, USA 概要\n我们在Chez Scheme上重建了Racket，并且运行良好——只要对Chez Scheme进行一些修补，就可以运行DrRacket。Racket发行版可以自行构建，并且几乎所有核心​​的Racket测试套件都可以通过。尽管仍有一些工作可以提高端到端的性能，但最终的实现还是不错的。我们评估的最不可预测的部分是，Racket和Chez Scheme之间的不同将变得多大，以及我们如何处理这些不同。我们希望Racket CS成为主要的Racket实现，并且我们鼓励其他语言实现者将Chez Scheme视为目标虚拟机。\n 该文详细地介绍了Racket CS是如何构建的，以及与Chez Scheme之间的差异， 完整内容见(https://dl.acm.org/doi/epdf/10.1145/3341642)\n","id":99,"section":"posts","summary":"作者 MATTHEW FLATT, University of Utah,USACANER DERICI, Indiana University, USAR. KENT DYBVIG, Cisco Systems, Inc., USAANDREW W. KEEP, Cisco Systems, Inc., USAGUSTAVO E. MASSACCESI, Universidad de Buenos Aires, ArgentinaSARAH SPALL, Indiana University, USASAM TOBIN-HOCHSTADT, Indiana University, USAJON ZEPPIERI, independent researcher, USA 概要 我们在Chez Scheme上重建了Racket，并且","tags":["pl"],"title":"基于Chez Scheme重建Racket","uri":"https://lvsq.net/2020/10/rebuilding-racket/","year":"2020"},{"content":"我相信每一位程序员在学习或者实践编程时，都会遇到作用域的问题。您可能觉得作用域很简单，甚至都不能当做一个问题来看待，我想原因可能是目前主流的计算机语言Java, Python, C等等几乎一致采用Lexical Scoping,程序员没有机会察觉到异样，从而掩盖了还有其他作用域的事实，许多教科书也很配合地一笔带过，当然还有一种可能是您已经洞察了不同作用域的差异和内涵，自觉地规避了问题。我衷心的希望所有程序员都是第二种可能。\n本文将浅显地描述两种作用域的特点及差异，希望可以解释地清楚一点，如果读完之后您更加模糊了，请记住，这并非我的本意。\n在计算机编程中，名称绑定的作用域（名称与实体的关联，比如变量）是程序中名称绑定有效的部分，也就是说，该名称可以被引用到一个实体。程序的其他部分，名称可能指向不同的实体（它可能具有不同的绑定），或者根本什么都没有（它可能是未绑定的）。作用域也称为实体的可见性， 尤其在较早的技术文献中可见，这是从所引用的实体的角度出发，而非引用的名称。\n术语\u0026quot;scope\u0026ldquo;也用于指代程序中有效的名称绑定的那部分集合，更加正确的称呼应该是上下文 或者 环境\n Lexical Scoping 词法作用域，某些书中也叫静态作用域，其在编写代码时或者说定义时就确定的，通过文本（源代码）就可以观察到名称与实体的关联，程序运行时会在距离被调用代码最近的环境中去查找绑定，如果存在多个环境，在优先从最里面一层的环境查找。\n来看一个例子：\n(setf x 1) ;; bind x to 1 (setq f (let ((x 2)) ;; bind x to 2 (lambda (y) (* x y)))) (funcall f 3) ;; result is 6 (format t \u0026#34;X = ~d \u0026#34; x) ;; X = 1 先绑定x为1，然后定义一个函数f，f中的变量x绑定为2，实际上f形成了一个闭包，由于两个x的环境不同，所以互不干扰，结果正是我们期望的，这就属于词法作用域。\nDynamic Scoping 动态作用域曾经让很多人深恶痛绝，以至于不愿意再提起它。早期的Lisp普遍使用了动态作用域，并带来了非常严重的问题，这也是Lisp Machine被Unix打败的除了商业因素之外的重要原因，Lisp至今未成为主流语言就不难理解了，尽管Lisp的语法最精炼、最优美，还具有最强悍的宏系统，还是世界上第一个使用GC的语言\u0026hellip;\n庆幸的是，Scheme, Common Lisp等Lisp方言已经都是用了Lexial Scoping（局部变量。所以某些时候我们可以把Lexical Scoping和Local Variable等价）, 我们无需再为一些莫名其妙的问题而烦恼，珍惜生命，不是吗？ 不过Scheme, Common Lisp还是保留了动态作用域的操作，Scheme可以参考Fluid Binding, Common Lisp的动态作用域将在后文举例说明，尽管如此，我们无需为这个保留担忧，因为基本上我们很少需要使用到这个功能。\n所谓dynamic scoping就是说，在函数定义中存在了“自由变量”（free variable）, 会在运行时随着函数的“调用位置”不同而发生变化，还是用上面的例子来说明，但是稍作变化：\n(defvar x 1) ;; bind x to 1, x is a free variable (setq f (let ((x 2)) ;; bind x to 2 (lambda (y) (* x y)))) (funcall f 3) (format t \u0026#34;X = ~d \u0026#34; x) (let ((x 100)) (format t \u0026#34;Inner X is ~d \u0026#34; x)) (defvar x 1)定义了x，值为1，但是这个x属于自由变量，处于动态作用域，因为Lisp自动将全局变量即由defvar、defparameter、special定义的变量自动声明为动态作用域。 x对于(lambda (y) (* x y))来说是“ **自由** ” 的，它可不会在意x绑定为2或者任何其他值，因为(let ((x 2)) \u0026hellip;)中指定的x已经不是(lambda \u0026hellip;)的参数了。\n所以当我们执行(funcall f 3) 时，其结果不像词法作用域那样等于6，而是3\n(format t \u0026ldquo;X = ~d \u0026quot; x) 依然输出： X = 1\n(let ((x 100)) (format t \u0026ldquo;Inner X is ~d \u0026quot; x)) 输出为：Inner X is 100。 等等，这里的x为什么又是100了？ 还记得上文提到的环境 吗？！\n如果将函数f放到不同的位置执行会发生什么？ 上面(funcall f 3)是在顶层执行的，我们换到let中执行会怎么样？\n(let ((x 2)) (funcall f 3)) 这次居然返回6，而不是3了。\n看到问题了吗？函数f的行为，会随着调用位置的一个名叫x的变量的值的不同而变化。虽然都叫x，但并不是同一个变量，只是名字相同而已。顺带提一句，现在可以理解Java中namespace的用处了吧。\n 词法作用域是通过搜索本地词法上下文解决的，而动态作用域是通过搜索本地执行上下文（即位置）解决的。这是编译器必须面对并解决的问题，或许编写程序时无需过多关注，但是多了解一下一定大有裨益。尽管动态作用域存在很大问题，但它并非洪水猛兽，它可以使全局变量更易于管理；假设您希望临时改变自由变量的值时，也可以声明为dynamic socping；另外在异常处理中也可以使用动态作用域将处理程序与异常相关联。\n","id":100,"section":"posts","summary":"我相信每一位程序员在学习或者实践编程时，都会遇到作用域的问题。您可能觉得作用域很简单，甚至都不能当做一个问题来看待，我想原因可能是目前主流的","tags":["lexical","scoping"],"title":"Lexical Scoping and Dynamic Scoping","uri":"https://lvsq.net/2020/09/lexical-dynamic-scoping/","year":"2020"},{"content":"快速排序是一种常见的排序手段，由C.A.R.Hoare在1960年提出。其基本思路为：\n  设定一个分界值，通常为第一个元素；\n  遍历列表，将所有小于分界值的元素集中到列表的左侧，所有大于或等于分界值的元素集中到右侧；\n  分别对左侧和右侧的元素进行快排；\n  重复上述的步骤，排序完成；\n  在平均状况下，排序n个元素需要$O(nlog n)$复杂度，最坏情况下需要$O(n^2)$,但一般很少出现这种情况。\n从算法的原理可以看出，需要多次执行重复的操作，自然采用递归可以减少很多代码，若问递归技术哪家强？首屈一指Lisp,下面给出CL版本的快排实现（简易版本，只支持数字类型的列表，其他类型的排序只需增加一个比较函数即可，本文不扩展）：\n(defun quickSort (lst) (let ( (len (list-length lst)) (st (lambda (l pk) ;; st函数实现上述第2步 (let ((left nil) (right nil)) (dolist (each l) (if (\u0026lt; each pk) (push each left) (push each right))) (values left right) ) ) ) ) (if (\u0026lt; len 2) lst (multiple-value-bind (l r) (st (cdr lst) (car lst)) (append (quickSort l) (cons (car lst) (quickSort r)))) ) ) ) (quickSort \u0026#39;(1 2 6 3 5 4)) =\u0026gt; (1 2 3 4 5 6) st函数可以用宏来实现：\n(defmacro st (lst pk) (let ((gslist (gensym))) `(let ((,gslist ,lst)) (let ((left nil) (right nil)) (dolist (each ,gslist) (if (\u0026lt; each ,pk) (push each left) (push each right))) (values left right) ) ) ) ) (defun quickSort (lst) (let ( (len (list-length lst)) ) (if (\u0026lt; len 2) lst (multiple-value-bind (l r) (st (cdr lst) (car lst)) (append (quickSort l) (cons (car lst) (quickSort r)))) ) ) ) ","id":101,"section":"posts","summary":"快速排序是一种常见的排序手段，由C.A.R.Hoare在1960年提出。其基本思路为： 设定一个分界值，通常为第一个元素； 遍历列表，将所有小于","tags":["lisp"],"title":"快速排序（Lisp版本）","uri":"https://lvsq.net/2020/07/quick-sort-in-cl/","year":"2020"},{"content":"讲故事并不是我擅长的事情，不过事情总有一个开始，诸位看官莫嫌我絮烦，只是希望可以讲述的更有条理一些。某日正读一本关于Erlang的书，书中出了一个关于八皇后的题目，这是计算机科学中经典的问题，当年上学时曾绞尽脑汁仍然云山雾罩，不得其解。如今再次相遇，岂能再坐壁上观？！更何况手边已有趁手的兵器。试看Erlang的实现：\n-module(queens). -export([queens/1]). queens(0) -\u0026gt; [[]]; queens(N) -\u0026gt; [[Row | Columns] || Columns \u0026lt;- queens(N - 1), Row \u0026lt;- lists:seq(1, 8) -- Columns, safe(Row, Columns, 1)]. safe(_Row, [], _N) -\u0026gt; true; safe(Row, [Column | Columns], N) -\u0026gt; (Row /= Column + N) andalso (Row /= Column - N) andalso safe(Row, Columns, (N + 1)). 从头至尾10行代码，如果不是为了使代码美观，6行足矣（这还包括了**-module** 和**-export** 两行声明语法，与算法本身无关的代码）。如此简短尽然可以清晰地实现复杂的**八皇后** 问题，如果采用命令式程序语言得写多少行？本文的重点不在于比较这个，Erlang是一门非常强大的语言，对于我来说Erlang好比探春，但是Scheme才是林黛玉呀，所以毫不迟疑用Scheme来实现：\n(define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence)))) ) (define (enumerate-interval low high) (if (\u0026gt; low high) \u0026#39;() (cons low (enumerate-interval (+ low 1) high))) ) (define (flatmap proc seq) (accumulate append \u0026#39;() (map proc seq)) ) (define empty-board \u0026#39;()) (define (safe? k position) (let loop ([new-queen (car position)] [rest-queens (cdr position)] [i 1]) (if (null? rest-queens) #t (let ([rest-current-queen (car rest-queens)]) (if (or (= new-queen rest-current-queen) (= new-queen (+ rest-current-queen i)) (= new-queen (- rest-current-queen i)) ) #f (loop new-queen (cdr rest-queens) (+ i 1)) ) ) ) ) ) (define (adjoin-position new-row k rest-of-queens) (cons new-row rest-of-queens) ) (define (queens board-size) (define (queen-cols k) (if (= k 0) (list empty-board) (filter (lambda (position) (safe? k position)) ;过滤无效的解 (flatmap (lambda (rest-of-queens) (map (lambda (new-row) ;扩充（k-1）个皇后的每一个解，给每个解都增加第k个皇后 (adjoin-position new-row k rest-of-queens)) (enumerate-interval 1 board-size) ) ) (queen-cols (- k 1)) ;前（k-1）个有效的皇后，虽然是太虚幻境，但可以认为是事实 ) ) ) ) (queen-cols board-size) ) Scheme版本比Erlang版本代码增加了不少，原因在于其没有模式匹配 和列表推导 这两大利器，不过我更喜欢Scheme强大的表现力，可以随心所欲地构造我需要的一切，而且S-表达式看起来十分优美自然。Scheme版本实际上解决了n-皇后，更进一步了。\n事情到这里并没有结束，原因在于我刚开始实现Scheme版本的八皇后时，选择翻译Erlang代码，最终失败了！一番挣扎之后，意识到该问题属于非确定性计算，猛然想起《SICP》中有一节专门介绍了此种计算，也即本文的主角——amb\n 非确定性计算 amb这个名字源于ambiguous ,其含义并不是很好理解。一番披肝沥胆之后，终于窥到了一些门径，趁机厘清很多知识点。我将尽力平铺直述，简要的介绍这种强大且十分有用的武器。\n首先，我们来观察一个问题：\n 假设有两个数组，数组中都是一些正整数，比如l1 = [1 2 3 4 5], l2 = [3 4 6 7 8]，我们分别从l1和l2中各取一个数字，相加之后，如果是素数，则满足要求。怎么办呢？\n 对于这个简单的问题，相信难不倒大家，采用回溯算法轻易就解决了，这里只是想引出“非确定性计算”的概念。非确定性计算和流处理类似，对于“生成和检测式”的应用特别有价值，它往往只描述问题，但没有描述问题的解决方法，这句话很有意思，如果暂时没有理解不用着急，继续往下看。\n对于非确定性计算，首先需要明确的一点是，表达式是允许存在多个值的，比如上面的问题的解至少有(1 4),(2 3)两个解吧。\n有一件很有教益的事情，那就是非确定性计算和流处理对于时间的不同看法。流处理利用了惰性求值，这会给我们一种错觉，仿佛所有可能的结果的出现没有时间顺序；对于非确定性的求值，一个表达式是对一个可能的世界的探索，每一个值都由一次选择所确定，某些选择会走入死胡同，而另一些会得到有用的值，所以非确定性计算给我们的感觉是，时间是有分支的。程序当中会保存所有可能的不同执行历史，在遇到一个死胡同时，总是可以回到以前的选择点，并沿着另一个分支继续下去。\n下面将要实现的非确定性求值器称为——amb求值器\namb求值器 假设目前已经扩充了Scheme以支持非确定性计算，引入了一种新的称为amb的新形式，表达式 $(amb \u0026lt;e_1\u0026gt; \u0026lt;e_2\u0026gt; \u0026hellip; \u0026lt;e_n\u0026gt;)$ 会“有歧义地”返回n个表达式之一的值，比如：\n(list (amb 1 2 3) (amb \u0026#39;a \u0026#39;b)) 可以有如下6个可能的值：(1 a) (1 b) (2 a) (2 b) (3 a) (3 b)\n对于没有选项的amb，即(amb) ——视为没有可接收值的表达式，这将导致求值“fail”。\namb求值器在每个选择点，总是选择第一个可能性，如果选择的结果失败，那么求值器自动地回溯到最近的选择点，去尝试下一个可能性。如果它用完了所以的可能性，则自动退回到上一个选择点，并从那里继续（这个“继续”很有意思，后文会看到，“继续”不但是结论，还是其实现的方式，一语双关）下去。从这个过程可以看出，这是一种深度优先 算法。\n逻辑谜题 在讨论amb求值器的实现之前，先看一道逻辑谜题：\n 曹操、孙权、刘备、袁绍、马超5人住在一栋5层的楼房里面，每人住一层。曹操不住顶层，孙权不住底层，刘备不住顶层也不住底层，袁绍比刘备高一层，马超与刘备不在相邻的楼层，刘备与孙权也不在相邻的楼层，请问他们各住在哪一层？\n 在没有amb时，代码怎么写呢？恐怕不容易吧。但是现在有了amb求值器，瞬间美好了：\n(define (multiple-dwelling) (let ( [caocao (amb 1 2 3 4 5)] [sunquan (amb 1 2 3 4 5)] [liubei (amb 1 2 3 4 5)] [yuanshao (amb 1 2 3 4 5)] [machao (amb 1 2 3 4 5)] ) (require (distinct? (list caocao sunquan liubei yuanshao machao))) (require (not (= caocao 5))) (require (not (= sunquan 1))) (require (not (= liubei 5))) (require (not (= liubei 1))) (require (\u0026gt; yuanshao liubei)) (require (not (= (abs (- machao liubei)) 1)) (require (not (= (abs (- sunquan liubei)) 1)) (list (list \u0026#39;caocao caocao) (list \u0026#39;sunquan sunquan) (list \u0026#39;liubei liubei) (list \u0026#39;yuanshao yuanshao) (list \u0026#39;machao machao)) ) ) 上述代码只是描述问题的关系，即各个require部分（先不考虑性能问题。还记得上文提到的“描述问题，但没有描述问题的解决方法”吗？），并没有添加什么“处理逻辑”，但是会产生下面结果：\n((caocao 3) (sunquan 2) (liubei 4) (yuanshao 5) (machao 1))\n居然得到了谜题的解，这是什么魔法？？？\namb轻而易举地解决了这种需要大量回溯的问题。\n实现 现在该谈一谈神奇的amb如何实现了吧。前文已经多次提到过，amb求值的过程可能会不断的回溯，这势必导致程序流程的跳转，程序跳转该怎么办呢？函数式语言可没有break,continue之类的语法，因为根本不需要，那么函数式语言有啥？答案是continuation(翻译成继续，或者延续都可以。还记得“一语双关”吗？)\nScheme内置了这个强大的控制抽象，过程名为：call-with-current-continuation， 名字略长，不过一般都是用其缩写：call/cc。囿于篇幅，本文不打算介绍continuation，如果想详细了解它，请自行搜索。\n常规求值器的执行过程有一个参数：执行环境env。amb求值器的执行过程有三个参数，除了执行环境env之外，还有两个continuation过程（一个成功延续、一个失败延续）。对一个表达式进行求值，结束后会调用这两个continuation过程之一：如果此次求值得到了一个结果，则调用成功延续；如果结果是遇到了死胡同，则调用失败延续。\n成功延续的工作是：接受一个值，并将计算进行去下，与这个值一起，成功延续过程还将得到一个另一个失败延续，如果使用该值时遇到了死胡同，则需要调用这个失败延续。\n失败延续的工作是：试探非确定性过程的另一个分支。非确定性计算的最关键的特征，在于表达式可以表示于不同可能性之间的选择。\n我承认有点烧脑，但还算清晰，让递归在脑海中奔涌吧。\n利用宏来简化amb的构造，代码参考这里：\n(define amb-fail \u0026#39;*) (define initialize-amb-fail (lambda () (set! amb-fail (lambda () (error \u0026#34;amb tree exhausted\u0026#34;))))) (initialize-amb-fail) (define-syntax amb (syntax-rules () ((amb alt ...) (let ((prev-amb-fail amb-fail)) ;保存前一个选择点 (call/cc (lambda (sk) ;对于整个amb表达式构造一个sk的contnuation (call/cc (lambda (fk) ;对于每一个amb的选项构造一个fk的continuation (set! amb-fail ;先把amb-fail设置为一个函数，该函数可将amb-fail恢复到进入amb前的值 (lambda () (set! amb-fail prev-amb-fail) (fk \u0026#39;fail)) ) (sk alt) ;立即返回自己的分支的值,从而引起amb表达式中途返回。注意，每一个分支执行时都会引起 amb 立即返回。后面的分支都还没有执行！ ) ) ... (prev-amb-fail) ) ) ) ) ) ) 第一个选项（也可以叫分支）会被立即返回，后面的暂时不执行。假设该值被认为是“无效的（比如应用该值后，执行到(amb)了）”，则执行(prev-amb-fail)，而prev-amb-fail在进入amb的时候被绑定到了amb-fail， 不过amb-fail已被设置成了一个函数：\n(lambda () (set! amb-fail prev-amb-fail) (fk \u0026#39;fail)) 它先把amb-fail设置成prev-amb-fail,也就是进入（amb alt \u0026hellip;）之前的值， 然后用(fk \u0026lsquo;fail)返回\u0026rsquo;fail到分支的continuation，即可以执行下一个分支（下一个选项）了。\n十分精巧的程序！！！\n上述的amb每次只能返回一个结果，如果需要返回所有有效的结果，可以用下面定义的宏：\n(define-syntax bag-of (syntax-rules () ((bag-of e) (let ((prev-amb-fail amb-fail) (results \u0026#39;())) (if (call/cc (lambda (k) (set! amb-fail (lambda () (k #f))) ;\u0026lt;-----+ (let ((v e)) ;amb-fail will be modified by e | (set! results (cons v results)) ;| (k #t)))) ;| (amb-fail)) ;so this amb-fail may not be ---+ (set! amb-fail prev-amb-fail) (reverse! results))))) (bag-of (let ([a (amb 1 2 3)] [b (amb 0 -1 2)]) (if (= (+ a b) 1) (list a b) (amb)) )) ;结果为：((1 0) (2 -1)) 回到n-皇后问题 到目前为止，我已手握amb这把利器，是时候重构一下n-皇后问题了。\n(define number-between (lambda (lo hi) (let loop ((i lo)) (if (\u0026gt; i hi) (amb) (amb i (loop (+ i 1))))))) ; (amb 1 (amb 2 (amb 3 ... ))) (define (n-queens n) (call/cc (lambda (return) (let add-queen ([i 0] [result \u0026#39;()]) (when (\u0026lt; i n) ;最多摆几个皇后 (let ([new-queen (number-between 1 n)]) (if (safe? n (append (list new-queen) result)) ;新加入的皇后必须是有效的 (add-queen (+ i 1) (append (list new-queen) result)) (amb)) ) ) (return result) ) ) ) ) (bag-of (n-queens 8)) ;8个皇后的所有解 该版本比之前的Scheme版本的实现改进了很多，现在只需要描述一下我的问题的关系即可，程序会自动选择所有正确的值，无需关心计算机内部到底发生了什么。在面对很多逻辑问题时，我们可以很轻松地解决了。\n也许有人会问，如果采用命令式语言来处理的话，可能几个嵌套的循环也能达到相同的结果，如此大费周章的介绍这个叫amb的技术，到底有什么价值呢？ 那就来聊一聊。\n有什么意义？ 在谈论意义之前，容许我提一个问题\n 为什么SQL语言要设计成这样？与命令式语言如此的不同？\n 首先需要明确的一点是，计算机科学处理的是命令式（怎样做）的知识，而数学处理的是说明式（是什么）的知识。 事实上，人类不可能只面临其中一种问题，程序设计中一个重要的分支就是逻辑程序设计，有很多问题或者数据之间存在着关联关系，难以观测到结论，描述它们的关系很简单，但是直接告诉计算机如何去做却不那么容易，或许我们可以为若干此类问题编写命令式代码，但是不可能对所有这样的问题都编写代码，显然信息之间的关系是多种多样的，那么代码就需要相应的变化，往往修改这样的代码是很困难的， 甚至需要重新设计并编码。另一方面，如果程序设计可以处理说明式的知识，岂不是大大减轻了程序员的工作了呢？函数式语言的设计是基于lambda理论，围绕着数学函数值的计算组织起来的，依靠其强大的表现力，在处理逻辑问题上更加得心应手，可以化繁为简。\n说到这里，是不是觉得，保存在数据库中的数据之间存在着种种联系呢？SQL正是描述了这种关系，我们只需要告诉数据库我们需要什么数据（select）, 数据在什么位置（from）, 哪些是有意义的（where）就行了，并不需要告诉数据库该如何具体操作，数据库可以根据我们的描述（SQL）就能够准确的返回结果，这真是关于非确定性计算的一个极好的例子，此时我们总该明白为什么数据库叫做关系型数据库 了吧。我们不妨设想一下，如果不采用描述的方式来查询数据，程序员们该怎么做？还能够轻易的查找到需要的数据吗？\n刚才我提出的问题，想必此刻应该有答案了。\n","id":102,"section":"posts","summary":"讲故事并不是我擅长的事情，不过事情总有一个开始，诸位看官莫嫌我絮烦，只是希望可以讲述的更有条理一些。某日正读一本关于Erlang的书，书中出","tags":["scheme"],"title":"从“八皇后”到amb","uri":"https://lvsq.net/2020/05/n-queens/","year":"2020"},{"content":"作者是 Francesco Cesarini \u0026amp; Gabor Olah\n 任何编程语言在Erlang生态系统中的成功都可以分为三个紧密耦合的组件。它们是：1）Erlang编程语言的语义，并在其上实现其他语言2）用于构建可伸缩和弹性并发系统的OTP库和中间件，以及3）与语言语义紧密耦合的BEAM虚拟机和OTP。单独使用这些组件中的任何一个，您将获得亚军。但是，将这三个因素放在一起，您将获得可伸缩，灵活的软实时系统的无可争议的赢家。引用Joe Armstrong的话：“您可以复制Erlang库，但是如果它不能在BEAM上运行，则无法模拟语义”。这是由罗伯特·维尔丁（Robert Virding）的《第一条编程规则》强制执行的，该条规定：“任何另一种足够复杂的并发程序都使用另一种语言，包含非正式的，临时指定的，bug缠身的缓慢的Erlang一半实现。”\n在本文中，我们想探索BEAM VM内部。我们将在适用的情况下将它们与JVM进行比较和对比，强调您为什么要注意它们并加以注意。长期以来，此组件一直被视为黑匣子，并且在不了解原因或含义的情况下被视为理所当然。现在该改变这种情况了！\nBEAM的亮点 发明Erlang和BEAM VM是解决特定问题的正确工具。它们是由爱立信开发的，旨在帮助实现处理移动和固定网络的电信基础设施。该基础架构本质上是高度并发和可伸缩的。它必须显示软实时属性，并且永远不会失败。我们不希望在手机上与祖母进行环聊通话时掉线或Fortnite的在线游戏体验不会受到系统升级，高用户负载或软件，硬件和网络中断的影响。BEAM VM通过提供可在可预测的并发编程模型之上运行的微调功能进行了优化，以解决许多挑战。\n它的秘诀是轻量级进程，它们不共享内存，由调度程序管理，该调度程序可以跨多个内核管理数百万个进程。它使用基于每个进程运行的垃圾收集器，并对其进行了高度优化以减少对其他进程的影响。结果，垃圾收集器不会影响系统的整体软实时属性。BEAM也是唯一使用规模广泛且具有内置分发模型的VM，它具有内置的分发模型，该模型允许程序透明地在多台计算机上运行。\nJVM的亮点 Java虚拟机（JVM）是​​由Sun Microsystem开发的，旨在提供一个可在任何地方运行的“一次写入”代码的平台。他们创建了一种类似于C++的面向对象的语言，但是内存安全，因为其运行时错误检测会检查数组范围和指针取消引用。在Internet时代，JVM生态系统变得非常流行，使其成为企业服务器应用程序的实际标准。满足广泛用例的虚拟机和可满足企业发展需求的令人印象深刻的库集使广泛的适用性成为可能。\nJVM设计时考虑了效率。它的大多数概念是流行操作系统中功能的抽象，例如映射到操作系统线程的线程模型。JVM是高度可定制的，包括垃圾收集器（GC）和类加载器。一些最先进的GC实现提供高度可调整的功能，以适应基于共享内存的编程模型。JVM允许您在程序运行时更改代码。而且，JIT编译器允许将字节码编译为本机代码，目的是加快应用程序的各个部分。\nJava世界中的并发性主要与在并行线程中运行应用程序有关，以确保它们是快速的。由于并发原语的共享内存模型带来了挑战，因此使用并发原语进行编程是一项艰巨的任务。为了克服这些困难，人们尝试简化和统一并发编程模型，最成功的尝试是Akka框架。\n并发与并行 如果部分代码在多个内核，处理器或计算机上同时运行，则我们谈论并行代码执行，而并发编程是指独立处理到达系统的事件。可以在单线程硬件上模拟并发执行，而并行执行则不能。尽管这种区别似乎很古怪，但这种差异导致需要解决的问题非常不同。想想很多厨师在做一盘Carbonara意大利面。在并行方法中，将任务分配给可用厨师的数量，并且只要完成这些厨师完成其特定任务的速度，就可以完成单个部分。在一个并发的世界中，每位厨师将获得一部分，每位厨师将完成所有任务。您将并行性用于速度，并发性用于规模。\n并行执行试图将问题的最佳分解解决为彼此独立的部分。将水煮沸，煮意大利面，混合鸡蛋，炸瓜里阿塞火腿，将佩克立诺奶酪磨碎1。共享数据（或在我们的示例中为餐盘）由锁，互斥锁和各种其他技术处理，以确保正确性。另一种看待这种情况的方式是存在数据（或成分），并且我们希望利用尽可能多的并行CPU资源来尽快完成工作。\n另一方面，并​​发编程处理许多事件，这些事件在不同的时间到达系统，并尝试在合理的时间内处理所有事件。在多核或分布式体系结构上，某些执行是并行运行的，但这不是必需的。另一种看待它的方法是，同一位厨师按照始终相同的顺序算法，将水煮沸，煮意大利面，混合鸡蛋等。跨过程（或做饭）的变化是要处理的数据（或成分），这些数据（或成分）存在于多个实例中。\nJVM是为并行而构建的，而BEAM是为并发构建的。它们是两个本质上不同的问题，需要不同的解决方案。\nBEAM和并发 BEAM提供轻量级流程为正在运行的代码提供上下文。这些进程也称为actor，不共享内存，而是通过消息传递进行通信，将数据从一个进程复制到另一个进程。消息传递是虚拟机通过各个进程拥有的邮箱实现的功能。消息传递是一种非阻塞操作，这意味着将消息发送到另一个进程几乎是即时的，并且不会阻塞发送者的执行。发送的消息采用不可变数据的形式，从发送过程的堆栈复制到接收者的邮箱。无需在进程之间使用锁和互斥锁即可实现此目的，而在多个进程并行将消息发送到同一收件人的情况下，只需对邮箱进行锁定即可。\n不变的数据和消息传递使程序员能够编写彼此独立工作的流程，并专注于功能而不是内存的低级管理和任务调度。事实证明，这种简单的设计不仅适用于单个线程，而且适用于在同一VM中运行的本地计算机上的多个线程，并使用内置的分发，在整个网络上通过VM和计算机集群运行。如果消息在进程之间是不可变的，则可以不加锁地将它们发送到另一个线程（或计算机），从而在分布式多核体系结构上几乎线性地扩展。进程在本地VM上的寻址方式与VM群集中的寻址方式相同，无论接收进程的位置如何，消息发送都是透明的。\n进程不共享内存，因此您可以复制数据以恢复弹性并分发数据以实现规模扩展。这意味着在两个不同的机器上具有相同进程的两个实例，彼此之间共享状态更新。如果一台计算机发生故障，则另一台计算机具有数据副本，并且可以继续处理该请求，从而使系统具有容错能力。如果两台计算机都可运行，则两个进程都可以处理请求，从而为您提供可伸缩性。BEAM为所有这些无缝集成提供了高度优化的原语，而OTP（“标准库”）则提供了更高级别的结构以简化程序员的生活。\nAkka在复制更高级别的结构方面做得很好，但是由于缺少JVM提供的原语而在一定程度上受到了限制，从而使其可以高度优化并发性。尽管JVM的原语支持更广泛的用例，但由于它们没有用于通信的内置原语且通常基于共享内存模型，因此它们使对分布式系统的编程变得更加困难。例如，您在分布式系统中的何处放置共享内存？以及访问它的成本是多少？\n调度器 我们提到过，BEAM的最强功能之一就是能够将程序分解为小的，轻量级的过程。管理这些过程是调度程序的任务。与JVM将其线程映射到OS线程并让操作系统调度它们不同，BEAM带有自己的调度程序。\n默认情况下，调度程序为每个内核启动一个OS线程，并优化它们之间的工作负载。每个过程都包含要执行的代码和随时间变化的状态。调度程序会选择运行队列中准备运行的第一个进程，并为其赋予定量的reductions（译者注：2000个），其中每次reduction都大致等同于一条指令。一旦进程用尽了reductions，会被I/O阻塞，等待消息或代码完成，调度程序就会在运行队列中选择下一个进程并将其分派（此句翻译有问题：原文是Once the process has either run out of reductions, is blocked by I/O, is waiting for a message or completes executing its code, the scheduler picks the next process in the run queue and dispatches it. 如果您有更好的翻译请不吝指教）。这种调度技术称为抢先式。\n我们多次提到Akka框架，因为它的最大缺点是需要在调度处添加注解，因为调度不是在JVM级别进行的。通过解除程序员的控制，可以保留和保证软实时属性，从而减低了导致进程饿死的风险。\n进程围绕着调度程序线程，并最大程度地利用CPU。有许多方法可以调整调度程序，但是它很少见，仅在边缘和边界情况下才需要，因为默认选项涵盖了大多数使用模式。\n关于调度程序，经常出现一个敏感的话题：如何处理本机实现的函数（NIF）。NIF是用C编写的代码片段，被编译为库并在与BEAM相同的内存空间中运行以提高速度。NIF的问题在于它们不是抢占式的，并且会影响调度程序。在最新的BEAM版本中，添加了一项新功能，即脏调度程序，以更好地控制NIF。肮脏的调度程序是在不同线程中运行的单独的调度程序，以最大程度地减少NIF对系统造成的中断。脏这个词是指这些调度程序运行的代码的性质。\n垃圾收集器 当今，现代的高级编程语言大多使用垃圾回收器进行内存管理。BEAM语言也不例外。当您要编写高级并发代码时，信任虚拟机来处理资源和管理内存非常方便，因为这可以简化任务。归功于基于不可变状态的内存模型，垃圾收集器的基础实现非常简单有效。数据被复制而不是突变，并且进程不共享内存这一事实消除了任何进程的相互依赖关系，因此不需要管理它们。\nBEAM的另一个功能是，仅在需要时才在每个进程的基础上运行垃圾回收，而不会影响在运行队列中等待的其他进程。结果，Erlang中的垃圾收集不会“stop-the-world”。它可以防止处理延迟高峰，因为VM不会从整体上停止——仅特定进程停止，并且绝不会同时停止所有进程。实际上，这只是流程的一部分，并且被视为另一种reduction。垃圾收集器收集过程将过程暂停很短的时间间隔，通常是微秒。代价是，将有许多小的爆发（bursts），仅在进程需要更多内存时才触发。单个进程通常不会分配大量内存，并且通常是短暂的，通过在终止时立即释放所有分配的内存，进一步降低了影响。JVM的一个功能是具备切换垃圾收集器的能力，因此，通过使用商用GC，还可以在JVM中实现不间断的GC。\nLukas Larsson在一篇出色的博客文章中讨论了垃圾收集器的功能。有许多复杂的细节，但已对其进行了优化以有效地处理不可变数据，并为每个进程在堆栈和堆之间分配了数据。最好的方法是在短暂的过程中完成大部分工作。\n这个主题上经常出现的一个问题是BEAM使用多少内存。虚拟机在后台分配了大块内存，并使用自定义分配器来有效地存储数据并最大程度地减少系统调用的开销。这有两个明显的效果：1）在不需要空间之后，已用内存逐渐减少2）重新分配大量数据可能意味着将当前工作内存加倍。如果确实需要，可以通过调整分配器策略来减轻第一个影响。如果您可以看到不同类型的内存使用情况，则第二个易于监视和计划。（WombatOAM就是这样一种提供开箱即用的系统指标的监视工具。）\n热代码加载 热代码加载可能是BEAM引用最多的独特功能。热代码加载意味着可以通过更改系统中的可运行代码来更新应用程序逻辑，同时保留内部流程状态。这是通过替换已加载的BEAM文件并指示VM替换正在运行的进程中的代码引用来实现的。\n对于电信基础架构无需停机代码升级而言，这是一项至关重要的功能，被裁减的硬件可用于处理高峰。如今，在容器化时代，其他技术也可以实现产线的更新。从未使用过它的人会认为它是不重要的功能，但是在开发工作流程中仍然有用。开发人员可以通过替换部分代码来加快迭代速度，而不必重新启动系统来对其进行测试。即使该应用程序并非设计为可在生产环境中进行升级，也可以减少重新编译和重新部署所需的时间。\n何时不使用BEAM 正确的工具非常重要。您需要一个速度极快的系统，但不关心并发性吗？并行处理一些事件，并且必须快速处理它们？是否需要计算图形，人工智能或分析数据？沿C ++，Python或Java路线走。电信基础设施不需要快速运行，因此速度从来都不是优先事项。在动态类型的辅助下，它必须在运行时进行所有类型检查，这意味着编译器时间优化并不那么简单。因此，数字运算最好留给JVM，Go或其他编译成本地语言的语言使用。毫不奇怪，在JVM上运行的Erlang版本Erjang上的浮点运算比BEAM快5000％。但是我们看到BEAM大放异彩的地方是利用它的并发来安排数字运算，将分析外包给C，Julia，Python或Rust。您可以在BEAM外部做map，而在BEAM内部做reduce(译者注：map-reduce思想)。\n口头禅总是很快。人类感知刺激（事件）并在大脑中进行处理需要几百毫秒，这意味着对于许多应用而言，微秒或纳秒的响应时间并不是必需的。您也不会将BEAM用于微控制器，这太浪费资源了。但是对于具有更多处理能力的嵌入式系统（多核已成为常态），您需要并发性，而BEAM令人眼前一亮。上世纪90年代，我们实现了电话交换机，以处理运行在具有16MB内存的嵌入式板上的成千上万的用户。RaspberryPi都有多少内存了？还有，硬实时系统，您可能不希望BEAM管理您的安全气囊控制系统。你需要硬保证 仅仅是硬实时操作系统，没有垃圾收集或异常的语言。在诸如GRiSP之类的裸机上运行的Erlang VM的实现将为您提供类似的保证。\n结论 使用正确的工具完成工作。如果您正在编写一个软实时系统，而该系统必须能够立即扩展并且永远不会失败，并且无需重新发明轮子就可以做到，那么BEAM是您正在寻找的经过验证的技术。对于许多人来说，它就像一个黑匣子。不知道它的工作原理类似于驾驶法拉利，无法获得最佳性能或无法理解奇怪声音来自马达的哪个部分。这就是为什么您应该更多地了解BEAM，了解其内部结构并准备对其进行微调和修复的原因。对于在实际任务中使用Erlang和Elixir的人（译者注：in anger 的意思是to do or use something in a real situation），我们开设了一天的讲师指导课程，该课程通俗易懂并解释您所看到的很多内容，同时为您准备大规模处理大规模并发做好准备。在这里了解更多。我们也推荐Erik Stenman撰写的关于BEAM的书和Dmytro Lytovchenko的文章集——BEAM Wisdoms。\n","id":103,"section":"posts","summary":"作者是 Francesco Cesarini \u0026amp; Gabor Olah 任何编程语言在Erlang生态系统中的成功都可以分为三个紧密耦合的组件。它们是：1）Erlang编程语言的语义，并在其上实现","tags":["erlang"],"title":"[译]BEAM vs JVM","uri":"https://lvsq.net/2020/05/beam-vs-jvm/","year":"2020"},{"content":"实现 下面将使用Scheme语言来实现“无重复字符的最长子串”，即，对于字符串\u0026quot;abbabcx\u0026quot;,其最长无重复字符的子串为\u0026quot;abcx\u0026quot;，长度4，详细描述可访问https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n(let* ( [s \u0026#34;abbabcx\u0026#34;] [arr-index 0] [ans 0] [d -1] [vec (make-vector 128 -1)] [keep-last-position (lambda (c pos-in-s) (vector-set! vec c pos-in-s))] [scan (lambda (c pos-in-s) (let* ([previous-pos (vector-ref vec c)] [len 0]) (begin (when (and (\u0026gt;= previous-pos 0) (\u0026gt; previous-pos d)) (set! d previous-pos) ) (set! len (- pos-in-s d)) (keep-last-position c pos-in-s) (when (\u0026gt; len ans) (set! ans len)) ) ) )] ) ( string-for-each (lambda (e) (scan (char-\u0026gt;integer e) arr-index) (set! arr-index (+ arr-index 1))) s ) ans ) 实现的思路为：\n由于字符可以有ASCII码表示，故可以用一个长度为128的向量vec来保存每个字符在给定的字符串中出现的最后一次的位置。维护一个变量d来记录最近一次出现重复的字符的起始位置。 如果：\n 判断某字符是否重复：1.1 某字符第一次出现，执行第2步1.2 某字符非第一次出现，如果该字符上次出现的位置，在d之后，则将d设置为该字符上次出现的位置。由于之前的最大长度已经由ans保存，所以只需要计算剩下的子串的长度能不能大于ans，这就是为什么d记录最近一次出现重复的字符串的起始位置就好了 计算当前位置和d的长度len 保存其位置到vec 如果len大于ans，改变ans为len  这种实现只需遍历一遍就可以计算出结果，性能非常棒。当然暴力计算或者滑动窗口也可以实现该功能，只是需要多次遍历，性能比不上。\n概要分析 上文说到性能问题，拿点数据出来证明一下吧。\n将上面的代码稍微改造一下，作为一个definition，并保存在longest_substr.ss文件中，\n(define longest-substr (lambda (str) (let* ( [s str] [arr-index 0] [ans 0] [d -1] [vec (make-vector 128 -1)] [keep-last-position (lambda (c pos-in-s) (vector-set! vec c pos-in-s))] [scan (lambda (c pos-in-s) (let* ([previous-pos (vector-ref vec c)] [len 0]) (begin (when (and (\u0026gt;= previous-pos 0) (\u0026gt; previous-pos d)) (set! d previous-pos) ) (set! len (- pos-in-s d)) (keep-last-position c pos-in-s) (when (\u0026gt; len ans) (set! ans len)) ) ) )] ) ( string-for-each (lambda (e) (scan (char-\u0026gt;integer e) arr-index) (set! arr-index (+ arr-index 1))) s ) ans ) ) ) Chez Scheme提供了一个概要分析工具，非常好用，来试用一下： 生成的html可以非常直观的看到该函数的执行情况 字符串越长，执行次数越多，执行时间是多少呢？选一个上面例子中最长的字符串来看看：\n\u0026gt; (time (longest-substr \u0026#34;abcabcxsfsdfw232sdfssdfsdfsdfsf1234567890\u0026#34;)) (time (longest-substr \u0026#34;abcabcxsfsdfw232sdfssdfsdfsdfsf1234567890\u0026#34;)) no collections 0.000003672s elapsed cpu time 0.000002000s elapsed real time 1792 bytes allocated 12 \u0026gt; 消耗的CPU时间0.000003672s，可以说非常短了，且分配的内存仅仅1792个字节。超乎寻常的性能，我想应该有两个方面原因：\n 算法 Scheme 和 Chez Scheme  ","id":104,"section":"posts","summary":"实现 下面将使用Scheme语言来实现“无重复字符的最长子串”，即，对于字符串\u0026quot;abbabcx\u0026quot;,其最长无重复字符的子串为","tags":["scheme"],"title":"无重复字符的最长子串-Scheme实现","uri":"https://lvsq.net/2020/03/longest-substr/","year":"2020"},{"content":"为什么要用Go练习函数式编程？简而言之，正是由于缺少状态和可变数据，函数式编程使您的代码更易读，更易于测试且不太复杂。如果遇到错误，只要不违反函数式编程规则，就可以快速调试应用程序。当函数被隔离时，您不必处理影响输出的隐藏状态的更改。\n软件工程师兼作者Eric Elliot定义了以下函数编程。\n 函数式编程是通过组合纯函数，避免共享状态，可变数据和副作用来构建软件的过程。函数式编程是声明性的，而不是命令性的，应用程序状态通过纯函数流动。与面向对象的编程相反，后者通常将应用程序状态与对象中的方法共享并放置在对象中。\n 我将更进一步：函数式编程（如面向对象和过程式编程）代表着范式的转变。它在编写代码时采用了独特的思维方式，并引入了一套全新的规则。\n4个重要概念 要完全掌握函数式编程，必须首先了解以下相关概念。\n 纯函数和幂等 副作用 函数构成 共享状态和不变数据  让我们快速回顾一下。\n纯函数和幂等 如果给纯函数提供相同的输入，则它总是会返回相同的输出。此属性也称为幂等。幂等意味着函数应始终返回相同的输出，而与调用次数无关。\n副作用 纯函数不能有任何副作用。换句话说，您的函数无法与外部环境进行交互。\n例如，函数式编程将API调用视为副作用。为什么？因为API调用被认为是不受您直接控制的外部环境。一个API可能有几个不一致的地方，例如超时或失败，或者甚至可能返回意外的值。它不适合纯函数的定义，因为每次调用API时都需要一致的结果。\n其他常见的副作用包括：\n 数据变化 DOM操作 请求有冲突的数据，例如当前时间time.Now()  函数构成 函数构成的基本思想很简单：将两个纯函数组合在一起以创建一个新函数。这意味着为相同输入产生相同输出的概念在这里仍然适用。因此，从简单的纯函数开始创建更高级的函数很重要。\n共享状态和不变数据 函数式编程的目的是创建不保持状态的函数。共享状态尤其会在纯函数中引入副作用或可变性问题，使它们变得不纯粹。\n但是，并非所有状态都不好。有时，必须有一个状态才能解决特定的软件问题。函数式编程的目的是使状态可见和显式，以消除任何副作用。程序使用不可变数据结构从纯函数中派生新数据。这样，就不需要可能引起副作用的可变数据。\n 现在我们已经涵盖了基础，让我们定义一些在Go中编写功能代码时要遵循的规则。\n功能编程规则 如前所述，函数式编程是一种范例。因此，很难为这种编程风格定义确切的规则。也不一定总是遵循这些规则。有时，您确实需要依赖拥有状态的功能。\n但是，为了尽可能严格地遵循函数式编程范例，我建议坚持以下准则。\n 没有可变数据以避免副作用 无状态（或者隐式状态，例如循环计数器） 给变量赋值后请勿修改 避免副作用，例如API调用  我们在函数式编程中经常遇到的一个好的“副作用”是强大的模块化。函数式编程不是自上而下地进行软件工程，而是鼓励自下而上的编程风格。首先定义模块，把将来可能使用的同类纯函数组合起来。接下来，开始编写那些小的，无状态的独立函数，以创建您的第一个模块。\n实质上我们是在创建黑匣子。稍后，我们将按照自下而上的方式将各个块捆绑在一起。这使您可以建立强大的测试基础，尤其是可以验证纯函数正确性的单元测试。\n一旦您可以信任您的模块，就可以将模块捆绑在一起了。开发过程中的这一步还涉及编写集成测试，以确保两个组件的正确集成。\n5个示例 为了更全面地描述Go函数编程的工作原理，让我们探索五个基本示例。\n 更新字符串  这是纯函数的最简单示例。通常，当您要更新字符串时，请执行以下操作。\nname：= \u0026#34;first name\u0026#34; name：= name + \u0026#34;last name\u0026#34; 上面的代码片段不符合函数式编程的规则，因为不能在函数内修改变量。因此，我们应该重写代码段，以便每个值都具有自己的变量。\n下面的代码段中的代码更具可读性。\nfirstname := \u0026#34;first\u0026#34; lastname := \u0026#34;last\u0026#34; fullname := firstname + \u0026#34; \u0026#34; + lastname 在查看非函数式代码段时，我们必须浏览程序以确定最新状态，才可以找到name变量的结果值。这需要更多的精力和时间来了解该功能的作用。\n避免更新数组  如前所述，函数式编程的目的是使用不变数据通过纯函数得出新的不变数据状态。我们可以在每次需要更新数组时创建一个新数组来实现\n在非函数式编程中，更新数组如下：\nnames := [3]string{\u0026#34;Tom\u0026#34;, \u0026#34;Ben\u0026#34;} // Add Lucas to the array \tnames[2] = \u0026#34;Lucas\u0026#34; 让我们根据功能编程范例进行尝试。\nnames := []string{\u0026#34;Tom\u0026#34;, \u0026#34;Ben\u0026#34;} allNames := append(names, \u0026#34;Lucas\u0026#34;) 避免更新map  这是函数编程的极端示例。想象一下，我们有一个带有字符串类型的键和整数类型的值的map。该map包含我们仍然留在家中的水果数量。但是，我们刚购买了苹果，并希望将其添加到列表中。\nfruits := map[string]int{\u0026#34;bananas\u0026#34;: 11} // Buy five apples \tfruits[\u0026#34;apples\u0026#34;] = 5 我们可以在功能编程范例下完成相同的功能。\nfruits := map[string]int{\u0026#34;bananas\u0026#34;: 11} newFruits := map[string]int{\u0026#34;apples\u0026#34;: 5} allFruits := make(map[string]int, len(fruits) + len(newFruits)) for k, v := range fruits { allFruits[k] = v } for k, v := range newFruits { allFruits[k] = v } 由于我们不想修改原始map，因此代码会遍历两个map，并将值添加到新map。这样，数据保持不变。\n正如您可能通过代码的长度可以看出的那样，此代码段的性能比对map进行简单的可变更新要差得多，因为我们要遍历两个map。这是您为代码性能交换更好的代码质量的时间。\n高阶函数和柯里化  大多数程序员在他们的代码中通常不会使用高阶函数，但是在函数式编程中柯里化很方便。\n假设我们有一个简单的函数，将两个整数相加。尽管这已经是一个纯粹的功能，但我们希望详细说明该示例，以展示如何通过curring创建更高级的功能。\n在这种情况下，我们只能接受一个参数。接下来，该函数返回另一个函数作为闭包。因为该函数返回一个闭包，所以它将记住外部范围，该范围包含初始输入参数。\nfunc add （x int）func （y int）int { return func（y int）int { return x + y } } 现在，让我们尝试currying并创建更多高级纯函数。\nfunc main() { // Create more variations \tadd10 := add(10) add20 := add(20) // Currying \tfmt.Println(add10(1)) // 11 \tfmt.Println(add20(1)) // 21 } 这种方法在函数式编程中很常见，尽管您通常不会在范式之外看到它。\n递归  递归是一种通常用于规避循环使用的软件模式。因为循环始终保持内部状态以明确循环在哪一轮，所以我们不能在函数式编程范式下使用循环。\n例如，下面的代码片段尝试计算数字的阶乘。阶乘是一个整数与其下所有整数的乘积。因此，阶乘4等于24（= 4 * 3 * 2 * 1）。\n通常，您将为此使用循环。\nfunc factorial(fac int) int { result := 1 for ; fac \u0026gt; 0; fac-- { result *= fac } return result } 为了在函数式编程范例中完成此任务，我们需要使用递归。换句话说，我们将一遍又一遍地调用相同的函数，直到达到阶乘的最低整数为止。\nfunc calculateFactorial(fac int) int { if fac == 0 { return 1 } return fac * calculateFactorial(fac - 1) } 结论 让我们总结一下我们从函数式编程中学到的知识：\n 尽管Golang支持函数式编程，但它并非为此目的而设计的，如缺少Map，Filter和Reduce函数。 函数式编程提高了代码的可读性，因为函数是纯粹的，因此易于理解 纯函数更易于测试，因为没有内部状态会改变输出  原文在此: https://blog.logrocket.com/functional-programming-in-go/\n","id":105,"section":"posts","summary":"为什么要用Go练习函数式编程？简而言之，正是由于缺少状态和可变数据，函数式编程使您的代码更易读，更易于测试且不太复杂。如果遇到错误，只要不违","tags":["functional"],"title":"使用Golang进行函数式编程","uri":"https://lvsq.net/2020/03/fp-in-go/","year":"2020"},{"content":"闲来无事，用Scheme实现一个FIFO队列，数据从末端插入，从前端删除或者查询。\n队列可以看成是由下面一组操作定义的结构：\n 构造函数  (make-queue)返回一个空队列\n 选择函数  (empty-queue? \u0026lt;queue\u0026gt; )检查队列是否为空(front-queue \u0026lt;queue\u0026gt; )返回最早进入队列的数据，其不会修改队列(length-queue \u0026lt;queue\u0026gt; )返回队列长度\n 改变函数  (insert-queue! \u0026lt;queue\u0026gt; \u0026lt;item\u0026gt; )将数据插入末端(delete-queue! \u0026lt;queue\u0026gt; )删除列头的数据\n 打印函数  (print-queue \u0026lt;queue\u0026gt;)\n(module FIFO-QUEUE (make-queue empty-queue? front-queue insert-queue! delete-queue! length-queue print-queue) (define front-ptr (lambda (q) (caar q))) (define set-front-ptr! (lambda (q item) (set-car! (car q) item))) (define rear-ptr (lambda (q) (cdar q))) (define set-rear-ptr! (lambda (q item) (set-cdr! (car q) item))) (define make-queue (lambda () (cons (cons \u0026#39;() \u0026#39;()) 0))) (define empty-queue? (lambda (q) (null? (front-ptr q)))) (define front-queue (lambda (q) (if (empty-queue? q) (error \u0026#34;FRONT called with an empty queue\u0026#34; q) (car (front-ptr q))))) (define (insert-queue! q item) (let ((new-pair (cons item \u0026#39;()))) (if (empty-queue? q) (begin (set-front-ptr! q new-pair) (set-rear-ptr! q new-pair) (set-cdr! q (+ 1 (cdr q))) q) (begin (set-cdr! (rear-ptr q) new-pair) (set-rear-ptr! q new-pair) (set-cdr! q ( + 1 (cdr q))) q) ) ) ) (define delete-queue! (lambda (q) (if (empty-queue? q) (error \u0026#34;DELETE! called with an empty queue\u0026#34; q) (begin (set-front-ptr! q (cdr (front-ptr q))) (set-cdr! q (- (cdr q) 1)) q) ) ) ) (define length-queue (lambda (q) (cdr q))) (define print-queue (lambda (q) (if (empty-queue? q) \u0026#39;() (front-ptr q)) )) ) 前4个过程是用于内部的帮助函数，队列维护两个指针，一个指向列头（front-ptr）,一个指向列尾（rear-ptr），这样可以弥补原生的set-car!和set-cdr!的不足。\n\u0026gt; (load \u0026#34;/path/to/FIFO-QUEUE.scm\u0026#34;) ;;加载FIFO-QUEUE模块 \u0026gt; (import FIFO-QUEUE) \u0026gt; (define q (make-queue)) \u0026gt; (insert-queue! q 1) ;; (((1) 1) . 1), 最后一个数字1表示队列长度, 在队列有删除或者插入时，及时修改该值，为了在取队列长度时减小开销，否则要遍历一次才行 \u0026gt; (insert-queue! q 2) ;; (((1 2) 2) . 2) \u0026gt; (insert-queue! q 3) ;; (((1 2 3) 3) . 3) \u0026gt; (insert-queue! q 4) ;; (((1 2 3 4) 4) . 4) \u0026gt; (delete-queue! q) ;; (((2 3 4) 4) . 3) \u0026gt; (delete-queue! q) ;; (((3 4) 4) . 2) \u0026gt; (front-queue q) ;; 3 \u0026gt; (length-queue q) ;; 2 ","id":106,"section":"posts","summary":"闲来无事，用Scheme实现一个FIFO队列，数据从末端插入，从前端删除或者查询。 队列可以看成是由下面一组操作定义的结构： 构造函数 (make","tags":["scheme"],"title":"Scheme实现一个FIFO队列","uri":"https://lvsq.net/2020/03/fifo-queue/","year":"2020"},{"content":"本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可能使用Scheme标准机制。\nHash Tables 略过。应使用标准hash table.\nExtend-Syntax Macros 本节介绍了extend-syntax，它是一种功能强大但易于使用的基于模式匹配的语法扩展工具。 使用extend-syntax编写的语法转换与使用define-syntax和syntax-case编写的语法转换相似，不同之处在于extend-syntax产生的转换不会自动遵循词法作用域。\n通常不可能将使用syntax-case编写的语法抽象与使用extend-syntax编写的语法抽象无缝地混合在一起。 通常尽可能只使用其中一种。 仅在迁移到syntax-case时提供了对syntax-case扩展器中extend-syntax的支持。\n (extend-syntax (name key \u0026hellip;) (pat fender template) \u0026hellip;)\n 标识符name 是要定义的句法扩展名或语法关键字。 当系统扩展器处理car为name 的任何list表达式时，将在该表达式上调用extend-syntax生成的语法转换过程。 其余的标识符key \u0026hellip; 是在扩展过程中要在输入表达式中识别的其他关键字（例如cond中的else或case）。\nkey列表之后的每个子句都包含一个模式pat ，一个可选的fender 和一个template 。 可选的fender 经常被省略。pat 指定了语法，用于匹配子句。模式中不是关键字（模式变量）的标识符绑定到输入表达式的相应部分。fender 如果存在，则是Scheme表达式，它指定输入表达式（通过模式变量访问）上的附加约束，必须选择这些约束才能选择子句。template 通常根据模式变量来指定输出采用什么形式。\n在扩展过程中，转换过程extend-syntax会尝试以给定的子句的顺序将输入表达式与每个模式进行匹配。如果输入表达式匹配了某个模式，则将模式变量绑定到输入表达式的相应部分，并对子句的fender （如果有）进行求值。如果fender 返回一个真值，则执行给定的扩展。 如果输入与模式不匹配，或者fender 返回错误值，则转换过程将尝试下一个子句。如果无法选择任何子句，则会引发条件类型**＆assertion**的异常。\n在模式内，省略号（\u0026hellip;）可用于指定零个或多个出现的前面的模式片段或原型。类似地，可以在输出中使用省略号来指定零个或多个扩展原型的结构。在这种情况下，扩展原型必须包含输入模式原型的一部分。\n第一个例子，定义了rec, 使用单个关键字，一个子句，且没有fender和省略号\n(extend-syntax (rec) [(rec id val) (let ([id #f]) (set! id val) id)]) 第二个例子，定义了when，展示了如何使用省略号\n(extend-syntax (when) [(when test exp1 exp2 ...) (if test (begin exp1 exp2 ...) #f)]) 下一个示例显示let的定义。 let的定义显示了多个省略号的使用，其中一个用于标识符/值序对，另一个用于body中的表达式。它还表明原型不必是单个标识符，并且在template中可以将原型的各个部分彼此分开。\n(extend-syntax (let) [(let ([x e] ...) b1 b2 ...) ((lambda (x ...) b1 b2 ...) e ...)]) 下一个示例显示let*，其语法与let相同，但是根据let以两个子句（一个用于基本情况，一个用于递归步骤）递归定义，因为它必须产生一个嵌套结构。\n(extend-syntax (let*) [(let* () b1 b2 ...) (let () b1 b2 ...)] [(let* ([x e] more ...) b1 b2 ...) (let ([x e]) (let* (more ...) b1 b2 ...))]) 定义式and需要3个子句。第一个子句对于识别**(and)**是必要的，后两个以递归方式定义所有其他**and**形式。\n(extend-syntax (and) [(and) #t] [(and x) x] [(and x y ...) (if x (and y ...) #f)]) cond的定义需要四个子句。 与let*一样，必须对cond进行递归描述，部分原因是它会产生嵌套的if表达式，部分原因是一个省略号原型不足以描述所有可能的cond子句。 cond的定义还要求除cond之外，我们还指定else作为关键字。 这是定义：\n(extend-syntax (cond else) [(cond) #f] [(cond (else e1 e2 ...)) (begin e1 e2 ...)] [(cond (test) more ...) (or test (cond more ...))] [(cond (test e1 e2 ...) more ...) (if test (begin e1 e2 ...) (cond more ...))]) 为了使let的语法绝对正确，我们实际上必须要求输入中的绑定标识符是符号。 如果我们输入类似**（let（[3 x]）x）**的内容，则不会从**let**中得到错误，因为它不会检查验证标识符位置中的对象是否为符号。 相反，lambda可能会抱怨，或者可能是扩展完成很久之后的求值程序。 这是*fenders* 起作用的地方。\n(extend-syntax (let) [(let ([x e] ...) b1 b2 ...) (andmap symbol? \u0026#39;(x ...)) ((lambda (x ...) b1 b2 ...) e ...)]) '（x \u0026hellip;）上的symbol?的andmap确保每个绑定标识符都是一个符号。 fender 仅仅是Scheme表达式。 在该表达式中，首先使用与子句的template 部分相同的规则来扩展引用的对象。 在这种情况下，将**'（x \u0026hellip;）**扩展到标识符/值对中的标识符列表。\nextend-syntax通常可以处理您的一切需求，但是某些语法扩展定义要求能够包含对任意Scheme表达式求值的结果。 该功能由with提供。\n (with ((pat expr) \u0026hellip;) template)\n with仅在extend-syntax内部的template 内有效。 with模式与extend-syntax模式相同，with表达式与extend-syntax的fenders 相同，with模板与extend-syntax模板相同。\nwith可用于引入新的模式标识符，该标识符绑定到extend-syntax模板中的任意Scheme表达式所生成的表达式。 也就是说，with允许从extend-syntax的声明式样式转为full Scheme的过程式样式。\nwith的一种常见用法是在模板中引入临时标识符或临时标识符列表。 如果在extend-syntax框架内执行，with也可用于执行可能笨拙或效率低下的复杂转换。\n例如，or需要使用临时标识符。 我们可以如下定义or：\n(extend-syntax (or) [(or) #f] [(or x) x] [(or x y ...) (let ([temp x]) (if temp temp (or y ...)))]) 这会一直有效，直到将or表达式放置在temp发生的范围内为止，在这种情况下，可能会发生奇怪的事情，因为extend-syntax不尊重词法作用域。 （这是define-syntax优于extend-syntax的原因之一。）\n(let ([temp #t]) (or #f temp)) ⇒ #f  如果将标识符temp换个名字，则一切正常。就可以理解\u0026quot;extend-syntax不尊重词法作用域\u0026quot;这句话了。 实际上，上述的(let \u0026hellip;)表达式，展开之后就变成了：\n (let ([temp #t]) (let ([temp #f]) (if temp temp (or temp)) ) ) 一种解决方案是，使用gensym和with来创建临时标识符，如下：\n(extend-syntax (or) [(or) #f] [(or x) x] [(or x y ...) (with ([temp (gensym)]) (let ([temp x]) (if temp temp (or y ...))))]) 而且，with可以以extend-syntax无法直接使用的方式来组合输入模式的元素，例如以下folding-plus示例:\n(extend-syntax (folding-plus) [(folding-plus x y) (and (number? \u0026#39;x) (number? \u0026#39;y)) (with ([val (+ \u0026#39;x \u0026#39;y)]) val)] [(folding-plus x y) (+ x y)]) 如果x和y均为数字常数，则folding-plus折叠为（+ x y）的值。 否则，folding-plus转换为（+ x y）以供以后评估。 fender在扩展时检查操作数是否为数字，并使用with进行求值。 与fender一样，扩展仅在带引号的表达式内执行，因为quote将数据与Scheme表达式的其余部分区分开。\n下面的示例利用with允许我们将模式绑定到表达式这一事实，将模式变量列表绑定到临时符号列表。 此临时列表帮助我们实现sigma语法扩展。 sigma与lambda相似，除了它在标识符列表中分配标识符而不是创建新绑定之外。 它可用于并行执行一系列分配。\n(extend-syntax (sigma) [(sigma (x ...) e1 e2 ...) (with ([(t ...) (map (lambda (x) (gensym)) \u0026#39;(x ...))]) (lambda (t ...) (set! x t) ... e1 e2 ...))]) (let ([x \u0026#39;a] [y \u0026#39;b]) ((sigma (x y) (list x y)) y x)) ⇒ (b a) 结构体 本节介绍一种机制，类似于第7.15节的record定义机制，该机制允许使用固定的命名字段集创建数据结构。 与record类型不同，结构体类型不是唯一类型，而是实现为向量。 具体而言，将结构体实现为向量，其长度比字段数大一倍，并且其第一个元素包含该结构体的符号名称。\n将结构体表示为向量可以在某种程度上简化结构体的读取和打印以及结构体定义工具的扩展。但是，它确实有一些缺点。 一个是在不适当的情况下，结构体可能会被错误地视为普通向量。当在程序中处理结构体和向量时，在检查更通用的向量类型之前，必须注意先寻找更具体的结构体类型，例如在一系列cond子句中。一个类似的缺点是，结构体实例容易被有意或无意地“伪造”。 也不可能控制如何打印和读取结构体。\n通过define-structure创建结构体。 每个结构体定义式都定义一个构造过程，一个类型谓词，每个字段的访问过程以及每个字段的分配过程。define-structure允许程序员控制哪些字段是构造函数过程的参数，以及哪些字段由构造函数过程显式初始化。define-structure非常简单，但对于大多数应用程序来说足够强大，如果还不足以应付应用程序的需求还可以很容易的扩展以满足之。 本节末尾给出的define-structure定义可以作为更复杂变体的起点。\n (define-structure (name id1 \u0026hellip;) ((id2 expr) \u0026hellip;))\n define-structure形式可以出现在任意位置。\ndefine-structure定义一个新的数据结构name ，并创建一组用于构造和操作该结构实例的过程。 标识符id1 \u0026hellip; 和id2 \u0026hellip; 命名数据结构的字段。\n下面的过程都有define-structure定义：\n 名为**make-**name 的构造过程 名为name? 的类型谓词 对于每一个字段id1 \u0026hellip; 和id2 \u0026hellip; ，都有名为name-field 的访问过程 对于每一个字段id1 \u0026hellip; 和id2 \u0026hellip; ，都有名为**set-**name-field! 的分配过程  标识符id1 \u0026hellip; 命名的字段由构造函数的参数初始化。 由标识符id2 \u0026hellip; 命名的字段被显式初始化为表达式expr \u0026hellip; 的值。每个表达式都在标识符id1 \u0026hellip; （绑定到相应的字段值）的范围内进行求值，并且在标识符id2 \u0026hellip; （绑定到相应的字段值）的范围内出现（类似let*） 。\n为了清晰起见，构造函数的行为就像定义为：\n(define make-name (lambda (id1 ...) (let* ([id2 expr ] ...) body ))) 其中body 根据标识符id1 \u0026hellip; 和id2 \u0026hellip; 的值构建结构体。\n如果不需要除构造函数过程的参数初始化的字段以外的其他字段，则可以省略第二个子表达式*( (id2 expr) \u0026hellip;)* 。\n以下简单示例演示了如何在Scheme中定义pair（如果它们不存在的话）。 这两个字段都由构造函数过程的参数初始化。\n(define-structure (pare car cdr)) (define p (make-pare ’a ’b)) (pare? p) ⇒ #t (pair? p) ⇒ #f (pare? ’(a . b)) ⇒ #f (pare-car p) ⇒ a (pare-cdr p) ⇒ b (set-pare-cdr! p (make-pare \u0026#39;b \u0026#39;c)) (pare-car (pare-cdr p)) ⇒ b (pare-cdr (pare-cdr p)) ⇒ c 以下示例定义了一个方便的字符串数据结构，称为strext-string ，该结构会根据需要增长。本例子中，会显式地初始化一个字段的值，该字段在构造函数中定义。\n(define-structure (stretch-string length fill) ([string (make-string length fill)])) (define stretch-string-ref (lambda (s i) (let ([n (stretch-string-length s)]) (when (\u0026gt;= i n) (stretch-stretch-string! s (+ i 1) n)) (string-ref (stretch-string-string s) i)))) (define stretch-string-set! (lambda (s i c) (let ([n (stretch-string-length s)]) (when (\u0026gt;= i n) (stretch-stretch-string! s (+ i 1) n)) (string-set! (stretch-string-string s) i c)))) (define stretch-string-fill! (lambda (s c) (string-fill! (stretch-string-string s) c) (set-stretch-string-fill! s c))) (define stretch-stretch-string! (lambda (s i n) (set-stretch-string-length! s i) (let ([str (stretch-string-string s)] [fill (stretch-string-fill s)]) (let ([xtra (make-string (- i n) fill)]) (set-stretch-string-string! s (string-append str xtra)))))) 通常，大多数自动定义的过程都用于定义更特殊的过程， 在这个例子中，说的就是stretch-string-ref ** 和stretch-string-set!。而stretch-string-length** 和 **stretch-string-string**是惟一直接使用的自动生成的过程。\n(define ss (make-stretch-string 2 #\\X)) (stretch-string-string ss) ⇒ \u0026#34;XX\u0026#34; (stretch-string-ref ss 3) ⇒ #\\X (stretch-string-length ss) ⇒ 4 (stretch-string-string ss) ⇒ \u0026#34;XXXX\u0026#34; (stretch-string-fill! ss #\\@) (stretch-string-string ss) ⇒ \u0026#34;@@@@\u0026#34; (stretch-string-ref ss 5) ⇒ #\\@ (stretch-string-string ss) ⇒ \u0026#34;@@@@@@\u0026#34; (stretch-string-set! ss 7 #\\=) (stretch-string-length ss) ⇒ 8 (stretch-string-string ss) ⇒ \u0026#34;@@@@@@@=\u0026#34; 《The Scheme Programming Language》（第4版）的8.4节定义了define-structure的简化变体，作为使用syntax-case的示例。 下面给出的定义实现了完整版本。\n(define-syntax define-structure (lambda (x) (define gen-id (lambda (template-id . args) (datum-\u0026gt;syntax template-id (string-\u0026gt;symbol (apply string-append (map (lambda (x) (if (string? x) x (symbol-\u0026gt;string (syntax-\u0026gt;datum x)))) args)))))) (syntax-case x () ((_ (name field1 ...)) (andmap identifier? #\u0026#39;(name field1 ...)) #\u0026#39;(define-structure (name field1 ...) ())) ((_ (name field1 ...) ((field2 init) ...)) (andmap identifier? #\u0026#39;(name field1 ... field2 ...)) (with-syntax ((constructor (gen-id #\u0026#39;name \u0026#34;make-\u0026#34; #\u0026#39;name)) (predicate (gen-id #\u0026#39;name #\u0026#39;name \u0026#34;?\u0026#34;)) ((access ...) (map (lambda (x) (gen-id x #\u0026#39;name \u0026#34;-\u0026#34; x)) #\u0026#39;(field1 ... field2 ...))) ((assign ...) (map (lambda (x) (gen-id x \u0026#34;set-\u0026#34; #\u0026#39;name \u0026#34;-\u0026#34; x \u0026#34;!\u0026#34;)) #\u0026#39;(field1 ... field2 ...))) (structure-length (+ (length #\u0026#39;(field1 ... field2 ...)) 1)) ((index ...) (let f ([i 1] [ids #\u0026#39;(field1 ... field2 ...)]) (if (null? ids) \u0026#39;() (cons i (f (+ i 1) (cdr ids))))))) #\u0026#39;(begin (define constructor (lambda (field1 ...) (let* ([field2 init] ...) (vector \u0026#39;name field1 ... field2 ...)))) (define predicate (lambda (x) (and (vector? x) (#3%fx= (vector-length x) structure-length) (eq? (vector-ref x 0) \u0026#39;name)))) (define access (lambda (x) (vector-ref x index))) ... (define assign (lambda (x update) (vector-set! x index update))) ...)))))) ","id":107,"section":"posts","summary":"本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可","tags":["scheme"],"title":"兼容性（Compatibility Features in Chez Scheme）","uri":"https://lvsq.net/2020/02/compatibility/","year":"2020"},{"content":"下面介绍Chez Scheme线程系统过程和语法形式。 除了锁，锁增量和锁减量之外，线程系统的功能在非基于Windows的系统上在Posix线程系统（pthreads）之上实现，并在基于Windows的系统上直接使用Windows API。 有关线程创建和交互的基本详细信息，请查阅系统上的相应文档。\n大多数原生的Scheme过程都是线程安全 的，这意味着可以从多个线程中同时调用它们。 这包括诸如cons和make-string之类的分配操作，诸如car和vector-ref之类的访问器，诸如**+**和**sqrt**之类的数字运算符以及诸如**append**和**map**之类的非破坏性的高级原生操作。\n简单的变动运算符（例如set-car！，vector-set！和record字段变动器）是线程安全的。 同样，对局部变量的分配，包括（未导出的）库和顶级程序变量的分配也是线程安全的。\n大多数I/O操作应被视为具有破坏性，因为它们可能会修改端口的内部结构。\n使用没有进行合适的同步策略的非线程安全的运算符可能会破坏它们所操作的对象。 这种损坏可能导致错误的行为，内存故障，甚至导致系统中止的不可恢复的错误。\n线程创建  (fork-thread thunk)\n thunk 必须是一个接受0个参数的过程。\nfork-thread在一个新线程中调用thunk ，并返回一个线程对象。\n除了打印它外，fork-thread返回的线程对象无法执行任何操作。\n除了使用fork-thread以外，可通过外部代码来创建的线程必须在触及任何Scheme数据或调用任何Scheme过程之前调用Sactivate_thread\n (thread? obj)\n 返回：如果obj 是一个线程对象，返回#t,否则返回#f\n (get-thread-id)\n 返回：当前线程的id\n线程id是由线程分配的线程号，并且与get-process-id返回的进程id没有关系，进程id在所有线程中都是相同的。\n互斥锁  (make-mutex)\n 返回：一个新的互斥锁对象\n (mutex? obj)\n 返回：如果obj 是互斥锁，返回#t\n (mutex-acquire mutex) | (mutex-acquire mutex block?)\n mutex 必须是一个互斥锁。\nmutex-acquire获取由mutex 标识的互斥锁。可选的bool参数block？ 默认为#t，指定线程是否应阻塞等待互斥锁。block？ 如果省略或为true，则线程将阻塞，直到获取了互斥锁为止，并返回未指定的值。\n如果block？ 为false并且互斥锁当前已属于其他线程，当前线程并不会阻塞，而是，mutex-acquire立即返回值**#f**，以指示互斥锁不可用。 如果*block？* 为false并且成功获取了互斥锁，**mutex-acquire**返回#t。\n互斥锁在Posix线程术语中是递归的，这意味着调用线程可以使用互斥锁获取（重新）获取它已经拥有的互斥锁（注：锁是可以重入的）。 在这种情况下，释放互斥锁需要执行相等数量的mutex-release。\n (mutex-release mutex)\n mutex 必须是一个互斥锁。\nmutex-release释放由mutex 标识的互斥锁。 如果mutex 不属于调用线程（即释放别人的互斥锁），则会导致无法预料的行为。\n (with-mutex mutex body1 body2 \u0026hellip;)\n with-mutex计算表达式mutex ，其必须可以计算为一个互斥锁，获取锁，并计算body1 body2 \u0026hellip; ,然后释放锁。无论body是正常返回还是通过控制操作（即可能由于错误而抛到continuation）释放互斥量，这都会导致with-mutex形式的非本地退出。如果控制随后通过continuation调用返回到body，则将重新获取互斥锁。\n与直接使用mutex-acquire和mutex-release相比，使用with-mutex通常更方便，更安全。\n条件  (make-condition)\n 返回：一个新的条件对象\n (thread-condition? obj)\n 返回：如果obj 是条件对象，返回#t\n (condition-wait cond mutex) | (condition-wait cond mutex timeout)\n 返回：如果调用线程被条件唤醒返回#t，如果调用线程超时等待返回#f\ncond 必须是条件对象，并且mutex 必须是互斥锁。 可选参数timeout 是类型为time-duration或time-utc或**#f**的时间记录，表示没有超时。 默认为**#f**。\ncondition-wait等待由cond 标识的条件，且等待指定的timeout时长。在调用condition-wait时，调用线程必须已获取互斥锁mutex 。由于调用condition-wait的副作用而释放了mutex 。当稍后通过下述的过程之一从条件变量释放线程或超时到期时，将重新获取mutex ，并返回condition-wait。\n (condition-signal cond)\n cond 必须是一个条件对象。\ncondition-signal释放所有等待cond 标识的条件对象的线程的其中一个。\n (condition-broadcast cond)\n cond 必须是一个条件对象。\ncondition-broadcast释放所有等待cond 标识的条件对象的线程\n锁 锁比互斥锁更原生，但是更加灵活和有效。\n只要锁在进程共享的内存中分配，它们还可以独立于线程系统使用（包括在Chez Scheme的非线程版本中）以在分离的Scheme进程中执行同步操作。锁只是一个字长的整数，即iptr或uptr外部类型，其中包含目标计算机的本机字节序，可能是使用define-ftype定义的大结构的一部分。必须在驻留于Scheme堆外部的内存中显式分配它，并在适当时显式释放。当仅涉及线程时（即，当不涉及多个进程时），可以通过foreign-alloc分配内存。 当涉及多个进程时，应在进程共享的某个区域中分配该锁。\n使用ftype-init-lock! 初始化后，进程或线程可以尝试通过**ftype-lock!或ftype-spin-lock!锁定lock 。一旦锁已被锁定并且在解锁之前，即使通过最近锁定它的进程或线程，再一次尝试锁定该锁也会失败。 任何进程或线程可以使用ftype-unlock!**来解锁lock，而不仅仅是通过最近锁定锁的进程或线程来解锁。\n锁机制提供的结构很少，并且分配和使用中的错误可能导致内存错误，死锁和其他问题。 因此，通常建议仅将锁用作更高级别抽象的一部分，以确保按规范方式使用锁。\n(define lock (make-ftype-pointer uptr (foreign-alloc (ftype-sizeof uptr)))) (ftype-init-lock! uptr () lock) (ftype-lock! uptr () lock) ⇒ #t (ftype-lock! uptr () lock) ⇒ #f (ftype-unlock! uptr () lock) (ftype-spin-lock! uptr () lock) (ftype-lock! uptr () lock) ⇒ #f (ftype-unlock! uptr () lock)  (ftype-init-lock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-init-lock! ftype-name (a \u0026hellip;) fptr-expr index)\n  (ftype-lock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-lock! ftype-name (a \u0026hellip;) fptr-expr index)\n  (ftype-spin-lock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-spin-lock! ftype-name (a \u0026hellip;) fptr-expr index)\n  (ftype-unlock! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-unlock! ftype-name (a \u0026hellip;) fptr-expr index)\n 它们每个的语法都类似于ftype-set!，尽管带有隐式的val-expr 。 特别是，对fptr-expr 和访问器a \u0026hellip; 的限制和处理是相似的，但有一个重要的限制：最后一个访问器所指定的字段（该格式在其上进行操作）必须是一个字长的整数，即 ，iptr，uptr或具有本地字节序的等效项。\n**ftype-init-lock!**应该在使用任何其他运算符之前用于初始化锁； 如果不这样做，则其他操作符的行为是不确定的。\nftype-lock! 可用于加锁。如果发现在操作时锁已解锁，则将其锁定并返回#t；如果发现该锁已加锁，则返回#f且不更改该锁。\nftype-spin-lock! 也可以用来加锁。 如果在操作时发现该锁已解锁，则将其锁定并返回； 如果发现该锁已锁定，它将一直等待直到锁被解锁，然后再锁定并返回。如果没有其他进程或者线程来释放该锁，该操作不会返回且不能以正常的方式（包括GC）中断。也不保证公平，因此即使其他进程正在主动锁定和释放该锁，进程也可能无限期挂起。\nftype-unlock! 用于解锁。如果发现锁已被锁定，则将其解锁并返回。 否则，它将返回而不更改锁。\n原子操作Locked increment and decrement 当需要原子递增或递减时，可以使用此处描述的锁定操作。\n (ftype-locked-incr! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-locked-incr! ftype-name (a \u0026hellip;) fptr-expr index)\n 返回：如果更新的值为0，则为#t，否则为#f\n (ftype-locked-decr! ftype-name (a \u0026hellip;) fptr-expr) | (ftype-locked-decr! ftype-name (a \u0026hellip;) fptr-expr index)\n 返回：如果更新的值为0，则为#t，否则为#f\n它们每个的语法都类似于ftype-set!，尽管带有隐式的val-expr 。 特别是，对fptr-expr 和访问器a \u0026hellip; 的限制和处理是相似的，但有一个重要的限制：最后一个访问器所指定的字段（该格式在其上进行操作）必须是一个字长的整数，即 ，iptr，uptr或具有本地字节序的等效项。\nftype-locked-incr! 自动读取指定字段的值，将值加1，然后将新值写回该字段。 同样，ftype-locked-decr! 原子读取指定字段的值，从该值中减去1，然后将新值写回到该字段中。 如果新值为0，则两者都返回#t，否则返回#f。\n引用计数 在Scheme堆之外管理内存的应用程序可以利用Scheme存储管理系统通过ftype guardians 执行引用计数。 在引用计数的内存管理系统中，每个对象都保存着指向它的指针计数。 当创建一个新的指针时，该计数增加；而在删除指针时，该计数减小。 当计数达到零时，不再需要该对象，并且可以将其占用的内存用于其他目的。\n (ftype-guardian ftype-name)\n ftype-name 必须命名一个ftype。 ftype的第一个基本字段（或在unions的情况下为第一个基本字段）必须是具有本地尾数的字长整数（iptr或uptr）。 假定此字段保存引用计数。\n返回新的ftype guardian g ，可以使用其注册ftype-name 类型（或ftype-nam e的某些子类型）的ftype-pointer。 通过使用ftype指针作为参数调用g ，可以向g 注册ftype指针。\nftype guardian不会像普通的guardian那样自动保护其注册的ftype指针免遭回收。而是，对于每个通过普通（非弱，非监护人指针）变得不可访问的已注册的ftype指针，guardian会减少ftype指针指向的对象的引用计数。如果引用计数值为0，则ftype指针将保留并可以从guardian中检索。 但是，如果生成的引用计数值非零，则不会保留ftype指针。假设回收器外部的代码正确维护了引用计数，则从ftype guardian检索的对象（通过不带参数的调用）将确保具有0引用计数。回收器使用等效的ftype-locked-decr!来减少引用计数，以支持由多个进程共享的内存中的非Scheme对象。在这样的系统中，程序本身应使用ftype-locked-incr! 和ftype-locked-decr! 或非Scheme等效项（例如，第4.8节中所述C语言的scheme.h中的 LOCKED_INCR和LOCKED_DECR宏）来维护引用计数。\n下面的示例为ftype对象定义了一个简单的ftype和一个分配器，该对象释放以前分配的且不再可访问的ftype对象。\nmodule (A make-A free-dropped-As) (define-ftype A (struct [refcount uptr] [data int])) (define g (ftype-guardian A)) (define free-dropped-As (lambda () (let ([a (g)]) (when a (printf \u0026#34;freeing ~s\\n\u0026#34; (ftype-ref A (data) a)) (foreign-free (ftype-pointer-address a)) (free-dropped-As))))) (define make-A (lambda (n) (free-dropped-As) (let ([a (make-ftype-pointer A (foreign-alloc (ftype-sizeof A)))]) (ftype-set! A (refcount) a 1) (ftype-set! A (data) a n) (g a) a)))) 我们可以通过分配，丢弃并立即回收指向A的ftype指针进行测试。\n\u0026gt; (do ([i 10 (fx- i 1)]) ((fx= i 0)) (make-A i) (collect)) freeing 10 freeing 9 freeing 8 freeing 7 freeing 6 freeing 5 freeing 4 freeing 3 freeing 2 \u0026gt; (free-dropped-As) freeing 1 由ftype guardian保护的对象可能包含指向其他对象的指针，这些其他对象的引用计数也应在分配包含对象时增加，并在释放包含对象时减少。\n线程参数  (make-thread-parameter object) | (make-thread-parameter object procedure)\n 创建线程参数后，将在每个当前线程和将来的线程中放置一个单独的位置，以保存参数的内部状态变量的值。 （当该参数变得不可访问时，存储管理器可以消除该位置。）一个线程中对线程参数的更改不会被其他任何线程看到。\n创建新线程时（请参阅fork-thread），每个线程参数的当前值（而非位置）都由新线程从派生线程继承。 类似地，当第一次激活通过其他方式创建的线程时（请参见4.8节中的Sactivate_thread），每个线程参数的当前值（而非位置）都由新线程从主（原始）线程继承。\n大多数内置参数是线程参数，但有些是全局的。 在他们定义的地方已经标注了是线程的还是全局的。 在非线程版本的Chez Scheme中，内置全局参数和线程参数之间没有区别。\nI/O 缓冲区 Chez Scheme为提高效率而缓冲文件I/O操作，但是缓冲的I/O不是线程安全的。 两个线程并发地读写同一个缓冲端口可能会破坏该端口，从而导致缓冲区溢出，并最终导致无效的内存引用。\n当以缓冲模式none打开时，可以禁用二进制输出端口上的缓冲。 但是，由于需要支持先行（lookahead），因此无法完全禁用输入端口上的缓冲，并且由于要在字符和字节之间进行转换的代码转换器有时需要先行输入，因此无法完全禁用文本端口（甚至是文本输出端口）上的缓冲。\n因此，除非在二进制输出端口开启缓冲模式为none的特殊情况下，否则两个线程绝不应该并发地读写同一个端口。替代方法包括指定一个线程为给定端口执行所有I / O，和为每个线程提供通用端口包装程序，仅在获取互斥量后才将请求转发到端口。\n初始的控制台以及当前的输入和输出端口以及transcript端口都是线程安全的，因此多个线程向控制台打印错误和/或调试消息是安全的。即使在同一行内，输出也可能是交错的，但是端口不会损坏。 这些端口的线程安全性是通过为每个I/O操作获取一个互斥锁的高成本来实现的。\n实例：有界队列 以下代码摘自文章“A Scheme for native threads1”，它使用许多线程系统功能实现了有界队列。 有界队列具有固定数量的可用插槽。 当队列已满时尝试入队会导致调用线程阻塞。 尝试从空队列中出队会导致调用线程阻塞。\n(define-record-type bq (fields (immutable data) (mutable head) (mutable tail) (immutable mutex) (immutable ready) (immutable room)) (protocol (lambda (new) (lambda (bound) (new (make-vector bound) 0 0 (make-mutex) (make-condition) (make-condition)))))) (define dequeue! (lambda (q) (with-mutex (bq-mutex q) (let loop () (let ([head (bq-head q)]) (cond [(= head (bq-tail q)) (condition-wait (bq-ready q) (bq-mutex q)) (loop)] [else (bq-head-set! q (incr q head)) (condition-signal (bq-room q)) (vector-ref (bq-data q) head)])))))) (define enqueue! (lambda (item q) (with-mutex (bq-mutex q) (let loop () (let* ([tail (bq-tail q)] [tail^ (incr q tail)]) (cond [(= tail^ (bq-head q)) (condition-wait (bq-room q) (bq-mutex q)) (loop)] [else (vector-set! (bq-data q) tail item) (bq-tail-set! q tail^) (condition-signal (bq-ready q))])))))) (define incr (lambda (q i) (modulo (+ i 1) (vector-length (bq-data q))))) 下面的代码演示了有界队列在一组线程中的应用，这些线程分别扮演数据的消费者和生产者。\n(define job-queue) (define die? #f) (define make-job (let ([count 0]) (define fib (lambda (n) (if (\u0026lt; n 2) n (+ (fib (- n 2)) (fib (- n 1)))))) (lambda (n) (set! count (+ count 1)) (printf \u0026#34;Adding job #~s = (lambda () (fib ~s))\\n\u0026#34; count n) (cons count (lambda () (fib n)))))) (define make-producer (lambda (n) (rec producer (lambda () (printf \u0026#34;producer ~s posting a job\\n\u0026#34; n) (enqueue! (make-job (+ 20 (random 10))) job-queue) (if die? (printf \u0026#34;producer ~s dying\\n\u0026#34; n) (producer)))))) (define make-consumer (lambda (n) (rec consumer (lambda () (printf \u0026#34;consumer ~s looking for a job~%\u0026#34; n) (let ([job (dequeue! job-queue)]) (if die? (printf \u0026#34;consumer ~s dying\\n\u0026#34; n) (begin (printf \u0026#34;consumer ~s executing job #~s~%\u0026#34; n (car job)) (printf \u0026#34;consumer ~s computed: ~s~%\u0026#34; n ((cdr job))) (consumer)))))))) (define (bq-test np nc) (set! job-queue (make-bq (max nc np))) (do ([np np (- np 1)]) ((\u0026lt;= np 0)) (fork-thread (make-producer np))) (do ([nc nc (- nc 1)]) ((\u0026lt;= nc 0)) (fork-thread (make-consumer nc)))) 这是示例程序运行后的可能的前几行输出：\n\u0026gt; (begin (bq-test 3 4) (system \u0026#34;sleep 3\u0026#34;) (set! die? #t)) producer 3 posting a job Adding job #1 = (lambda () (fib 29)) producer 3 posting a job Adding job #2 = (lambda () (fib 26)) producer 3 posting a job Adding job #3 = (lambda () (fib 22)) producer 3 posting a job Adding job #4 = (lambda () (fib 21)) producer 2 posting a job Adding job #5 = (lambda () (fib 29)) producer 1 posting a job Adding job #6 = (lambda () (fib 29)) consumer 4 looking for a job producer 3 posting a job Adding job #7 = (lambda () (fib 24)) consumer 4 executing job #1 consumer 3 looking for a job producer 2 posting a job Adding job #8 = (lambda () (fib 26)) consumer 3 executing job #2 consumer 3 computed: 121393 consumer 3 looking for a job producer 1 posting a job Adding job #9 = (lambda () (fib 26)) ... 在“A Scheme for native threads1”中给出了其他示例，包括可悬挂线程的定义和在无法访问时自动终止的线程。\n  R. Kent Dybvig. A Scheme for native threads. In Symposium in Honor of Mitchell Wand, August 2009. http://www.ccs.neu.edu/events/wand-symposium/.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","id":108,"section":"posts","summary":"下面介绍Chez Scheme线程系统过程和语法形式。 除了锁，锁增量和锁减量之外，线程系统的功能在非基于Windows的系统上在Posix线程","tags":["thread","scheme"],"title":"线程（Thread System in Chez Scheme）","uri":"https://lvsq.net/2020/02/thread/","year":"2020"},{"content":"垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。\n回收由默认的collect-request处理程序自动触发，该处理程序通过collect-request中断调用，该中断在分配了大约n个字节的存储空间后发生，其中n是参数collect-trip-bytes 的值。 默认的collect-request处理程序通过调用不带参数的collect程序来进行会睡。 可以通过更改参数collect-request-handler 的值来重新定义collect-request处理程序。 程序还可以通过直接调用collect来导致在collect-request中断之间发生回收。\nChez Scheme的回收器是基于分代 的。它根据对象的年龄（大致来说，回收幸存数）来对对象进行分类，且老对象比年轻对象回收的频率要低。由于年轻对象比老对象更快地变为不可访问，因此结果是大多数的回收花费的时间更少。系统还维护一个静态代（static generation, 类似Java的永久代），不会对此存储进行回收。仅当压缩堆（Scompact_heap）或要collect的target-generation 参数为static符号时，才将对象放入静态代中。\n非静态代的编号从最年轻的世代（开始于0）到collect-maximum-generation的当前值。存储管理器将新分配的对象放入第0代。在第0代的回收过程中，默认情况下，将第0代的对象挪到第1代，类似地，在第1代回收期间，存活的第0代和第1代对象移动到第2代，依此类推。在最大非静态对象回收的过程中，所有幸存的非静态对象都将移动（可能返回）到最大非静态代中。 通过这种机制，一个对象有可能跳过一个或多个世代，但这在许多对象上不太可能发生，并且如果这些对象变得不可访问，则最终将回收它们的存储。\n维护内部计数器gc-trip来控制何时回收每一代。 每次调用不带参数的collect 时（从默认的collect-request处理程序开始），gc-trip都会加1。在collect-generation基数为r 的情况下，回收的世代编号为g ，其gc-trip是$r^g$的倍数。 如果将collect-generation-radix设置为4，则系统将每次收集0代，每4次收集1代，每16次收集2代，依此类推。\n每次某个世代g 调用collect时，该世代g 被回收且gc-trip前进到下个$r^g$的边界，但是不会超过$r^{g+1}$的边界，r 不变还是collect-generation-radix的值。\n如果使用第二个参数tg 调用collect，则tg 确定目标代。 当g 是最大的非静态代时，tg 必须为g 或为static。 否则，tg 必须为g 或g + 1 。 当目标代是static符号时，非静态代中的所有数据都将移动到静态代中。静态代中的对象从不会被回收。 这在加载和初始化应用程序的永久代码和数据结构之后非常有用，以减少后续回收的开销。\n通过设置本节中描述的参数，可以对回收器的行为进行实质性的调整。通过重新定义collect-request处理程序且使用显式的g 和tg 参数调用collect，甚至有可能完全覆盖收集器的默认策略来确定何时回收每个世代。例如，程序员可以通过使用显式的g 和tg 参数调用collect来重新定义处理程序，以在长时间内将最大的非静态代视为静态代，该参数在该时间段内绝不等于最大的非静态代。\n (collect) | (collect g) | (collect g tg)\n g 必须是不大于最大非静态代（collect-maximum-generation返回的值）的非负确定编号。 如果g 已经是最大的非静态代编号，则tg 必须是一个等于g 的fixnum或static符号。 否则，tg 必须是一个等于g 或大于g 的fixnum。\n此过程使存储管理器执行垃圾回收。 collect是通过collect-request处理程序定期调用的，但是也可以显式调用它，以在特定时间（例如，在计时计算之前）强制进行回收。 在Chez Scheme的线程版本中，调用collect的线程必须是唯一的活动线程。\n系统将根据g 和tg （如果提供）确定回收哪些世代，如本节的介绍中所述。\n (collect-rendezvous)\n 请求垃圾回收的方式应该与由系统自动发起的GC的方式相一致。所有正在运行的线程经过协调，以便其中一个调用collect-request处理程序，而其他线程暂停直到处理程序返回。\n请注意，如果collect-request处理程序（请参阅collect-request-handler）没有调用collect，那么collect-rendezvous实际上不会执行垃圾回收。\n collect-notify\n 如果将collect-notify设置为true，则每当运行GC时，回收器都会打印一条消息。 默认情况下，collect-notify设置为#f。\n collect-trip-bytes\n Chez Scheme在内部以大块分配内存，并通过内联操作将这些块细分以提高效率。存储管理器确定是否为每个分配的大块仅请求一次回收。此外，在存储管理器请求回收和兑现回收请求之间可能会花费一些时间，尤其是如果通过with-interrupts-disabled或disable-interrupts临时禁用了中断时。因此，collect-trip-bytes仅是一种近似度量。\n collect-generation-radix\n 此参数确定默认情况下的collect-request处理程序调用不带参数的collect时回收每一代的频率。每$r^g$次发生一次对应世代的回收，其中r 是collect-generation-radix的值，g 是世代数。\n将collect-generation-radix设置为1会强制所有世代每次都被回收， 将collect-generation-radix设置为非常大的数目将无限期有效地延迟较早的一代的回收。\n collect-maximum-generation\n 此参数确定当前可以使用的最大非静态世代数,它的值是1到254范围内的精确整数。设置为1时，仅使用两个非静态生成。 设置为2时，将使用三个非静态世代，依此类推。 当设置为254时，将使用255个非静态代，再加上一个静态代，总共256个世代。增加世代数可以减少了收集旧对象的频率，潜在地减少了收集开销，但同时也潜在地增加了系统中保留的不可访问对象的数量，从而增加了所需的内存总量。\n collect-request-handler\n collect-request-handler的值必须是一个过程。当系统认为应该要进行GC时（即，自上次GC以来，系统分配了由参数collect-trip-bytes规定的存储量之后），该过程在不带参数的情况下被调用。\n默认情况下，collect-request-handler仅调用不带参数的collect。 可以通过将collect-request-handler设置为不执行任何操作的过程来禁用自动收集，例如：\n(collect-request-handler void) 也可以利用防止任何中断的critical-section来临时禁用GC\n release-minimum-generation\n 此参数的值必须介于0到collect-maximum-generation的值（包括）之间，并且默认为collect-maximum-generation的值。\n当分配新数据且进行GC时，storage-management会自动地从操作系统中请求额外的虚拟内存地址。相应地，在堆显著减小的情况下，系统尝试将先前从操作系统获得的某些虚拟内存返回给操作系统。默认情况下，系统仅在针对最大非静态时代的GC之后才这样做。也可以让系统在对更年轻的世代回收之后就执行此操作，方法是将release-minimum-generation的值更改为小于collect-maximum-generation的值。由参数指定的世代，或者任何较老的世代是GC的目标世代时，存储管理系统将在GC之后尝试将不需要的虚拟内存返回给操作系统。\n当collect-maximum-generation设置为一个新值g 时，release-minimum-generation也同时隐式地更改为g ，有两个前提：（a）修改前这两个参数具有相同的值；（b）release-minimum-generation的值大于g\n heap-reserve-ratio\n 此参数确定了保留的内存的大概数量（没有返回给OS，如release-minimum-generation所描述的）与当前已占用的内存量（不包含已变为静态的内存区域）的比例，它的值必须是不精确的非负整数值； 如果设置为精确的实数值，则精确的值将转换为不精确的值。默认值1.0，为每个当前占用的非静态页面保留一页内存。 将其设置为较小的值可能会导致较小的平均虚拟内存占用量，而将其设置为较大的值可能会导致较少的操作系统调用以请求和释放内存空间。\n弱序对，暂时序对和守护者Weak Pairs, Ephemeron Pairs, and Guardians weak pairs允许程序维护指向对象的弱指针。 指向对象的弱指针不会阻止存储管理系统回收该对象，但是只要该对象在系统中是可访问的，它仍然有效。\nephemeron pairs与weak pairs类似，但是ephemeron pairs拥有两个指针，其中仅仅在第一个指针存在的情况第二个指针才能存在\nguardians允许程序保护对象免遭垃圾回收器的重分配，并确定该对象何时被重新分配。\nweak paris, ephemeron pairs 和guardians允许程序将有关对象的信息保留在单独的数据结构（例如哈希表）中，而无需担心维护此信息将导致对象无限期地保留在系统中。\n另外，guardians允许无限期地从释放对象中保存对象，以便可以重用它们，或者可以使用存储在对象中的数据执行清理或其他操作。\n (weak-cons obj1 obj2)\n 返回：一个新的弱序对\nobj1 是新对的car, obj2构成了新对的cdr。弱序对和普通对是无法区分的，除了这两种方式：\n 弱序对可以使用**weak-pair?**这个谓词来区别普通对 弱序对维护了一个指向(car obj)的弱指针  弱序对的car中的弱指针就像普通指针一样，只要它指向的对象可以通过系统中某个地方的普通（非弱）指针访问即可。 但是，如果垃圾收集器在某个时候识别出不存在指向该对象的非弱指针，则它将每个指向该对象的弱指针替换为“ broken weak-pointer”对象**#!bwp**，并丢弃该对象。\n弱序对的cdr字段不是弱指针，因此可以使用弱序对来构造弱保持对象的列表。可以像使用普通的列表的处理操作（例如length，map和assv）来操作这些list。弱序对可以使用set-car!和set-cdr!来修改； 在set-car!之后，car字段包含指向新对象的弱指针，代替了旧对象。弱序对的打印方式与普通对相同。 弱序对没有reader语法。弱序对在被写入然后被读取时成为普通对。\n(define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x \u0026#39;())) (car p) ⇒ (a . b) (define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x \u0026#39;())) (set! x \u0026#39;*) (collect) (car p) ⇒ #!bwp  (weak-pair? obj)\n (weak-pair? (weak-cons ’a ’b)) ⇒ #t (weak-pair? (cons ’a ’b)) ⇒ #f (weak-pair? \u0026#34;oops\u0026#34;) ⇒ #f  (ephemeron-cons obj1 obj2)\n obj1 是新对的car, obj2构成了新对的cdr。暂时序对和普通对是无法区分的，除了这两种方式：\n 暂时序对可以使用**ephemeron-pair?**这个谓词来区别普通对 暂时序对维护了一个指向(car obj)的弱指针，并且仅仅在pair的car存在时cdr才能保留  暂时序对的行为与弱序对类似，不过cdr有特殊的处理：如果car被设置为**#!bwp**的同时也会将cdr设置为**#!bwp**。由于同时将car和cdr字段设置为为**#!bwp**，因此可以通过cdr对象引用car对象这一事实本身并不意味着必须保留car（与弱序对不同）。 相反，出于某种原因，car必须独立于cdr对象保存。\n与弱序对和其他对一样，暂时序对使用**set-car!和set-cdr!**来修改数据，暂时序对的打印方式与普通对一样，但没有reader语法\n(define x (cons \u0026#39;a \u0026#39;b)) (define p (ephemeron-cons x x)) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b) (define x (cons \u0026#39;a \u0026#39;b)) (define p (ephemeron-cons x x)) (set! x \u0026#39;*) (collect) (car p) ⇒ #!bwp (cdr p) ⇒ #!bwp (define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x x)) ; not an ephemeron pair (set! x \u0026#39;*) (collect) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b) 与弱序对一样，如果在将x设置为*之前进行了垃圾回收将该pair提升为较老的一代，则上面中间示例的最后两个表达式实际上可能返回（a . b）。 但是，在上面的最后一个示例中，最后两个表达式的结果将始终为（a . b），因为弱序对的cdr持有非弱引用，并且该非弱引用阻止car字段变** #!bwp**。\n (ephemeron-pair? obj)\n (ephemeron-pair? (ephemeron-cons \u0026#39;a \u0026#39;b)) ⇒ #t (ephemeron-pair? (cons \u0026#39;a \u0026#39;b)) ⇒ #f (ephemeron-pair? (weak-cons \u0026#39;a \u0026#39;b)) ⇒ #f (ephemeron-pair? \u0026#34;oops\u0026#34;) ⇒ #f  (bwp-object? obj)\n 返回：如果obj是断开的broken weak-pair对象，则返回#t，否则返回#f\n(bwp-object? #!bwp) ⇒ #t (bwp-object? \u0026#39;bwp) ⇒ #f (define x (cons \u0026#39;a \u0026#39;b)) (define p (weak-cons x \u0026#39;())) (set! x \u0026#39;*) (collect (collect-maximum-generation)) (car p) ⇒ #!bwp (bwp-object? (car p)) ⇒ #t  (make-guardian)\n Guardians由要保护的对象组的过程表示。创建guardian后，注册对象组为空。 通过将对象作为参数传递给守护者，可以向guardian注册对象：\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) x ⇒ (aaa . bbb) (G x) 注册对象时也可以指定“representative”（即，y）对象。 继续上面的示例：\n(define y (cons \u0026#39;ccc \u0026#39;ddd)) y ⇒ (ccc . ddd) (G y \u0026#39;rep) 与守护者关联的一组注册对象在逻辑上细分为两个不相交的子组：一个子组称为“可访问”对象，一个子组称为“不可访问”对象。不可访问的对象是已被证明无法访问的对象（通过guardian机制本身或通过弱序对或暂时序对的car字段除外），可访问的对象是未经证明的对象。“已证明”一词在这里很重要：可能是可访问组中的某些对象确实是不可访问的，但这尚未得到证明。 在某些情况下，直到对象实际上变得不可访问很久之后（在当前实现中，直到发生包含对象的世代的垃圾回收），才可能做出这种证明。\n向guardian注册的对象最初被放置在可访问组中，并在它们变得不可访问后的某个时刻移入不可访问组。 不可访问组中的对象是通过调用不带参数的guardian来检索的。 如果不可访问组中没有对象，则guardian返回#f。 继续上面的示例：\n(G) ⇒ #f (set! x #f) (set! y #f) (collect) (G) ⇒ (aaa . bbb) ; 也有可能这个后打印出来 (G) ⇒ rep ; 这个先打印出来 (G) ⇒ #f 对G的初始调用返回#f，因为绑定到x和y的对是向G注册的唯一对象，并且仍然可以通过这些绑定访问这些序对。调用collect时，对象将移入不可访问的组。 因此，对G的两个调用返回先前绑定到x的序对和先前绑定到y的序对的representative，尽管可能与所示顺序相反。 （如上所述，对于弱序对，如果对象已迁移到较老的一代，则调用collect实际上可能不足以证明该对象不可访问。）\n实际上，从guardian那里获取的对象在任何方面都没有特殊的地位。 此功能避免了共享或循环结构可能会出现的问题。 由不可访问对象组成的共享或循环结构将被完整保留，将注册由guardian保护的部分都放置在该guardian不可访问的集合中。 然后，程序员可以完全控制结构的处理顺序。\n一个对象可以在guardian处多次注册，在这种情况下，可以多次检索该对象：\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) (G x) (G x) (set! x #f) (collect) (G) ⇒ (aaa . bbb) (G) ⇒ (aaa . bbb) 它也可以向不止一个guardian注册，并且guardian本身也可以向其他guardian注册。 在没有“representative”的情况下向guardian注册的对象，并放置在一个弱序对或暂时对的car字段中，其直到从guardian处将返回并由程序丢弃，或者直到guardian本身被丢弃为止。\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) (define p (weak-cons x \u0026#39;())) (G x) (set! x #f) (collect) (set! y (G)) y ⇒ (aaa . bbb) (car p) ⇒ (aaa . bbb) (set! y #f) (collect 1) (car p) ⇒ #!bwp 另一方面，如果指定了representative（对象本身除外），则在从guardian处获得representative的同时，也会从弱序对或暂时序对的car字段中丢弃受保护的对象。\n(define G (make-guardian)) (define x (cons \u0026#39;aaa \u0026#39;bbb)) (define p (weak-cons x \u0026#39;())) (G x \u0026#39;rep) (set! x #f) (collect) (G) ⇒ rep ; 获得representative的值 (car p) ⇒ #!bwp ; 自动丢弃 下面的示例说明了当guardian本身丢弃时，该对象已被释放并且弱序对的car字段设置为#!bwp：\n(define G (make-guardian)) (define x (cons aaa \u0026#39;bbb)) (define p (weak-cons x \u0026#39;())) (G x) (set! x #f) (set! G #f) (collect) (car p) ⇒ #!bwp 下面的示例演示了如何使用guardian来释放外部存储，就像由C库“malloc”和“free”操作管理存储。\n(define malloc (let ([malloc-guardian (make-guardian)]) (lambda (size) ; first free any storage that has been dropped. to avoid long ; delays, it might be better to deallocate no more than, say, ; ten objects for each one allocated (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f)))) ; then allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x)))) do-malloc必须返回一个Scheme对象“header”，该header封装一个指向外部存储的指针（可能是无符号整数），并且必须通过此header对外部存储进行所有访问。特别是，必须注意在删除相应的header之后，在Scheme之外不存在指向外部存储的指针。 do-free必须使用封装的指针释放外部存储。这两个原语都可以使用外部分配和外部无关的定义，也可以作为外部过程导入的C库“malloc”和“free”运算符进行定义。\n如果不希望调用malloc来释放存储，则可以使用collect-request处理器来检查并释放已丢弃的存储，如下所示：\n(define malloc) (let ([malloc-guardian (make-guardian)]) (set! malloc (lambda (size) ; allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x))) (collect-request-handler (lambda () ; first, invoke the collector (collect) ; then free any storage that has been dropped (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f))))))) 通过一点重构，就有可能将封装的外部地址注册为带header的representative，在这种情况下，do-free将仅将外部地址作为参数。 这将使标头一旦变得不可访问，便可以将其从Scheme堆中删除。\n锁对象Locking Objects 来自C语言的变量或数据结构到Scheme对象的所有指针，通常应在输入（或重新输入）Scheme之前丢弃。 当无法遵循该准则时，可以通过锁定对象或等效的C库过程Slock_object锁定该对象。\n (lock-object obj)\n 锁定对象可防止存储管理器收回或重定位该对象。 应谨慎使用锁定，因为它会导致内存碎片并增加存储管理开销。\n如果未解锁对象，锁定也会导致意外保留存储空间。 可以通过解锁对象或等效的C库过程Sunlock_object来解锁对象。\n锁定立即数（例如，fixnum，布尔值和字符）或已被静态化的对象是不必要但无害的。\n (unlock-object obj)\n 通过连续调用lock-object，Slock_object或同时调用这两个对象，可以多次锁定对象，在这种情况下，必须先通过相等次数的对unlock-object或Sunlock_object的调用来将其解锁。\n除非存在指向对象的单独的C指针，否则也无需锁定包含在锁定对象中的对象（例如，锁定序对的car中的对象）。也就是说，如果仅允许通过外部对象来间接访问的内部对象，则应将其解锁，以便回收器在回收期间可以自由地重分配它。\n解锁立即值（例如，fixnum，布尔值和字符）或已设为静态的对象是不必要的，无效的，但无害。\n (locked-object? obj)\n 返回：如果obj是锁定的，立即的或静态的，返回#t\n如果回收器无法重分配或回收obj，则该谓词将返回true，包括立即值，例如fixnums，布尔值和字符以及已设为静态的对象。\n","id":109,"section":"posts","summary":"垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动","tags":["scheme"],"title":"存储管理(Storage Management in Chez Scheme)","uri":"https://lvsq.net/2020/02/storage-management/","year":"2020"},{"content":"异常  (warning who msg irritant \u0026hellip;)\n  返回：未指定\n 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止程序继续运行但可能在以后导致更严重问题的情况。通常最好是识别程序员已调用的过程，而不是程序员可能不知道的其他过程。 msg必须为字符串，并应描述异常情况。irritant可以是任何Scheme对象，并且应包含可能导致或严重涉及异常情况的值。\n (assertion-violationf who msg irritant \u0026hellip;) | (errorf who msg irritant \u0026hellip;) | (warningf who msg irritant \u0026hellip;)\n 这些过程类似于assertion-violation, error, warning, 所不同的在于 msg 设定为一个格式字符串\n中断 Chez Scheme允许程序在发生各种事件时控制Scheme系统的操作，这些事件包括键盘中断，由set-timer设置的内部计时器到期，由中断调用引发的断点或者来自存储管理器的请求启动GC。\n无论何时break被调用，系统都会立即启用中断处理程序\n (break who msg irritant \u0026hellip;) | (break who) | (break)\n break参数遵循上述errorf的协议。默认的中断处理程序（请参见break-handler）显示一条消息并调用调试器。可以省略格式字符串和对象，在这种情况下，默认中断处理程序发出的消息使用who参数标识中断，但不提供有关中断的更多信息。如果也省略了who参数，则不会生成任何消息。如果调试器正常退出，则默认的中断处理程序将正常返回。\n break-handler\n 此参数的值必须是一个过程。当前的中断处理程序由break调用，它传递其参数。有关默认中断处理程序的描述，请参见break。以下示例显示了如何禁用breaks。\n(break-handler (lambda args (void)))  (set-timer n)\n n 必须为非负整数。当n 为非零时，设置计时器启动一个内部计时器，其初始值为n。经过n个tick后，将发生计时器中断，从而导致计时器中断处理程序被调用。tick不是统一的时间单位，而是在很大程度上取决于每个过程调用要完成多少工作。\n当n为零时，设置计时器关闭计时器。\nengine机制建立在计时器中断之上，因此不应与engine共同使用。\n (register-signal-handler sig procedure)\n register-signal-handler用于为给定的底层信号建立信号处理程序。 sig必须是标识有效信号的精确整数，过程应接受一个参数。在注册了给定signal的处理程序之后，收到了给定的signal会调用该处理程序。signal编号会传递给该处理程序，从而允许同一处理程序用于不同的信号，同时区分它们。\n以这种方式处理的信号类似于键盘中断，因为在将信号传递到进程时不会立即调用处理程序，而是在信号传递后在某个过程调用边界处调用该处理程序。因此，为内存故障，非法指令等建立处理程序通常不是一个好主意，因为导致故障或非法指令的代码将在调用处理程序之前继续执行（可能是错误的）一段时间。\n另外，仅在基于Unix的系统上才支持register-signal-handler。\n环境 环境是包含标识符绑定的顶级（first-class）对象。它们类似于模块，但是与模块不同，它们可以在运行时进行操作。环境可以作为eval，expand以及过程的定义，分配或引用顶级值的可选参数。\n有几种内置环境，也可以通过复制现有环境或从现有环境中选择的绑定来创建新环境。\n环境可以是可变的或不变的。可变的环境可以使用新的绑定进行扩展，可以修改其现有绑定，还可以分配其变量。不变的环境不能以任何这些方式进行修改。\n 联想一下SICP中关于环境的内容   (environment? obj)\n (environment? (interaction-environment)) ⇒ #t (environment? \u0026#39;interaction-environment) ⇒ #f (environment? (copy-environment (scheme-environment))) ⇒ #t (environment? (environment \u0026#39;(prefix (rnrs) $rnrs-))) ⇒ #t  (environment-mutable? env)\n (environment-mutable? (interaction-environment)) ⇒ #t (environment-mutable? (scheme-environment)) ⇒ #f (environment-mutable? (copy-environment (scheme-environment))) ⇒ #t (environment-mutable? (environment \u0026#39;(prefix (rnrs) $rnrs-))) ⇒ #f  (scheme-environment)\n scheme-environment返回一个包含初始顶级绑定的环境。该环境对应于Scheme模块。此过程返回的环境是不可变的。\n(define cons 3) (top-level-value \u0026#39;cons (scheme-environment)) ⇒ #\u0026lt;procedure cons\u0026gt; (set-top-level-value! \u0026#39;cons 3 (scheme-environment)) ⇒ exception  (copy-environment env) | (copy-environment env mutable?) | (copy-environment env mutable? syms)\n copy-environment返回env的副本，即包含与env 相同绑定的新环境。mutable? 如果为true，则该environment是可变的，反之则不可变；\n从env 复制到新环境的绑定集由syms 确定，其默认值为（environment-symbols env）。每个syms 元素的绑定（如果有）都被复制到新环境中，并且新环境中不存在其他绑定。\n在当前的实现中，永远不会收集环境使用的存储空间，因此重复使用复制环境最终将导致系统内存不足。\n(define e (copy-environment (scheme-environment))) (eval \u0026#39;(define cons +) e) (eval \u0026#39;(cons 3 4) e) ⇒ 7 (eval \u0026#39;(cons 3 4) (scheme-environment)) ⇒ (3 . 4)  (environment-symbols env)\n 此过程返回代表环境env中绑定的标识符的符号列表。它主要用于构建要从一种环境复制到另一种环境的符号列表。\n(define listless-environment (copy-environment (scheme-environment) #t (remq \u0026#39;list (environment-symbols (scheme-environment))))) (eval \u0026#39;(let ([x (cons 3 4)]) x) listless-environment) ⇒ (3 . 4) (eval \u0026#39;(list 3 4) listless-environment) ⇒ exception 编译、求值和加载  (eval obj) | (eval obj env)\n eval将obj 视为表达式的表示形式。它在环境env中计算表达式并返回其值。如果未提供任何环境，则默认为由交互环境返回的环境。单参数求值是Chez Scheme的扩展。当环境可变时，Chez Scheme还允许obj表示非表达形式，比如一个definition。 Chez Scheme还允许obj作为一个annotation，默认求值程序利用注释将源文件信息合并到错误消息中，并将源文件信息与编译后的代码相关联。\n在Chez Scheme中，eval实际上是一个包装器，仅将其参数传递给当前求值器（请参阅current-eval）。默认的评估器是compile，它通过当前的扩展器（参阅current-expand）扩展表达式，对其进行编译，执行生成的代码，并返回其值。如果存在环境参数env ，则compile将其传递给当前的扩展器，默认情况下为sc-expand。\n (compile obj) | (compile obj env)\n obj 可以为Scheme表达式，在指定的环境（或交互环境，如果未提供环境）中使用当前扩展器（current-expand的值）进行扩展），编译为机器代码，然后执行。 compile是current-eval参数的默认值。\n(compile \u0026#39;(cons 1 2)) =\u0026gt; (1 . 2)  (interpret obj) | (interpret obj env)\n 解释类似于编译，只是表达式是解释的而不是编译的（the expression is interpreted rather than compiled）。解释可以用作编译的替代品，但有以下警告：\n 解释后的代码运行速度大大降低 解释后的代码不会生成检查器信息，因此检查器对于解释的代码不如在编译的代码中有用、 无法解释外部过程表达式，因此解释器需要为所有外部过程表达式调用编译器（这是透明完成的）  当求值形式运行时间较短时，解释有时比编译更快，因为它避免了在求值之前通过编译完成的某些工作。\n (load path) | (load path eval-proc)\n path 必须是字符串。 load读取并求值path 指定的文件的内容。该文件可能包含源代码或目标代码。默认情况下，load使用eval求值源文件中找到的每个源表达式。如果指定了eval-proc ，则load将使用此过程。 eval-proc 必须接受一个参数，即要求值的表达式。\neval-proc参数有助于实现嵌入的类似于Scheme的语言，并有助于使用用于Scheme程序的替代评估机制。 eval-proc也可以用于其他用途。例如，\n(load \u0026#34;myfile.ss\u0026#34; (lambda (x) (pretty-print (if (annotation? x) (annotation-stripped x) x)) (newline) (eval x))) 对每一个表达式求值之前使用pretty-print打印。\n参数source-directorys确定了搜索目录，以搜索未由绝对路径名标识的源文件。\n (load-library path) | (load-library path eval-proc)\n load-library与load相同，除了它会将输入文件视为由隐式**＃!r6rs**作为前缀。这有效地禁用了所有**非R6RS**词法语法，除非随后被**＃！chezscheme**覆盖\n (load-program path) | (load-program path eval-proc)\n path 必须是字符串。加载程序读取并求值path指定的文件的内容。该文件可能包含源代码或目标代码。如果包含源代码，则加载程序会将代码以顶级程序形式包装起来，以便将文件的内容视为RNRS顶级程序（Scheme编程语言，第4版的10.3节）。默认情况下，加载程序使用eval求值文件中找到的每个源表达式。如果指定了eval-proc，则装入程序将使用此过程。 eval-proc必须接受一个参数，即要评估的表达式。传递给eval-proc的表达式可能是注释或未注释的值。 参数source-directorys确定了搜索目录，以搜索未由绝对路径名标识的源文件。\n (load-compiled-from-port input-port)\n load-compiled-from-port读取并求值来自input-port的对象代码的内容，这些input-port是事先由诸如compile-file, compile-script, compile-library, compile-to-port创建的返回值是最后一个表达式的值，该表达式的编译形式为input-port。如果input-port为空，则结果值未指定。\n (compile-file input-filename) | (compile-file input-filename output-filename)\n input-filename 和output-filename 必须是字符串。input-filename 必须是已存在的可读文件。它必须包含零个或多个源表达式的序列；如果不是这种情况，则编译文件会引发条件类型为＆syntax的异常。\n正常求值过程分为两个步骤：编译和执行。 compile-file对整个源文件执行编译过程，从而生成目标文件。随后加载目标文件（请参见load）时，不需要编译过程，并且文件加载通常快几倍。\n (compile-script input-filename) | (compile-script input-filename output-filename)\n compile-script与compile-file类似，不同点在于，它会从源文件复制开头的**#!**行到目标文件，同时该行不会被压缩，尽管参数**compile-compressed**被设置为#t，其他代码会被压缩，这样会保证操作系统可以正确地解释。\ncompile-script允许从源脚本创建已编译的脚本文件，以减少脚本加载时间。与源代码脚本一样，可以使用**\u0026ndash;script**命令行选项运行已编译的脚本。\n (compile-library input-filename) | (compile-library input-filename oiutput-filename)\n compile-library与compile-file相同，不同之处在于，它会将输入文件视为由隐式**＃!r6rs**作为前缀。这有效地禁用了所有非R6RS词法语法，除非随后被＃!chezscheme覆盖。\n (compile-program input-filename) | (compile-program input-filename output-filename)\n compile-program类似于compile-script，但不同之处在于，它实现了RNRS顶级程序的语义，而compile-script则实现了交互式顶级程序的语义。与通过compile-file或compile-script进行编译相比，生成的已编译程序的运行速度也更快。\ncompile-program返回由编译的顶层程序直接调用的库的列表，不包括（rnrs）和（chezscheme）之类的内置库\n (compile-whole-program input-filename output-filename) | (compile-whole-program input-filename output-filename libs-visible?)\n compile-whole-program接受一个文件名作为名称输入，该文件名为顶级程序命名为“ whole program optimization”（wpo）文件，并生成一个包含该程序及其所依赖的每个库的目标文件，前提是需要一个可以找到库的wpo文件。\n如果wpo文件找不到所需库，但可以找到该库的目标文件，则该库不会合并到生成的目标文件中。这些库将在运行时加载。 compile-whole-program返回这些库的列表。如果没有这样的库，则生成的目标文件是自包含的，并且compile-whole-program返回空列表。\n如果libs-visible? 设置为非false，则库合并到目标文件是可见的（供environment和eval使用），任何合并到目标文件中并在运行时保留下来的目标文件所要求的库都是可见的。\n当generate-wpo-files参数设置为#t时，过程compile-file，compile-program，compile-library，compile-script和compile-whole-library会生成wpo文件以及普通目标文件。 （默认值为#f）。另外如果传递可选的wpo端口时，compile-port和compile-to-port也会这样做。\n (compile-whole-library input-filename output-filename)\n compile-whole-library类似于compile-whole-program，不同之处在于input-filename必须为库指定一个wpo文件，所有库自动显示，并生成一个新的wpo文件（当generate-wpo-files为#t时）以及用于生成的库组合的目标文件。\n (compile-port input-port output-port) | (compile-port input-port output-port sfd) | (compile-port input-port output-port sfd wpo-port)\n input-port 必须是文本输入端口。out-port 和wpo-port（如果存在）必须是二进制输出端口。如果存在sfd ,必须是源文件描述符。\n (make-boot-file output-filename base-boot-list input-filename \u0026hellip;)\n 所有参数都必须是字符串。\nmake-boot-file将引导标头（boot header）写入以output-filename 命名的文件，然后依次写入每个input-filename 的目标代码。如果尚未编译输入文件，make-boot-file将在对其进行编译。\n引导文件通过\u0026ndash;boot或-b命令行选项显式加载，或基于可执行文件的名称隐式加载。\n (make-boot-header output-filename base-boot1 base-boot2\u0026hellip;)\n 该过程已包含在make-boot-file中，并提供了向后兼容性。\n(make-boot-header output-filename base-boot1 base-boot2 \u0026hellip;)等价于：(make-boot-file output-filename ’(base-boot1 base-boot2 \u0026hellip;))源目录和文件  source-directories\n source-directories的值必须是一个字符串列表，每个字符串都命名一个目录路径。当通过load, load-library, load-program, include, visit, or revisit在交互式检查器中发生语法错误或打开源文件时，source-directory确定用于搜索源文件或目标文件的目录集。\n默认值为列表（“.”），这意味着仅在当前目录中或相对于当前目录才能找到源文件，除非使用绝对路径命名。\n (with-source-path who name procedure)\n 过程with-source-path依次搜索当前源目录路径，以查找具有指定名称的文件，并在结果上调用过程。如果未找到这样的文件，则引发**\u0026amp;assertion**和**\u0026amp;who**异常，**\u0026amp;who**的值为*who* 的值\n如果name 是绝对路径，或者以./（Windows下是./），或者../（Windows下是..\\），或者源目录列表中只包含“.”，或者默认值 \u0026ldquo;\u0026quot;，相当于 \u0026ldquo;.\u0026quot;，不执行搜索并返回name。\nwho 必须是符号，name 必须是字符串，procedure 应接受一个参数。\n以下示例假定文件“ pie”存在于目录“ ../spam”中，但不在“ ../ham”或当前目录中。\n(define find-file (lambda (fn) (with-source-path \u0026#39;find-file fn values))) (find-file \u0026#34;pie\u0026#34;) ⇒ \u0026#34;pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../ham\u0026#34;)) (find-file \u0026#34;pie\u0026#34;) ⇒ exception in find-file: pie not found (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../spam\u0026#34;)) (find-file \u0026#34;pie\u0026#34;) ⇒ \u0026#34;../spam/pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../ham\u0026#34;)) (find-file \u0026#34;/pie\u0026#34;) ⇒ \u0026#34;/pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../ham\u0026#34;)) (find-file \u0026#34;./pie\u0026#34;) ⇒ \u0026#34;./pie\u0026#34; (source-directories \u0026#39;(\u0026#34;.\u0026#34; \u0026#34;../spam\u0026#34;)) (find-file \u0026#34;../pie\u0026#34;) ⇒ \u0026#34;../ham/pie\u0026#34; 编译器管理  optimize-level\n 该参数可以是0，1，2，3这4个值中的一个。\n理论上，此参数控制编译器执行的优化量。 实际上，它只是间接执行此操作，唯一的区别在于优化级别3（编译器生成“不安全”代码）与优化级别0-2（编译器生成“安全”代码）之间。 安全代码会执行完整类型和范围检查，例如，尝试应用非过程，尝试对non-pair的car操作或尝试引用向量的末尾，均会导致 引发异常。 对于不安全的代码，相同的情况可能会导致无效的内存引用，Scheme堆损坏（这可能在以后引起看似无关的问题），系统崩溃或其他不良行为。不安全的代码通常会更快，但是应该谨慎使用优化级别3，并且仅运用在必须尽快运行且经过良好测试的代码中。\n尽管编译器为优化0至2级生成了相同的代码，但如果需要，用户定义的宏转换器可以区分不同的级别。\n一种使用优化级别的方法是在每个文件上，强制使用eval-when。 例如:\n(eval-when (compile) (optimize-level 3))  也可以通过\u0026ndash;optimize-level命令行选项设置优化级别。此选项对于通过\u0026ndash;program命令行选项在优化级别3运行RNRS顶层程序特别有用，因为eval-when对RNRS顶层程序无效。\n ($primitive variable) | ($primitive 2 variable) | ($primitive 3 variable)\n variable 必须是一个原始procedure的名字。** $primitive**语法形式允许以单个原始引用的粒度控制优化级别，并且它可以用于访问原始值。\n表达式（$primitive variable）可以缩写为**#%variable**。\n(#%car ’(a b c)) ⇒ a (let ([car cdr]) (car \u0026#39;(a b c))) ⇒ (b c) (let ([car cdr]) (#%car \u0026#39;(a b c))) ⇒ a (begin (set! car cdr) (#%car \u0026#39;(a b c))) ⇒ a  debug-level\n 该参数可以采用0、1、2和3这四个值之一。它用于告诉编译器保留调试信息的重要性，其中0的重要性最低，而3的重要性最高。 默认值是1。从9.0版开始，它仅用于确定在非尾部位置遇到的引起错误的调用是否被视为在尾部位置（因此，导致调用者的帧不出现在堆栈回溯中）。 这发生在低于2的调试级别。\n概要分析Profiling ChezScheme支持两种类型的配置文件：源代码概要分析和块概要分析。\n启用源概要分析后，编译器会对生成的代码进行检测，以计算每个源代码表达式的执行次数。 该信息可以HTML格式显示或打包在列表中，以进行任意用户定义的处理。 也可以将其转储到文件中，然后再加载到编译器的概要分析信息数据库中，以用于源代码级优化。\n源代码概要分析至少包含下面一些步骤：\n 编译代码且开启source profiling 运行编译后的代码生成源代码概要分析信息，且 转储概要分析信息  通过将参数compile-profile设置为符号源或布尔值#t，可以启用源概要分析。 可以通过以下方式转储概要分析信息：\nprofile-dump-html 以HTML格式显示，以便程序员可以直观地看到使用彩色编码系统执行每个表达式的频率，该系统可以轻松发现“热点”profile-dump-list 以适合用户定义的后处理的形式;profile-dump 以适合于通过上述方法之一或某些自定义方式进行离线处理的形式，或profile-dump-data 以适合加载到编译器数据库中的形式。\n由profile-dump-data转储的概要分析信息通过profile-load-data加载到编译器的profiling数据库中。 除非通过profile-dump-data显式转储并通过profile-load-data加载，否则分析信息对编译器不可用。\n当使用块概要文件信息进行优化时，步骤是相似的： 编译代码并开启block profiling 运行代码生成block-profiling信息 转储概要分析信息 加载概要信息，且 重新编译代码  通过将参数compile-profile设置为符号块或布尔值#t，可以启用块分析。 概要文件信息必须通过profile-dump-data转储，并通过profile-load-data加载。 与源配置文件信息一样，块配置文件信息可以与转储信息的加载过程相同或不同。\n对于块优化，要重新编译的代码必须相同。 通常，这意味着所涉及的文件必须未经修改，并且其他任何更改都不会间接影响编译器生成的代码。\n出于同样的原因，当要同时使用源概要分析和块概要分析信息进行优化时，必须先收集并加载源信息，然后再运行涉及块概要分析的第一次和第二次编译。 即，必须使用以下步骤：1. 编译代码并起开源代码概要分析 2. 运行代码生成source-profiling信息 2. 转储source-profiling 3. 加载source-profiling 3. 重新编译代码，并开启块概要分析 4. 运行代码生成block-profiling信息 4. 转储block-profiling 5. 加载source-和block-profiling 5. 重新编译代码  标记每个步骤的数字既指示步骤的顺序，又指示必须在同一计划过程中执行的顺序。 （如果需要，所有步骤都可以在同一Scheme流程中执行。） 当compile-profile设置为默认值#f时，将禁用源和块分析。\n假设文件/tmp/fatfib/fatfib.ss包含以下代码：\n(define fat+ (lambda (x y) (if (zero? y) x (fat+ (1+ x) (1- y))))) (define fatfib (lambda (x) (if (\u0026lt; x 2) 1 (fat+ (fatfib (1- x)) (fatfib (1- (1- x))))))) 我们可以像下面这样加载fatfib.ss并且开启概要分析：\n(parameterize ([compile-profile \u0026#39;source]) (load \u0026#34;/tmp/fatfib/fatfib.ss\u0026#34;)) 然后运行代码：\n(fatfib 20) ⇒ 10946 运行（或多次运行）之后，转储概要文件为一些html文件集合： 使用profile-dump-html\n(profile-dump-html) 这将创建一个名为profile.html的文件\n在图中，执行最频繁的代码以接近红色的颜色突出显示，而执行最不频繁的代码以接近紫色的颜色突出显示。\n compile-profile\n 当将此参数设置为符号source或布尔值**#t**时，编译器将使用指令对生成的代码进行检测，这些指令对源代码的每个部分执行的次数进行计数。 当设置为符号**block**时，编译器类似地使用指令对生成的代码进行检测，该指令对每个代码块的执行次数进行计数。 当设置为**#f**（默认值）时，编译器不会插入这些指令。\n当compile-profile为非false时生成的代码较大且效率较低，因此仅在需要概要分析信息时才应设置此参数。启用概要分析检测后编译的代码的概要文件计数器将无限期保留，即使与它们关联的代码已被垃圾收集器回收。 这样可以得到更完整和准确的概要分析数据，但会导致动态生成或加载代码的程序出现空间泄漏，程序可以通过profile-release-counters过程显式地释放计数器，从而避免潜在的空间泄漏。\n (profile-clear)\n 调用此过程会清空概要分析信息，代码每个部分关联的计数都被置为0\n (profile-release-counters)\n 调用此过程将丢弃概要分析\n (profile-dump)\n 此过程将生成自启动或上次调用profile-clear以来收集的所有配置文件信息的转储。 它返回一个pair的列表，其中每个pair的car是一个source-object，而cdr是一个精确的非负整数计数。\nprofile-dump优于profile-dump-list的优点在于，profile-dump仅执行最少的处理，并保留完整的源对象，包括其嵌入式源文件描述符。 例如，它可以用于将概要分析信息转储到一台计算机上的fasl文件中，以便在另一台计算机上进行后续处理。\n (profile-dump-html) | (profile-dump-html prefix) | (profile-dump-html prefix dump)\n 此过程将生成一个或多个HTML文件，包括profile.html（其中包含用颜色编码的摘要信息），以及一个文件source.html，其中每个源文件源都包含用源代码进行颜色编码的副本，如前导中所述： 在本节中。 如果指定了prefix ，则它必须是字符串，并且在生成的HTML文件的名称之前。 例如，如果前缀为**“ /tmp/”**，则生成的文件将放置在目录/tmp中。 原始概要分析信息是从转储获取的，默认为**profile-dump**返回的值\n (profile-palette)\n 此参数的值必须是至少三对的非空向量。 每个pair的car是背景色，而cdr是前景（文本）色。 每种颜色都必须是一个字符串，并且每个字符串都应包含HTML层叠样式表（CSS）颜色说明符。 第一组用于未配置的代码，第二对用于未执行的配置的代码。 第三个用于执行频率最低的代码，第四个用于执行频率倒数第二低的代码，以此类推，最后一个用于执行频率最高的代码。 程序员可能希望提供自己的调色板以增强可见性或更改所用颜色的数量。\n默认情况下，黑色背景用于未配置文件的代码，灰色背景用于未执行的配置文件的代码。 根据执行频率，紫色到红色的背景颜色用于执行的概要分析代码，而最频繁执行的代码使用红色。\n(profile-palette) ⇒ #((\u0026#34;#111111\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#607D8B\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#9C27B0\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#673AB7\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#3F51B5\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#2196F3\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#00BCD4\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#4CAF50\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#CDDC39\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FFEB3B\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FFC107\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FF9800\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#F44336\u0026#34; . \u0026#34;white\u0026#34;)) (profile-palette ; set palette with rainbow colors and black text ; for all but unprofiled or unexecuted code \u0026#39;#((\u0026#34;#000000\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#666666\u0026#34; . \u0026#34;white\u0026#34;) (\u0026#34;#8B00FF\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#6600FF\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#0000FF\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#00FF00\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FFFF00\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FF7F00\u0026#34; . \u0026#34;black\u0026#34;) (\u0026#34;#FF0000\u0026#34; . \u0026#34;black\u0026#34;))) ; red  (profile-line-number-color)\n 此参数的值必须是字符串或#f。 如果是字符串，则该字符串应包含HTML层叠样式表（CSS）颜色说明符。 如果参数设置为字符串，则profile-dump-html使用指定的颜色在每个源文件的html呈现中包括行号。 如果参数设置为#f，则不包含行号。\n个性化（Waiter Customization）  (new-cafe) | (new-cafe eval-proc)\n Chez Scheme通过waiter 或read-eval-print循环（REPL）与用户进行交互。 waiter在称为caf́e的上下文中运行。 当系统启动时，将用户置于caf́e中并分配waiter 。 new-cafe在旧的caf́e之上开启了一个新的Scheme caf́e。 除了启动waiter 之外，new-cafe还设置了caf́e的重置和退出处理程序（请参阅reset-handler和exit-handler）。 退出caf́e会返回到创建该caf́e的caf́e。从最初的caf́e退出后会完全退出了Scheme。 caf́e可以通过显式调用exit或通过接收end-of-file（Unix系统上为“ control-D”）来退出。在前一种情况下，传递给exit的任何值都是从new-cafe返回的。\n\u0026gt; (define x 1) \u0026gt; x 1 \u0026gt; (new-cafe) \u0026gt;\u0026gt; x 1 \u0026gt;\u0026gt; (define y 2) \u0026gt;\u0026gt; y 2 \u0026gt;\u0026gt; (exit 1) 1 如果指定了可选的eval-proc 参数，则使用eval-proc 求值从控制台输入的程序。 否则，将使用参数current-eval 的值。 eval-proc必须接受一个参数，即要求值的表达式。\n\u0026gt; (new-cafe (lambda (x) x)) \u0026gt;\u0026gt; 3 3 \u0026gt;\u0026gt; (a . (b . (c . ()))) (a b c) \u0026gt; (define sum (lambda (ls) (if (null? ls) 0 (+ (car ls) (sum (cdr ls)))))) \u0026gt; (new-cafe sum) \u0026gt;\u0026gt; (1 2 3) 6 时间和日期 时间由时间对象表示。 时间对象记录特定时间或持续时间的纳秒和秒，以及标识时间对象性质的time type 。 时间类型是以下符号之一：time-utc: 从“纪元”1970年1月1日0点0分0秒以来的时间time-monotonic: 从过去某个任意时间点开始经过的时间，理想情况下无需进行调整。time-duration: 两个时间的间隔。当作为current-time的参数时，其行为与time-monotonic类似，但也可以用来表示两个时间对象相减的结果time-process: 当前进程使用的CPU时间量。time-thread: 当前线程使用的CPU时间量。 如果未运行线程，或者系统不允许确定单个线程时间，则该时间与time-process相同。time-collector-cpu: 当前进程用于垃圾回收的这部分CPU消耗的时间。time-collector-real: 当前进程用于垃圾回收的这部分实时消耗的时间日期由日期对象表示。 日期对象记录特定日期的纳秒，秒，分钟，小时，日，月和年，以及标识时区的偏移量。\n (current-time) | (current-time time-type)\n time-type 必须是上述的时间对象之一，默认为time-utc\n(current-time) ⇒ #\u0026lt;time-utc 1198815722.473668000\u0026gt; (current-time ’time-process) ⇒ #\u0026lt;time-process 0.120534264\u0026gt;  (make-time type nsec sec)\n type 必须是上面列出的时间类型符号之一。 nsec 表示纳秒，并且必须是小于$10^9$的精确非负整数。sec 表示秒，并且必须是精确的整数。\n(make-time \u0026#39;time-utc 787511000 1198783214) (make-time \u0026#39;time-duration 10 5) (make-time \u0026#39;time-duration 10 -5)  (time? obj)\n (time? (current-time)) ⇒ #t (time? (make-time ’time-utc 0 0)) ⇒ #t (time? \u0026#34;1400 hours\u0026#34;) ⇒ #f  (time-type time)\n 返回time 的时间类型\n (time-nanosecond time)\n 返回time 的纳秒\n (time-second time)\n 返回time 的秒\n (set-time-type! time type) | (set-time-nanosecond! time nsec) | (set-time-second! time sec)\n 每一个过程都会修改时间对象，只改变局部，而其他值则不受影响。 例如，set-time-nanosecond! 只更改纳秒时间，而不更改秒或类型。 特别地，当时间对象的类型改变时，值并不会更改。\n (time=? time1 time2) | (time\u0026lt;? time1 time2) | (time\u0026gt;? time1 time2) | (time\u0026lt;=? time1 time2) | (time\u0026gt;=? time1 time2)\n 时间比较。\n (copy-time time)\n 复制时间。\n(define t1 (current-time)) (define t2 (copy-time t1)) (eq? t2 t1) ⇒ #f (eqv? (time-second t2) (time-second t1)) ⇒ #t (eqv? (time-nanosecond t2) (time-nanosecond t1)) ⇒ #t  (time-difference time1 time2 ) | (time-difference! time1 time2 ) | (add-duration time timed) | (add-duration! time timed) | (subtract-duration time timed) | (subtract-duration! time timed)\n 对于time-difference，time1和time2必须具有相同的时间类型，结果是时间类型为time-duration的时间对象。 对于add-duration，add-duration！，subtract-duration和subtract-duration！，timed必须具有时间类型time-duration，并且结果是时间类型与时间相同的时间对象。 time-difference！，add-duration！和subtract-duration！ 可能具有破坏性，即每个对象都可能修改并返回其第一个参数，或者可能分配了新的时间对象\n(let ([delay (make-time \u0026#39;time-duration 0 1)]) (let ([t1 (current-time \u0026#39;time-monotonic)]) (sleep delay) (let ([t2 (current-time \u0026#39;time-monotonic)]) (let ([t3 (time-difference t2 t1)]) (and (eq? (time-type t3) \u0026#39;time-duration) (time\u0026gt;=? t3 delay) (time=? (add-duration t1 t3) t2) (time=? (subtract-duration t2 t3) t1)))))) ⇒ #t  (current-date) | (current-date offset)\n 如上所述，offset 表示UTC以东的时区偏移量（以秒为单位）。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 可以通过传递零偏移量来获得UTC.offset表示UTC以东以秒为单位的时区偏移量，如上所述。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 UTC可以通过传递零偏移来获得。\n如果未提供offset ，则使用当前时区的offset，以及date-dst？ 和date-zone-name报告有关时区的信息。 如果提供了偏移量，那么date-dst？ 和结果日期对象上的date-zone-name都是**#f**。\n(current-date) ⇒ #\u0026lt;date Thu Dec 27 23:23:20 2007\u0026gt; (current-date 0) ⇒ #\u0026lt;date Fri Dec 28 04:23:20 2007\u0026gt; (date-zone-name (current-date)) ⇒ \u0026#34;EST\u0026#34; or other system-provided string (date-zone-name (current-date 0)) ⇒ #f  (make-date nsec sec min hour day mon year) | (make-date nsec sec min hour day mon year offset)\n nsec代表纳秒，并且必须是小于$10^9$的精确非负整数。sec代表秒，并且必须是小于62的精确非负整数。min代表分钟，并且必须是小于60的精确非负整数。hour必须是精确的非负整数 小于24。day必须是一个精确的整数，1≤day≤31。（实际上限可能取决于月份和年份。）mon表示月份必须是一个精确的整数，1≤mon≤12。年必须 是一个精确的整数。 如上所述，它应至少为1970。offset表示UTC以东的时区偏移（以秒为单位）。 它必须是-86400到+86400（含）范围内的精确整数。 可以通过传递零偏移量来指定UTC。\n(make-date 0 0 0 0 1 1 1970 0) ⇒ #\u0026lt;date Thu Jan 1 00:00:00 1970\u0026gt; (make-date 0 30 7 9 23 9 2007 -14400) ⇒ #\u0026lt;date Sun Sep 23 09:07:30 2007\u0026gt; (date-zone-name (make-date 0 30 7 9 23 9 2007 -14400)) ⇒ #f (string? (date-zone-name (make-date 0 30 7 9 23 9 2007))) ⇒ #t  (date-nanosecond date) | (date-second date) | (date-minute date) | (date-hour date) | (date-day date) | (date-month date) | (date-year date) | (date-zone-offset date)\n 如字面的意思， 返回日期的对应的部分的值\n (date-week-day date) | (date-year-day date)\n 通过这些过程，可以确定以date 表示的日期是星期几还是每年的某天。 week-day是小于7的精确非负整数，其中0表示星期日，1表示星期一，依此类推。 year-day是小于367的精确非负整数，其中0代表一年的第一天（1月1日），1代表第二天，2代表第三天，依此类推。\n (time-utc-\u0026gt;date time) | (time-utc-\u0026gt;date time offset) | (date-\u0026gt;time-utc date)\n 这些过程用于在时间和日期对象之间进行转换。 time-utc-\u0026gt;date的时间参数必须具有time-type utc，date-\u0026gt;time-utc始终返回带有time-type utc的时间对象。\n对于time-utc-\u0026gt;date，offset 表示UTC以东的秒数中的时区偏移，如本节开头所述。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 UTC可以通过传递零偏移来获得。\n (date-and-time) | (date-and-time date)\n 字符串始终采用以下示例所示的格式，长度始终为24。\n(date-and-time) ⇒ \u0026#34;Fri Jul 13 13:13:13 2001\u0026#34; (defined (make-date 0 0 0 0 1 1 2007 0)) (date-and-time d) ⇒ \u0026#34;Mon Jan 01 00:00:00 2007\u0026#34;  (sleep time)\n time 必须是类型为time-duration的时间对象。 sleep 导致调用线程在大约由时间对象指示的时间量内暂停操作，除非该进程收到中断睡眠操作的信号。 实际睡眠时间取决于系统时钟的粒度以及系统运行其他线程和进程的繁忙程度。\n时间和统计  (time expr) time求值expr ，并且作为副作用，打印（到console-output端口）cpu时间量，实时时间量，分配的字节数以及与求值expr 相关的收集开销。\n \u0026gt; (time (collect)) (time (collect)) 1 collection 1 ms elapsed cpu time, including 1 ms collecting 1 ms elapsed real time, including 1 ms collecting 160 bytes allocated, including 8184 bytes reclaimed   (cpu-time)\n 返回：自系统启动以来消耗的cpu时间量。\n该量以毫秒为单位。 该数量包括“system”时间和“user”时间，即代表进程在内核中花费的时间以及在进程本身中花费的时间。\n (real-time)\n 返回：自系统启动以来经过的实时时间\n以毫秒为单位的时间总量\n (bytes-allocated) | (bytes-allocated g)\n 返回：当前分配的字节数\n如果提供了g ，则bytes-allocated返回指定generation中当前为Scheme对象分配的字节数。 g 必须为非负精确整数，且不得大于最大非静态generation，即，collect-maximum-generation返回的值或符号为static。 如果未提供g ，则bytes-allocated返回所有generation中分配的字节总数。\n (initial-bytes-allocated)\n 返回：加载启动文件后分配的总字节数\n (bytes-deallocated)\n 返回：垃圾回收器释放的总字节数\n通过将（bytes-deallocated）和（bytes-allocated）相加并减去（initial-bytes-allocated），可以获得当前进程分配的总字节数（无论是否仍在使用中）。\n (current-memory-bytes)\n 返回：当前分配的字节总数，包括开销.\ncurrent-memory-bytes返回堆的总大小（以字节为单位），不仅包括Scheme对象占用的字节，还包括各种形式的开销（包括碎片和保留但当前不占用的内存），因此，它是操作系统中当前进程的堆内存量的准确度量值\n (maximum-memory-bytes)\n 返回：分配过的最大字节数，包括开销\n (reset-maximum-memory-bytes!)\n 将堆内存的最大记录值重置为当前堆大小\n (collections)\n 返回：到目前为止的垃圾回收次数\n (statistics)\n 返回：包含当前统计信息的sstats记录\nstatistics将各种时间和分配统计信息打包在一起，形成一个sstats记录。 sstats记录具有以下字段：\n         cpu, 消耗的cpu时间   real, 经过的时间   bytes, 分配的字节数   gc-count, gc次数   gc-real, gc经历的时间   gc-bytes, gc回收的字节数    所有值都是从系统启动开始算\nstatistics可以像如下定义：\n(define statistics (lambda () (make-sstats (current-time ’time-thread) (current-time ’time-monotonic) (- (+ (bytes-allocated) (bytes-deallocated)) (initial-bytes-allocated)) (collections) (current-time ’time-collector-cpu) (current-time ’time-collector-real) (bytes-deallocated))))  (make-sstats cpu real bytes gc-count gc-cpu gc-real gc-bytes) 返回：sstats记录\n  (sstats-cpu s) | (sstats-real s) | (sstats-bytes s) | (sstats-gc-count s) | (sstats-gc-cpu s) | (sstats-gc-real s) | (sstats-gc-bytes s)\n 返回：s 对应的部分的值\n (set-sstats-cpu! s new-value) | (set-sstats-real! s new-value) | (set-sstats-bytes! s new-value) | (set-sstats-gc-count! s new-value) | (set-sstats-gc-cpu! s new-value) | (set-sstats-gc-real! s new-value) | (set-sstats-gc-bytes! s new-value)\n 设置对应部分的值\n (sstats-difference s1 s2)\n 比较两个sstats\n enable-object-counts\n enable-object-counts的值是一个布尔值，它确定收集器在运行时是否记录对象计数，从而确定过程对象计数返回的object-counts是否准确。 由于启用对象计数会增加收集的开销，因此默认情况下该参数设置为#f。\n (object-counts)\n 过程object-countsx返回一个嵌套的关联列表，该列表表示为一个或多个世代中至少有一个活动实例的每个堆分配的原始类型和记录类型分配的对象计数和字节。 （堆分配的基本类型包括，例如，pair和向量，但不包括，例如，fixnum或字符。）仅当enable-object-countsxx为#t时，收集器才会收集对象计数。\nobject-countsx返回的关联列表具有以下结构： ((type (generation count . bytes) \u0026hellip;) \u0026hellip;)\ntype是原始类型的名称，以符号（例如，对）表示，或者是record-type描述符（rtd）。 generation是介于0和（collect-maximum-generation）的值（包含在内）或表示静态生成的符号static之间的非负固定编号。 count和字节是非负的fixnum。\n(collect-request-handler void) (enable-object-counts #t) (define-record-type frob (fields x)) (define x (make-frob (make-frob #f))) (collect 3 3) (cdr (assoc 3 (cdr (assoc (record-type-descriptor frob) (object-counts))))) =\u0026gt; (2. 16) 成本中心 Cost Centers 成本中心用于在求值选定的代码段时跟踪分配的字节，执行的指令和/或经过的CPU时间。 成本中心是通过过程make-cost-center创建的，而成本是通过with-cost-center过程进行跟踪的。\n仅为此目的代码跟踪分配和指令计数。 该工具由两个参数控制：generate-allocation-counts和generate-instruction-counts。 默认情况下禁用检测。 内置程序没有检测，解释代码或非Scheme代码也没有。 仅当过程with-cost-center的可选参数*timed?*有值且不为false时才会跟踪经历的时间\nwith-cost-center过程即使在使用同一成本中心重新输入，在多个线程中同时使用并通过继续调用退出或重新输入一次或多次后，也要遵循上述注意事项来准确跟踪成本。\n generate-allocation-counts\n 当此参数为true时，编译器会在生成的代码的每个分配点插入一小段指令，以跟踪发生的分配量。此参数最初为false。\n generate-instruction-counts\n 当此参数为true时，编译器将在生成的代码的每个块中插入简短的指令序列，以跟踪该块执行的指令数。 此参数最初为false。\n (make-cost-center)\n 返回: 新的成本中心\n (with-cost-center cost-center thunk) | (with-cost-center timed? cost-center thunk)\n thunk 必须是一个接受零参数的过程。 with-cost-center调用不带参数的thunk 并返回其值。 它还可以动态计算分配的字节数，执行的指令以及在计算thunk 调用时所经过的cpu时间，并将跟踪的成本添加到成本中心记录中。\n如上所述，仅对于将参数generate-allocation-counts 设置为true的编译的代码跟踪分配计数，并且仅对将generate-instruction-counts 设置为true的编译的代码跟踪指令计数。 仅在提供timed? 且不为false的情况下，才会跟踪cpu时间，其中包括在已测量的代码，未测量代码和非Scheme代码中花费的cpu时间。\n (cost-center-instruction-count cost-center)\n 返回：成本中心跟踪的指令数\n (cost-center-allocation-count cost-center)\n 返回：成本中心跟踪的已分配字节数\n (cost-center-time cost-center)\n 返回：成本中心跟踪的CPU时间\n (reset-cost-center! cost-center)\n 此过程将成本中心记录的成本重置为零。\n参数 本节介绍了用于创建和操作参数的机制。 可以使用make-parameter方便地创建新参数。 但是，除了它们的行为外，没有什么能将参数与其他过程区分开。 如果调用参数时必须采取比通过make-parameter机制容易容纳的更为复杂的动作，则可以直接使用case-lambda定义该参数\n (make-parameter object) | (make-parameter object procudure)\n make-parameter接受一个或两个参数。 第一个参数是内部变量的初始值，第二个参数（如果存在）是应用于初始值和所有后续值的过滤器。 过滤器应接受一个参数。 如果该值不合适，则过滤器应引发异常或将值转换为更合适的形式。\n例如，print-length的默认定义如下：\n(define print-length (make-parameter #f (lambda (x) (unless (or (not x) (and (fixnum? x) (fx\u0026gt;= x 0))) (assertion-violationf ’print-length \u0026#34;~s is not a positive fixnum or #f\u0026#34; x)) x))) (print-length) ⇒ #f (print-length 3) (print-length) ⇒ 3 (format\u0026#34;~s\u0026#34;’(123456)) ⇒ \u0026#34;(123...)\u0026#34; (print-length #f) (format\u0026#34;~s\u0026#34;’(123456)) ⇒ \u0026#34;(123456)\u0026#34; make-parameter的定义使用case-lambda很简单：\n(define make-parameter (case-lambda [(init guard) (let ([v (guard init)]) (case-lambda [() v] [(u) (set! v (guard u))]))] [(init) (make-parameter init (lambda (x) x))]))  (parameterize ((param expr) \u0026hellip;) body1 body2 \u0026hellip;)\n 使用语法形式parameterize，可以以类似于普通变量的fluid-let的方式更改参数的值。 在计算body时，将每个param 设置为相应的expr 的值。\n(define test (make-parameter 0)) (test) ⇒ 0 (test 1) (test) ⇒ 1 (parameterize ([test 2]) (test)) ⇒ 2 (test) ⇒ 1 (parameterize ([test 2]) (test 3) (test)) ⇒ 3 (test) ⇒ 1 (define k (lambda (x) x)) (begin (set! k (call/cc k)) ’k) ⇒ k (parameterize ([test 2]) (test (call/cc k)) (test)) ⇒ k (test) ⇒ 1 (k3) ⇒3 (test) ⇒ 1 虚拟寄存器Virtual registers 编译器支持一组有限的虚拟寄存器 ，以供需要高速，全局和可变存储位置的程序使用。 引用或分配虚拟寄存器可能比访问可分配的局部变量或全局变量更快，并且访问时永远不会比它们更慢，而且这样做的代码序列通常更小。 分配可能会显著加快，因为不需要跟踪从虚拟寄存器到年轻对象的指针，因为可能存在于较早一世代中的可变位置。 在系统的线程版本上，虚拟寄存器是“每个线程”的，因此可以以比线程参数低廉的方式用作thread-local存储。\n该接口包含三个过程：virtual-register-count（返回虚拟寄存器的数量），set-virtual-register!（设置指定的虚拟寄存器的值）和virtual-register（获取指定虚拟寄存器的值）。\n虚拟寄存器由小于虚拟寄存器数量的非负fixnum索引指定。 为了获得set-virtual-register!和virtual-register的最佳性能，索引应该是直接嵌入在调用中的常量（或者可以通过对调用的优化来传播）。 为了避免将这些常量放在源代码中，程序员应考虑使用标识符宏为虚拟寄存器命名，例如：\n(define-syntax current-state (identifier-syntax [id (virtual-register 0)] [(set! id e) (set-virtual-register! 0 e)])) (set! current-state \u0026#39;start) current-state ⇒ start 虚拟寄存器必须被视为应用程序级资源，即，打算由多个应用程序使用的库通常不应使用虚拟寄存器，以避免与应用程序使用寄存器冲突。\n (virtual-register-count)\n 从9.0版开始，虚拟寄存器的数量设置为16。除非通过源重新编译Chez Scheme，否则无法更改。\n (set-virtual-register! k x)\n **set-virtual-register!**将x 存储在虚拟寄存器k 中。 k 必须是小于（virtual-register-count）的值的非负fixnum。\n (virtual-register k)\n virtual-register返回最后一次存储在虚拟寄存器k 中的值（在当前线程上）。\n环境查询和设置Environmental Queries and Settings  (scheme-version)\n Chez Scheme的版本\n (threaded?)\n 返回：#t（如果在系统为线程版本），否则返回#f\n (get-process-id)\n 返回：当前进程的PID\n (getenv key)\n 返回：环境中key 的值，或 #f\n(getenv \u0026#34;HOME\u0026#34;) ⇒ \u0026#34;/u/freddy\u0026#34;  (putenv key value)\n key 和 value 必须是字符串\n(putenv \u0026#34;SCHEME\u0026#34; \u0026#34;rocks!\u0026#34;) (getenv \u0026#34;SCHEME\u0026#34;) ⇒ \u0026#34;rocks!\u0026#34;  (get-registry key)\n 返回：key 的注册表值，或者**#f**\n (put-registry! key val) | (remove-registry! key)\n key 和 value 必须是字符串\n","id":110,"section":"posts","summary":"异常 (warning who msg irritant \u0026hellip;) 返回：未指定 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止","tags":["scheme"],"title":"系统操作(System Operations in Chez Scheme)","uri":"https://lvsq.net/2020/02/system-operations/","year":"2020"},{"content":"define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回true的谓词、以及每个字段的访问procedure和针对可变字段的赋值procedure。总的来说，与Java中的POJO类比较相似，不过不用自定义getter和setter方法，这与Kotlin倒为类似，例如：\n(define-record-type point (fields x y)) 创建了一个名为point的record类型，并且有两个字段x和y，和如下几个定义式（自动生成）：         (make-point x y) 构造函数   (point? obj) 谓词   (point-x p) 字段x的访问器   (point-y p) 字段y的访问器    默认下，字段是不可变的，但是可以声明为可变的（mutable）。如下定义point中，字段x是可变的，但y维持不变：\n(define-record-type point (fields (mutable x) y)) 当然亦可显式地将字段声明为不可变的：\n(define-record-type point (fields (mutable x) (immutable y))) 在这个例子中，define-record-type除了生成了上述的几个定义式之外，还为字段x增加了一个赋值过程：\n(point-x-set! p x)\n该赋值过程可以用于改变x的内容\n(define p (make-point 36 -17)) (point-x-set! p (- (point-x p) 12)) (point-x p) =\u0026gt; 24 自动生成的几个定义式是允许改变名称的，下面的point定义式，其构造函数名为mkpoint, 谓词为ispoint?，x和y的访问器分别为x-val和y-val, x的赋值器为set-x-val!\n(define-record-type (point mkpoint ispoint?) (fields (mutable x x-val set-x-val!) (immutable y y-val))) 默认情况下，每次一个record definition创建一个新类型（为方便理解，可以用Java来解释，即对于同一个POJO类new出两个实例，但这两个实例并不能equal），如下所示：\n(define (f p) (define-record-type point (fields x y)) (if (eq? p \u0026#39;make) (make-point 3 4) (point? p))) (f (f \u0026#39;make)) =\u0026gt; #f 第一个f的调用即(f \u0026lsquo;make)返回一个point类型的p，将p传递给第二个f，但p是由第一个调用生成的类型，所以point?返回#f。按照SICP的说法，这两个define-record-type并不在一个环境中，只是名字一样而已。\n默认的生产行为(generative behavior)或许可以由记录定义式中的nongenerative子句来重载：\n(define (f p) (define-record-type point (fields x y) (nongenerative)) (if (eq? p \u0026#39;make) (make-point 3 4) (point? p))) (f (f \u0026#39;make)) =\u0026gt; #t 以这种方式创建的记录类型仍然不同于由定义出现在程序的不同部分中创建的记录类型，即使这些定义在语法上是相同的：\n(define (f) (define-record-type point (fields x y) (nongenerative)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative)) (point? p)) (g (f)) =\u0026gt; #f 甚至可以通过在nongenerative子句中包含uid（唯一id）来覆盖它：\n(define (f) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (point? p)) (g (f)) =\u0026gt; #t 记录类型可以定义为有parent子句的子类型，即一个记录类型可以声明为某一个记录类型的子类型，如果指定了父类型，则子类型将继承父类型所有字段，且子类型的每个实例都被视为父类型的实例，因此可以直接使用父类型的访问器和字段等等。\n(define-record-type point (fields x y)) (define-record-type cpoint (parent point) (fields color)) (define cp (make-cpoint 3 4 \u0026#39;red)) (point? (make-cpoint 3 4 \u0026#39;red)) =\u0026gt;  #t (cpoint? (make-point 3 4)) =\u0026gt; #f (define cp (make-cpoint 3 4 \u0026#39;red)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (cpoint-color cp) =\u0026gt; red 到目前为止，define-record-type定义的默认构造函数接受record包含的字段一样多的参数，其实我们可以重写默认值，这里需要引入protocol子句，以下定义将创建一个具有三个字段的点记录：x，y和d，其中d表示距原点的位移。构造函数仍然只接受两个参数，即x和y值，并将d初始化为x和y平方和的平方根。\n(define-record-type point (fields x y d) (protocol (lambda (new) (lambda (x y) (new x y (sqrt (+ (* x x) (* y y)))))))) (define p (make-point 3 4)) (point-x p) =\u0026gt; 3 (point-y p) =\u0026gt; 4 (point-d p) =\u0026gt; 5 另外，子类型的构造函数中的参数顺序是不可改变的，即先是父类型构造函数的字段，然后才是子类型的参数，如果需要改变子类型的构造函数的参数顺序该如何呢？\n(define-record-type cpoint (parent point) (fields color) (protocol (lambda (pargs-\u0026gt;new) (lambda (x c y) ((pargs-\u0026gt;new x y) c))))) (define cp (make-cpoint 3 \u0026#39;red 4)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (point-d cp) =\u0026gt; 5 (cpoint-color cp) =\u0026gt; red 最后来看看define-record-type的语法形式：\n syntax: (define-record-type record-name clause \u0026hellip;)\n  syntax: (define-record-type (record-name constructor pred) clause \u0026hellip;)\n Fields clause语法形式:\n (fields field-spec \u0026hellip;)\n field-spec必须是下面5个中的一个:\n field-name (immmutable field-name) (mutable field-name) (immmutable field-name accessor-name) (mutable field-name accessor-name mutator-name)   define-record in Chez Scheme Chez Scheme依然支持$R^6RS$中传统的record类型的定义，另外还提供一个新的语法，即define-record，其语法形式与define-record-type一样，所不同的地方在于，define-record中的字段默认是可变的，这与$R^6RS$中的record相反，因此，创建一个记录类型时，同时会定义下列过程：\n(define-record point (x y)) (make-point x y) ;;\tconstructor (point? obj) ;;\tpredicate (point-x p) ;;\taccessor for field x (point-y p) ;;\taccessor for field y (set-point-x! p obj) ;;\tmutator for field x (set-point-y! p obj) ;;\tmutator for field y  通过对define-record-type的了解，可以发现其非常OO，smalltalk是否受其影响不得而知，至少经过纵向比较对于我们学习技术大有裨益。\n","id":111,"section":"posts","summary":"define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回tr","tags":["scheme"],"title":"Scheme语法define-record-type介绍","uri":"https://lvsq.net/2020/02/define-record-type/","year":"2020"},{"content":"Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以在 Chez Scheme 中以“微模块”级别使用，因为 Chez Scheme 中的模块和 import 形式属于定义，并且可以出现在定义可以出现的任意位置，包括在 lambda 表达式的程序体或其他局部作用域中。\n 微模块与函数孰好？？？还是视情况而定？？？\n 模块控制绑定的可见性，可以用作扩展词法作用域，以允许更精确地控制绑定的可见范围。模块导出标识符的绑定，即变量绑定、关键字绑定或模块名绑定。模块可以是具名的抑或匿名的。只要模块名可见，那么在具名模块出现处导入的绑定都可见。匿名模块中导出的绑定，在模块出现的地方被隐式地导入。匿名模块可用于隐藏一组绑定中的一些绑定，同时允许其余绑定可见。\n语法  (module name interface defn \u0026hellip; init \u0026hellip;)\n  (module interface defn \u0026hellip; init \u0026hellip;)\n name 是标识符，defn \u0026hellip; 是定义，init \u0026hellip; 是表达式。interface 是形如 (export \u0026hellip;) 的导出表，其中每个 export 都是标识符 identifier 抑或形式 (identifier export \u0026hellip;)。\n模块由一组（可能为空的）定义和一组（可能为空的）初始化表达式序列组成。模块中定义的标识符（可理解为变量或者状态，下同）在模块的程序体中可见，被导出的标识符在模块的导入作用域内亦可见。模块接口中列出的每个标识符必须在该模块中定义或被导入该到模块。module 形式是一种定义，因此可以出现在其他定义可以出现的任何位置，包括嵌套在 lambda 表达式的程序体、 library 形式、顶层程序，以及嵌套在其他模块中。此外，因为模块名的作用域与其他标识符相同，所以模块和库可以像变量和关键字那样导出模块名。\n模块名与其他标识符占用相同的名字空间，并遵循相同的作用域规则。除非被导出，否则模块中定义的标识符仅在该模块中可见。\n模块内的表达式可以引用在模块外部绑定的标识符。\n(let ([x 3]) (module m (plusx) (define plusx (lambda (y) (+ x y)))) (import m) (let ([x 4]) (plusx 5))) ; =\u0026gt; 8,注意不是9哦，可以将plusx视为：(define plusx (lambda (y) (+ 3 y)))) 同样，import不会阻止访问出现导入表单的可见标识符，但import标识符所覆盖的变量除外（啥叫覆盖，看下面两段代码）。\n(module m (y) (define y \u0026#39;m-y)) (let ([x \u0026#39;local-x] [y \u0026#39;local-y]) (import m) (list x y)) ; =\u0026gt; (local-x m-y) 模块m中定义了标识符y, 在其被import之后会覆盖let中的y；\n(module m (y) (define y \u0026#39;m-y)) (let () (import m) (let ([x \u0026#39;local-x] [y \u0026#39;local-y]) (list x y)) ; =\u0026gt; (local-x local-y) ) 先import m，之后再定义y，模块中定义的y不会覆盖let的y。\n另一方面，在模块中使用 import-only 会建立一个隔离的作用域，其中唯一可见的是被导入模块所导出的标识符，下面的代码中只有y可见。对于静态验证，有时不希望使用任何标识符，除了明确导入模块或本地范围的标识符外，这有时是合乎需要的。\n(module m (y) (define y \u0026#39;m-y)) (let ([x \u0026#39;local-x] [y \u0026#39;local-y]) (import-only m) x) ; =\u0026gt; Error: x is not visible 除非通过“import-only”导入的模块导出“import”或“import-only”以及至少一个模块的名称，否则无法在“import-only”范围内进行后续导入。 要创建一个包含多个模块导出的隔离范围而又不使“import”或“import-only”可见，必须以相同的“import-only”形式列出所有要导入的模块。\n另一种解决方案是创建一个包含每个其他模块的导出的模块。\n(module m2 (y) (define y \u0026#39;y)) (module m1 (x) (define x \u0026#39;x)) (module mega-module (cons x y) (import m1) (import m2) (import scheme)) (let ([y 3]) (import-only mega-module) (cons x y)) ; =\u0026gt; (x . y) 在它被编译之前，源程序被翻译成不含语法抽象、语法定义、库定义、模块定义以及 import 形式的核心语言程序。翻译由语法展开器负责，语法展开器以递归下降的方式处理源程序中的形式。\nmodule 和 import 特殊形式仅影响标识符(identifier)在源程序中的可见性，而不影响其含义。特别地，无论变量被绑定到在模块内部或外部定义的位置，import 都不会引入新位置。为了保持由模块和语法抽象建立的作用域关系，局部变量在必要时会被重命名。因此，表达式：\n(let ([x 1]) (module m (x setter) (define-syntax x (identifier-syntax z)) (define setter (lambda (x) (set! z x))) (define z 5)) (let ([y x] [z 0]) (import m) (setter 3) (+ x y z))) ; =\u0026gt; 4 等价于下面的表达式，其中标识符被统一地更名，并带上了下标：\n(let ([x0 1]) (define-syntax x1 (identifier-syntax z1)) (define setter1 (lambda (x2) (set! z1 x2))) (define z1 5) (let ([y3 x0] [z3 0]) (setter1 3) (+ x1 y3 z3))) 互递归module (module (a b) (module a (x) (define x (lambda () y))) (module b (y) (define y (lambda () x))) (import a) (import b)) 此模式的一般化语法定义如下，允许定义多个互递归的模块\n(define-syntax rec-modules (syntax-rules (module) [(_ (module m (id ...) form ...) ...) (module (m ...) (module m (id ...) form ...) ... (import m) ...)])) 组合module 由于模块可以重新导出所导入的绑定，所以很容易在单个模块上提供多个视图，就像下面的 s 和 t 为 r 提供的视图那样，或者将几个模块组合成一个复合，就像 r 那样。\n(module p (x y) (define x 1) (define y 2)) (module q (y z) (define y 3) (define z 4)) (module r (a b c d) (import* p (a x) (b y)) (import* q (c y) (d z))) (module s (a c) (import r)) (module t (b d) (import r)) import* 稍微解释一下import*, 其语法定义如下：\n(define-syntax import* (syntax-rules () [(_ m) (begin)] [(_ m (new old)) (module (new) (module (tmp) (import m) (alias tmp old)) (alias new tmp))] [(_ m id) (module (id) (import m))] [(_ m spec0 spec1 ...) (begin (import* m spec0) (import* m spec1 ...))])) 它支持重命名import的绑定和选择性导入特定的绑定，无需使用内置的import子形式来选择和重命名标识符，举例来说：\n(let () (import* scheme (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7) (let () (import* (rnrs) (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7) 元定义Meta Definitions  语法：(meta . definition)\n meta 关键字实际上是一个可以放在任何定义关键字前面的前缀，例如，\n (meta define x 3)\n 它告诉展开器，该定义式产生的任何变量定义都只是展开期定义，只能用于其他元定义的右侧，最主要是用在转换器表达式中。它用于定义展开期辅助函数，以及供一个或多个 syntax-case 转换器所使用的其他信息。\n元定义的语义类似于let*，它可以是自递归，但不是互递归的。\n元定义通过宏展开传播，因此可以编写，例如：\n(module (a) (meta define-record foo (x)) (define-syntax a (let ([q (make-foo #\u0026#39;\u0026#39;q)]) (lambda (x) (foo-x q))))) a ；=\u0026gt; q 条件展开Conditional expansion 可以通过 meta-cond 在展开期做出决策，这类似于 cond，但是是在展开期求值并测试表达式，并且可以在预期为定义的上下文中以及在表达式上下文中使用。\n 语法：(meta-cond clause1 clause2 \u0026hellip;)\n 除了最后一个 clause，其余的必须采取以下形式：\n (test expr1 expr2 \u0026hellip;)\n 最后一个 cluase 除可采取上述形式外，还可以使用下面的 else 子句形式：\n (else expr1 expr2 \u0026hellip;)\n 在展开期间，test 表达式会被顺序地求值，直到某条表达式求值为真或者求值完所有的表达式为止。如果一条 test 表达式求值为真，则 meta-cond 形式将展开为包含相应表达式 expr1 expr2 \u0026hellip; 所组成的 begin 形式。如果没有求值为真的 test 表达式，且存在 else 子句，则 meta-cond 形式将展开为由来自于 else 子句的表达式 expr1 expr2 \u0026hellip; 所组成的 begin 形式。否则，meta-cond 表达式展开为对 void 过程的调用。\nmeta-cond 可以按如下定义：\n(define-syntax meta-cond (syntax-rules () [(_ [a0 a1 a2 ...] [b0 b1 b2 ...] ...) (let-syntax ([expr (cond [a0 (identifier-syntax (begin a1 a2 ...))] [b0 (identifier-syntax (begin b1 b2 ...))] ...)]) expr)])) meta-cond 用于在展开期从一组可能的形式中进行选择。例如，程序员可以定义过程的安全（进行错误检查）和不安全（不进行错误检查）版本，并根据编译期优化级别决定调用版本，如下所示:\n(meta-cond [(= (optimize-level) 3) (unsafe-frob x)] [else (safe-frob x)]) 别名Aliases  语法：(alias id1 id2)\n alias 是一类定义，可以出现在其他定义可以出现的任何位置。它用于将绑定从一个标识符转移到另一个标识符。\n(let ([x 3]) (alias y x) (set! y 4) (list x y)) ; =\u0026gt; (4 4) 由于展开是由左至右进行的，别名应该出现在右侧的标识符的定义之后，例如：\n(let () (import-only (chezscheme)) (define y 3) (alias x y) x) ; =\u0026gt; 3 而不是：\n(let () (import-only (chezscheme)) (alias x y) (define y 3) x) ; =\u0026gt; exception: unbound identifier ","id":112,"section":"posts","summary":"Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以","tags":["modules"],"title":"Chez Scheme Modules","uri":"https://lvsq.net/2020/01/modules/","year":"2020"},{"content":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。\n (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_ ((a1 v1) (a2 v2) ...) bodys ...) (let ((a1 v1)) (my-let* ((a2 v2) ...) bodys ...)) ) ) ) 注意，my-let*是可以递归使用的，以及**\u0026hellip;**的用法。\n(define-syntax my-let* (syntax-rules () ( (_ () bodys ...) (let () bodys ...) ) ( (_ ((a1 v1) ...) bodys ...) (let () (define a1 v1) ... bodys ... ) ) ) ) 这个实现方式与上面的不同，上面的是嵌套let，这里将直接按顺序define内部变量，代码更短。注意此处的**\u0026hellip;**的用法。\n","id":113,"section":"posts","summary":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。 (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_","tags":["scheme"],"title":"自定义 Let*","uri":"https://lvsq.net/2020/01/my-let/","year":"2020"},{"content":"Fluid Keyword Bindings fluid-let-syntax  语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩展期间会暂时更改keyword的现有绑定，而不是引入keyword的新绑定。也就是说，在扩展form1 form2 \u0026hellip;的过程中，每个keyword的可见范围（或顶级）将会临时替换为新的绑定关系。\n (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 2 ) ) ) (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (fluid-let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 1 ) ) ) 对比上述两段代码，可知：两个表达式基本相同的，除了前者采用内部let-synctax语法，第二个采用fluid-let-syntax语法。在第一个表达式中，(g 1)扩展中的出现的f引用的是let-bound的变量f，而第二个表达式，f引用的是由fluid-let-syntax绑定的f\n","id":114,"section":"posts","summary":"Fluid Keyword Bindings fluid-let-syntax 语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩","tags":["module","syntactic"],"title":"Syntactic Extension and Modules in Chez Scheme","uri":"https://lvsq.net/2020/01/syntactic-extension-and-modules/","year":"2020"},{"content":"Chez Scheme中有一种Boxes结构，它是一个单元素对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构可以共享指向一个对象的引用，或指针。例如，在采用此种参数传递规则的语言的解释器中，可以用 boxes 实现 call-by-reference 的语义。解释有点绕，按我的理解boxes就相当于Golang的struct、Java中的类，将一些状态包装成一个整块，外界通过引用该整块的指针来访问内部的各个状态。\nBoxes 的字面形式带有前缀 #\u0026amp; (发音为 “hash-ampersand”). 例如， #\u0026amp;(a b c) 是一个 box，内容为列表 (a b c). 读取器若遇到 #!r6rs ，则会在其后的输入流中禁用 box 语法，除非在更近的位置遇到 #!chezscheme.\n所有 boxes 默认是可变的，包括常量。程序可以通过 box-immutable 创建不可变 boxes. 尝试修改不可变 box 会导致抛出异常。\n我们来看看一些用法：\n (box? obj) 如果 obj 是 box, 则为 #t, 否则为 #f.\n(box? \u0026#39;#\u0026amp;a) =\u0026gt; #t (box? \u0026#39;a) =\u0026gt; #f (box? (box 3)) =\u0026gt; #t (box obj) 创建一个由obj组成的box\n(box \u0026#39;a) =\u0026gt; #\u0026amp;a (box (box \u0026#39;(a b c))) =\u0026gt; #\u0026amp;#\u0026amp;(a b c) (unbox box) 返回box的内容\n(unbox #\u0026amp;a) =\u0026gt; a (unbox #\u0026amp;#\u0026amp;(a b c)) =\u0026gt; #\u0026amp;(a b c) (let ([b (box \u0026#34;hi\u0026#34;)]) (unbox b)) =\u0026gt; \u0026#34;hi\u0026#34; (set-box! box obj) box 必须是可变的。 set-box! 把 box 的内容设置为 obj.\n(let ([b (box \u0026#39;x)]) (set-box! b \u0026#39;y) b) =\u0026gt; #\u0026amp;y (let ([incr! (lambda (x) (set-box! x (+ (unbox x) 1)))]) (let ([b (box 3)]) (incr! b) (unbox b))) =\u0026gt; 4 (box-cas! box old-obj new-obj) 如果 box 被改变，则为 #t, 否则为 #f.box 必须是可变的。 若 box 待替换的内容和 old-obj 相同(基于 eq?), 则 box-cas! 自动将 box 的内容替换为 new-obj; 若不相同，则 box 保持不变。即CAS操作，原子的。\n(define b (box \u0026#39;old)) (box-cas! b \u0026#39;old \u0026#39;new) =\u0026gt; #t (unbox b) =\u0026gt; \u0026#39;new (box-cas! b \u0026#39;other \u0026#39;wrong) =\u0026gt; #f (unbox b) =\u0026gt; \u0026#39;new (mutable-box? obj) 如果 obj 是可变的 box ，则为 #t, 否则为 #f.\n(immutable-box? obj) 如果 obj 是不可变的 box ，则为 #t, 否则为 #f.\n(box-immutable obj) 返回一个内容为obj的不可变的box。Boxes 通常用来支持共享的，可变的结构，所以不可变的 box 一般没什么用。\n","id":115,"section":"posts","summary":"Chez Scheme中有一种Boxes结构，它是一个单元素对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构","tags":["scheme"],"title":"Chez Scheme中Boxes介绍","uri":"https://lvsq.net/2020/01/boxes-in-chez/","year":"2020"},{"content":"Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x)))\n(atom? \u0026#39;(a b c)) ⇒ #f (atom? \u0026#39;(3 . 4)) ⇒ #f (atom? \u0026#39;()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) n是一个非负整数，且小于等于list的长度；list-head和Scheme标准过程list-tail可能会同时使用来切割一个list，不同点在于，list-tail不会分配内存而只是返回源list的一个子列表，list-head总是返回源list前n个元素的副本\n(list-head \u0026#39;(a b c) 0) ⇒ () (list-head \u0026#39;(a b c) 2) ⇒ (a b) (list-head \u0026#39;(a b c) 3) ⇒ (a b c) (list-head \u0026#39;(a b c . d) 2) ⇒ (a b) (list-head \u0026#39;(a b c . d) 3) ⇒ (a b c) (list-head \u0026#39;#1=(a . #1#) 5) ⇒ (a a a a a) last-pair(Chez) 用法：(last-pair list) 列表不能为空。 last-pair返回列表的最后一对（pair）（不是最后一个元素）, list可能是不正确的列表，在这种情况下，最后一对是包含最后一个元素和终止对象的一个pair。\n(last-pair \u0026#39;(a b c d)) ⇒ (d) (last-pair \u0026#39;(a b c.d)) ⇒ (c . d) list-copy(Chez) 用法： (list-copy list) 返回一个list的副本，equal?（结构和值相同）判断为#t\nlist*(Chez) 用法：(list* obj \u0026hellip; final-obj)返回一个由obj \u0026hellip; final-obj 组成的list, 与R6RS的**cons***相同\nmake-list(Chez) 用法： (make-list n) 或者 (make-list n obj)返回n个对象的列表。n是一个正整数， 如果obj不指定，则返回的list是不确定的\n(make-list 0 \u0026#39;()) =\u0026gt; () (make-list 3 0) =\u0026gt; (0 0 0) (make-list 2 \u0026#34;hi\u0026#34;) =\u0026gt; (\u0026#34;hi\u0026#34; \u0026#34;hi\u0026#34;) iota(Chez) 用法：(iota n)返回从 0（包含）到 n（不包含）的整数列表，n须为精确的非负整数\n(iota 0) =\u0026gt; () (iota 5) =\u0026gt; (0 1 2 3 4) enumerate(Chez) 用法： (enumerate ls)返回: 从 0（包含）到长度 ls（不包含）的整数列表\n(enumerate \u0026#39;()) =\u0026gt; () (enumerate \u0026#39;(a b c)) =\u0026gt; (0 1 2) (let ([ls \u0026#39;(a b c)]) (map cons ls (enumerate ls))) =\u0026gt; ((a . 0) (b . 1) (c . 2)) remq! | remv! | remove!(Chez) 用法： (remq! obj list) | (remv! obj list) | (remove! obj list)返回: 列表中所有 obj 都被移除后的列表这些过程与 R6RS 中的 remq, remv, 及 remove 过程类似，只是 remq!, remv! 和 remove! 使用输入列表中的pair来构成输出列表。它们进行较少的空间分配，但并不一定比它们非破坏性的相应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(remq! \u0026#39;a \u0026#39;(a b a c a d)) ⇒ (b c d) (remv! #\\a \u0026#39;(#\\a #\\b #\\c)) =\u0026gt; (#\\b #\\c) (remove! \u0026#39;(c) \u0026#39;((a) (b) (c))) =\u0026gt; ((a) (b)) substq | substv | subst | substq! | substv! | subst!(Chez) 用法： (subs* new old tree)返回：在tree中将匹配到的old元素全部替换为new之后的tree.对于 substq 和 substq! ，相等性测试是基于 eq?, substv 和 substv! 是基于 eqv?, 而 subst 和 subst! 是基于 equal? substq!, substv!, 和 subst! 执行破坏性的替换。它们进行较少的空间分配，但并不一定比它们非破坏性的对应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(substq \u0026#39;a \u0026#39;b \u0026#39;((b c) b a)) =\u0026gt; ((a c) a a) (substv 2 1 \u0026#39;((1 . 2) (1 . 4) . 1)) =\u0026gt; ((2 . 2) (2 . 4) . 2) (subst \u0026#39;a \u0026#39;(a . b) \u0026#39;((a . b) (c a . b) . c)) =\u0026gt; (a (c . a) . c) (let ([tr \u0026#39;((b c) b a)]) (substq! \u0026#39;a \u0026#39;b tr) tr) =\u0026gt; ((a c) a a) reverse! 用法：(reverse! list)返回：将原list反向输出reverse! 通过反转其链接破坏性地反向排序列表。以 reverse! 取代 reverse 减少了空间分配，但并不一定比使用 reverse 更快。如果滥用，会很容易导致混乱或错误的结果。\n(reverse! \u0026#39;()) =\u0026gt; () (reverse! \u0026#39;(a b c)) =\u0026gt; (c b a) (let ([x \u0026#39;(a b c)]) (reverse! x) x) =\u0026gt; (a) (let ([x \u0026#39;(a b c)]) (set! x (reverse! x)) x) =\u0026gt; (c b a) append! 用法：(append! list \u0026hellip;)返回：将所有输入list串联起来的列表如同 append, append! 返回一个新的列表，其中元素依次为第一个列表中的元素，第二个列表中的元素，第三个列表中的元素，等等。不同之处在于， append! 重用所有参数中的点对以构造新列表。即，每一个列表参数的最后一个cdr, 其后一元素变为指向下一个列表参数。除最后一个参数外，如果任一参数为空列表，它实质上会被忽略。最后一个参数（并不一定得是列表）是不变的。\n相比于 append, append! 进行更少的空间分配（因为只修改指针，并没有数据拷贝），但并不一定更快。如果滥用，会很容易导致混乱或错误的结果。\n(append! \u0026#39;(a b) \u0026#39;(c d)) =\u0026gt; (a b c d) (let ([x \u0026#39;(a b)]) (append! x \u0026#39;(c d)) x) =\u0026gt; (a b c d) (append \u0026#39;(1 2 (3 4)) \u0026#39;(5 6)) =\u0026gt; (1 2 (3 4) 5 6) (append \u0026#39;(1 2 (3 4)) \u0026#39;() \u0026#39;(5 6)) =\u0026gt; (1 2 (3 4) 5 6) ","id":116,"section":"posts","summary":"Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x))) (atom? \u0026#39;(a b c)) ⇒ #f (atom? \u0026#39;(3 . 4)) ⇒ #f (atom? \u0026#39;()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) n是一个非负整数，且小于等于list的长度","tags":["scheme"],"title":"Scheme/Chez Scheme 对象操作","uri":"https://lvsq.net/2019/12/operations-on-objects/","year":"2019"},{"content":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。\n (make-engine thunk)\n 通过传递一个无参数的thunk(形实转换程序)给make-engine来创建一个engine。thunk的body是会被engine执行的计算，engine本身是带3个参数的过程： ticks： 一个正整数，指定提供给engine的执行时间片（原文用的是fuel这个单词，意思是燃料，正对应这engine的本意，十分贴切）的数量，engine将会执行到时间片用完或者计算完成为止； complete： 一个或多个参数的函数，用于指定计算完成后的操作。它的参数是剩余的时间片数量和计算产生的值； expire： 一个参数的函数，该函数指定如果在计算完成之前时间片用完了该怎么办。它的参数是一个能从中断点继续进行计算的新引擎。  将引擎应用于其参数时，它将开启一个时长为ticks的计时器，如果引擎计算在计时器执行之前完成，系统将调用complete，并将剩余的ticks和计算产生的值传递给它；\n另一方面，如果计时器在引擎计算完成之前耗尽了，则系统会从中断计算的continuation中创建一个新引擎，并使该引擎过期。complete和expire会被新引擎继续使用。If, on the other hand, the timer goes off before the engine computation completes, the system creates a new engine from the continuation of the in- terrupted computation and passes this engine to expire. complete and expire are invoked in the continuation of the engine invocation.\n 看看具体的例子：\n(define eng (make-engine (lambda () 3))) (eng 10 ;; ticks (lambda (ticks value) value) ;; complete (lambda (x) x) ;; expire ) ⇒ 3 通常将列表作为完整过程传递给引擎，使引擎完成时返回一个列表，该列表的第一个元素是剩余的ticks，另一个元素是计算返回的值，这通常很有用。\n(define eng (make-engine (lambda () 3))) (eng 10 list (lambda (x) x)) ⇒ (9 3) 在上面的示例中，计算值为3，还剩下9个时间片，即，需要一单位的时间片来计算出3。\n 再看一个复杂点的例子： 先定义一个计算裴波那切值的函数\n(define fibonacci (lambda (n) (let fib ([i n]) (cond [(= i 0) 0] [(= i 1) 1] [else (+ (fib (- i 1)) (fib (- i 2)))])))) 创建engine\n(define eng (make-engine (lambda () (fibonacci 10)))) (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ \u0026#34;expired\u0026#34; (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ \u0026#34;expired\u0026#34; (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ \u0026#34;expired\u0026#34; (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026#34;expired\u0026#34;)) ⇒ (21 55) 每次时间片（燃料）用完时，到期程序都会将eng分配给新引擎。整个计算需要4个blocks，每个block包含50个ticks。最后50个燃料中，有21个都用掉了。因此，使用的燃料总量为179个。\n我们还可以统计一下消耗的ticks数量\n(define mileage (lambda (thunk) (let loop ([eng (make-engine thunk)] [total-ticks 0]) (eng 50 (lambda (ticks . values) (+ total-ticks (- 50 ticks))) (lambda (new-eng) (loop new-eng (+ total-ticks 50))))))) (mileage (lambda () (fibonacci 10))) ⇒ 179  再看看一个例子——round-robin:\n(define round-robin (lambda (engs) (if (null? engs) \u0026#39;() ((car engs) 1 ;;ticks (lambda (ticks value) (cons value (round-robin (cdr engs)))) ;;complete (lambda (eng) ;;expire (round-robin (append (cdr engs) (list eng)))))))) (round-robin (map (lambda (x) (make-engine (lambda () (fibonacci x)))) \u0026#39;(4 5 2 8 3 7 6 2))) ⇒ (1 1 2 3 5 8 13 21) 这段代码需要费些思量，首先map函数创建了8个engine, 然后代入round-robin函数，该函数依次执行各个engine，但是每个engine分配的时间片只有1，对于参数'(4 5 2 8 3 7 6 2)，数字越小，越先执行完成，所以越早执行complete函数，最终结果就是排好顺序的了，很棒的程序！\n","id":117,"section":"posts","summary":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。 (make-engine thunk) 通过传递一个无参数的thun","tags":["engine","scheme"],"title":"Engine in Scheme","uri":"https://lvsq.net/2019/12/engine-in-scheme/","year":"2019"},{"content":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Scheme提供了case语法来处理这种情况，这与Java中的switch语法非常相似。\n我们来看看case的语法：\n (case expr0 clause1 clause2 \u0026hellip;)\n 除了最后一个clause之外，每个子句都必须采用以下形式之一：\n ((key \u0026hellip;) expr1 expr2 \u0026hellip;) (key expr1 expr2 \u0026hellip;)  每一个key值都应该是不同的，最后一个子句要么是上述那种形式，或者是一个像下面这样的else子句\n (else expr1 expr2 \u0026hellip;)   那么返回值是什么呢？\n(define p (lambda (x) (case x [(\u0026#34;abc\u0026#34; \u0026#34;def\u0026#34;) \u0026#39;one \u0026#39;1] [((a b c)) \u0026#39;two] [else #f]))) (p (string #\\d #\\e #\\f)) ⇒ 1 (p \u0026#39;(a b c)) ⇒ two (p \u0026#34;eee\u0026#34;) ⇒ #f 上面的例子定义了一个函数p，接收一个参数x\n 如果x为字符串\u0026quot;abc\u0026quot;或者\u0026quot;def\u0026quot;，则返回1； 如果x为列表((a b c)，则返回two 其他情况返回#f  可见，有了case语法多条件判断写起来就方便很多，并且代码也容易读了，当然这里也可以用cond来写，这里只是为了描述case的语法而没有使用cond\n再看一个例子，就不用解释了：\n(let ([ls \u0026#39;(ii iv)]) (case (cadr ls) [i 1] [ii 2] [iii 3] [(iiii iv) 4] [else \u0026#39;out-of-range])) ⇒ 4  record-case 来看看另一个很类似的扩展，也十分有用，它就是record-case。它可以以record为单位来做条件判断并执行指令。语法格式：  (record-case expr clause1 clause2 \u0026hellip;)\n 除了最后一个子句之外，每个clause的格式如下：\n ((key \u0026hellip;) formals body1 body2 \u0026hellip;)\n 每一个key都不应该相同, 最后一个clause可能是上述的格式或者是一个else子句：\n (else body1 body2 \u0026hellip;)\n expr必须是一个pair。Chez会拿(car expr)与各个子句中的key进行比较（用eqv?）来确定哪一个clause匹配, 然后(cdr expr)将与formals绑定。\n来看换一个例子：\n(define calc (lambda (x) (record-case x [(add) (x y) (+ x y)] [(sub) (x y) (- x y)] [(mul) (x y) (* x y)] [(div) (x y) (/ x y)] [else (assertion-violationf 'calc \u0026quot;invalid expression ~s\u0026quot; x)]))) (calc '(add 3 4)) =\u0026gt; 7 (calc '(div 3 4)) =\u0026gt; 3/4 ","id":118,"section":"posts","summary":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Schem","tags":["chez","scheme"],"title":"Chez Scheme中的case扩展","uri":"https://lvsq.net/2019/12/case-in-chez-scheme/","year":"2019"},{"content":"  易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴至，克尽其用，上下一体，俱不倦而事可毕矣\n  周云成康，汉言文景。无有六十年与民休息，累藏蓄积，汉武开疆之功便是空文，此厚积薄发耳，俗语言，胳膊收回来，打出去才有力\n  武帝一代雄主，文治武功，奋高祖之余烈，承三王之圣绪，开万世不拔之基，吾国斯民之幸，铭记汉青\n  ","id":119,"section":"posts","summary":"易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴","tags":["随想"],"title":"继学录","uri":"https://lvsq.net/2019/12/think/","year":"2019"},{"content":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫易变绑定吧，如果有更好的翻译请在文后的评论中尽情发表。\n先看看该语法描述：(fluid-let ((var expr) \u0026hellip;) body1 body2 \u0026hellip;) returns: the values of the body body1 body2 \u0026hellip; libraries: (chezscheme)该Binding的作用类似局部变量，与set! 比较相似。由fluid-let定义的变量必须已绑定到顶层(top level)或者封闭的lambda内或者其他形式的绑定，这很关键！\n 请看代码：\n(let ([x 3]) (+ (fluid-let ([x 5]) x) x)) ⇒ 8 先定义变量x=3，然后在加法操作当中临时将x的值改为5，最后结果为8，如果将fluid-let中的x换个名字，比如y，将如何呢？会得到一个异常：\n Exception: variable y is not bound\n y没有绑定，是的，y即没有在顶层中被定义，也未在某个lambda中或者任何其他形式，这里只能是x\n 再学习下两个例子，加深印象：\n(let ([x \u0026#39;a]) (letrec ([f (lambda (y) (cons x y))]) (fluid-let ([x \u0026#39;b]) (f \u0026#39;c)) )) ⇒ (b . c) (let ([x \u0026#39;a]) (call/cc (lambda (k) (fluid-let ([x \u0026#39;b]) (letrec ([f (lambda (y) (k \u0026#39;*))]) (f \u0026#39;*))))) x) ⇒ a  Fluid Binding实际上是Scheme对Dynamic Scoping的保留，Scheme使用的是Lexical Scoping， 对于这两种Scoping更详细的描述可参考Lexical Scoping and Dynamic Scoping\n","id":120,"section":"posts","summary":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫易变绑定吧，如果有更好的翻译请在文后的评论中尽情发表。 先看看该语法描","tags":["fluid-let","Scheme"],"title":"Fluid Binding in Chez Scheme","uri":"https://lvsq.net/2019/12/fluid-binding/","year":"2019"},{"content":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。\n 这是语法描述：(rec var expr) syntaxreturns: value of exprlibraries: (chezscheme)The syntactic form rec creates a recursive object from expr by establishing a binding of var within expr to the value of expr. In essence, it is a special case of letrec for self-recursive objects.\nThis form is useful for creating recursive objects (especially procedures) that do not depend on external variables for the recursion, which are sometimes undesirable because the exter-nal bindings can change. For example, a recursive procedure defined at top level depends on the value of the top-level variable given as its name. If the value of this variable should change, the meaning of the procedure itself would change. If the procedure is defined instead with rec, its meaning is independent of the variable to which it is bound.\n简要翻译一下：语法rec 通过在expr中建立var与expr的值的绑定，创建一个递归对象。从本质上讲，这是letrec用于自递归对象的一种特殊情况。\n语法rec通过绑定expr中创建一个递归对象，用来 这种形式对于创建不依赖于外部变量进行递归的递归对象（尤其是过程）很有用，因为外部绑定可能会发生变化，所以有时这是不可取的。\n 看一个例子来感受一下：给定一个全是数字的list，对于每一个数字n，算出$1+2+\u0026hellip;+n$的和，最终返回和的list.\n(map (rec sum (lambda (x) (if (= x 0) 0 (+ x (sum (- x 1)))))) ’(0 1 2 3 4 5)) ⇒ (0 1 3 6 10 15) 如果没有rec语法，用letrec也是可以的，但是稍显麻烦，代码也多一些，所以rec还是很好用的\n 最后看一下rec语法的定义：\n(define-syntax rec (syntax-rules () [(_ x e) (letrec ((x e)) x)])) ","id":121,"section":"posts","summary":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。 这是语法描述：(","tags":["Scheme","Chez","rec"],"title":"Recursive Bindings in Chez Scheme","uri":"https://lvsq.net/2019/12/recursive-bindings/","year":"2019"},{"content":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些时间，动手写了一个，目前已经在公司内部运行了几年，效果良好，并且已经开源在Github上，以飨各位。\n 特点：\n  API简洁\n  支持3种事件：\n UP DOWN JOIN    基于Vert.X\n  引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lvsq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jgossip\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 一个简单的例子：\nint gossip_port = 60001; String cluster = \u0026#34;gossip_cluster\u0026#34;; GossipSettings settings = new GossipSettings(); settings.setGossipInterval(1000); try { String myIpAddress = InetAddress.getLocalHost().getHostAddress(); List\u0026lt;SeedMember\u0026gt; seedNodes = new ArrayList\u0026lt;\u0026gt;(); SeedMember seed = new SeedMember(); seed.setCluster(cluster); seed.setIpAddress(myIpAddress); seed.setPort(60001); seedNodes.add(seed); gossipService = new GossipService(cluster, myIpAddress, gossip_port, null, seedNodes, settings, (member, state) -\u0026gt;System.out.println(\u0026#34;member:\u0026#34; + member + \u0026#34; state: \u0026#34; + state)); } catch (Exception e) { e.printStackTrace(); } gossipService.start();  详细介绍请看 =\u0026gt; 项目地址\n欢迎大家fork， 如果觉得好请start ~~~\n","id":122,"section":"posts","summary":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些","tags":["jgossip","gossip"],"title":"Jgossip - gossip协议的开源实现","uri":"https://lvsq.net/2019/12/jgossip/","year":"2019"},{"content":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加\nGolang的实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} nodes := []*ListNode{} var carry = 0 for { node, c := add(l1, l2, carry) carry = c if node != nil { nodes = append(nodes, node) if l1 != nil \u0026amp;\u0026amp; l1.Next != nil { l1 = l1.Next } else { l1 = nil } if l2 != nil \u0026amp;\u0026amp; l2.Next != nil { l2 = l2.Next } else { l2 = nil } if carry \u0026gt; 0 \u0026amp;\u0026amp; (l1 == nil \u0026amp;\u0026amp; l2 == nil) { nodes = append(nodes, \u0026amp;ListNode{Val:carry}) } } else { break } } for i, n := range nodes{ if i == 0 { result = n } if i + 1 \u0026lt; len(nodes) { n.Next = nodes[i + 1] } } return result } func add (n1 *ListNode, n2 *ListNode, carry int) (*ListNode, int) { node := \u0026amp;ListNode{} if (n1 == nil \u0026amp;\u0026amp; n2 == nil) { return nil, 0 } if n1 == nil { n1 = \u0026amp;ListNode{Val : 0} } if n2 == nil { n2 = \u0026amp;ListNode{Val : 0} } sum := n1.Val + n2.Val + carry carry = 0 if sum \u0026gt; 9 { carry = 1 sum = sum - 10 } node.Val = sum return node, carry }  下面提供Scheme版本的实现【(1 0) + (9 1 2) = (0 2 2)】，为了简单起见，与题目要求稍有不同，这里采用list，而不是题目要求的链表，但实际上应是一样的。比较之下可以看出，相对而言，Scheme语言的实现更加简短优雅，得益于其强大的表达能力\n(letrec ( [Polishing (lambda (l num) (if (eq? num 0) l (Polishing (append l \u0026#39;(0)) (- num 1))) ) ] [Align (lambda (l1 l2) (let ([len1 (length l1)] [len2 (length l2)]) (if [eq? len1 len2] [list l1 l2] [if (\u0026gt; len1 len2) (list l1 (Polishing l2 (- len1 len2))) (list (Polishing l1 (- len2 len1)) l2)])) ) ] [Add (lambda (l1 l2) (let ([ l (Align l1 l2)]) (Carry (map (lambda (x y) (+ x y)) (car l) (cadr l)) 0) ) ) ] [Carry (lambda (l c) (if (null? l) (if [eq? c 0] \u0026#39;() [cons c l]) (cons (mod ( + (car l) c ) 10) (Carry (cdr l) (quotient ( + (car l) c) 10))) ) ) ]) (Add \u0026#39;(1 0) \u0026#39;(9 1 2)))  Golang版本和Scheme版本的实现思路不相同，简要描述一下后者：\n (1 0) + (9 1 2), 先进行补位： (1 0 0) + (9 1 2), 按顺序相加，得： (10 1 2), 再计算进位： (0 2 2)  ","id":123,"section":"posts","summary":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加 Golang的实现： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result","tags":["Scheme","leetcode"],"title":"两数相加","uri":"https://lvsq.net/2019/12/leetcode-2/","year":"2019"},{"content":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发。\n 问题描述 假设我们已经有足够多的1分，2分，5分钱币，任意给定金额比如1元，问有多少种组合方式？ 换言之，$$1x+2y+5z = 100$$ 求x,y,z的解有多少个\n 思路 组合方式的总和应为：\n  任意扣去一种钱币比如1分，1元采用2分，5分两种钱币的组合数，再加上：\n  总额为（1元-1分），采用1分，2分，5分三种钱币的组合数；\n  很明显这可以很容易用递归实现\n 稍作一点解释：\na. 上面两步的意思是：不带1分的组合数 + 带1分的组合数 = 全部的组合数； 这是显而易见的\nb. 上述第2步，（1元-1分）的意思是：这样可以保证任意一种组合方式再加1分都等于1元，保证至少有1个1分的钱币\n(letrec [ (A (lambda (n d) (if (= 0 (mod n d)) 1 0))) (B (lambda (n d) (cond [(not (pair? d)) 0] [(null? d) 0] [(= 0 n) 1] [(\u0026gt; 0 n) 0] [(= 1 (length d)) (A n (car d))] [else ( + (B n (cdr d)) (B (- n (car d)) d)) ] ) ) ) ] [B 100 \u0026#39;(1 2 5)] ) ","id":124,"section":"posts","summary":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发","tags":["Scheme","SICP"],"title":"钱币组合问题","uri":"https://lvsq.net/2019/12/count-coins/","year":"2019"},{"content":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026quot;x-\u0026quot;）该如何开发做紧要的介绍。\n一切开始之前，有一点需要keep in mind，即增加扩展的位置不同，所用的方法不同，所以需要对Swagger的标准有所了解，可参考官方文档  springfox目前只允许三种扩展实现:\n ListVendorExtension:列表的形式,该对象支持泛型，最终形式：”x-field”:[{field:value}] ObjectVendorExtension:对象的扩展形式,最终的扩展形式是：”x-field”:[{field:value}] StringVendorExtension:string类型的扩展实现，最终的扩展形式是”x-field”:”value”   Swagger根对象扩展 以在info中添加一个x-logo为例\n\u0026#34;info\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;\u0026lt;div style=\u0026#39;font-size:14px;color:red;\u0026#39;\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;swagger-bootstrap-ui！！！\u0026#34;, \u0026#34;termsOfService\u0026#34;: \u0026#34;http://www.xxx.com/\u0026#34;, \u0026#34;contact\u0026#34;: { \u0026#34;name\u0026#34;: pxxxx@domain.com\u0026#34; }, \u0026#34;x-logo\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#090807\u0026#34; } }, ... 后台代码：\nObjectVendorExtension logo = new ObjectVendorExtension(\u0026#34;x-logo\u0026#34;); logo.addProperty(new StringVendorExtension(\u0026#34;url\u0026#34;, \u0026#34;https://xxx.svg\u0026#34;)); logo.addProperty(new StringVendorExtension(\u0026#34;color\u0026#34;, \u0026#34;#090807\u0026#34;)); return new ApiInfoBuilder() .title(\u0026#34;swagger-bootstrap-ui！！\u0026#34;) .extensions(Lists.newArrayList(logo)) .description(\u0026#34;\u0026lt;div style=\u0026#39;font-size:14px;color:red;\u0026#39;\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026#34;) .termsOfServiceUrl(\u0026#34;http://www.xxx.com/\u0026#34;) .version(\u0026#34;1.0.0\u0026#34;) .build();  内部对象扩展 给Path添加一个扩展属性x-order为例\n@Component @Order(Ordered.HIGHEST_PRECEDENCE+100) public class OperationPositionBulderPlugin implements OperationBuilderPlugin { @Override public void apply(OperationContext context) { context.operationBuilder().extensions(Lists.newArrayList(new StringVendorExtension(\u0026#34;x-order\u0026#34;,\u0026#34;1\u0026#34;))); } @Override public boolean supports(DocumentationType delimiter) { return true; } } 详细介绍可以参考\n","id":125,"section":"posts","summary":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026quo","tags":["swagger","vendorExtensions"],"title":"Swagger 如何使用vendorExtensions进行扩展","uri":"https://lvsq.net/2019/11/swagger-vendor/","year":"2019"},{"content":" 秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁，如平原君广纳异国宾客；苏秦上书于七国；荀子遍游天下者皆可证各国文字并无大乖。 《史籀篇》文首盖云“太史籀书”，人多误以太史籀所作，如此便望文生义了。太史乃官职，王国维先生引《说文》解释，籀即读，读即籀书。另太史籀书乃周世之成语，绝非人名。  ","id":126,"section":"posts","summary":"秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁","tags":["文史"],"title":"历史不能碰","uri":"https://lvsq.net/2019/11/do-not-touch-history/","year":"2019"},{"content":"M -\u0026gt; Alt(option) S -\u0026gt; Shift    快捷键 用途     M-v 上（后）一屏   C-v 下（前）一屏   C-l 重绘屏幕，将光标所在行置于屏幕中央   C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符   C-x C-f  查找或者新建一个文件   C-x C-b 列出缓冲区。 C-x 1 关闭缓冲区列表   C-x C-q 开启或者关闭buffer的只读模式   C-x C-s 保存当前文件   C-x s 保存所有文件   C-x h 全选   M-w 复制   C-y 粘贴   C-w 剪切   C-s 往前搜索   C-r 往后搜索. DEL 也可以往后搜索，   C-/ undo   M-x calendar 打开日历。按 q 退出。【g d 到指定日期】【. 到今日（不居中）】【\u0026gt; 前一个月】【\u0026lt; 后一个月】   M-x *-mode 选择Major mode   M-x shell 运行一个shell   M-x eshell 运行一个eshell   C-a 移到行首   C-a C-k、C-S-backspace 删除整行   C-u 5 C-S-backspace、M-5 C-S-backspace 删除后5行，不加数字则删除4行（默认），如果数字为负数，则往前删   C-g 停止当前的命令   C-k 删除从光标位置到行尾所有字符    Org-Mode    快捷键 用途     C-c . 插入时间   C-c C-e 导出其它格式   C-c C-s 在标题下面插入一个带有“==SCHEDULED==”关键字的时间戳。   C-c C-d 在标题下面插入一个带有“==DEADLINE==”关键字的时间戳   C-c C-t 将当前项的状态在（unmarked）-\u0026gt;TODO-\u0026gt;DONE 之间循环切换   M-RET 插入一个同级标题   M-LEFT/RIGHT 将当前的标题提升/降低一个等级   C-c C-c 插入标签tag。 光标在标题中   C-c C-q 插入标签tag。光标在任意位置   C-c , 设置当前标题的优先级,’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的   C-c \\ 查找标签tag   S-Tab 展开所有标题   Tab 展开光标所在标题   C-c C-l 编辑链接   C-c C-o 打开链接    ","id":127,"section":"posts","summary":"M -\u0026gt; Alt(option) S -\u0026gt; Shift 快捷键 用途 M-v 上（后）一屏 C-v 下（前）一屏 C-l 重绘屏幕，将光标所在行置于屏幕中央 C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符 C-x C-f 查","tags":["emacs"],"title":"Emacs","uri":"https://lvsq.net/2019/11/emacs/","year":"2019"}],"tags":[{"title":"about","uri":"https://lvsq.net/tags/about/"},{"title":"chez","uri":"https://lvsq.net/tags/chez/"},{"title":"emacs","uri":"https://lvsq.net/tags/emacs/"},{"title":"engine","uri":"https://lvsq.net/tags/engine/"},{"title":"erlang","uri":"https://lvsq.net/tags/erlang/"},{"title":"fluid-let","uri":"https://lvsq.net/tags/fluid-let/"},{"title":"functional","uri":"https://lvsq.net/tags/functional/"},{"title":"gossip","uri":"https://lvsq.net/tags/gossip/"},{"title":"jgossip","uri":"https://lvsq.net/tags/jgossip/"},{"title":"leetcode","uri":"https://lvsq.net/tags/leetcode/"},{"title":"lexical","uri":"https://lvsq.net/tags/lexical/"},{"title":"lisp","uri":"https://lvsq.net/tags/lisp/"},{"title":"module","uri":"https://lvsq.net/tags/module/"},{"title":"modules","uri":"https://lvsq.net/tags/modules/"},{"title":"pl","uri":"https://lvsq.net/tags/pl/"},{"title":"racket","uri":"https://lvsq.net/tags/racket/"},{"title":"rec","uri":"https://lvsq.net/tags/rec/"},{"title":"scheme","uri":"https://lvsq.net/tags/scheme/"},{"title":"scoping","uri":"https://lvsq.net/tags/scoping/"},{"title":"SICP","uri":"https://lvsq.net/tags/sicp/"},{"title":"swagger","uri":"https://lvsq.net/tags/swagger/"},{"title":"syntactic","uri":"https://lvsq.net/tags/syntactic/"},{"title":"thread","uri":"https://lvsq.net/tags/thread/"},{"title":"vendorExtensions","uri":"https://lvsq.net/tags/vendorextensions/"},{"title":"文史","uri":"https://lvsq.net/tags/%E6%96%87%E5%8F%B2/"},{"title":"随想","uri":"https://lvsq.net/tags/%E9%9A%8F%E6%83%B3/"}]}