{"categories":[{"title":"Chez","uri":"https://lvsq.net/categories/chez/"},{"title":"Java","uri":"https://lvsq.net/categories/java/"},{"title":"LeetCode","uri":"https://lvsq.net/categories/leetcode/"},{"title":"scheme","uri":"https://lvsq.net/categories/scheme/"},{"title":"tool","uri":"https://lvsq.net/categories/tool/"},{"title":"文史","uri":"https://lvsq.net/categories/%E6%96%87%E5%8F%B2/"}],"posts":[{"content":" define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回true的谓词、以及每个字段的访问procedure和针对可变字段的赋值procedure。总的来说，与Java中的POJO类比较相似，不过不用自定义getter和setter方法，这与Kotlin倒为类似，例如：\n(define-record-type point (fields x y))  创建了一个名为point的record类型，并且有两个字段x和y，和如下几个定义式（自动生成）：\n| \u0026mdash; | \u0026mdash; (make-point x y) | 构造函数 (point? obj) | 谓词 (point-x p) | 字段x的访问器 (point-y p) | 字段y的访问器\n默认下，字段是不可变的，但是可以声明为可变的（mutable）。如下定义point中，字段x是可变的，但y维持不变：\n(define-record-type point (fields (mutable x) y))  当然亦可显式地将字段声明为不可变的：\n(define-record-type point (fields (mutable x) (immutable y)))  在这个例子中，define-record-type除了生成了上述的几个定义式之外，还为字段x增加了一个赋值过程：\n(point-x-set! p x)\n该赋值过程可以用于改变x的内容\n(define p (make-point 36 -17)) (point-x-set! p (- (point-x p) 12)) (point-x p) =\u0026gt; 24  自动生成的几个定义式是允许改变名称的，下面的point定义式，其构造函数名为mkpoint, 谓词为ispoint?，x和y的访问器分别为x-val和y-val, x的赋值器为set-x-val!\n(define-record-type (point mkpoint ispoint?) (fields (mutable x x-val set-x-val!) (immutable y y-val)))  默认情况下，每次一个record definition创建一个新类型（为方便理解，可以用Java来解释，即对于同一个POJO类new出两个实例，但这两个实例并不能equal），如下所示：\n(define (f p) (define-record-type point (fields x y)) (if (eq? p 'make) (make-point 3 4) (point? p))) (f (f 'make)) =\u0026gt; #f  第一个f的调用即(f \u0026lsquo;make)返回一个point类型的p，将p传递给第二个f，但p是由第一个调用生成的类型，所以point?返回#f。按照SICP的说法，这两个define-record-type并不在一个环境中，只是名字一样而已。\n默认的生产行为(generative behavior)或许可以由记录定义式中的nongenerative子句来重载：\n(define (f p) (define-record-type point (fields x y) (nongenerative)) (if (eq? p 'make) (make-point 3 4) (point? p))) (f (f 'make)) =\u0026gt; #t  以这种方式创建的记录类型仍然不同于由定义出现在程序的不同部分中创建的记录类型，即使这些定义在语法上是相同的：\n(define (f) (define-record-type point (fields x y) (nongenerative)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative)) (point? p)) (g (f)) =\u0026gt; #f  甚至可以通过在nongenerative子句中包含uid（唯一id）来覆盖它：\n(define (f) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (point? p)) (g (f)) =\u0026gt; #t  记录类型可以定义为有parent子句的子类型，即一个记录类型可以声明为某一个记录类型的子类型，如果指定了父类型，则子类型将继承父类型所有字段，且子类型的每个实例都被视为父类型的实例，因此可以直接使用父类型的访问器和字段等等。\n(define-record-type point (fields x y)) (define-record-type cpoint (parent point) (fields color)) (define cp (make-cpoint 3 4 'red)) (point? (make-cpoint 3 4 'red)) =\u0026gt; #t (cpoint? (make-point 3 4)) =\u0026gt; #f (define cp (make-cpoint 3 4 'red)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (cpoint-color cp) =\u0026gt; red  到目前为止，define-record-type定义的默认构造函数接受record包含的字段一样多的参数，其实我们可以重写默认值，这里需要引入protocol子句，以下定义将创建一个具有三个字段的点记录：x，y和d，其中d表示距原点的位移。构造函数仍然只接受两个参数，即x和y值，并将d初始化为x和y平方和的平方根。\n(define-record-type point (fields x y d) (protocol (lambda (new) (lambda (x y) (new x y (sqrt (+ (* x x) (* y y)))))))) (define p (make-point 3 4)) (point-x p) =\u0026gt; 3 (point-y p) =\u0026gt; 4 (point-d p) =\u0026gt; 5  另外，子类型的构造函数中的参数顺序是不可改变的，即先是父类型构造函数的字段，然后才是子类型的参数，如果需要改变子类型的构造函数的参数顺序该如何呢？\n(define-record-type cpoint (parent point) (fields color) (protocol (lambda (pargs-\u0026gt;new) (lambda (x c y) ((pargs-\u0026gt;new x y) c))))) (define cp (make-cpoint 3 'red 4)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (point-d cp) =\u0026gt; 5 (cpoint-color cp) =\u0026gt; red  最后来看看define-record-type的语法形似：\n syntax: (define-record-type record-name clause \u0026hellip;)\nsyntax: (define-record-type (record-name constructor pred) clause \u0026hellip;)\n Fields clause语法形式:\n (fields field-spec \u0026hellip;)\n field-spec必须是下面5个中的一个:\n field-name (immmutable field-name) (mutable field-name) (immmutable field-name accessor-name) (mutable field-name accessor-name mutator-name)  define-record in Chez Scheme Chez Scheme依然支持$R^6RS$中传统的record类型的定义，另外还提供一个新的语法，即define-record，其语法形式与define-record-type一样，所不同的地方在于，define-record中的字段默认是可变的，这与$R^6RS$中的record相反，因此，创建一个记录类型时，同时会定义下列过程：\n(define-record point (x y)) (make-point x y) ;;\tconstructor (point? obj) ;;\tpredicate (point-x p) ;;\taccessor for field x (point-y p) ;;\taccessor for field y (set-point-x! p obj) ;;\tmutator for field x (set-point-y! p obj) ;;\tmutator for field y  ","id":0,"section":"posts","summary":"define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回tr","tags":["scheme"],"title":"Scheme语define-record-type介绍","uri":"https://lvsq.net/2020/02/define-record-type/","year":"2020"},{"content":" Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以在 Chez Scheme 中以“微模块”级别使用，因为 Chez Scheme 中的模块和 import 形式属于定义，并且可以出现在定义可以出现的任意位置，包括在 lambda 表达式的程序体或其他局部作用域中。\n 微模块与函数孰好？？？还是视情况而定？？？\n 模块控制绑定的可见性，可以用作扩展词法作用域，以允许更精确地控制绑定的可见范围。模块导出标识符的绑定，即变量绑定、关键字绑定或模块名绑定。模块可以是具名的抑或匿名的。只要模块名可见，那么在具名模块出现处导入的绑定都可见。匿名模块中导出的绑定，在模块出现的地方被隐式地导入。匿名模块可用于隐藏一组绑定中的一些绑定，同时允许其余绑定可见。\n语法  (module name interface defn \u0026hellip; init \u0026hellip;)\n(module interface defn \u0026hellip; init \u0026hellip;)\n name 是标识符，defn \u0026hellip; 是定义，init \u0026hellip; 是表达式。interface 是形如 (export \u0026hellip;) 的导出表，其中每个 export 都是标识符 identifier 抑或形式 (identifier export \u0026hellip;)。\n模块由一组（可能为空的）定义和一组（可能为空的）初始化表达式序列组成。模块中定义的标识符（可理解为变量或者状态，下同）在模块的程序体中可见，被导出的标识符在模块的导入作用域内亦可见。模块接口中列出的每个标识符必须在该模块中定义或被导入该到模块。module 形式是一种定义，因此可以出现在其他定义可以出现的任何位置，包括嵌套在 lambda 表达式的程序体、 library 形式、顶层程序，以及嵌套在其他模块中。此外，因为模块名的作用域与其他标识符相同，所以模块和库可以像变量和关键字那样导出模块名。\n模块名与其他标识符占用相同的名字空间，并遵循相同的作用域规则。除非被导出，否则模块中定义的标识符仅在该模块中可见。\n模块内的表达式可以引用在模块外部绑定的标识符。\n(let ([x 3]) (module m (plusx) (define plusx (lambda (y) (+ x y)))) (import m) (let ([x 4]) (plusx 5))) ; =\u0026gt; 8,注意不是9哦，可以将plusx视为：(define plusx (lambda (y) (+ 3 y))))  同样，import不会阻止访问出现导入表单的可见标识符，但import标识符所覆盖的变量除外（啥叫覆盖，看下面两段代码）。\n(module m (y) (define y 'm-y)) (let ([x 'local-x] [y 'local-y]) (import m) (list x y)) ; =\u0026gt; (local-x m-y)  模块m中定义了标识符y, 在其被import之后会覆盖let中的y；\n(module m (y) (define y 'm-y)) (let () (import m) (let ([x 'local-x] [y 'local-y]) (list x y)) ; =\u0026gt; (local-x local-y) )  先import m，之后再定义y，模块中定义的y不会覆盖let的y。\n另一方面，在模块中使用 import-only 会建立一个隔离的作用域，其中唯一可见的是被导入模块所导出的标识符，下面的代码中只有y可见。\n对于静态验证，有时不希望使用任何标识符，除了明确导入模块或本地范围的标识符外，这有时是合乎需要的。\n(module m (y) (define y 'm-y)) (let ([x 'local-x] [y 'local-y]) (import-only m) x) ; =\u0026gt; Error: x is not visible  除非通过“import-only”导入的模块导出“import”或“import-only”以及至少一个模块的名称，否则无法在“import-only”范围内进行后续导入。 要创建一个包含多个模块导出的隔离范围而又不使“import”或“import-only”可见，必须以相同的“import-only”形式列出所有要导入的模块。\n另一种解决方案是创建一个包含每个其他模块的导出的模块。\n(module m2 (y) (define y 'y)) (module m1 (x) (define x 'x)) (module mega-module (cons x y) (import m1) (import m2) (import scheme)) (let ([y 3]) (import-only mega-module) (cons x y)) ; =\u0026gt; (x . y)  在它被编译之前，源程序被翻译成不含语法抽象、语法定义、库定义、模块定义以及 import 形式的核心语言程序。翻译由语法展开器负责，语法展开器以递归下降的方式处理源程序中的形式。\nmodule 和 import 特殊形式仅影响标识符(identifier)在源程序中的可见性，而不影响其含义。特别地，无论变量被绑定到在模块内部或外部定义的位置，import 都不会引入新位置。为了保持由模块和语法抽象建立的作用域关系，局部变量在必要时会被重命名。因此，表达式：\n(let ([x 1]) (module m (x setter) (define-syntax x (identifier-syntax z)) (define setter (lambda (x) (set! z x))) (define z 5)) (let ([y x] [z 0]) (import m) (setter 3) (+ x y z))) ; =\u0026gt; 4  等价于下面的表达式，其中标识符被统一地更名，并带上了下标：\n(let ([x0 1]) (define-syntax x1 (identifier-syntax z1)) (define setter1 (lambda (x2) (set! z1 x2))) (define z1 5) (let ([y3 x0] [z3 0]) (setter1 3) (+ x1 y3 z3)))  互递归module (module (a b) (module a (x) (define x (lambda () y))) (module b (y) (define y (lambda () x))) (import a) (import b))  此模式的一般化语法定义如下，允许定义多个互递归的模块\n(define-syntax rec-modules (syntax-rules (module) [(_ (module m (id ...) form ...) ...) (module (m ...) (module m (id ...) form ...) ... (import m) ...)]))  组合module 由于模块可以重新导出所导入的绑定，所以很容易在单个模块上提供多个视图，就像下面的 s 和 t 为 r 提供的视图那样，或者将几个模块组合成一个复合，就像 r 那样。\n(module p (x y) (define x 1) (define y 2)) (module q (y z) (define y 3) (define z 4)) (module r (a b c d) (import* p (a x) (b y)) (import* q (c y) (d z))) (module s (a c) (import r)) (module t (b d) (import r))  import* 稍微解释一下import*, 其语法定义如下：\n(define-syntax import* (syntax-rules () [(_ m) (begin)] [(_ m (new old)) (module (new) (module (tmp) (import m) (alias tmp old)) (alias new tmp))] [(_ m id) (module (id) (import m))] [(_ m spec0 spec1 ...) (begin (import* m spec0) (import* m spec1 ...))]))  它支持重命名import的绑定和选择性导入特定的绑定，无需使用内置的import子形式来选择和重命名标识符，举例来说：\n(let () (import* scheme (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7) (let () (import* (rnrs) (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7)  ","id":1,"section":"posts","summary":"Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以","tags":["modules"],"title":"Chez Scheme Modules","uri":"https://lvsq.net/2020/01/modules/","year":"2020"},{"content":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。\n(define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_ ((a1 v1) (a2 v2) ...) bodys ...) (let ((a1 v1)) (my-let* ((a2 v2) ...) bodys ...)) ) ) )  注意，my-let*是可以递归使用的，以及\u0026hellip;的用法。\n(define-syntax my-let* (syntax-rules () ( (_ () bodys ...) (let () bodys ...) ) ( (_ ((a1 v1) ...) bodys ...) (let () (define a1 v1) ... bodys ... ) ) ) )  这个实现方式与上面的不同，上面的是嵌套let，这里将直接按顺序define内部变量，代码更短。注意此处的\u0026hellip;的用法。\n","id":2,"section":"posts","summary":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。 (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_","tags":["scheme"],"title":"自定义 Let*","uri":"https://lvsq.net/2020/01/my-let/","year":"2020"},{"content":" Fluid Keyword Bindings fluid-let-syntax  语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩展期间会暂时更改keyword的现有绑定，而不是引入keyword的新绑定。也就是说，在扩展form1 form2 \u0026hellip;的过程中，每个keyword的可见范围（或顶级）将会临时替换为新的绑定关系。\n (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 2 ) ) )  (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (fluid-let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 1 ) ) )  对比上述两段代码，可知：两个表达式基本相同的，除了前者采用内部let-synctax语法，第二个采用fluid-let-syntax语法。在第一个表达式中，(g 1)扩展中的出现的f引用的是let-bound的变量f，而第二个表达式，f引用的是由fluid-let-syntax绑定的f\n","id":3,"section":"posts","summary":"Fluid Keyword Bindings fluid-let-syntax 语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩","tags":["module","syntactic"],"title":"Syntactic Extension and Modules in Chez Scheme","uri":"https://lvsq.net/2020/01/syntactic-extension-and-modules/","year":"2020"},{"content":" Chez Scheme中有一种Boxes结构，它是一个*单元素*对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构可以共享指向一个对象的引用，或指针。例如，在采用此种参数传递规则的语言的解释器中，可以用 boxes 实现 call-by-reference 的语义。解释有点绕，按我的理解boxes就相当于Golang的struct、Java中的类，将一些状态包装成一个整块，外界通过引用该整块的指针来访问内部的各个状态。\nBoxes 的字面形式带有前缀 #\u0026amp; (发音为 “hash-ampersand”). 例如， #\u0026amp;(a b c) 是一个 box，内容为列表 (a b c). 读取器若遇到 #!r6rs ，则会在其后的输入流中禁用 box 语法，除非在更近的位置遇到 #!chezscheme.\n所有 boxes 默认是可变的，包括常量。程序可以通过 box-immutable 创建不可变 boxes. 尝试修改不可变 box 会导致抛出异常。\n我们来看看一些用法：\n(box? obj) 如果 obj 是 box, 则为 #t, 否则为 #f.\n(box? '#\u0026amp;a) =\u0026gt; #t (box? 'a) =\u0026gt; #f (box? (box 3)) =\u0026gt; #t  (box obj) 创建一个由obj组成的box\n(box 'a) =\u0026gt; #\u0026amp;a (box (box '(a b c))) =\u0026gt; #\u0026amp;#\u0026amp;(a b c)  (unbox box) 返回box的内容\n(unbox #\u0026amp;a) =\u0026gt; a (unbox #\u0026amp;#\u0026amp;(a b c)) =\u0026gt; #\u0026amp;(a b c) (let ([b (box \u0026quot;hi\u0026quot;)]) (unbox b)) =\u0026gt; \u0026quot;hi\u0026quot;  (set-box! box obj) box 必须是可变的。 set-box! 把 box 的内容设置为 obj.\n(let ([b (box 'x)]) (set-box! b 'y) b) =\u0026gt; #\u0026amp;y (let ([incr! (lambda (x) (set-box! x (+ (unbox x) 1)))]) (let ([b (box 3)]) (incr! b) (unbox b))) =\u0026gt; 4  (box-cas! box old-obj new-obj) 如果 box 被改变，则为 #t, 否则为 #f.\nbox 必须是可变的。 若 box 待替换的内容和 old-obj 相同(基于 eq?), 则 box-cas! 自动将 box 的内容替换为 new-obj; 若不相同，则 box 保持不变。即CAS操作，原子的。\n(define b (box 'old)) (box-cas! b 'old 'new) =\u0026gt; #t (unbox b) =\u0026gt; 'new (box-cas! b 'other 'wrong) =\u0026gt; #f (unbox b) =\u0026gt; 'new  (mutable-box? obj) 如果 obj 是可变的 box ，则为 #t, 否则为 #f.\n(immutable-box? obj) 如果 obj 是不可变的 box ，则为 #t, 否则为 #f.\n(box-immutable obj) 返回一个内容为obj的不可变的box。Boxes 通常用来支持共享的，可变的结构，所以不可变的 box 一般没什么用。\n","id":4,"section":"posts","summary":"Chez Scheme中有一种Boxes结构，它是一个*单元素*对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据","tags":["scheme"],"title":"Chez Scheme中Boxes介绍","uri":"https://lvsq.net/2020/01/boxes-in-chez/","year":"2020"},{"content":" Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x)))\n(atom? '(a b c)) ⇒ #f (atom? '(3 . 4)) ⇒ #f (atom? '()) ⇒ #t (atom? 3) ⇒ #t  list-head(Chez) 用法：(list-head list n) *n*是一个非负整数，且小于等于*list*的长度；list-head和Scheme标准过程list-tail可能会同时使用来切割一个list，不同点在于，list-tail不会分配内存而只是返回源list的一个子列表，list-head总是返回源list前n个元素的副本\n(list-head '(a b c) 0) ⇒ () (list-head '(a b c) 2) ⇒ (a b) (list-head '(a b c) 3) ⇒ (a b c) (list-head '(a b c . d) 2) ⇒ (a b) (list-head '(a b c . d) 3) ⇒ (a b c) (list-head '#1=(a . #1#) 5) ⇒ (a a a a a)  last-pair(Chez) 用法：(last-pair list) 列表不能为空。 last-pair返回列表的最后一对（pair）（不是最后一个元素）, list可能是不正确的列表，在这种情况下，最后一对是包含最后一个元素和终止对象的一个pair。\n(last-pair '(a b c d)) ⇒ (d) (last-pair '(a b c.d)) ⇒ (c . d)  list-copy(Chez) 用法： (list-copy list) 返回一个list的副本，equal?（结构和值相同）判断为#t\nlist*(Chez) 用法：(list* obj \u0026hellip; final-obj)\n返回一个由obj \u0026hellip; final-obj 组成的list, 与R6RS的cons*相同\nmake-list(Chez) 用法： (make-list n) 或者 (make-list n obj)\n返回n个对象的列表。n是一个正整数， 如果obj不指定，则返回的list是不确定的\n(make-list 0 '()) =\u0026gt; () (make-list 3 0) =\u0026gt; (0 0 0) (make-list 2 \u0026quot;hi\u0026quot;) =\u0026gt; (\u0026quot;hi\u0026quot; \u0026quot;hi\u0026quot;)  iota(Chez) 用法：(iota n)\n返回从 0（包含）到 n（不包含）的整数列表，n须为精确的非负整数\n(iota 0) =\u0026gt; () (iota 5) =\u0026gt; (0 1 2 3 4)  enumerate(Chez) 用法： (enumerate ls)\n返回: 从 0（包含）到长度 ls（不包含）的整数列表\n(enumerate '()) =\u0026gt; () (enumerate '(a b c)) =\u0026gt; (0 1 2) (let ([ls '(a b c)]) (map cons ls (enumerate ls))) =\u0026gt; ((a . 0) (b . 1) (c . 2))  remq! | remv! | remove!(Chez) 用法： (remq! obj list) | (remv! obj list) | (remove! obj list)\n返回: 列表中所有 obj 都被移除后的列表\n这些过程与 R6RS 中的 remq, remv, 及 remove 过程类似，只是 remq!, remv! 和 remove! 使用输入列表中的pair来构成输出列表。它们进行较少的空间分配，但并不一定比它们非破坏性的相应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(remq! 'a '(a b a c a d)) ⇒ (b c d) (remv! #\\a '(#\\a #\\b #\\c)) =\u0026gt; (#\\b #\\c) (remove! '(c) '((a) (b) (c))) =\u0026gt; ((a) (b))  substq | substv | subst | substq! | substv! | subst!(Chez) 用法： (subs* new old tree)\n返回：在tree中将匹配到的old元素全部替换为new之后的tree.\n对于 substq 和 substq! ，相等性测试是基于 eq?, substv 和 substv! 是基于 eqv?, 而 subst 和 subst! 是基于 equal? substq!, substv!, 和 subst! 执行破坏性的替换。它们进行较少的空间分配，但并不一定比它们非破坏性的对应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(substq 'a 'b '((b c) b a)) =\u0026gt; ((a c) a a) (substv 2 1 '((1 . 2) (1 . 4) . 1)) =\u0026gt; ((2 . 2) (2 . 4) . 2) (subst 'a '(a . b) '((a . b) (c a . b) . c)) =\u0026gt; (a (c . a) . c) (let ([tr '((b c) b a)]) (substq! 'a 'b tr) tr) =\u0026gt; ((a c) a a)  reverse! 用法：(reverse! list)\n返回：将原list反向输出\nreverse! 通过反转其链接破坏性地反向排序列表。以 reverse! 取代 reverse 减少了空间分配，但并不一定比使用 reverse 更快。如果滥用，会很容易导致混乱或错误的结果。\n(reverse! '()) =\u0026gt; () (reverse! '(a b c)) =\u0026gt; (c b a) (let ([x '(a b c)]) (reverse! x) x) =\u0026gt; (a) (let ([x '(a b c)]) (set! x (reverse! x)) x) =\u0026gt; (c b a)  append! 用法：(append! list \u0026hellip;)\n返回：将所有输入list串联起来的列表\n如同 append, append! 返回一个新的列表，其中元素依次为第一个列表中的元素，第二个列表中的元素，第三个列表中的元素，等等。不同之处在于， append! 重用所有参数中的点对以构造新列表。即，每一个列表参数的最后一个cdr, 其后一元素变为指向下一个列表参数。除最后一个参数外，如果任一参数为空列表，它实质上会被忽略。最后一个参数（并不一定得是列表）是不变的。\n相比于 append, append! 进行更少的空间分配（因为只修改指针，并没有数据拷贝），但并不一定更快。如果滥用，会很容易导致混乱或错误的结果。\n(append! '(a b) '(c d)) =\u0026gt; (a b c d) (let ([x '(a b)]) (append! x '(c d)) x) =\u0026gt; (a b c d) (append '(1 2 (3 4)) '(5 6)) =\u0026gt; (1 2 (3 4) 5 6) (append '(1 2 (3 4)) '() '(5 6)) =\u0026gt; (1 2 (3 4) 5 6)  ","id":5,"section":"posts","summary":"Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x))) (atom? '(a b c)) ⇒ #f (atom? '(3 . 4)) ⇒ #f (atom? '()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) *n*是一个非负整数，且小于等于*list","tags":["scheme"],"title":"Scheme/Chez Scheme 对象操作","uri":"https://lvsq.net/2019/12/operations-on-objects/","year":"2019"},{"content":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。\n (make-engine thunk)\n 通过传递一个无参数的thunk(形实转换程序)给make-engine来创建一个engine。thunk的body是会被engine执行的计算，engine本身是带3个参数的过程：\n ticks： 一个正整数，指定提供给engine的执行时间片（原文用的是fuel这个单词，意思是燃料，正对应这engine的本意，十分贴切）的数量，engine将会执行到时间片用完或者计算完成为止； complete： 一个或多个参数的函数，用于指定计算完成后的操作。它的参数是剩余的时间片数量和计算产生的值； expire： 一个参数的函数，该函数指定如果在计算完成之前时间片用完了该怎么办。它的参数是一个能从中断点继续进行计算的新引擎。  将引擎应用于其参数时，它将开启一个时长为ticks的计时器，如果引擎计算在计时器执行之前完成，系统将调用complete，并将剩余的ticks和计算产生的值传递给它；\n另一方面，如果计时器在引擎计算完成之前耗尽了，则系统会从中断计算的continuation中创建一个新引擎，并使该引擎过期。complete和expire会被新引擎继续使用。If, on the other hand, the timer goes off before the engine computation completes, the system creates a new engine from the continuation of the in- terrupted computation and passes this engine to expire. complete and expire are invoked in the continuation of the engine invocation.\n请勿同时使用计时器中断（set-timer），因为engine就是由计时器实现的。\n看看具体的例子：\n(define eng (make-engine (lambda () 3))) (eng 10 ;; ticks (lambda (ticks value) value) ;; complete (lambda (x) x) ;; expire ) ⇒ 3  通常将列表作为完整过程传递给引擎，使引擎完成时返回一个列表，该列表的第一个元素是剩余的ticks，另一个元素是计算返回的值，这通常很有用。\n(define eng (make-engine (lambda () 3))) (eng 10 list (lambda (x) x)) ⇒ (9 3)  在上面的示例中，计算值为3，还剩下9个时间片，即，需要一单位的时间片来计算出3。\n再看一个复杂点的例子： 先定义一个计算裴波那切值的函数\n(define fibonacci (lambda (n) (let fib ([i n]) (cond [(= i 0) 0] [(= i 1) 1] [else (+ (fib (- i 1)) (fib (- i 2)))]))))  创建engine\n(define eng (make-engine (lambda () (fibonacci 10))))  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ (21 55)  每次时间片（燃料）用完时，到期程序都会将eng分配给新引擎。整个计算需要4个blocks，每个block包含50个ticks。最后50个燃料中，有21个都用掉了。因此，使用的燃料总量为179个。\n我们还可以统计一下消耗的ticks数量\n(define mileage (lambda (thunk) (let loop ([eng (make-engine thunk)] [total-ticks 0]) (eng 50 (lambda (ticks . values) (+ total-ticks (- 50 ticks))) (lambda (new-eng) (loop new-eng (+ total-ticks 50))))))) (mileage (lambda () (fibonacci 10))) ⇒ 179  再看看一个例子——round-robin:\n(define round-robin (lambda (engs) (if (null? engs) '() ((car engs) 1 ;;ticks (lambda (ticks value) (cons value (round-robin (cdr engs)))) ;;complete (lambda (eng) ;;expire (round-robin (append (cdr engs) (list eng)))))))) (round-robin (map (lambda (x) (make-engine (lambda () (fibonacci x)))) '(4 5 2 8 3 7 6 2))) ⇒ (1 1 2 3 5 8 13 21)  这段代码需要费些思量，首先map函数创建了8个engine, 然后代入round-robin函数，该函数依次执行各个engine，但是每个engine分配的时间片只有1，对于参数\u0026rsquo;(4 5 2 8 3 7 6 2)，数字越小，越先执行完成，所以越早执行complete函数，最终结果就是排好顺序的了，很棒的程序！\n","id":6,"section":"posts","summary":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。 (make-engine thunk) 通过传递一个无参数的thun","tags":["engine","scheme"],"title":"Engine in Scheme","uri":"https://lvsq.net/2019/12/engine-in-scheme/","year":"2019"},{"content":" case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Scheme提供了case语法来处理这种情况，这与Java中的switch语法非常相似。\n我们来看看case的语法：\n (case expr0 clause1 clause2 \u0026hellip;)\n 除了最后一个clause之外，每个子句都必须采用以下形式之一：\n ((key \u0026hellip;) expr1 expr2 \u0026hellip;) (key expr1 expr2 \u0026hellip;)  每一个key值都应该是不同的，最后一个子句要么是上述那种形式，或者是一个像下面这样的else子句\n (else expr1 expr2 \u0026hellip;)  那么返回值是什么呢？\n匹配到某个key的或者else中的最后一个expr的值\n(define p (lambda (x) (case x [(\u0026quot;abc\u0026quot; \u0026quot;def\u0026quot;) 'one '1] [((a b c)) 'two] [else #f]))) (p (string #\\d #\\e #\\f)) ⇒ 1 (p '(a b c)) ⇒ two (p \u0026quot;eee\u0026quot;) ⇒ #f  上面的例子定义了一个函数p，接收一个参数x\n 如果x为字符串\u0026rdquo;abc\u0026rdquo;或者\u0026rdquo;def\u0026rdquo;，则返回1； 如果x为列表((a b c)，则返回two 其他情况返回#f  可见，有了case语法多条件判断写起来就方便很多，并且代码也容易读了，当然这里也可以用cond来写，这里只是为了描述case的语法而没有使用cond\n再看一个例子，就不用解释了：\n(let ([ls '(ii iv)]) (case (cadr ls) [i 1] [ii 2] [iii 3] [(iiii iv) 4] [else 'out-of-range])) ⇒ 4  record-case 来看看另一个很类似的扩展，也十分有用，它就是record-case。它可以以record为单位来做条件判断并执行指令。\n语法格式：  (record-case expr clause1 clause2 \u0026hellip;)\n 除了最后一个子句之外，每个clause的格式如下：\n ((key \u0026hellip;) formals body1 body2 \u0026hellip;)\n 每一个*key*都不应该相同, 最后一个clause可能是上述的格式或者是一个else子句：\n (else body1 body2 \u0026hellip;)\n expr必须是一个pair。Chez会拿(car expr)与各个子句中的key进行比较（用eqv?）来确定哪一个clause匹配, 然后(cdr expr)将与formals绑定。\n来看换一个例子：\n(define calc (lambda (x) (record-case x [(add) (x y) (+ x y)] [(sub) (x y) (- x y)] [(mul) (x y) (* x y)] [(div) (x y) (/ x y)] [else (assertion-violationf 'calc \u0026quot;invalid expression ~s\u0026quot; x)]))) (calc '(add 3 4)) =\u0026gt; 7 (calc '(div 3 4)) =\u0026gt; 3/4  ","id":7,"section":"posts","summary":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Schem","tags":["chez","scheme"],"title":"Chez Scheme中的case扩展","uri":"https://lvsq.net/2019/12/case-in-chez-scheme/","year":"2019"},{"content":" 易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴至，克尽其用，上下一体，俱不倦而事可毕矣\n 周云成康，汉言文景。无有六十年与民休息，累藏蓄积，汉武开疆之功便是空文，此厚积薄发耳，俗语言，胳膊收回来，打出去才有力\n 武帝一代雄主，文治武功，奋高祖之余烈，承三王之圣绪，开万世不拔之基，吾国斯民之幸，铭记汉青\n  ","id":8,"section":"posts","summary":"易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴","tags":["随想"],"title":"继学录","uri":"https://lvsq.net/2019/12/think/","year":"2019"},{"content":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。\n先看看该语法描述：\n(fluid-let ((var expr) \u0026hellip;) body1 body2 \u0026hellip;) returns: the values of the body body1 body2 \u0026hellip; libraries: (chezscheme)\n该Binding的作用类似局部变量，与set! 比较相似。由fluid-let定义的变量必须已绑定到顶层(top level)或者封闭的lambda内或者其他形式的绑定，这很关键！\n请看代码：\n(let ([x 3]) (+ (fluid-let ([x 5]) x) x)) ⇒ 8  先定义变量x=3，然后在加法操作当中临时将x的值改为5，最后结果为8，如果将fluid-let中的x换个名字，比如y，将如何呢？\n会得到一个异常：\n Exception: variable y is not bound\n y没有绑定，是的，y即没有在顶层中被定义，也未在某个lambda中或者任何其他形式，这里只能是x\n再学习下两个例子，加深印象：\n(let ([x 'a]) (letrec ([f (lambda (y) (cons x y))]) (fluid-let ([x 'b]) (f 'c)) )) ⇒ (b . c)  (let ([x 'a]) (call/cc (lambda (k) (fluid-let ([x 'b]) (letrec ([f (lambda (y) (k '*))]) (f '*))))) x) ⇒ a  ","id":9,"section":"posts","summary":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。 先看看该语法描","tags":["fluid-let","Scheme"],"title":"Fluid Binding in Chez Scheme","uri":"https://lvsq.net/2019/12/fluid-binding/","year":"2019"},{"content":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。\n这是语法描述：\n(rec var expr) syntax\nreturns: value of expr\nlibraries: (chezscheme)\nThe syntactic form rec creates a recursive object from expr by establishing a binding of var within expr to the value of expr. In essence, it is a special case of letrec for self-recursive objects.\nThis form is useful for creating recursive objects (especially procedures) that do not depend on external variables for the recursion, which are sometimes undesirable because the exter-nal bindings can change. For example, a recursive procedure defined at top level depends on the value of the top-level variable given as its name. If the value of this variable should change, the meaning of the procedure itself would change. If the procedure is defined instead with rec, its meaning is independent of the variable to which it is bound.\n简要翻译一下：\n语法rec 通过在expr中建立var与expr的值的绑定，创建一个递归对象。从本质上讲，这是letrec用于自递归对象的一种特殊情况。\n语法rec通过绑定expr中创建一个递归对象，用来 这种形式对于创建不依赖于外部变量进行递归的递归对象（尤其是过程）很有用，因为外部绑定可能会发生变化，所以有时这是不可取的。\n看一个例子来感受一下：\n给定一个全是数字的list，对于每一个数字n，算出$1+2+\u0026hellip;+n$的和，最终返回和的list.\n(map (rec sum (lambda (x) (if (= x 0) 0 (+ x (sum (- x 1)))))) ’(0 1 2 3 4 5)) ⇒ (0 1 3 6 10 15)  如果没有rec语法，用letrec也是可以的，但是稍显麻烦，代码也多一些，所以rec还是很好用的\n最后看一下rec语法的定义：\n(define-syntax rec (syntax-rules () [(_ x e) (letrec ((x e)) x)]))  ","id":10,"section":"posts","summary":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。 这是语法描述： (rec","tags":["Scheme","Chez","rec"],"title":"Recursive Bindings in Chez Scheme","uri":"https://lvsq.net/2019/12/recursive-bindings/","year":"2019"},{"content":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些时间，动手写了一个，目前已经在公司内部运行了几年，效果良好，并且已经开源在Github上，以飨各位。\n特点：\n API简洁 支持3种事件：\n UP DOWN JOIN  基于Vert.X\n  引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lvsq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jgossip\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  一个简单的例子：\nint gossip_port = 60001; String cluster = \u0026quot;gossip_cluster\u0026quot;; GossipSettings settings = new GossipSettings(); settings.setGossipInterval(1000); try { String myIpAddress = InetAddress.getLocalHost().getHostAddress(); List\u0026lt;SeedMember\u0026gt; seedNodes = new ArrayList\u0026lt;\u0026gt;(); SeedMember seed = new SeedMember(); seed.setCluster(cluster); seed.setIpAddress(myIpAddress); seed.setPort(60001); seedNodes.add(seed); gossipService = new GossipService(cluster, myIpAddress, gossip_port, null, seedNodes, settings, (member, state) -\u0026gt;System.out.println(\u0026quot;member:\u0026quot; + member + \u0026quot; state: \u0026quot; + state)); } catch (Exception e) { e.printStackTrace(); } gossipService.start();  详细介绍请看 =\u0026gt; 项目地址\n欢迎大家fork， 如果觉得好请start ~~~\n","id":11,"section":"posts","summary":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些","tags":["jgossip","gossip"],"title":"Jgossip - gossip协议的开源实现","uri":"https://lvsq.net/2019/12/jgossip/","year":"2019"},{"content":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加\nGolang的实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} nodes := []*ListNode{} var carry = 0 for { node, c := add(l1, l2, carry) carry = c if node != nil { nodes = append(nodes, node) if l1 != nil \u0026amp;\u0026amp; l1.Next != nil { l1 = l1.Next } else { l1 = nil } if l2 != nil \u0026amp;\u0026amp; l2.Next != nil { l2 = l2.Next } else { l2 = nil } if carry \u0026gt; 0 \u0026amp;\u0026amp; (l1 == nil \u0026amp;\u0026amp; l2 == nil) { nodes = append(nodes, \u0026amp;ListNode{Val:carry}) } } else { break } } for i, n := range nodes{ if i == 0 { result = n } if i + 1 \u0026lt; len(nodes) { n.Next = nodes[i + 1] } } return result } func add (n1 *ListNode, n2 *ListNode, carry int) (*ListNode, int) { node := \u0026amp;ListNode{} if (n1 == nil \u0026amp;\u0026amp; n2 == nil) { return nil, 0 } if n1 == nil { n1 = \u0026amp;ListNode{Val : 0} } if n2 == nil { n2 = \u0026amp;ListNode{Val : 0} } sum := n1.Val + n2.Val + carry carry = 0 if sum \u0026gt; 9 { carry = 1 sum = sum - 10 } node.Val = sum return node, carry }  下面提供Scheme版本的实现【(1 0) + (9 1 2) = (0 2 2)】，为了简单起见，与题目要求稍有不同，这里采用list，而不是题目要求的链表，但实际上应是一样的。比较之下可以看出，相对而言，Scheme语言的实现更加简短优雅，得益于其强大的表达能力\n(letrec ( [Polishing (lambda (l num) (if (eq? num 0) l (Polishing (append l '(0)) (- num 1))) ) ] [Align (lambda (l1 l2) (let ([len1 (length l1)] [len2 (length l2)]) (if [eq? len1 len2] [list l1 l2] [if (\u0026gt; len1 len2) (list l1 (Polishing l2 (- len1 len2))) (list (Polishing l1 (- len2 len1)) l2)])) ) ] [Add (lambda (l1 l2) (let ([ l (Align l1 l2)]) (Carry (map (lambda (x y) (+ x y)) (car l) (cadr l)) 0) ) ) ] [Carry (lambda (l c) (if (null? l) (if [eq? c 0] '() [cons c l]) (cons (mod ( + (car l) c ) 10) (Carry (cdr l) (quotient ( + (car l) c) 10))) ) ) ]) (Add '(1 0) '(9 1 2)))  Golang版本和Scheme版本的实现思路不相同，简要描述一下后者：\n (1 0) + (9 1 2), 先进行补位： (1 0 0) + (9 1 2), 按顺序相加，得： (10 1 2), 再计算进位： (0 2 2)  ","id":12,"section":"posts","summary":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加 Golang的实现： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result","tags":["Scheme","leetcode"],"title":"两数相加","uri":"https://lvsq.net/2019/12/leetcode-2/","year":"2019"},{"content":" 最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发。\n问题描述 假设我们已经有足够多的1分，2分，5分钱币，任意给定金额比如1元，问有多少种组合方式？ 换言之，$$1x+2y+5z = 100$$ 求x,y,z的解有多少个\n思路 组合方式的总和应为：\n 任意扣去一种钱币比如1分，1元采用2分，5分两种钱币的组合数，再加上：\n 总额为（1元-1分），采用1分，2分，5分三种钱币的组合数；\n  很明显这可以很容易用递归实现\n稍作一点解释：\na. 上面两步的意思是：不带1分的组合数 + 带1分的组合数 = 全部的组合数； 这是显而易见的\nb. 上述第2步，（1元-1分）的意思是：这样可以保证任意一种组合方式再加1分都等于1元，保证至少有1个1分的钱币\n(letrec [ (A (lambda (n d) (if (= 0 (mod n d)) 1 0))) (B (lambda (n d) (cond [(not (pair? d)) 0] [(null? d) 0] [(= 0 n) 1] [(\u0026gt; 0 n) 0] [(= 1 (length d)) (A n (car d))] [else ( + (B n (cdr d)) (B (- n (car d)) d)) ] ) ) ) ] [B 100 '(1 2 5)] )  ","id":13,"section":"posts","summary":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发","tags":["Scheme","SICP"],"title":"钱币组合问题","uri":"https://lvsq.net/2019/12/count-coins/","year":"2019"},{"content":" Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdquo;x-\u0026ldquo;）该如何开发做紧要的介绍。\n一切开始之前，有一点需要keep in mind，即增加扩展的位置不同，所用的方法不同，所以需要对Swagger的标准有所了解，可参考官方文档 springfox目前只允许三种扩展实现:\n ListVendorExtension:列表的形式,该对象支持泛型，最终形式：”x-field”:[{field:value}] ObjectVendorExtension:对象的扩展形式,最终的扩展形式是：”x-field”:[{field:value}] StringVendorExtension:string类型的扩展实现，最终的扩展形式是”x-field”:”value”  Swagger根对象扩展 以在info中添加一个x-logo为例\n\u0026quot;info\u0026quot;: { \u0026quot;description\u0026quot;: \u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;swagger-bootstrap-ui！！！\u0026quot;, \u0026quot;termsOfService\u0026quot;: \u0026quot;http://www.xxx.com/\u0026quot;, \u0026quot;contact\u0026quot;: { \u0026quot;name\u0026quot;: pxxxx@domain.com\u0026quot; }, \u0026quot;x-logo\u0026quot;: { \u0026quot;url\u0026quot;: \u0026quot;http://\u0026quot;, \u0026quot;color\u0026quot;: \u0026quot;#090807\u0026quot; } }, ...  后台代码：\nObjectVendorExtension logo = new ObjectVendorExtension(\u0026quot;x-logo\u0026quot;); logo.addProperty(new StringVendorExtension(\u0026quot;url\u0026quot;, \u0026quot;https://xxx.svg\u0026quot;)); logo.addProperty(new StringVendorExtension(\u0026quot;color\u0026quot;, \u0026quot;#090807\u0026quot;)); return new ApiInfoBuilder() .title(\u0026quot;swagger-bootstrap-ui！！\u0026quot;) .extensions(Lists.newArrayList(logo)) .description(\u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;) .termsOfServiceUrl(\u0026quot;http://www.xxx.com/\u0026quot;) .version(\u0026quot;1.0.0\u0026quot;) .build();  内部对象扩展 给Path添加一个扩展属性x-order为例\n@Component @Order(Ordered.HIGHEST_PRECEDENCE+100) public class OperationPositionBulderPlugin implements OperationBuilderPlugin { @Override public void apply(OperationContext context) { context.operationBuilder().extensions(Lists.newArrayList(new StringVendorExtension(\u0026quot;x-order\u0026quot;,\u0026quot;1\u0026quot;))); } @Override public boolean supports(DocumentationType delimiter) { return true; } }  详细介绍可以参考\n","id":14,"section":"posts","summary":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdq","tags":["swagger","vendorExtensions"],"title":"Swagger 如何使用vendorExtensions进行扩展","uri":"https://lvsq.net/2019/11/swagger-vendor/","year":"2019"},{"content":" 秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁，如平原君广纳异国宾客；苏秦上书于七国；荀子遍游天下者皆可证各国文字并无大乖。 《史籀篇》文首盖云“太史籀书”，人多误以太史籀所作，如此便望文生义了。太史乃官职，王国维先生引《说文》解释，籀即读，读即籀书。另太史籀书乃周世之成语，绝非人名。  ","id":15,"section":"posts","summary":"秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁","tags":["文史"],"title":"历史不能碰","uri":"https://lvsq.net/2019/11/do-not-touch-history/","year":"2019"},{"content":" M -\u0026gt; Alt(option) S -\u0026gt; Shift    快捷键 用途     M-v 上（后）一屏   C-v 下（前）一屏   C-l 重绘屏幕，将光标所在行置于屏幕中央   C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符   C-x C-f  查找或者新建一个文件   C-x C-b 列出缓冲区。 C-x 1 关闭缓冲区列表   C-x C-q 开启或者关闭buffer的只读模式   C-x C-s 保存当前文件   C-x s 保存所有文件   C-x h 全选   M-w 复制   C-y 粘贴   C-w 剪切   C-s 往前搜索   C-r 往后搜索. DEL 也可以往后搜索，   C-/ undo   M-x calendar 打开日历。按 q 退出。【g d 到指定日期】【. 到今日（不居中）】【\u0026gt; 前一个月】【\u0026lt; 后一个月】   M-x *-mode 选择Major mode   M-x shell 运行一个shell   M-x eshell 运行一个eshell   C-a 移到行首   C-a C-k、C-S-backspace 删除整行   C-u 5 C-S-backspace、M-5 C-S-backspace 删除后5行，不加数字则删除4行（默认），如果数字为负数，则往前删   C-g 停止当前的命令   C-k 删除从光标位置到行尾所有字符    Org-Mode    快捷键 用途     C-c . 插入时间   C-c C-e 导出其它格式   C-c C-s 在标题下面插入一个带有“==SCHEDULED==”关键字的时间戳。   C-c C-d 在标题下面插入一个带有“==DEADLINE==”关键字的时间戳   C-c C-t 将当前项的状态在（unmarked）-\u0026gt;TODO-\u0026gt;DONE 之间循环切换   M-RET 插入一个同级标题   M-LEFT/RIGHT 将当前的标题提升/降低一个等级   C-c C-c 插入标签tag。 光标在标题中   C-c C-q 插入标签tag。光标在任意位置   C-c , 设置当前标题的优先级,’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的   C-c  查找标签tag   S-Tab 展开所有标题   Tab 展开光标所在标题   C-c C-l 编辑链接   C-c C-o 打开链接    ","id":16,"section":"posts","summary":"M -\u0026gt; Alt(option) S -\u0026gt; Shift 快捷键 用途 M-v 上（后）一屏 C-v 下（前）一屏 C-l 重绘屏幕，将光标所在行置于屏幕中央 C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符 C-x C-f 查","tags":["emacs"],"title":"Emacs","uri":"https://lvsq.net/2019/11/emacs/","year":"2019"},{"content":" define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回true的谓词、以及每个字段的访问procedure和针对可变字段的赋值procedure。总的来说，与Java中的POJO类比较相似，不过不用自定义getter和setter方法，这与Kotlin倒为类似，例如：\n(define-record-type point (fields x y))  创建了一个名为point的record类型，并且有两个字段x和y，和如下几个定义式（自动生成）：\n| \u0026mdash; | \u0026mdash; (make-point x y) | 构造函数 (point? obj) | 谓词 (point-x p) | 字段x的访问器 (point-y p) | 字段y的访问器\n默认下，字段是不可变的，但是可以声明为可变的（mutable）。如下定义point中，字段x是可变的，但y维持不变：\n(define-record-type point (fields (mutable x) y))  当然亦可显式地将字段声明为不可变的：\n(define-record-type point (fields (mutable x) (immutable y)))  在这个例子中，define-record-type除了生成了上述的几个定义式之外，还为字段x增加了一个赋值过程：\n(point-x-set! p x)\n该赋值过程可以用于改变x的内容\n(define p (make-point 36 -17)) (point-x-set! p (- (point-x p) 12)) (point-x p) =\u0026gt; 24  自动生成的几个定义式是允许改变名称的，下面的point定义式，其构造函数名为mkpoint, 谓词为ispoint?，x和y的访问器分别为x-val和y-val, x的赋值器为set-x-val!\n(define-record-type (point mkpoint ispoint?) (fields (mutable x x-val set-x-val!) (immutable y y-val)))  默认情况下，每次一个record definition创建一个新类型（为方便理解，可以用Java来解释，即对于同一个POJO类new出两个实例，但这两个实例并不能equal），如下所示：\n(define (f p) (define-record-type point (fields x y)) (if (eq? p 'make) (make-point 3 4) (point? p))) (f (f 'make)) =\u0026gt; #f  第一个f的调用即(f \u0026lsquo;make)返回一个point类型的p，将p传递给第二个f，但p是由第一个调用生成的类型，所以point?返回#f。按照SICP的说法，这两个define-record-type并不在一个环境中，只是名字一样而已。\n默认的生产行为(generative behavior)或许可以由记录定义式中的nongenerative子句来重载：\n(define (f p) (define-record-type point (fields x y) (nongenerative)) (if (eq? p 'make) (make-point 3 4) (point? p))) (f (f 'make)) =\u0026gt; #t  以这种方式创建的记录类型仍然不同于由定义出现在程序的不同部分中创建的记录类型，即使这些定义在语法上是相同的：\n(define (f) (define-record-type point (fields x y) (nongenerative)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative)) (point? p)) (g (f)) =\u0026gt; #f  甚至可以通过在nongenerative子句中包含uid（唯一id）来覆盖它：\n(define (f) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (point? p)) (g (f)) =\u0026gt; #t  记录类型可以定义为有parent子句的子类型，即一个记录类型可以声明为某一个记录类型的子类型，如果指定了父类型，则子类型将继承父类型所有字段，且子类型的每个实例都被视为父类型的实例，因此可以直接使用父类型的访问器和字段等等。\n(define-record-type point (fields x y)) (define-record-type cpoint (parent point) (fields color)) (define cp (make-cpoint 3 4 'red)) (point? (make-cpoint 3 4 'red)) =\u0026gt; #t (cpoint? (make-point 3 4)) =\u0026gt; #f (define cp (make-cpoint 3 4 'red)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (cpoint-color cp) =\u0026gt; red  到目前为止，define-record-type定义的默认构造函数接受record包含的字段一样多的参数，其实我们可以重写默认值，这里需要引入protocol子句，以下定义将创建一个具有三个字段的点记录：x，y和d，其中d表示距原点的位移。构造函数仍然只接受两个参数，即x和y值，并将d初始化为x和y平方和的平方根。\n(define-record-type point (fields x y d) (protocol (lambda (new) (lambda (x y) (new x y (sqrt (+ (* x x) (* y y)))))))) (define p (make-point 3 4)) (point-x p) =\u0026gt; 3 (point-y p) =\u0026gt; 4 (point-d p) =\u0026gt; 5  另外，子类型的构造函数中的参数顺序是不可改变的，即先是父类型构造函数的字段，然后才是子类型的参数，如果需要改变子类型的构造函数的参数顺序该如何呢？\n(define-record-type cpoint (parent point) (fields color) (protocol (lambda (pargs-\u0026gt;new) (lambda (x c y) ((pargs-\u0026gt;new x y) c))))) (define cp (make-cpoint 3 'red 4)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (point-d cp) =\u0026gt; 5 (cpoint-color cp) =\u0026gt; red  最后来看看define-record-type的语法形似：\n syntax: (define-record-type record-name clause \u0026hellip;)\nsyntax: (define-record-type (record-name constructor pred) clause \u0026hellip;)\n Fields clause语法形式:\n (fields field-spec \u0026hellip;)\n field-spec必须是下面5个中的一个:\n field-name (immmutable field-name) (mutable field-name) (immmutable field-name accessor-name) (mutable field-name accessor-name mutator-name)  define-record in Chez Scheme Chez Scheme依然支持$R^6RS$中传统的record类型的定义，另外还提供一个新的语法，即define-record，其语法形式与define-record-type一样，所不同的地方在于，define-record中的字段默认是可变的，这与$R^6RS$中的record相反，因此，创建一个记录类型时，同时会定义下列过程：\n(define-record point (x y)) (make-point x y) ;;\tconstructor (point? obj) ;;\tpredicate (point-x p) ;;\taccessor for field x (point-y p) ;;\taccessor for field y (set-point-x! p obj) ;;\tmutator for field x (set-point-y! p obj) ;;\tmutator for field y  ","id":17,"section":"posts","summary":"define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回tr","tags":["scheme"],"title":"Scheme语define-record-type介绍","uri":"https://lvsq.net/2020/02/define-record-type/","year":"2020"},{"content":" Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以在 Chez Scheme 中以“微模块”级别使用，因为 Chez Scheme 中的模块和 import 形式属于定义，并且可以出现在定义可以出现的任意位置，包括在 lambda 表达式的程序体或其他局部作用域中。\n 微模块与函数孰好？？？还是视情况而定？？？\n 模块控制绑定的可见性，可以用作扩展词法作用域，以允许更精确地控制绑定的可见范围。模块导出标识符的绑定，即变量绑定、关键字绑定或模块名绑定。模块可以是具名的抑或匿名的。只要模块名可见，那么在具名模块出现处导入的绑定都可见。匿名模块中导出的绑定，在模块出现的地方被隐式地导入。匿名模块可用于隐藏一组绑定中的一些绑定，同时允许其余绑定可见。\n语法  (module name interface defn \u0026hellip; init \u0026hellip;)\n(module interface defn \u0026hellip; init \u0026hellip;)\n name 是标识符，defn \u0026hellip; 是定义，init \u0026hellip; 是表达式。interface 是形如 (export \u0026hellip;) 的导出表，其中每个 export 都是标识符 identifier 抑或形式 (identifier export \u0026hellip;)。\n模块由一组（可能为空的）定义和一组（可能为空的）初始化表达式序列组成。模块中定义的标识符（可理解为变量或者状态，下同）在模块的程序体中可见，被导出的标识符在模块的导入作用域内亦可见。模块接口中列出的每个标识符必须在该模块中定义或被导入该到模块。module 形式是一种定义，因此可以出现在其他定义可以出现的任何位置，包括嵌套在 lambda 表达式的程序体、 library 形式、顶层程序，以及嵌套在其他模块中。此外，因为模块名的作用域与其他标识符相同，所以模块和库可以像变量和关键字那样导出模块名。\n模块名与其他标识符占用相同的名字空间，并遵循相同的作用域规则。除非被导出，否则模块中定义的标识符仅在该模块中可见。\n模块内的表达式可以引用在模块外部绑定的标识符。\n(let ([x 3]) (module m (plusx) (define plusx (lambda (y) (+ x y)))) (import m) (let ([x 4]) (plusx 5))) ; =\u0026gt; 8,注意不是9哦，可以将plusx视为：(define plusx (lambda (y) (+ 3 y))))  同样，import不会阻止访问出现导入表单的可见标识符，但import标识符所覆盖的变量除外（啥叫覆盖，看下面两段代码）。\n(module m (y) (define y 'm-y)) (let ([x 'local-x] [y 'local-y]) (import m) (list x y)) ; =\u0026gt; (local-x m-y)  模块m中定义了标识符y, 在其被import之后会覆盖let中的y；\n(module m (y) (define y 'm-y)) (let () (import m) (let ([x 'local-x] [y 'local-y]) (list x y)) ; =\u0026gt; (local-x local-y) )  先import m，之后再定义y，模块中定义的y不会覆盖let的y。\n另一方面，在模块中使用 import-only 会建立一个隔离的作用域，其中唯一可见的是被导入模块所导出的标识符，下面的代码中只有y可见。\n对于静态验证，有时不希望使用任何标识符，除了明确导入模块或本地范围的标识符外，这有时是合乎需要的。\n(module m (y) (define y 'm-y)) (let ([x 'local-x] [y 'local-y]) (import-only m) x) ; =\u0026gt; Error: x is not visible  除非通过“import-only”导入的模块导出“import”或“import-only”以及至少一个模块的名称，否则无法在“import-only”范围内进行后续导入。 要创建一个包含多个模块导出的隔离范围而又不使“import”或“import-only”可见，必须以相同的“import-only”形式列出所有要导入的模块。\n另一种解决方案是创建一个包含每个其他模块的导出的模块。\n(module m2 (y) (define y 'y)) (module m1 (x) (define x 'x)) (module mega-module (cons x y) (import m1) (import m2) (import scheme)) (let ([y 3]) (import-only mega-module) (cons x y)) ; =\u0026gt; (x . y)  在它被编译之前，源程序被翻译成不含语法抽象、语法定义、库定义、模块定义以及 import 形式的核心语言程序。翻译由语法展开器负责，语法展开器以递归下降的方式处理源程序中的形式。\nmodule 和 import 特殊形式仅影响标识符(identifier)在源程序中的可见性，而不影响其含义。特别地，无论变量被绑定到在模块内部或外部定义的位置，import 都不会引入新位置。为了保持由模块和语法抽象建立的作用域关系，局部变量在必要时会被重命名。因此，表达式：\n(let ([x 1]) (module m (x setter) (define-syntax x (identifier-syntax z)) (define setter (lambda (x) (set! z x))) (define z 5)) (let ([y x] [z 0]) (import m) (setter 3) (+ x y z))) ; =\u0026gt; 4  等价于下面的表达式，其中标识符被统一地更名，并带上了下标：\n(let ([x0 1]) (define-syntax x1 (identifier-syntax z1)) (define setter1 (lambda (x2) (set! z1 x2))) (define z1 5) (let ([y3 x0] [z3 0]) (setter1 3) (+ x1 y3 z3)))  互递归module (module (a b) (module a (x) (define x (lambda () y))) (module b (y) (define y (lambda () x))) (import a) (import b))  此模式的一般化语法定义如下，允许定义多个互递归的模块\n(define-syntax rec-modules (syntax-rules (module) [(_ (module m (id ...) form ...) ...) (module (m ...) (module m (id ...) form ...) ... (import m) ...)]))  组合module 由于模块可以重新导出所导入的绑定，所以很容易在单个模块上提供多个视图，就像下面的 s 和 t 为 r 提供的视图那样，或者将几个模块组合成一个复合，就像 r 那样。\n(module p (x y) (define x 1) (define y 2)) (module q (y z) (define y 3) (define z 4)) (module r (a b c d) (import* p (a x) (b y)) (import* q (c y) (d z))) (module s (a c) (import r)) (module t (b d) (import r))  import* 稍微解释一下import*, 其语法定义如下：\n(define-syntax import* (syntax-rules () [(_ m) (begin)] [(_ m (new old)) (module (new) (module (tmp) (import m) (alias tmp old)) (alias new tmp))] [(_ m id) (module (id) (import m))] [(_ m spec0 spec1 ...) (begin (import* m spec0) (import* m spec1 ...))]))  它支持重命名import的绑定和选择性导入特定的绑定，无需使用内置的import子形式来选择和重命名标识符，举例来说：\n(let () (import* scheme (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7) (let () (import* (rnrs) (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7)  ","id":18,"section":"posts","summary":"Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以","tags":["modules"],"title":"Chez Scheme Modules","uri":"https://lvsq.net/2020/01/modules/","year":"2020"},{"content":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。\n(define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_ ((a1 v1) (a2 v2) ...) bodys ...) (let ((a1 v1)) (my-let* ((a2 v2) ...) bodys ...)) ) ) )  注意，my-let*是可以递归使用的，以及\u0026hellip;的用法。\n(define-syntax my-let* (syntax-rules () ( (_ () bodys ...) (let () bodys ...) ) ( (_ ((a1 v1) ...) bodys ...) (let () (define a1 v1) ... bodys ... ) ) ) )  这个实现方式与上面的不同，上面的是嵌套let，这里将直接按顺序define内部变量，代码更短。注意此处的\u0026hellip;的用法。\n","id":19,"section":"posts","summary":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。 (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_","tags":["scheme"],"title":"自定义 Let*","uri":"https://lvsq.net/2020/01/my-let/","year":"2020"},{"content":" Fluid Keyword Bindings fluid-let-syntax  语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩展期间会暂时更改keyword的现有绑定，而不是引入keyword的新绑定。也就是说，在扩展form1 form2 \u0026hellip;的过程中，每个keyword的可见范围（或顶级）将会临时替换为新的绑定关系。\n (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 2 ) ) )  (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (fluid-let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 1 ) ) )  对比上述两段代码，可知：两个表达式基本相同的，除了前者采用内部let-synctax语法，第二个采用fluid-let-syntax语法。在第一个表达式中，(g 1)扩展中的出现的f引用的是let-bound的变量f，而第二个表达式，f引用的是由fluid-let-syntax绑定的f\n","id":20,"section":"posts","summary":"Fluid Keyword Bindings fluid-let-syntax 语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩","tags":["module","syntactic"],"title":"Syntactic Extension and Modules in Chez Scheme","uri":"https://lvsq.net/2020/01/syntactic-extension-and-modules/","year":"2020"},{"content":" Chez Scheme中有一种Boxes结构，它是一个*单元素*对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构可以共享指向一个对象的引用，或指针。例如，在采用此种参数传递规则的语言的解释器中，可以用 boxes 实现 call-by-reference 的语义。解释有点绕，按我的理解boxes就相当于Golang的struct、Java中的类，将一些状态包装成一个整块，外界通过引用该整块的指针来访问内部的各个状态。\nBoxes 的字面形式带有前缀 #\u0026amp; (发音为 “hash-ampersand”). 例如， #\u0026amp;(a b c) 是一个 box，内容为列表 (a b c). 读取器若遇到 #!r6rs ，则会在其后的输入流中禁用 box 语法，除非在更近的位置遇到 #!chezscheme.\n所有 boxes 默认是可变的，包括常量。程序可以通过 box-immutable 创建不可变 boxes. 尝试修改不可变 box 会导致抛出异常。\n我们来看看一些用法：\n(box? obj) 如果 obj 是 box, 则为 #t, 否则为 #f.\n(box? '#\u0026amp;a) =\u0026gt; #t (box? 'a) =\u0026gt; #f (box? (box 3)) =\u0026gt; #t  (box obj) 创建一个由obj组成的box\n(box 'a) =\u0026gt; #\u0026amp;a (box (box '(a b c))) =\u0026gt; #\u0026amp;#\u0026amp;(a b c)  (unbox box) 返回box的内容\n(unbox #\u0026amp;a) =\u0026gt; a (unbox #\u0026amp;#\u0026amp;(a b c)) =\u0026gt; #\u0026amp;(a b c) (let ([b (box \u0026quot;hi\u0026quot;)]) (unbox b)) =\u0026gt; \u0026quot;hi\u0026quot;  (set-box! box obj) box 必须是可变的。 set-box! 把 box 的内容设置为 obj.\n(let ([b (box 'x)]) (set-box! b 'y) b) =\u0026gt; #\u0026amp;y (let ([incr! (lambda (x) (set-box! x (+ (unbox x) 1)))]) (let ([b (box 3)]) (incr! b) (unbox b))) =\u0026gt; 4  (box-cas! box old-obj new-obj) 如果 box 被改变，则为 #t, 否则为 #f.\nbox 必须是可变的。 若 box 待替换的内容和 old-obj 相同(基于 eq?), 则 box-cas! 自动将 box 的内容替换为 new-obj; 若不相同，则 box 保持不变。即CAS操作，原子的。\n(define b (box 'old)) (box-cas! b 'old 'new) =\u0026gt; #t (unbox b) =\u0026gt; 'new (box-cas! b 'other 'wrong) =\u0026gt; #f (unbox b) =\u0026gt; 'new  (mutable-box? obj) 如果 obj 是可变的 box ，则为 #t, 否则为 #f.\n(immutable-box? obj) 如果 obj 是不可变的 box ，则为 #t, 否则为 #f.\n(box-immutable obj) 返回一个内容为obj的不可变的box。Boxes 通常用来支持共享的，可变的结构，所以不可变的 box 一般没什么用。\n","id":21,"section":"posts","summary":"Chez Scheme中有一种Boxes结构，它是一个*单元素*对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据","tags":["scheme"],"title":"Chez Scheme中Boxes介绍","uri":"https://lvsq.net/2020/01/boxes-in-chez/","year":"2020"},{"content":" Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x)))\n(atom? '(a b c)) ⇒ #f (atom? '(3 . 4)) ⇒ #f (atom? '()) ⇒ #t (atom? 3) ⇒ #t  list-head(Chez) 用法：(list-head list n) *n*是一个非负整数，且小于等于*list*的长度；list-head和Scheme标准过程list-tail可能会同时使用来切割一个list，不同点在于，list-tail不会分配内存而只是返回源list的一个子列表，list-head总是返回源list前n个元素的副本\n(list-head '(a b c) 0) ⇒ () (list-head '(a b c) 2) ⇒ (a b) (list-head '(a b c) 3) ⇒ (a b c) (list-head '(a b c . d) 2) ⇒ (a b) (list-head '(a b c . d) 3) ⇒ (a b c) (list-head '#1=(a . #1#) 5) ⇒ (a a a a a)  last-pair(Chez) 用法：(last-pair list) 列表不能为空。 last-pair返回列表的最后一对（pair）（不是最后一个元素）, list可能是不正确的列表，在这种情况下，最后一对是包含最后一个元素和终止对象的一个pair。\n(last-pair '(a b c d)) ⇒ (d) (last-pair '(a b c.d)) ⇒ (c . d)  list-copy(Chez) 用法： (list-copy list) 返回一个list的副本，equal?（结构和值相同）判断为#t\nlist*(Chez) 用法：(list* obj \u0026hellip; final-obj)\n返回一个由obj \u0026hellip; final-obj 组成的list, 与R6RS的cons*相同\nmake-list(Chez) 用法： (make-list n) 或者 (make-list n obj)\n返回n个对象的列表。n是一个正整数， 如果obj不指定，则返回的list是不确定的\n(make-list 0 '()) =\u0026gt; () (make-list 3 0) =\u0026gt; (0 0 0) (make-list 2 \u0026quot;hi\u0026quot;) =\u0026gt; (\u0026quot;hi\u0026quot; \u0026quot;hi\u0026quot;)  iota(Chez) 用法：(iota n)\n返回从 0（包含）到 n（不包含）的整数列表，n须为精确的非负整数\n(iota 0) =\u0026gt; () (iota 5) =\u0026gt; (0 1 2 3 4)  enumerate(Chez) 用法： (enumerate ls)\n返回: 从 0（包含）到长度 ls（不包含）的整数列表\n(enumerate '()) =\u0026gt; () (enumerate '(a b c)) =\u0026gt; (0 1 2) (let ([ls '(a b c)]) (map cons ls (enumerate ls))) =\u0026gt; ((a . 0) (b . 1) (c . 2))  remq! | remv! | remove!(Chez) 用法： (remq! obj list) | (remv! obj list) | (remove! obj list)\n返回: 列表中所有 obj 都被移除后的列表\n这些过程与 R6RS 中的 remq, remv, 及 remove 过程类似，只是 remq!, remv! 和 remove! 使用输入列表中的pair来构成输出列表。它们进行较少的空间分配，但并不一定比它们非破坏性的相应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(remq! 'a '(a b a c a d)) ⇒ (b c d) (remv! #\\a '(#\\a #\\b #\\c)) =\u0026gt; (#\\b #\\c) (remove! '(c) '((a) (b) (c))) =\u0026gt; ((a) (b))  substq | substv | subst | substq! | substv! | subst!(Chez) 用法： (subs* new old tree)\n返回：在tree中将匹配到的old元素全部替换为new之后的tree.\n对于 substq 和 substq! ，相等性测试是基于 eq?, substv 和 substv! 是基于 eqv?, 而 subst 和 subst! 是基于 equal? substq!, substv!, 和 subst! 执行破坏性的替换。它们进行较少的空间分配，但并不一定比它们非破坏性的对应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(substq 'a 'b '((b c) b a)) =\u0026gt; ((a c) a a) (substv 2 1 '((1 . 2) (1 . 4) . 1)) =\u0026gt; ((2 . 2) (2 . 4) . 2) (subst 'a '(a . b) '((a . b) (c a . b) . c)) =\u0026gt; (a (c . a) . c) (let ([tr '((b c) b a)]) (substq! 'a 'b tr) tr) =\u0026gt; ((a c) a a)  reverse! 用法：(reverse! list)\n返回：将原list反向输出\nreverse! 通过反转其链接破坏性地反向排序列表。以 reverse! 取代 reverse 减少了空间分配，但并不一定比使用 reverse 更快。如果滥用，会很容易导致混乱或错误的结果。\n(reverse! '()) =\u0026gt; () (reverse! '(a b c)) =\u0026gt; (c b a) (let ([x '(a b c)]) (reverse! x) x) =\u0026gt; (a) (let ([x '(a b c)]) (set! x (reverse! x)) x) =\u0026gt; (c b a)  append! 用法：(append! list \u0026hellip;)\n返回：将所有输入list串联起来的列表\n如同 append, append! 返回一个新的列表，其中元素依次为第一个列表中的元素，第二个列表中的元素，第三个列表中的元素，等等。不同之处在于， append! 重用所有参数中的点对以构造新列表。即，每一个列表参数的最后一个cdr, 其后一元素变为指向下一个列表参数。除最后一个参数外，如果任一参数为空列表，它实质上会被忽略。最后一个参数（并不一定得是列表）是不变的。\n相比于 append, append! 进行更少的空间分配（因为只修改指针，并没有数据拷贝），但并不一定更快。如果滥用，会很容易导致混乱或错误的结果。\n(append! '(a b) '(c d)) =\u0026gt; (a b c d) (let ([x '(a b)]) (append! x '(c d)) x) =\u0026gt; (a b c d) (append '(1 2 (3 4)) '(5 6)) =\u0026gt; (1 2 (3 4) 5 6) (append '(1 2 (3 4)) '() '(5 6)) =\u0026gt; (1 2 (3 4) 5 6)  ","id":22,"section":"posts","summary":"Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x))) (atom? '(a b c)) ⇒ #f (atom? '(3 . 4)) ⇒ #f (atom? '()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) *n*是一个非负整数，且小于等于*list","tags":["scheme"],"title":"Scheme/Chez Scheme 对象操作","uri":"https://lvsq.net/2019/12/operations-on-objects/","year":"2019"},{"content":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。\n (make-engine thunk)\n 通过传递一个无参数的thunk(形实转换程序)给make-engine来创建一个engine。thunk的body是会被engine执行的计算，engine本身是带3个参数的过程：\n ticks： 一个正整数，指定提供给engine的执行时间片（原文用的是fuel这个单词，意思是燃料，正对应这engine的本意，十分贴切）的数量，engine将会执行到时间片用完或者计算完成为止； complete： 一个或多个参数的函数，用于指定计算完成后的操作。它的参数是剩余的时间片数量和计算产生的值； expire： 一个参数的函数，该函数指定如果在计算完成之前时间片用完了该怎么办。它的参数是一个能从中断点继续进行计算的新引擎。  将引擎应用于其参数时，它将开启一个时长为ticks的计时器，如果引擎计算在计时器执行之前完成，系统将调用complete，并将剩余的ticks和计算产生的值传递给它；\n另一方面，如果计时器在引擎计算完成之前耗尽了，则系统会从中断计算的continuation中创建一个新引擎，并使该引擎过期。complete和expire会被新引擎继续使用。If, on the other hand, the timer goes off before the engine computation completes, the system creates a new engine from the continuation of the in- terrupted computation and passes this engine to expire. complete and expire are invoked in the continuation of the engine invocation.\n请勿同时使用计时器中断（set-timer），因为engine就是由计时器实现的。\n看看具体的例子：\n(define eng (make-engine (lambda () 3))) (eng 10 ;; ticks (lambda (ticks value) value) ;; complete (lambda (x) x) ;; expire ) ⇒ 3  通常将列表作为完整过程传递给引擎，使引擎完成时返回一个列表，该列表的第一个元素是剩余的ticks，另一个元素是计算返回的值，这通常很有用。\n(define eng (make-engine (lambda () 3))) (eng 10 list (lambda (x) x)) ⇒ (9 3)  在上面的示例中，计算值为3，还剩下9个时间片，即，需要一单位的时间片来计算出3。\n再看一个复杂点的例子： 先定义一个计算裴波那切值的函数\n(define fibonacci (lambda (n) (let fib ([i n]) (cond [(= i 0) 0] [(= i 1) 1] [else (+ (fib (- i 1)) (fib (- i 2)))]))))  创建engine\n(define eng (make-engine (lambda () (fibonacci 10))))  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ (21 55)  每次时间片（燃料）用完时，到期程序都会将eng分配给新引擎。整个计算需要4个blocks，每个block包含50个ticks。最后50个燃料中，有21个都用掉了。因此，使用的燃料总量为179个。\n我们还可以统计一下消耗的ticks数量\n(define mileage (lambda (thunk) (let loop ([eng (make-engine thunk)] [total-ticks 0]) (eng 50 (lambda (ticks . values) (+ total-ticks (- 50 ticks))) (lambda (new-eng) (loop new-eng (+ total-ticks 50))))))) (mileage (lambda () (fibonacci 10))) ⇒ 179  再看看一个例子——round-robin:\n(define round-robin (lambda (engs) (if (null? engs) '() ((car engs) 1 ;;ticks (lambda (ticks value) (cons value (round-robin (cdr engs)))) ;;complete (lambda (eng) ;;expire (round-robin (append (cdr engs) (list eng)))))))) (round-robin (map (lambda (x) (make-engine (lambda () (fibonacci x)))) '(4 5 2 8 3 7 6 2))) ⇒ (1 1 2 3 5 8 13 21)  这段代码需要费些思量，首先map函数创建了8个engine, 然后代入round-robin函数，该函数依次执行各个engine，但是每个engine分配的时间片只有1，对于参数\u0026rsquo;(4 5 2 8 3 7 6 2)，数字越小，越先执行完成，所以越早执行complete函数，最终结果就是排好顺序的了，很棒的程序！\n","id":23,"section":"posts","summary":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。 (make-engine thunk) 通过传递一个无参数的thun","tags":["engine","scheme"],"title":"Engine in Scheme","uri":"https://lvsq.net/2019/12/engine-in-scheme/","year":"2019"},{"content":" case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Scheme提供了case语法来处理这种情况，这与Java中的switch语法非常相似。\n我们来看看case的语法：\n (case expr0 clause1 clause2 \u0026hellip;)\n 除了最后一个clause之外，每个子句都必须采用以下形式之一：\n ((key \u0026hellip;) expr1 expr2 \u0026hellip;) (key expr1 expr2 \u0026hellip;)  每一个key值都应该是不同的，最后一个子句要么是上述那种形式，或者是一个像下面这样的else子句\n (else expr1 expr2 \u0026hellip;)  那么返回值是什么呢？\n匹配到某个key的或者else中的最后一个expr的值\n(define p (lambda (x) (case x [(\u0026quot;abc\u0026quot; \u0026quot;def\u0026quot;) 'one '1] [((a b c)) 'two] [else #f]))) (p (string #\\d #\\e #\\f)) ⇒ 1 (p '(a b c)) ⇒ two (p \u0026quot;eee\u0026quot;) ⇒ #f  上面的例子定义了一个函数p，接收一个参数x\n 如果x为字符串\u0026rdquo;abc\u0026rdquo;或者\u0026rdquo;def\u0026rdquo;，则返回1； 如果x为列表((a b c)，则返回two 其他情况返回#f  可见，有了case语法多条件判断写起来就方便很多，并且代码也容易读了，当然这里也可以用cond来写，这里只是为了描述case的语法而没有使用cond\n再看一个例子，就不用解释了：\n(let ([ls '(ii iv)]) (case (cadr ls) [i 1] [ii 2] [iii 3] [(iiii iv) 4] [else 'out-of-range])) ⇒ 4  record-case 来看看另一个很类似的扩展，也十分有用，它就是record-case。它可以以record为单位来做条件判断并执行指令。\n语法格式：  (record-case expr clause1 clause2 \u0026hellip;)\n 除了最后一个子句之外，每个clause的格式如下：\n ((key \u0026hellip;) formals body1 body2 \u0026hellip;)\n 每一个*key*都不应该相同, 最后一个clause可能是上述的格式或者是一个else子句：\n (else body1 body2 \u0026hellip;)\n expr必须是一个pair。Chez会拿(car expr)与各个子句中的key进行比较（用eqv?）来确定哪一个clause匹配, 然后(cdr expr)将与formals绑定。\n来看换一个例子：\n(define calc (lambda (x) (record-case x [(add) (x y) (+ x y)] [(sub) (x y) (- x y)] [(mul) (x y) (* x y)] [(div) (x y) (/ x y)] [else (assertion-violationf 'calc \u0026quot;invalid expression ~s\u0026quot; x)]))) (calc '(add 3 4)) =\u0026gt; 7 (calc '(div 3 4)) =\u0026gt; 3/4  ","id":24,"section":"posts","summary":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Schem","tags":["chez","scheme"],"title":"Chez Scheme中的case扩展","uri":"https://lvsq.net/2019/12/case-in-chez-scheme/","year":"2019"},{"content":" 易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴至，克尽其用，上下一体，俱不倦而事可毕矣\n 周云成康，汉言文景。无有六十年与民休息，累藏蓄积，汉武开疆之功便是空文，此厚积薄发耳，俗语言，胳膊收回来，打出去才有力\n 武帝一代雄主，文治武功，奋高祖之余烈，承三王之圣绪，开万世不拔之基，吾国斯民之幸，铭记汉青\n  ","id":25,"section":"posts","summary":"易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴","tags":["随想"],"title":"继学录","uri":"https://lvsq.net/2019/12/think/","year":"2019"},{"content":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。\n先看看该语法描述：\n(fluid-let ((var expr) \u0026hellip;) body1 body2 \u0026hellip;) returns: the values of the body body1 body2 \u0026hellip; libraries: (chezscheme)\n该Binding的作用类似局部变量，与set! 比较相似。由fluid-let定义的变量必须已绑定到顶层(top level)或者封闭的lambda内或者其他形式的绑定，这很关键！\n请看代码：\n(let ([x 3]) (+ (fluid-let ([x 5]) x) x)) ⇒ 8  先定义变量x=3，然后在加法操作当中临时将x的值改为5，最后结果为8，如果将fluid-let中的x换个名字，比如y，将如何呢？\n会得到一个异常：\n Exception: variable y is not bound\n y没有绑定，是的，y即没有在顶层中被定义，也未在某个lambda中或者任何其他形式，这里只能是x\n再学习下两个例子，加深印象：\n(let ([x 'a]) (letrec ([f (lambda (y) (cons x y))]) (fluid-let ([x 'b]) (f 'c)) )) ⇒ (b . c)  (let ([x 'a]) (call/cc (lambda (k) (fluid-let ([x 'b]) (letrec ([f (lambda (y) (k '*))]) (f '*))))) x) ⇒ a  ","id":26,"section":"posts","summary":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。 先看看该语法描","tags":["fluid-let","Scheme"],"title":"Fluid Binding in Chez Scheme","uri":"https://lvsq.net/2019/12/fluid-binding/","year":"2019"},{"content":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。\n这是语法描述：\n(rec var expr) syntax\nreturns: value of expr\nlibraries: (chezscheme)\nThe syntactic form rec creates a recursive object from expr by establishing a binding of var within expr to the value of expr. In essence, it is a special case of letrec for self-recursive objects.\nThis form is useful for creating recursive objects (especially procedures) that do not depend on external variables for the recursion, which are sometimes undesirable because the exter-nal bindings can change. For example, a recursive procedure defined at top level depends on the value of the top-level variable given as its name. If the value of this variable should change, the meaning of the procedure itself would change. If the procedure is defined instead with rec, its meaning is independent of the variable to which it is bound.\n简要翻译一下：\n语法rec 通过在expr中建立var与expr的值的绑定，创建一个递归对象。从本质上讲，这是letrec用于自递归对象的一种特殊情况。\n语法rec通过绑定expr中创建一个递归对象，用来 这种形式对于创建不依赖于外部变量进行递归的递归对象（尤其是过程）很有用，因为外部绑定可能会发生变化，所以有时这是不可取的。\n看一个例子来感受一下：\n给定一个全是数字的list，对于每一个数字n，算出$1+2+\u0026hellip;+n$的和，最终返回和的list.\n(map (rec sum (lambda (x) (if (= x 0) 0 (+ x (sum (- x 1)))))) ’(0 1 2 3 4 5)) ⇒ (0 1 3 6 10 15)  如果没有rec语法，用letrec也是可以的，但是稍显麻烦，代码也多一些，所以rec还是很好用的\n最后看一下rec语法的定义：\n(define-syntax rec (syntax-rules () [(_ x e) (letrec ((x e)) x)]))  ","id":27,"section":"posts","summary":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。 这是语法描述： (rec","tags":["Scheme","Chez","rec"],"title":"Recursive Bindings in Chez Scheme","uri":"https://lvsq.net/2019/12/recursive-bindings/","year":"2019"},{"content":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些时间，动手写了一个，目前已经在公司内部运行了几年，效果良好，并且已经开源在Github上，以飨各位。\n特点：\n API简洁 支持3种事件：\n UP DOWN JOIN  基于Vert.X\n  引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lvsq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jgossip\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  一个简单的例子：\nint gossip_port = 60001; String cluster = \u0026quot;gossip_cluster\u0026quot;; GossipSettings settings = new GossipSettings(); settings.setGossipInterval(1000); try { String myIpAddress = InetAddress.getLocalHost().getHostAddress(); List\u0026lt;SeedMember\u0026gt; seedNodes = new ArrayList\u0026lt;\u0026gt;(); SeedMember seed = new SeedMember(); seed.setCluster(cluster); seed.setIpAddress(myIpAddress); seed.setPort(60001); seedNodes.add(seed); gossipService = new GossipService(cluster, myIpAddress, gossip_port, null, seedNodes, settings, (member, state) -\u0026gt;System.out.println(\u0026quot;member:\u0026quot; + member + \u0026quot; state: \u0026quot; + state)); } catch (Exception e) { e.printStackTrace(); } gossipService.start();  详细介绍请看 =\u0026gt; 项目地址\n欢迎大家fork， 如果觉得好请start ~~~\n","id":28,"section":"posts","summary":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些","tags":["jgossip","gossip"],"title":"Jgossip - gossip协议的开源实现","uri":"https://lvsq.net/2019/12/jgossip/","year":"2019"},{"content":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加\nGolang的实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} nodes := []*ListNode{} var carry = 0 for { node, c := add(l1, l2, carry) carry = c if node != nil { nodes = append(nodes, node) if l1 != nil \u0026amp;\u0026amp; l1.Next != nil { l1 = l1.Next } else { l1 = nil } if l2 != nil \u0026amp;\u0026amp; l2.Next != nil { l2 = l2.Next } else { l2 = nil } if carry \u0026gt; 0 \u0026amp;\u0026amp; (l1 == nil \u0026amp;\u0026amp; l2 == nil) { nodes = append(nodes, \u0026amp;ListNode{Val:carry}) } } else { break } } for i, n := range nodes{ if i == 0 { result = n } if i + 1 \u0026lt; len(nodes) { n.Next = nodes[i + 1] } } return result } func add (n1 *ListNode, n2 *ListNode, carry int) (*ListNode, int) { node := \u0026amp;ListNode{} if (n1 == nil \u0026amp;\u0026amp; n2 == nil) { return nil, 0 } if n1 == nil { n1 = \u0026amp;ListNode{Val : 0} } if n2 == nil { n2 = \u0026amp;ListNode{Val : 0} } sum := n1.Val + n2.Val + carry carry = 0 if sum \u0026gt; 9 { carry = 1 sum = sum - 10 } node.Val = sum return node, carry }  下面提供Scheme版本的实现【(1 0) + (9 1 2) = (0 2 2)】，为了简单起见，与题目要求稍有不同，这里采用list，而不是题目要求的链表，但实际上应是一样的。比较之下可以看出，相对而言，Scheme语言的实现更加简短优雅，得益于其强大的表达能力\n(letrec ( [Polishing (lambda (l num) (if (eq? num 0) l (Polishing (append l '(0)) (- num 1))) ) ] [Align (lambda (l1 l2) (let ([len1 (length l1)] [len2 (length l2)]) (if [eq? len1 len2] [list l1 l2] [if (\u0026gt; len1 len2) (list l1 (Polishing l2 (- len1 len2))) (list (Polishing l1 (- len2 len1)) l2)])) ) ] [Add (lambda (l1 l2) (let ([ l (Align l1 l2)]) (Carry (map (lambda (x y) (+ x y)) (car l) (cadr l)) 0) ) ) ] [Carry (lambda (l c) (if (null? l) (if [eq? c 0] '() [cons c l]) (cons (mod ( + (car l) c ) 10) (Carry (cdr l) (quotient ( + (car l) c) 10))) ) ) ]) (Add '(1 0) '(9 1 2)))  Golang版本和Scheme版本的实现思路不相同，简要描述一下后者：\n (1 0) + (9 1 2), 先进行补位： (1 0 0) + (9 1 2), 按顺序相加，得： (10 1 2), 再计算进位： (0 2 2)  ","id":29,"section":"posts","summary":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加 Golang的实现： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result","tags":["Scheme","leetcode"],"title":"两数相加","uri":"https://lvsq.net/2019/12/leetcode-2/","year":"2019"},{"content":" 最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发。\n问题描述 假设我们已经有足够多的1分，2分，5分钱币，任意给定金额比如1元，问有多少种组合方式？ 换言之，$$1x+2y+5z = 100$$ 求x,y,z的解有多少个\n思路 组合方式的总和应为：\n 任意扣去一种钱币比如1分，1元采用2分，5分两种钱币的组合数，再加上：\n 总额为（1元-1分），采用1分，2分，5分三种钱币的组合数；\n  很明显这可以很容易用递归实现\n稍作一点解释：\na. 上面两步的意思是：不带1分的组合数 + 带1分的组合数 = 全部的组合数； 这是显而易见的\nb. 上述第2步，（1元-1分）的意思是：这样可以保证任意一种组合方式再加1分都等于1元，保证至少有1个1分的钱币\n(letrec [ (A (lambda (n d) (if (= 0 (mod n d)) 1 0))) (B (lambda (n d) (cond [(not (pair? d)) 0] [(null? d) 0] [(= 0 n) 1] [(\u0026gt; 0 n) 0] [(= 1 (length d)) (A n (car d))] [else ( + (B n (cdr d)) (B (- n (car d)) d)) ] ) ) ) ] [B 100 '(1 2 5)] )  ","id":30,"section":"posts","summary":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发","tags":["Scheme","SICP"],"title":"钱币组合问题","uri":"https://lvsq.net/2019/12/count-coins/","year":"2019"},{"content":" Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdquo;x-\u0026ldquo;）该如何开发做紧要的介绍。\n一切开始之前，有一点需要keep in mind，即增加扩展的位置不同，所用的方法不同，所以需要对Swagger的标准有所了解，可参考官方文档 springfox目前只允许三种扩展实现:\n ListVendorExtension:列表的形式,该对象支持泛型，最终形式：”x-field”:[{field:value}] ObjectVendorExtension:对象的扩展形式,最终的扩展形式是：”x-field”:[{field:value}] StringVendorExtension:string类型的扩展实现，最终的扩展形式是”x-field”:”value”  Swagger根对象扩展 以在info中添加一个x-logo为例\n\u0026quot;info\u0026quot;: { \u0026quot;description\u0026quot;: \u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;swagger-bootstrap-ui！！！\u0026quot;, \u0026quot;termsOfService\u0026quot;: \u0026quot;http://www.xxx.com/\u0026quot;, \u0026quot;contact\u0026quot;: { \u0026quot;name\u0026quot;: pxxxx@domain.com\u0026quot; }, \u0026quot;x-logo\u0026quot;: { \u0026quot;url\u0026quot;: \u0026quot;http://\u0026quot;, \u0026quot;color\u0026quot;: \u0026quot;#090807\u0026quot; } }, ...  后台代码：\nObjectVendorExtension logo = new ObjectVendorExtension(\u0026quot;x-logo\u0026quot;); logo.addProperty(new StringVendorExtension(\u0026quot;url\u0026quot;, \u0026quot;https://xxx.svg\u0026quot;)); logo.addProperty(new StringVendorExtension(\u0026quot;color\u0026quot;, \u0026quot;#090807\u0026quot;)); return new ApiInfoBuilder() .title(\u0026quot;swagger-bootstrap-ui！！\u0026quot;) .extensions(Lists.newArrayList(logo)) .description(\u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;) .termsOfServiceUrl(\u0026quot;http://www.xxx.com/\u0026quot;) .version(\u0026quot;1.0.0\u0026quot;) .build();  内部对象扩展 给Path添加一个扩展属性x-order为例\n@Component @Order(Ordered.HIGHEST_PRECEDENCE+100) public class OperationPositionBulderPlugin implements OperationBuilderPlugin { @Override public void apply(OperationContext context) { context.operationBuilder().extensions(Lists.newArrayList(new StringVendorExtension(\u0026quot;x-order\u0026quot;,\u0026quot;1\u0026quot;))); } @Override public boolean supports(DocumentationType delimiter) { return true; } }  详细介绍可以参考\n","id":31,"section":"posts","summary":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdq","tags":["swagger","vendorExtensions"],"title":"Swagger 如何使用vendorExtensions进行扩展","uri":"https://lvsq.net/2019/11/swagger-vendor/","year":"2019"},{"content":" 秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁，如平原君广纳异国宾客；苏秦上书于七国；荀子遍游天下者皆可证各国文字并无大乖。 《史籀篇》文首盖云“太史籀书”，人多误以太史籀所作，如此便望文生义了。太史乃官职，王国维先生引《说文》解释，籀即读，读即籀书。另太史籀书乃周世之成语，绝非人名。  ","id":32,"section":"posts","summary":"秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁","tags":["文史"],"title":"历史不能碰","uri":"https://lvsq.net/2019/11/do-not-touch-history/","year":"2019"},{"content":" M -\u0026gt; Alt(option) S -\u0026gt; Shift    快捷键 用途     M-v 上（后）一屏   C-v 下（前）一屏   C-l 重绘屏幕，将光标所在行置于屏幕中央   C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符   C-x C-f  查找或者新建一个文件   C-x C-b 列出缓冲区。 C-x 1 关闭缓冲区列表   C-x C-q 开启或者关闭buffer的只读模式   C-x C-s 保存当前文件   C-x s 保存所有文件   C-x h 全选   M-w 复制   C-y 粘贴   C-w 剪切   C-s 往前搜索   C-r 往后搜索. DEL 也可以往后搜索，   C-/ undo   M-x calendar 打开日历。按 q 退出。【g d 到指定日期】【. 到今日（不居中）】【\u0026gt; 前一个月】【\u0026lt; 后一个月】   M-x *-mode 选择Major mode   M-x shell 运行一个shell   M-x eshell 运行一个eshell   C-a 移到行首   C-a C-k、C-S-backspace 删除整行   C-u 5 C-S-backspace、M-5 C-S-backspace 删除后5行，不加数字则删除4行（默认），如果数字为负数，则往前删   C-g 停止当前的命令   C-k 删除从光标位置到行尾所有字符    Org-Mode    快捷键 用途     C-c . 插入时间   C-c C-e 导出其它格式   C-c C-s 在标题下面插入一个带有“==SCHEDULED==”关键字的时间戳。   C-c C-d 在标题下面插入一个带有“==DEADLINE==”关键字的时间戳   C-c C-t 将当前项的状态在（unmarked）-\u0026gt;TODO-\u0026gt;DONE 之间循环切换   M-RET 插入一个同级标题   M-LEFT/RIGHT 将当前的标题提升/降低一个等级   C-c C-c 插入标签tag。 光标在标题中   C-c C-q 插入标签tag。光标在任意位置   C-c , 设置当前标题的优先级,’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的   C-c  查找标签tag   S-Tab 展开所有标题   Tab 展开光标所在标题   C-c C-l 编辑链接   C-c C-o 打开链接    ","id":33,"section":"posts","summary":"M -\u0026gt; Alt(option) S -\u0026gt; Shift 快捷键 用途 M-v 上（后）一屏 C-v 下（前）一屏 C-l 重绘屏幕，将光标所在行置于屏幕中央 C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符 C-x C-f 查","tags":["emacs"],"title":"Emacs","uri":"https://lvsq.net/2019/11/emacs/","year":"2019"}],"tags":[{"title":"about","uri":"https://lvsq.net/tags/about/"},{"title":"chez","uri":"https://lvsq.net/tags/chez/"},{"title":"emacs","uri":"https://lvsq.net/tags/emacs/"},{"title":"engine","uri":"https://lvsq.net/tags/engine/"},{"title":"fluid-let","uri":"https://lvsq.net/tags/fluid-let/"},{"title":"gossip","uri":"https://lvsq.net/tags/gossip/"},{"title":"jgossip","uri":"https://lvsq.net/tags/jgossip/"},{"title":"leetcode","uri":"https://lvsq.net/tags/leetcode/"},{"title":"module","uri":"https://lvsq.net/tags/module/"},{"title":"modules","uri":"https://lvsq.net/tags/modules/"},{"title":"rec","uri":"https://lvsq.net/tags/rec/"},{"title":"scheme","uri":"https://lvsq.net/tags/scheme/"},{"title":"SICP","uri":"https://lvsq.net/tags/sicp/"},{"title":"swagger","uri":"https://lvsq.net/tags/swagger/"},{"title":"syntactic","uri":"https://lvsq.net/tags/syntactic/"},{"title":"vendorExtensions","uri":"https://lvsq.net/tags/vendorextensions/"},{"title":"文史","uri":"https://lvsq.net/tags/%E6%96%87%E5%8F%B2/"},{"title":"随想","uri":"https://lvsq.net/tags/%E9%9A%8F%E6%83%B3/"}]}