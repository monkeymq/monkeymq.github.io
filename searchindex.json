{"categories":[{"title":"Chez","uri":"https://lvsq.net/categories/chez/"},{"title":"Java","uri":"https://lvsq.net/categories/java/"},{"title":"LeetCode","uri":"https://lvsq.net/categories/leetcode/"},{"title":"scheme","uri":"https://lvsq.net/categories/scheme/"},{"title":"tool","uri":"https://lvsq.net/categories/tool/"},{"title":"文史","uri":"https://lvsq.net/categories/%E6%96%87%E5%8F%B2/"}],"posts":[{"content":" 垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。\n回收由默认的collect-request处理程序自动触发，该处理程序通过collect-request中断调用，该中断在分配了大约n个字节的存储空间后发生，其中n是参数collect-trip-bytes 的值。 默认的collect-request处理程序通过调用不带参数的collect程序来进行会睡。 可以通过更改参数collect-request-handler 的值来重新定义collect-request处理程序。 程序还可以通过直接调用collect来导致在collect-request中断之间发生回收。\nChez Scheme的回收器是基于分代 的。它根据对象的年龄（大致来说，回收幸存数）来对对象进行分类，且老对象比年轻对象回收的频率要低。由于年轻对象比老对象更快地变为不可访问，因此结果是大多数的回收花费的时间更少。系统还维护一个静态代（static generation, 类似Java的永久代），不会对此存储进行回收。仅当压缩堆（Scompact_heap）或要collect的target-generation 参数为static符号时，才将对象放入静态代中。\n非静态代的编号从最年轻的世代（开始于0）到collect-maximum-generation的当前值。存储管理器将新分配的对象放入第0代。在第0代的回收过程中，默认情况下，将第0代的对象挪到第1代，类似地，在第1代回收期间，存活的第0代和第1代对象移动到第2代，依此类推。在最大非静态对象回收的过程中，所有幸存的非静态对象都将移动（可能返回）到最大非静态代中。 通过这种机制，一个对象有可能跳过一个或多个世代，但这在许多对象上不太可能发生，并且如果这些对象变得不可访问，则最终将回收它们的存储。\n维护内部计数器gc-trip来控制何时回收每一代。 每次调用不带参数的collect 时（从默认的collect-request处理程序开始），gc-trip都会加1。在collect-generation基数为r 的情况下，回收的世代编号为g ，其gc-trip是$r^g$的倍数。 如果将collect-generation-radix设置为4，则系统将每次收集0代，每4次收集1代，每16次收集2代，依此类推。\n每次某个世代g 调用collect时，该世代g 被回收且gc-trip前进到下个$r^g$的边界，但是不会超过$r^{g+1}$的边界，r 不变还是collect-generation-radix的值。\n如果使用第二个参数tg 调用collect，则tg 确定目标代。 当g 是最大的非静态代时，tg 必须为g 或为static。 否则，tg 必须为g 或g + 1 。 当目标代是static符号时，非静态代中的所有数据都将移动到静态代中。静态代中的对象从不会被回收。 这在加载和初始化应用程序的永久代码和数据结构之后非常有用，以减少后续回收的开销。\n通过设置本节中描述的参数，可以对回收器的行为进行实质性的调整。通过重新定义collect-request处理程序且使用显式的g 和tg 参数调用collect，甚至有可能完全覆盖收集器的默认策略来确定何时回收每个世代。例如，程序员可以通过使用显式的g 和tg 参数调用collect来重新定义处理程序，以在长时间内将最大的非静态代视为静态代，该参数在该时间段内绝不等于最大的非静态代。\n (collect) | (collect g) | (collect g tg)\n g 必须是不大于最大非静态代（collect-maximum-generation返回的值）的非负确定编号。 如果g 已经是最大的非静态代编号，则tg 必须是一个等于g 的fixnum或static符号。 否则，tg 必须是一个等于g 或大于g 的fixnum。\n此过程使存储管理器执行垃圾回收。 collect是通过collect-request处理程序定期调用的，但是也可以显式调用它，以在特定时间（例如，在计时计算之前）强制进行回收。 在Chez Scheme的线程版本中，调用collect的线程必须是唯一的活动线程。\n系统将根据g 和tg （如果提供）确定回收哪些世代，如本节的介绍中所述。\n (collect-rendezvous)\n 请求垃圾回收的方式应该与由系统自动发起的GC的方式相一致。所有正在运行的线程经过协调，以便其中一个调用collect-request处理程序，而其他线程暂停直到处理程序返回。\n请注意，如果collect-request处理程序（请参阅collect-request-handler）没有调用collect，那么collect-rendezvous实际上不会执行垃圾回收。\n collect-notify\n 如果将collect-notify设置为true，则每当运行GC时，回收器都会打印一条消息。 默认情况下，collect-notify设置为#f。\n collect-trip-bytes\n Chez Scheme在内部以大块分配内存，并通过内联操作将这些块细分以提高效率。存储管理器确定是否为每个分配的大块仅请求一次回收。此外，在存储管理器请求回收和兑现回收请求之间可能会花费一些时间，尤其是如果通过with-interrupts-disabled或disable-interrupts临时禁用了中断时。因此，collect-trip-bytes仅是一种近似度量。\n collect-generation-radix\n 此参数确定默认情况下的collect-request处理程序调用不带参数的collect时回收每一代的频率。每$r^g$次发生一次对应世代的回收，其中r 是collect-generation-radix的值，g 是世代数。\n将collect-generation-radix设置为1会强制所有世代每次都被回收， 将collect-generation-radix设置为非常大的数目将无限期有效地延迟较早的一代的回收。\n collect-maximum-generation\n 此参数确定当前可以使用的最大非静态世代数,它的值是1到254范围内的精确整数。设置为1时，仅使用两个非静态生成。 设置为2时，将使用三个非静态世代，依此类推。 当设置为254时，将使用255个非静态代，再加上一个静态代，总共256个世代。增加世代数可以减少了收集旧对象的频率，潜在地减少了收集开销，但同时也潜在地增加了系统中保留的不可访问对象的数量，从而增加了所需的内存总量。\n collect-request-handler\n collect-request-handler的值必须是一个过程。当系统认为应该要进行GC时（即，自上次GC以来，系统分配了由参数collect-trip-bytes规定的存储量之后），该过程在不带参数的情况下被调用。\n默认情况下，collect-request-handler仅调用不带参数的collect。 可以通过将collect-request-handler设置为不执行任何操作的过程来禁用自动收集，例如：\n(collect-request-handler void)  也可以利用防止任何中断的critical-section来临时禁用GC\n release-minimum-generation\n 此参数的值必须介于0到collect-maximum-generation的值（包括）之间，并且默认为collect-maximum-generation的值。\n当分配新数据且进行GC时，storage-management会自动地从操作系统中请求额外的虚拟内存地址。相应地，在堆显著减小的情况下，系统尝试将先前从操作系统获得的某些虚拟内存返回给操作系统。默认情况下，系统仅在针对最大非静态时代的GC之后才这样做。也可以让系统在对更年轻的世代回收之后就执行此操作，方法是将release-minimum-generation的值更改为小于collect-maximum-generation的值。由参数指定的世代，或者任何较老的世代是GC的目标世代时，存储管理系统将在GC之后尝试将不需要的虚拟内存返回给操作系统。\n当collect-maximum-generation设置为一个新值g 时，release-minimum-generation也同时隐式地更改为g ，有两个前提：（a）修改前这两个参数具有相同的值；（b）release-minimum-generation的值大于g\n heap-reserve-ratio\n 此参数确定了保留的内存的大概数量（没有返回给OS，如release-minimum-generation所描述的）与当前已占用的内存量（不包含已变为静态的内存区域）的比例，它的值必须是不精确的非负整数值； 如果设置为精确的实数值，则精确的值将转换为不精确的值。默认值1.0，为每个当前占用的非静态页面保留一页内存。 将其设置为较小的值可能会导致较小的平均虚拟内存占用量，而将其设置为较大的值可能会导致较少的操作系统调用以请求和释放内存空间。\n弱序对，暂时序对和守护者Weak Pairs, Ephemeron Pairs, and Guardians weak pairs允许程序维护指向对象的弱指针。 指向对象的弱指针不会阻止存储管理系统回收该对象，但是只要该对象在系统中是可访问的，它仍然有效。\nephemeron pairs与weak pairs类似，但是ephemeron pairs拥有两个指针，其中仅仅在第一个指针存在的情况第二个指针才能存在\nguardians允许程序保护对象免遭垃圾回收器的重分配，并确定该对象何时被重新分配。\nweak paris, ephemeron pairs 和guardians允许程序将有关对象的信息保留在单独的数据结构（例如哈希表）中，而无需担心维护此信息将导致对象无限期地保留在系统中。\n另外，guardians允许无限期地从释放对象中保存对象，以便可以重用它们，或者可以使用存储在对象中的数据执行清理或其他操作。\n (weak-cons obj1 obj2)\n 返回：一个新的弱序对\nobj1 是新对的car, obj2构成了新对的cdr。弱序对和普通对是无法区分的，除了这两种方式：\n 弱序对可以使用weak-pair?这个谓词来区别普通对 弱序对维护了一个指向(car obj)的弱指针  弱序对的car中的弱指针就像普通指针一样，只要它指向的对象可以通过系统中某个地方的普通（非弱）指针访问即可。 但是，如果垃圾收集器在某个时候识别出不存在指向该对象的非弱指针，则它将每个指向该对象的弱指针替换为“ broken weak-pointer”对象#!bwp，并丢弃该对象。\n弱序对的cdr字段不是弱指针，因此可以使用弱序对来构造弱保持对象的列表。可以像使用普通的列表的处理操作（例如length，map和assv）来操作这些list。弱序对可以使用set-car!和set-cdr!来修改； 在set-car!之后，car字段包含指向新对象的弱指针，代替了旧对象。弱序对的打印方式与普通对相同。 弱序对没有reader语法。弱序对在被写入然后被读取时成为普通对。\n(define x (cons 'a 'b)) (define p (weak-cons x '())) (car p) ⇒ (a . b) (define x (cons 'a 'b)) (define p (weak-cons x '())) (set! x '*) (collect) (car p) ⇒ #!bwp   (weak-pair? obj)\n (weak-pair? (weak-cons ’a ’b)) ⇒ #t (weak-pair? (cons ’a ’b)) ⇒ #f (weak-pair? \u0026quot;oops\u0026quot;) ⇒ #f   (ephemeron-cons obj1 obj2)\n obj1 是新对的car, obj2构成了新对的cdr。暂时序对和普通对是无法区分的，除了这两种方式：\n 暂时序对可以使用ephemeron-pair?这个谓词来区别普通对 暂时序对维护了一个指向(car obj)的弱指针，并且仅仅在pair的car存在时cdr才能保留  暂时序对的行为与弱序对类似，不过cdr有特殊的处理：如果car被设置为#!bwp的同时也会将cdr设置为#!bwp。由于同时将car和cdr字段设置为为#!bwp，因此可以通过cdr对象引用car对象这一事实本身并不意味着必须保留car（与弱序对不同）。 相反，出于某种原因，car必须独立于cdr对象保存。\n与弱序对和其他对一样，暂时序对使用set-car!和set-cdr!来修改数据，暂时序对的打印方式与普通对一样，但没有reader语法\n(define x (cons 'a 'b)) (define p (ephemeron-cons x x)) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b) (define x (cons 'a 'b)) (define p (ephemeron-cons x x)) (set! x '*) (collect) (car p) ⇒ #!bwp (cdr p) ⇒ #!bwp (define x (cons 'a 'b)) (define p (weak-cons x x)) ; not an ephemeron pair (set! x '*) (collect) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b)  与弱序对一样，如果在将x设置为*之前进行了垃圾回收将该pair提升为较老的一代，则上面中间示例的最后两个表达式实际上可能返回（a . b）。 但是，在上面的最后一个示例中，最后两个表达式的结果将始终为（a . b），因为弱序对的cdr持有非弱引用，并且该非弱引用阻止car字段变** #!bwp**。\n (ephemeron-pair? obj)\n (ephemeron-pair? (ephemeron-cons 'a 'b)) ⇒ #t (ephemeron-pair? (cons 'a 'b)) ⇒ #f (ephemeron-pair? (weak-cons 'a 'b)) ⇒ #f (ephemeron-pair? \u0026quot;oops\u0026quot;) ⇒ #f   (bwp-object? obj)\n 返回：如果obj是断开的broken weak-pair对象，则返回#t，否则返回#f\n(bwp-object? #!bwp) ⇒ #t (bwp-object? 'bwp) ⇒ #f (define x (cons 'a 'b)) (define p (weak-cons x '())) (set! x '*) (collect (collect-maximum-generation)) (car p) ⇒ #!bwp (bwp-object? (car p)) ⇒ #t   (make-guardian)\n Guardians由要保护的对象组的过程表示。创建guardian后，注册对象组为空。 通过将对象作为参数传递给守护者，可以向guardian注册对象：\n(define G (make-guardian)) (define x (cons 'aaa 'bbb)) x ⇒ (aaa . bbb) (G x)  注册对象时也可以指定“representative”（即，y）对象。 继续上面的示例：\n(define y (cons 'ccc 'ddd)) y ⇒ (ccc . ddd) (G y 'rep)  与守护者关联的一组注册对象在逻辑上细分为两个不相交的子组：一个子组称为“可访问”对象，一个子组称为“不可访问”对象。不可访问的对象是已被证明无法访问的对象（通过guardian机制本身或通过弱序对或暂时序对的car字段除外），可访问的对象是未经证明的对象。“已证明”一词在这里很重要：可能是可访问组中的某些对象确实是不可访问的，但这尚未得到证明。 在某些情况下，直到对象实际上变得不可访问很久之后（在当前实现中，直到发生包含对象的世代的垃圾回收），才可能做出这种证明。\n向guardian注册的对象最初被放置在可访问组中，并在它们变得不可访问后的某个时刻移入不可访问组。 不可访问组中的对象是通过调用不带参数的guardian来检索的。 如果不可访问组中没有对象，则guardian返回#f。 继续上面的示例：\n(G) ⇒ #f (set! x #f) (set! y #f) (collect) (G) ⇒ (aaa . bbb) ; 也有可能这个后打印出来 (G) ⇒ rep ; 这个先打印出来 (G) ⇒ #f  对G的初始调用返回#f，因为绑定到x和y的对是向G注册的唯一对象，并且仍然可以通过这些绑定访问这些序对。调用collect时，对象将移入不可访问的组。 因此，对G的两个调用返回先前绑定到x的序对和先前绑定到y的序对的representative，尽管可能与所示顺序相反。 （如上所述，对于弱序对，如果对象已迁移到较老的一代，则调用collect实际上可能不足以证明该对象不可访问。）\n实际上，从guardian那里获取的对象在任何方面都没有特殊的地位。 此功能避免了共享或循环结构可能会出现的问题。 由不可访问对象组成的共享或循环结构将被完整保留，将注册由guardian保护的部分都放置在该guardian不可访问的集合中。 然后，程序员可以完全控制结构的处理顺序。\n一个对象可以在guardian处多次注册，在这种情况下，可以多次检索该对象：\n(define G (make-guardian)) (define x (cons 'aaa 'bbb)) (G x) (G x) (set! x #f) (collect) (G) ⇒ (aaa . bbb) (G) ⇒ (aaa . bbb)  它也可以向不止一个guardian注册，并且guardian本身也可以向其他guardian注册。 在没有“representative”的情况下向guardian注册的对象，并放置在一个弱序对或暂时对的car字段中，其直到从guardian处将返回并由程序丢弃，或者直到guardian本身被丢弃为止。\n(define G (make-guardian)) (define x (cons 'aaa 'bbb)) (define p (weak-cons x '())) (G x) (set! x #f) (collect) (set! y (G)) y ⇒ (aaa . bbb) (car p) ⇒ (aaa . bbb) (set! y #f) (collect 1) (car p) ⇒ #!bwp  另一方面，如果指定了representative（对象本身除外），则在从guardian处获得representative的同时，也会从弱序对或暂时序对的car字段中丢弃受保护的对象。\n(define G (make-guardian)) (define x (cons 'aaa 'bbb)) (define p (weak-cons x '())) (G x 'rep) (set! x #f) (collect) (G) ⇒ rep ; 获得representative的值 (car p) ⇒ #!bwp ; 自动丢弃  下面的示例说明了当guardian本身丢弃时，该对象已被释放并且弱序对的car字段设置为#!bwp：\n(define G (make-guardian)) (define x (cons aaa 'bbb)) (define p (weak-cons x '())) (G x) (set! x #f) (set! G #f) (collect) (car p) ⇒ #!bwp  下面的示例演示了如何使用guardian来释放外部存储，就像由C库“malloc”和“free”操作管理存储。\n(define malloc (let ([malloc-guardian (make-guardian)]) (lambda (size) ; first free any storage that has been dropped. to avoid long ; delays, it might be better to deallocate no more than, say, ; ten objects for each one allocated (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f)))) ; then allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x))))  do-malloc必须返回一个Scheme对象“header”，该header封装一个指向外部存储的指针（可能是无符号整数），并且必须通过此header对外部存储进行所有访问。特别是，必须注意在删除相应的header之后，在Scheme之外不存在指向外部存储的指针。 do-free必须使用封装的指针释放外部存储。这两个原语都可以使用外部分配和外部无关的定义，也可以作为外部过程导入的C库“malloc”和“free”运算符进行定义。\n如果不希望调用malloc来释放存储，则可以使用collect-request处理器来检查并释放已丢弃的存储，如下所示：\n(define malloc) (let ([malloc-guardian (make-guardian)]) (set! malloc (lambda (size) ; allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x))) (collect-request-handler (lambda () ; first, invoke the collector (collect) ; then free any storage that has been dropped (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f)))))))  通过一点重构，就有可能将封装的外部地址注册为带header的representative，在这种情况下，do-free将仅将外部地址作为参数。 这将使标头一旦变得不可访问，便可以将其从Scheme堆中删除。\n锁对象Locking Objects 来自C语言的变量或数据结构到Scheme对象的所有指针，通常应在输入（或重新输入）Scheme之前丢弃。 当无法遵循该准则时，可以通过锁定对象或等效的C库过程Slock_object锁定该对象。\n (lock-object obj)\n 锁定对象可防止存储管理器收回或重定位该对象。 应谨慎使用锁定，因为它会导致内存碎片并增加存储管理开销。\n如果未解锁对象，锁定也会导致意外保留存储空间。 可以通过解锁对象或等效的C库过程Sunlock_object来解锁对象。\n锁定立即数（例如，fixnum，布尔值和字符）或已被静态化的对象是不必要但无害的。\n (unlock-object obj)\n 通过连续调用lock-object，Slock_object或同时调用这两个对象，可以多次锁定对象，在这种情况下，必须先通过相等次数的对unlock-object或Sunlock_object的调用来将其解锁。\n除非存在指向对象的单独的C指针，否则也无需锁定包含在锁定对象中的对象（例如，锁定序对的car中的对象）。也就是说，如果仅允许通过外部对象来间接访问的内部对象，则应将其解锁，以便回收器在回收期间可以自由地重分配它。\n解锁立即值（例如，fixnum，布尔值和字符）或已设为静态的对象是不必要的，无效的，但无害。\n (locked-object? obj)\n 返回：如果obj是锁定的，立即的或静态的，返回#t\n如果回收器无法重分配或回收obj，则该谓词将返回true，包括立即值，例如fixnums，布尔值和字符以及已设为静态的对象。\n","id":0,"section":"posts","summary":"垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动","tags":["scheme"],"title":"存储管理(Storage Management in Chez Scheme)","uri":"https://lvsq.net/2020/02/storage-management/","year":"2020"},{"content":" 异常  (warning who msg irritant \u0026hellip;)\n返回：未指定\n 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止程序继续运行但可能在以后导致更严重问题的情况。\n通常最好是识别程序员已调用的过程，而不是程序员可能不知道的其他过程。 msg必须为字符串，并应描述异常情况。irritant可以是任何Scheme对象，并且应包含可能导致或严重涉及异常情况的值。\n (assertion-violationf who msg irritant \u0026hellip;) | (errorf who msg irritant \u0026hellip;) | (warningf who msg irritant \u0026hellip;)\n 这些过程类似于assertion-violation, error, warning, 所不同的在于 msg 设定为一个格式字符串\n中断 Chez Scheme允许程序在发生各种事件时控制Scheme系统的操作，这些事件包括键盘中断，由set-timer设置的内部计时器到期，由中断调用引发的断点或者来自存储管理器的请求启动GC。\n无论何时break被调用，系统都会立即启用中断处理程序\n (break who msg irritant \u0026hellip;) | (break who) | (break)\n break参数遵循上述errorf的协议。默认的中断处理程序（请参见break-handler）显示一条消息并调用调试器。可以省略格式字符串和对象，在这种情况下，默认中断处理程序发出的消息使用who参数标识中断，但不提供有关中断的更多信息。如果也省略了who参数，则不会生成任何消息。如果调试器正常退出，则默认的中断处理程序将正常返回。\n break-handler\n 此参数的值必须是一个过程。当前的中断处理程序由break调用，它传递其参数。有关默认中断处理程序的描述，请参见break。以下示例显示了如何禁用breaks。\n(break-handler (lambda args (void)))   (set-timer n)\n n 必须为非负整数。当n 为非零时，设置计时器启动一个内部计时器，其初始值为n。经过n个tick后，将发生计时器中断，从而导致计时器中断处理程序被调用。tick不是统一的时间单位，而是在很大程度上取决于每个过程调用要完成多少工作。\n当n为零时，设置计时器关闭计时器。\nengine机制建立在计时器中断之上，因此不应与engine共同使用。\n (register-signal-handler sig procedure)\n register-signal-handler用于为给定的底层信号建立信号处理程序。 sig必须是标识有效信号的精确整数，过程应接受一个参数。在注册了给定signal的处理程序之后，收到了给定的signal会调用该处理程序。signal编号会传递给该处理程序，从而允许同一处理程序用于不同的信号，同时区分它们。\n以这种方式处理的信号类似于键盘中断，因为在将信号传递到进程时不会立即调用处理程序，而是在信号传递后在某个过程调用边界处调用该处理程序。因此，为内存故障，非法指令等建立处理程序通常不是一个好主意，因为导致故障或非法指令的代码将在调用处理程序之前继续执行（可能是错误的）一段时间。\n另外，仅在基于Unix的系统上才支持register-signal-handler。\n环境 环境是包含标识符绑定的顶级（first-class）对象。它们类似于模块，但是与模块不同，它们可以在运行时进行操作。环境可以作为eval，expand以及过程的定义，分配或引用顶级值的可选参数。\n有几种内置环境，也可以通过复制现有环境或从现有环境中选择的绑定来创建新环境。\n环境可以是可变的或不变的。可变的环境可以使用新的绑定进行扩展，可以修改其现有绑定，还可以分配其变量。不变的环境不能以任何这些方式进行修改。\n 联想一下SICP中关于环境的内容 (environment? obj)\n (environment? (interaction-environment)) ⇒ #t (environment? 'interaction-environment) ⇒ #f (environment? (copy-environment (scheme-environment))) ⇒ #t (environment? (environment '(prefix (rnrs) $rnrs-))) ⇒ #t   (environment-mutable? env)\n (environment-mutable? (interaction-environment)) ⇒ #t (environment-mutable? (scheme-environment)) ⇒ #f (environment-mutable? (copy-environment (scheme-environment))) ⇒ #t (environment-mutable? (environment '(prefix (rnrs) $rnrs-))) ⇒ #f   (scheme-environment)\n scheme-environment返回一个包含初始顶级绑定的环境。该环境对应于Scheme模块。此过程返回的环境是不可变的。\n(define cons 3) (top-level-value 'cons (scheme-environment)) ⇒ #\u0026lt;procedure cons\u0026gt; (set-top-level-value! 'cons 3 (scheme-environment)) ⇒ exception   (copy-environment env) | (copy-environment env mutable?) | (copy-environment env mutable? syms)\n copy-environment返回env的副本，即包含与env 相同绑定的新环境。mutable? 如果为true，则该environment是可变的，反之则不可变；\n从env 复制到新环境的绑定集由syms 确定，其默认值为（environment-symbols env）。每个syms 元素的绑定（如果有）都被复制到新环境中，并且新环境中不存在其他绑定。\n在当前的实现中，永远不会收集环境使用的存储空间，因此重复使用复制环境最终将导致系统内存不足。\n(define e (copy-environment (scheme-environment))) (eval '(define cons +) e) (eval '(cons 3 4) e) ⇒ 7 (eval '(cons 3 4) (scheme-environment)) ⇒ (3 . 4)   (environment-symbols env)\n 此过程返回代表环境env中绑定的标识符的符号列表。它主要用于构建要从一种环境复制到另一种环境的符号列表。\n(define listless-environment (copy-environment (scheme-environment) #t (remq 'list (environment-symbols (scheme-environment))))) (eval '(let ([x (cons 3 4)]) x) listless-environment) ⇒ (3 . 4) (eval '(list 3 4) listless-environment) ⇒ exception  编译、求值和加载  (eval obj) | (eval obj env)\n eval将obj 视为表达式的表示形式。它在环境*env*中计算表达式并返回其值。如果未提供任何环境，则默认为由交互环境返回的环境。\n单参数求值是Chez Scheme的扩展。当环境可变时，Chez Scheme还允许obj表示非表达形式，比如一个definition。 Chez Scheme还允许obj作为一个annotation，默认求值程序利用注释将源文件信息合并到错误消息中，并将源文件信息与编译后的代码相关联。\n在Chez Scheme中，eval实际上是一个包装器，仅将其参数传递给当前求值器（请参阅current-eval）。默认的评估器是compile，它通过当前的扩展器（参阅current-expand）扩展表达式，对其进行编译，执行生成的代码，并返回其值。如果存在环境参数env ，则compile将其传递给当前的扩展器，默认情况下为sc-expand。\n (compile obj) | (compile obj env)\n obj 可以为Scheme表达式，在指定的环境（或交互环境，如果未提供环境）中使用当前扩展器（current-expand的值）进行扩展），编译为机器代码，然后执行。 compile是current-eval参数的默认值。\n(compile '(cons 1 2)) =\u0026gt; (1 . 2)   (interpret obj) | (interpret obj env)\n 解释类似于编译，只是表达式是解释的而不是编译的（the expression is interpreted rather than compiled）。解释可以用作编译的替代品，但有以下警告：\n 解释后的代码运行速度大大降低 解释后的代码不会生成检查器信息，因此检查器对于解释的代码不如在编译的代码中有用、 无法解释外部过程表达式，因此解释器需要为所有外部过程表达式调用编译器（这是透明完成的）  当求值形式运行时间较短时，解释有时比编译更快，因为它避免了在求值之前通过编译完成的某些工作。\n (load path) | (load path eval-proc)\n path 必须是字符串。 load读取并求值path 指定的文件的内容。该文件可能包含源代码或目标代码。默认情况下，load使用eval求值源文件中找到的每个源表达式。如果指定了eval-proc ，则load将使用此过程。 eval-proc 必须接受一个参数，即要求值的表达式。\neval-proc参数有助于实现嵌入的类似于Scheme的语言，并有助于使用用于Scheme程序的替代评估机制。 eval-proc也可以用于其他用途。例如，\n(load \u0026quot;myfile.ss\u0026quot; (lambda (x) (pretty-print (if (annotation? x) (annotation-stripped x) x)) (newline) (eval x)))  对每一个表达式求值之前使用pretty-print打印。\n参数source-directorys确定了搜索目录，以搜索未由绝对路径名标识的源文件。\n (load-library path) | (load-library path eval-proc)\n load-library与load相同，除了它会将输入文件视为由隐式＃!r6rs作为前缀。这有效地禁用了所有非R6RS词法语法，除非随后被＃！chezscheme覆盖\n (load-program path) | (load-program path eval-proc)\n path 必须是字符串。加载程序读取并求值path指定的文件的内容。\n该文件可能包含源代码或目标代码。如果包含源代码，则加载程序会将代码以顶级程序形式包装起来，以便将文件的内容视为RNRS顶级程序（Scheme编程语言，第4版的10.3节）。\n默认情况下，加载程序使用eval求值文件中找到的每个源表达式。如果指定了eval-proc，则装入程序将使用此过程。 eval-proc必须接受一个参数，即要评估的表达式。传递给eval-proc的表达式可能是注释或未注释的值。 参数source-directorys确定了搜索目录，以搜索未由绝对路径名标识的源文件。\n (load-compiled-from-port input-port)\n load-compiled-from-port读取并求值来自input-port的对象代码的内容，这些input-port是事先由诸如compile-file, compile-script, compile-library, compile-to-port创建的\n返回值是最后一个表达式的值，该表达式的编译形式为input-port。如果input-port为空，则结果值未指定。\n (compile-file input-filename) | (compile-file input-filename output-filename)\n input-filename 和output-filename 必须是字符串。input-filename 必须是已存在的可读文件。它必须包含零个或多个源表达式的序列；如果不是这种情况，则编译文件会引发条件类型为＆syntax的异常。\n正常求值过程分为两个步骤：编译和执行。 compile-file对整个源文件执行编译过程，从而生成目标文件。随后加载目标文件（请参见load）时，不需要编译过程，并且文件加载通常快几倍。\n (compile-script input-filename) | (compile-script input-filename output-filename)\n compile-script与compile-file类似，不同点在于，它会从源文件复制开头的#!行到目标文件，同时该行不会被压缩，尽管参数compile-compressed被设置为#t，其他代码会被压缩，这样会保证操作系统可以正确地解释。\ncompile-script允许从源脚本创建已编译的脚本文件，以减少脚本加载时间。与源代码脚本一样，可以使用\u0026ndash;script命令行选项运行已编译的脚本。\n (compile-library input-filename) | (compile-library input-filename oiutput-filename)\n compile-library与compile-file相同，不同之处在于，它会将输入文件视为由隐式＃!r6rs作为前缀。这有效地禁用了所有非R6RS词法语法，除非随后被＃!chezscheme覆盖。\n (compile-program input-filename) | (compile-program input-filename output-filename)\n compile-program类似于compile-script，但不同之处在于，它实现了RNRS顶级程序的语义，而compile-script则实现了交互式顶级程序的语义。与通过compile-file或compile-script进行编译相比，生成的已编译程序的运行速度也更快。\ncompile-program返回由编译的顶层程序直接调用的库的列表，不包括（rnrs）和（chezscheme）之类的内置库\n (compile-whole-program input-filename output-filename) | (compile-whole-program input-filename output-filename libs-visible?)\n compile-whole-program接受一个文件名作为名称输入，该文件名为顶级程序命名为“ whole program optimization”（wpo）文件，并生成一个包含该程序及其所依赖的每个库的目标文件，前提是需要一个可以找到库的wpo文件。\n如果wpo文件找不到所需库，但可以找到该库的目标文件，则该库不会合并到生成的目标文件中。这些库将在运行时加载。 compile-whole-program返回这些库的列表。如果没有这样的库，则生成的目标文件是自包含的，并且compile-whole-program返回空列表。\n如果libs-visible? 设置为非false，则库合并到目标文件是可见的（供environment和eval使用），任何合并到目标文件中并在运行时保留下来的目标文件所要求的库都是可见的。\n当generate-wpo-files参数设置为#t时，过程compile-file，compile-program，compile-library，compile-script和compile-whole-library会生成wpo文件以及普通目标文件。 （默认值为#f）。另外如果传递可选的wpo端口时，compile-port和compile-to-port也会这样做。\n (compile-whole-library input-filename output-filename)\n compile-whole-library类似于compile-whole-program，不同之处在于input-filename必须为库指定一个wpo文件，所有库自动显示，并生成一个新的wpo文件（当generate-wpo-files为#t时）以及用于生成的库组合的目标文件。\n (compile-port input-port output-port) | (compile-port input-port output-port sfd) | (compile-port input-port output-port sfd wpo-port)\n input-port 必须是文本输入端口。out-port 和*wpo-port*（如果存在）必须是二进制输出端口。如果存在sfd ,必须是源文件描述符。\n (make-boot-file output-filename base-boot-list input-filename \u0026hellip;)\n 所有参数都必须是字符串。\nmake-boot-file将引导标头（boot header）写入以output-filename 命名的文件，然后依次写入每个input-filename 的目标代码。如果尚未编译输入文件，make-boot-file将在对其进行编译。\n引导文件通过\u0026ndash;boot或-b命令行选项显式加载，或基于可执行文件的名称隐式加载。\n (make-boot-header output-filename base-boot1 base-boot2\u0026hellip;)\n 该过程已包含在make-boot-file中，并提供了向后兼容性。\n(make-boot-header output-filename base-boot1 base-boot2 \u0026hellip;)\n等价于：\n(make-boot-file output-filename ’(base-boot1 base-boot2 \u0026hellip;))\n源目录和文件  source-directories\n source-directories的值必须是一个字符串列表，每个字符串都命名一个目录路径。当通过load, load-library, load-program, include, visit, or revisit在交互式检查器中发生语法错误或打开源文件时，source-directory确定用于搜索源文件或目标文件的目录集。\n默认值为列表（“.”），这意味着仅在当前目录中或相对于当前目录才能找到源文件，除非使用绝对路径命名。\n (with-source-path who name procedure)\n 过程with-source-path依次搜索当前源目录路径，以查找具有指定名称的文件，并在结果上调用过程。如果未找到这样的文件，则引发\u0026amp;assertion和\u0026amp;who异常，\u0026amp;who的值为who 的值\n如果name 是绝对路径，或者以./（Windows下是./），或者../（Windows下是..\\），或者源目录列表中只包含“.”，或者默认值 \u0026ldquo;\u0026ldquo;，相当于 \u0026ldquo;.\u0026ldquo;，不执行搜索并返回*name*。\nwho 必须是符号，name 必须是字符串，procedure 应接受一个参数。\n以下示例假定文件“ pie”存在于目录“ ../spam”中，但不在“ ../ham”或当前目录中。\n(define find-file (lambda (fn) (with-source-path 'find-file fn values))) (find-file \u0026quot;pie\u0026quot;) ⇒ \u0026quot;pie\u0026quot; (source-directories '(\u0026quot;.\u0026quot; \u0026quot;../ham\u0026quot;)) (find-file \u0026quot;pie\u0026quot;) ⇒ exception in find-file: pie not found (source-directories '(\u0026quot;.\u0026quot; \u0026quot;../spam\u0026quot;)) (find-file \u0026quot;pie\u0026quot;) ⇒ \u0026quot;../spam/pie\u0026quot; (source-directories '(\u0026quot;.\u0026quot; \u0026quot;../ham\u0026quot;)) (find-file \u0026quot;/pie\u0026quot;) ⇒ \u0026quot;/pie\u0026quot; (source-directories '(\u0026quot;.\u0026quot; \u0026quot;../ham\u0026quot;)) (find-file \u0026quot;./pie\u0026quot;) ⇒ \u0026quot;./pie\u0026quot; (source-directories '(\u0026quot;.\u0026quot; \u0026quot;../spam\u0026quot;)) (find-file \u0026quot;../pie\u0026quot;) ⇒ \u0026quot;../ham/pie\u0026quot;  编译器管理  optimize-level\n 该参数可以是0，1，2，3这4个值中的一个。\n理论上，此参数控制编译器执行的优化量。 实际上，它只是间接执行此操作，唯一的区别在于优化级别3（编译器生成“不安全”代码）与优化级别0-2（编译器生成“安全”代码）之间。 安全代码会执行完整类型和范围检查，例如，尝试应用非过程，尝试对non-pair的car操作或尝试引用向量的末尾，均会导致 引发异常。 对于不安全的代码，相同的情况可能会导致无效的内存引用，Scheme堆损坏（这可能在以后引起看似无关的问题），系统崩溃或其他不良行为。不安全的代码通常会更快，但是应该谨慎使用优化级别3，并且仅运用在必须尽快运行且经过良好测试的代码中。\n尽管编译器为优化0至2级生成了相同的代码，但如果需要，用户定义的宏转换器可以区分不同的级别。\n一种使用优化级别的方法是在每个文件上，强制使用eval-when。 例如:\n(eval-when (compile) (optimize-level 3))  也可以通过\u0026ndash;optimize-level命令行选项设置优化级别。此选项对于通过\u0026ndash;program命令行选项在优化级别3运行RNRS顶层程序特别有用，因为eval-when对RNRS顶层程序无效。\n ($primitive variable) | ($primitive 2 variable) | ($primitive 3 variable)\n variable 必须是一个原始procedure的名字。** $primitive**语法形式允许以单个原始引用的粒度控制优化级别，并且它可以用于访问原始值。\n表达式（$primitive variable）可以缩写为#%variable。\n(#%car ’(a b c)) ⇒ a (let ([car cdr]) (car '(a b c))) ⇒ (b c) (let ([car cdr]) (#%car '(a b c))) ⇒ a (begin (set! car cdr) (#%car '(a b c))) ⇒ a   debug-level\n 该参数可以采用0、1、2和3这四个值之一。它用于告诉编译器保留调试信息的重要性，其中0的重要性最低，而3的重要性最高。 默认值是1。从9.0版开始，它仅用于确定在非尾部位置遇到的引起错误的调用是否被视为在尾部位置（因此，导致调用者的帧不出现在堆栈回溯中）。 这发生在低于2的调试级别。\n概要分析Profiling ChezScheme支持两种类型的配置文件：源代码概要分析和块概要分析。\n启用源概要分析后，编译器会对生成的代码进行检测，以计算每个源代码表达式的执行次数。 该信息可以HTML格式显示或打包在列表中，以进行任意用户定义的处理。 也可以将其转储到文件中，然后再加载到编译器的概要分析信息数据库中，以用于源代码级优化。\n源代码概要分析至少包含下面一些步骤： - 编译代码且开启source profiling - 运行编译后的代码生成源代码概要分析信息，且 - 转储概要分析信息\n通过将参数compile-profile设置为符号源或布尔值#t，可以启用源概要分析。 可以通过以下方式转储概要分析信息：\nprofile-dump-html 以HTML格式显示，以便程序员可以直观地看到使用彩色编码系统执行每个表达式的频率，该系统可以轻松发现“热点”\nprofile-dump-list 以适合用户定义的后处理的形式;\nprofile-dump 以适合于通过上述方法之一或某些自定义方式进行离线处理的形式，或\nprofile-dump-data 以适合加载到编译器数据库中的形式。\n由profile-dump-data转储的概要分析信息通过profile-load-data加载到编译器的profiling数据库中。 除非通过profile-dump-data显式转储并通过profile-load-data加载，否则分析信息对编译器不可用。\n当使用块概要文件信息进行优化时，步骤是相似的：\n- 编译代码并开启block profiling - 运行代码生成block-profiling信息 - 转储概要分析信息 - 加载概要信息，且 - 重新编译代码\n通过将参数compile-profile设置为符号块或布尔值#t，可以启用块分析。 概要文件信息必须通过profile-dump-data转储，并通过profile-load-data加载。 与源配置文件信息一样，块配置文件信息可以与转储信息的加载过程相同或不同。\n对于块优化，要重新编译的代码必须相同。 通常，这意味着所涉及的文件必须未经修改，并且其他任何更改都不会间接影响编译器生成的代码。\n出于同样的原因，当要同时使用源概要分析和块概要分析信息进行优化时，必须先收集并加载源信息，然后再运行涉及块概要分析的第一次和第二次编译。 即，必须使用以下步骤：\n1. 编译代码并起开源代码概要分析 2. 运行代码生成source-profiling信息 2. 转储source-profiling 3. 加载source-profiling 3. 重新编译代码，并开启块概要分析 4. 运行代码生成block-profiling信息 4. 转储block-profiling 5. 加载source-和block-profiling 5. 重新编译代码\n标记每个步骤的数字既指示步骤的顺序，又指示必须在同一计划过程中执行的顺序。 （如果需要，所有步骤都可以在同一Scheme流程中执行。） 当compile-profile设置为默认值#f时，将禁用源和块分析。\n假设文件/tmp/fatfib/fatfib.ss包含以下代码：\n(define fat+ (lambda (x y) (if (zero? y) x (fat+ (1+ x) (1- y))))) (define fatfib (lambda (x) (if (\u0026lt; x 2) 1 (fat+ (fatfib (1- x)) (fatfib (1- (1- x)))))))  我们可以像下面这样加载fatfib.ss并且开启概要分析：\n(parameterize ([compile-profile 'source]) (load \u0026quot;/tmp/fatfib/fatfib.ss\u0026quot;))  然后运行代码：\n(fatfib 20) ⇒ 10946  运行（或多次运行）之后，转储概要文件为一些html文件集合： 使用profile-dump-html\n(profile-dump-html)  这将创建一个名为profile.html的文件\n在图中，执行最频繁的代码以接近红色的颜色突出显示，而执行最不频繁的代码以接近紫色的颜色突出显示。\n compile-profile\n 当将此参数设置为符号source或布尔值#t时，编译器将使用指令对生成的代码进行检测，这些指令对源代码的每个部分执行的次数进行计数。 当设置为符号block时，编译器类似地使用指令对生成的代码进行检测，该指令对每个代码块的执行次数进行计数。 当设置为#f（默认值）时，编译器不会插入这些指令。\n当compile-profile为非false时生成的代码较大且效率较低，因此仅在需要概要分析信息时才应设置此参数。启用概要分析检测后编译的代码的概要文件计数器将无限期保留，即使与它们关联的代码已被垃圾收集器回收。 这样可以得到更完整和准确的概要分析数据，但会导致动态生成或加载代码的程序出现空间泄漏，程序可以通过profile-release-counters过程显式地释放计数器，从而避免潜在的空间泄漏。\n (profile-clear)\n 调用此过程会清空概要分析信息，代码每个部分关联的计数都被置为0\n (profile-release-counters)\n 调用此过程将丢弃概要分析\n (profile-dump)\n 此过程将生成自启动或上次调用profile-clear以来收集的所有配置文件信息的转储。 它返回一个pair的列表，其中每个pair的car是一个source-object，而cdr是一个精确的非负整数计数。\nprofile-dump优于profile-dump-list的优点在于，profile-dump仅执行最少的处理，并保留完整的源对象，包括其嵌入式源文件描述符。 例如，它可以用于将概要分析信息转储到一台计算机上的fasl文件中，以便在另一台计算机上进行后续处理。\n (profile-dump-html) | (profile-dump-html prefix) | (profile-dump-html prefix dump)\n 此过程将生成一个或多个HTML文件，包括profile.html（其中包含用颜色编码的摘要信息），以及一个文件source.html，其中每个源文件源都包含用源代码进行颜色编码的副本，如前导中所述： 在本节中。 如果指定了*prefix*，则它必须是字符串，并且在生成的HTML文件的名称之前。 例如，如果前缀为“ /tmp/”，则生成的文件将放置在目录/tmp中。 原始概要分析信息是从转储获取的，默认为profile-dump返回的值\n (profile-palette)\n 此参数的值必须是至少三对的非空向量。 每个pair的car是背景色，而cdr是前景（文本）色。 每种颜色都必须是一个字符串，并且每个字符串都应包含HTML层叠样式表（CSS）颜色说明符。 第一组用于未配置的代码，第二对用于未执行的配置的代码。 第三个用于执行频率最低的代码，第四个用于执行频率倒数第二低的代码，以此类推，最后一个用于执行频率最高的代码。 程序员可能希望提供自己的调色板以增强可见性或更改所用颜色的数量。\n默认情况下，黑色背景用于未配置文件的代码，灰色背景用于未执行的配置文件的代码。 根据执行频率，紫色到红色的背景颜色用于执行的概要分析代码，而最频繁执行的代码使用红色。\n(profile-palette) ⇒ #((\u0026quot;#111111\u0026quot; . \u0026quot;white\u0026quot;) (\u0026quot;#607D8B\u0026quot; . \u0026quot;white\u0026quot;) (\u0026quot;#9C27B0\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#673AB7\u0026quot; . \u0026quot;white\u0026quot;) (\u0026quot;#3F51B5\u0026quot; . \u0026quot;white\u0026quot;) (\u0026quot;#2196F3\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#00BCD4\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#4CAF50\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#CDDC39\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#FFEB3B\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#FFC107\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#FF9800\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#F44336\u0026quot; . \u0026quot;white\u0026quot;)) (profile-palette ; set palette with rainbow colors and black text ; for all but unprofiled or unexecuted code '#((\u0026quot;#000000\u0026quot; . \u0026quot;white\u0026quot;) (\u0026quot;#666666\u0026quot; . \u0026quot;white\u0026quot;) (\u0026quot;#8B00FF\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#6600FF\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#0000FF\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#00FF00\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#FFFF00\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#FF7F00\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#FF0000\u0026quot; . \u0026quot;black\u0026quot;))) ; red   (profile-line-number-color)\n 此参数的值必须是字符串或#f。 如果是字符串，则该字符串应包含HTML层叠样式表（CSS）颜色说明符。 如果参数设置为字符串，则profile-dump-html使用指定的颜色在每个源文件的html呈现中包括行号。 如果参数设置为#f，则不包含行号。\n个性化（Waiter Customization）  (new-cafe) | (new-cafe eval-proc)\n Chez Scheme通过waiter 或read-eval-print循环（REPL）与用户进行交互。 *waiter*在称为caf́e的上下文中运行。 当系统启动时，将用户置于caf́e中并分配waiter 。 new-cafe在旧的caf́e之上开启了一个新的Scheme caf́e。 除了启动waiter 之外，new-cafe还设置了caf́e的重置和退出处理程序（请参阅reset-handler和exit-handler）。 退出caf́e会返回到创建该caf́e的caf́e。从最初的caf́e退出后会完全退出了Scheme。 caf́e可以通过显式调用exit或通过接收end-of-file（Unix系统上为“ control-D”）来退出。在前一种情况下，传递给exit的任何值都是从new-cafe返回的。\n\u0026gt; (define x 1) \u0026gt; x 1 \u0026gt; (new-cafe) \u0026gt;\u0026gt; x 1 \u0026gt;\u0026gt; (define y 2) \u0026gt;\u0026gt; y 2 \u0026gt;\u0026gt; (exit 1) 1  如果指定了可选的eval-proc 参数，则使用eval-proc 求值从控制台输入的程序。 否则，将使用参数current-eval 的值。 eval-proc必须接受一个参数，即要求值的表达式。\n\u0026gt; (new-cafe (lambda (x) x)) \u0026gt;\u0026gt; 3 3 \u0026gt;\u0026gt; (a . (b . (c . ()))) (a b c) \u0026gt; (define sum (lambda (ls) (if (null? ls) 0 (+ (car ls) (sum (cdr ls)))))) \u0026gt; (new-cafe sum) \u0026gt;\u0026gt; (1 2 3) 6  时间和日期 时间由时间对象表示。 时间对象记录特定时间或持续时间的纳秒和秒，以及标识时间对象性质的time type 。 时间类型是以下符号之一：\ntime-utc: 从“纪元”1970年1月1日0点0分0秒以来的时间\ntime-monotonic: 从过去某个任意时间点开始经过的时间，理想情况下无需进行调整。\ntime-duration: 两个时间的间隔。当作为current-time的参数时，其行为与time-monotonic类似，但也可以用来表示两个时间对象相减的结果\ntime-process: 当前进程使用的CPU时间量。\ntime-thread: 当前线程使用的CPU时间量。 如果未运行线程，或者系统不允许确定单个线程时间，则该时间与time-process相同。\ntime-collector-cpu: 当前进程用于垃圾回收的这部分CPU消耗的时间。\ntime-collector-real: 当前进程用于垃圾回收的这部分实时消耗的时间\n日期由日期对象表示。 日期对象记录特定日期的纳秒，秒，分钟，小时，日，月和年，以及标识时区的偏移量。\n (current-time) | (current-time time-type)\n time-type 必须是上述的时间对象之一，默认为time-utc\n(current-time) ⇒ #\u0026lt;time-utc 1198815722.473668000\u0026gt; (current-time ’time-process) ⇒ #\u0026lt;time-process 0.120534264\u0026gt;   (make-time type nsec sec)\n type 必须是上面列出的时间类型符号之一。 nsec 表示纳秒，并且必须是小于$10^9$的精确非负整数。sec 表示秒，并且必须是精确的整数。\n(make-time 'time-utc 787511000 1198783214) (make-time 'time-duration 10 5) (make-time 'time-duration 10 -5)   (time? obj)\n(time? (current-time)) ⇒ #t (time? (make-time ’time-utc 0 0)) ⇒ #t (time? \u0026quot;1400 hours\u0026quot;) ⇒ #f  (time-type time)\n 返回time 的时间类型\n (time-nanosecond time)\n 返回time 的纳秒\n (time-second time)\n 返回time 的秒\n (set-time-type! time type) | (set-time-nanosecond! time nsec) | (set-time-second! time sec)\n 每一个过程都会修改时间对象，只改变局部，而其他值则不受影响。 例如，set-time-nanosecond! 只更改纳秒时间，而不更改秒或类型。 特别地，当时间对象的类型改变时，值并不会更改。\n (time=? time1 time2) | (time\u0026lt;? time1 time2) | (time\u0026gt;? time1 time2) | (time\u0026lt;=? time1 time2) | (time\u0026gt;=? time1 time2)\n 时间比较。\n (copy-time time)\n 复制时间。\n(define t1 (current-time)) (define t2 (copy-time t1)) (eq? t2 t1) ⇒ #f (eqv? (time-second t2) (time-second t1)) ⇒ #t (eqv? (time-nanosecond t2) (time-nanosecond t1)) ⇒ #t   (time-difference time1 time2 ) | (time-difference! time1 time2 ) | (add-duration time timed) | (add-duration! time timed) | (subtract-duration time timed) | (subtract-duration! time timed)\n 对于time-difference，time1和time2必须具有相同的时间类型，结果是时间类型为time-duration的时间对象。 对于add-duration，add-duration！，subtract-duration和subtract-duration！，timed必须具有时间类型time-duration，并且结果是时间类型与时间相同的时间对象。 time-difference！，add-duration！和subtract-duration！ 可能具有破坏性，即每个对象都可能修改并返回其第一个参数，或者可能分配了新的时间对象\n(let ([delay (make-time 'time-duration 0 1)]) (let ([t1 (current-time 'time-monotonic)]) (sleep delay) (let ([t2 (current-time 'time-monotonic)]) (let ([t3 (time-difference t2 t1)]) (and (eq? (time-type t3) 'time-duration) (time\u0026gt;=? t3 delay) (time=? (add-duration t1 t3) t2) (time=? (subtract-duration t2 t3) t1)))))) ⇒ #t   (current-date) | (current-date offset)\n 如上所述，offset 表示UTC以东的时区偏移量（以秒为单位）。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 可以通过传递零偏移量来获得UTC.offset表示UTC以东以秒为单位的时区偏移量，如上所述。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 UTC可以通过传递零偏移来获得。\n如果未提供offset ，则使用当前时区的offset，以及date-dst？ 和date-zone-name报告有关时区的信息。 如果提供了偏移量，那么date-dst？ 和结果日期对象上的date-zone-name都是#f。\n(current-date) ⇒ #\u0026lt;date Thu Dec 27 23:23:20 2007\u0026gt; (current-date 0) ⇒ #\u0026lt;date Fri Dec 28 04:23:20 2007\u0026gt; (date-zone-name (current-date)) ⇒ \u0026quot;EST\u0026quot; or other system-provided string (date-zone-name (current-date 0)) ⇒ #f   (make-date nsec sec min hour day mon year) | (make-date nsec sec min hour day mon year offset)\n nsec代表纳秒，并且必须是小于$10^9$的精确非负整数。sec代表秒，并且必须是小于62的精确非负整数。min代表分钟，并且必须是小于60的精确非负整数。hour必须是精确的非负整数 小于24。day必须是一个精确的整数，1≤day≤31。（实际上限可能取决于月份和年份。）mon表示月份必须是一个精确的整数，1≤mon≤12。年必须 是一个精确的整数。 如上所述，它应至少为1970。offset表示UTC以东的时区偏移（以秒为单位）。 它必须是-86400到+86400（含）范围内的精确整数。 可以通过传递零偏移量来指定UTC。\n(make-date 0 0 0 0 1 1 1970 0) ⇒ #\u0026lt;date Thu Jan 1 00:00:00 1970\u0026gt; (make-date 0 30 7 9 23 9 2007 -14400) ⇒ #\u0026lt;date Sun Sep 23 09:07:30 2007\u0026gt; (date-zone-name (make-date 0 30 7 9 23 9 2007 -14400)) ⇒ #f (string? (date-zone-name (make-date 0 30 7 9 23 9 2007))) ⇒ #t   (date-nanosecond date) | (date-second date) | (date-minute date) | (date-hour date) | (date-day date) | (date-month date) | (date-year date) | (date-zone-offset date)\n 如字面的意思， 返回日期的对应的部分的值\n (date-week-day date) | (date-year-day date)\n 通过这些过程，可以确定以date 表示的日期是星期几还是每年的某天。 week-day是小于7的精确非负整数，其中0表示星期日，1表示星期一，依此类推。 year-day是小于367的精确非负整数，其中0代表一年的第一天（1月1日），1代表第二天，2代表第三天，依此类推。\n (time-utc-\u0026gt;date time) | (time-utc-\u0026gt;date time offset) | (date-\u0026gt;time-utc date)\n 这些过程用于在时间和日期对象之间进行转换。 time-utc-\u0026gt;date的时间参数必须具有time-type utc，date-\u0026gt;time-utc始终返回带有time-type utc的时间对象。\n对于time-utc-\u0026gt;date，offset 表示UTC以东的秒数中的时区偏移，如本节开头所述。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 UTC可以通过传递零偏移来获得。\n (date-and-time) | (date-and-time date)\n 字符串始终采用以下示例所示的格式，长度始终为24。\n(date-and-time) ⇒ \u0026quot;Fri Jul 13 13:13:13 2001\u0026quot; (defined (make-date 0 0 0 0 1 1 2007 0)) (date-and-time d) ⇒ \u0026quot;Mon Jan 01 00:00:00 2007\u0026quot;   (sleep time)\n time 必须是类型为time-duration的时间对象。 sleep 导致调用线程在大约由时间对象指示的时间量内暂停操作，除非该进程收到中断睡眠操作的信号。 实际睡眠时间取决于系统时钟的粒度以及系统运行其他线程和进程的繁忙程度。\n时间和统计  (time expr) time求值expr ，并且作为副作用，打印（到console-output端口）cpu时间量，实时时间量，分配的字节数以及与求值expr 相关的收集开销。\n\u0026gt; (time (collect)) (time (collect)) 1 collection 1 ms elapsed cpu time, including 1 ms collecting 1 ms elapsed real time, including 1 ms collecting 160 bytes allocated, including 8184 bytes reclaimed  (cpu-time)\n 返回：自系统启动以来消耗的cpu时间量。\n该量以毫秒为单位。 该数量包括“system”时间和“user”时间，即代表进程在内核中花费的时间以及在进程本身中花费的时间。\n (real-time)\n 返回：自系统启动以来经过的实时时间\n以毫秒为单位的时间总量\n (bytes-allocated) | (bytes-allocated g)\n 返回：当前分配的字节数\n如果提供了g ，则bytes-allocated返回指定generation中当前为Scheme对象分配的字节数。 g 必须为非负精确整数，且不得大于最大非静态generation，即，collect-maximum-generation返回的值或符号为static。 如果未提供g ，则bytes-allocated返回所有generation中分配的字节总数。\n (initial-bytes-allocated)\n 返回：加载启动文件后分配的总字节数\n (bytes-deallocated)\n 返回：垃圾回收器释放的总字节数\n通过将（bytes-deallocated）和（bytes-allocated）相加并减去（initial-bytes-allocated），可以获得当前进程分配的总字节数（无论是否仍在使用中）。\n (current-memory-bytes)\n 返回：当前分配的字节总数，包括开销.\ncurrent-memory-bytes返回堆的总大小（以字节为单位），不仅包括Scheme对象占用的字节，还包括各种形式的开销（包括碎片和保留但当前不占用的内存），因此，它是操作系统中当前进程的堆内存量的准确度量值\n (maximum-memory-bytes)\n 返回：分配过的最大字节数，包括开销\n (reset-maximum-memory-bytes!)\n 将堆内存的最大记录值重置为当前堆大小\n (collections)\n 返回：到目前为止的垃圾回收次数\n (statistics)\n 返回：包含当前统计信息的sstats记录\nstatistics将各种时间和分配统计信息打包在一起，形成一个sstats记录。 sstats记录具有以下字段：\n         cpu, 消耗的cpu时间   real, 经过的时间   bytes, 分配的字节数   gc-count, gc次数   gc-real, gc经历的时间   gc-bytes, gc回收的字节数    所有值都是从系统启动开始算\nstatistics可以像如下定义：\n(define statistics (lambda () (make-sstats (current-time ’time-thread) (current-time ’time-monotonic) (- (+ (bytes-allocated) (bytes-deallocated)) (initial-bytes-allocated)) (collections) (current-time ’time-collector-cpu) (current-time ’time-collector-real) (bytes-deallocated))))   (make-sstats cpu real bytes gc-count gc-cpu gc-real gc-bytes) 返回：sstats记录\n(sstats-cpu s) | (sstats-real s) | (sstats-bytes s) | (sstats-gc-count s) | (sstats-gc-cpu s) | (sstats-gc-real s) | (sstats-gc-bytes s)\n 返回：s 对应的部分的值\n (set-sstats-cpu! s new-value) | (set-sstats-real! s new-value) | (set-sstats-bytes! s new-value) | (set-sstats-gc-count! s new-value) | (set-sstats-gc-cpu! s new-value) | (set-sstats-gc-real! s new-value) | (set-sstats-gc-bytes! s new-value)\n 设置对应部分的值\n (sstats-difference s1 s2)\n 比较两个sstats\n enable-object-counts\n enable-object-counts的值是一个布尔值，它确定收集器在运行时是否记录对象计数，从而确定过程对象计数返回的object-counts是否准确。 由于启用对象计数会增加收集的开销，因此默认情况下该参数设置为#f。\n (object-counts)\n 过程object-countsx返回一个嵌套的关联列表，该列表表示为一个或多个世代中至少有一个活动实例的每个堆分配的原始类型和记录类型分配的对象计数和字节。 （堆分配的基本类型包括，例如，pair和向量，但不包括，例如，fixnum或字符。）仅当enable-object-countsxx为#t时，收集器才会收集对象计数。\nobject-countsx返回的关联列表具有以下结构： ((type (generation count . bytes) \u0026hellip;) \u0026hellip;)\n*type*是原始类型的名称，以符号（例如，对）表示，或者是record-type描述符（rtd）。 generation是介于0和（collect-maximum-generation）的值（包含在内）或表示静态生成的符号static之间的非负固定编号。 *count*和字节是非负的fixnum。\n(collect-request-handler void) (enable-object-counts #t) (define-record-type frob (fields x)) (define x (make-frob (make-frob #f))) (collect 3 3) (cdr (assoc 3 (cdr (assoc (record-type-descriptor frob) (object-counts))))) =\u0026gt; (2. 16)  成本中心 Cost Centers 成本中心用于在求值选定的代码段时跟踪分配的字节，执行的指令和/或经过的CPU时间。 成本中心是通过过程make-cost-center创建的，而成本是通过with-cost-center过程进行跟踪的。\n仅为此目的代码跟踪分配和指令计数。 该工具由两个参数控制：generate-allocation-counts和generate-instruction-counts。 默认情况下禁用检测。 内置程序没有检测，解释代码或非Scheme代码也没有。 仅当过程with-cost-center的可选参数*timed?*有值且不为false时才会跟踪经历的时间\nwith-cost-center过程即使在使用同一成本中心重新输入，在多个线程中同时使用并通过继续调用退出或重新输入一次或多次后，也要遵循上述注意事项来准确跟踪成本。\n generate-allocation-counts\n 当此参数为true时，编译器会在生成的代码的每个分配点插入一小段指令，以跟踪发生的分配量。此参数最初为false。\n generate-instruction-counts\n 当此参数为true时，编译器将在生成的代码的每个块中插入简短的指令序列，以跟踪该块执行的指令数。 此参数最初为false。\n (make-cost-center)\n 返回: 新的成本中心\n (with-cost-center cost-center thunk) | (with-cost-center timed? cost-center thunk)\n thunk 必须是一个接受零参数的过程。 with-cost-center调用不带参数的thunk 并返回其值。 它还可以动态计算分配的字节数，执行的指令以及在计算thunk 调用时所经过的cpu时间，并将跟踪的成本添加到成本中心记录中。\n如上所述，仅对于将参数generate-allocation-counts 设置为true的编译的代码跟踪分配计数，并且仅对将generate-instruction-counts 设置为true的编译的代码跟踪指令计数。 仅在提供timed? 且不为false的情况下，才会跟踪cpu时间，其中包括在已测量的代码，未测量代码和非Scheme代码中花费的cpu时间。\n (cost-center-instruction-count cost-center)\n 返回：成本中心跟踪的指令数\n (cost-center-allocation-count cost-center)\n 返回：成本中心跟踪的已分配字节数\n (cost-center-time cost-center)\n 返回：成本中心跟踪的CPU时间\n (reset-cost-center! cost-center)\n 此过程将成本中心记录的成本重置为零。\n参数 本节介绍了用于创建和操作参数的机制。 可以使用make-parameter方便地创建新参数。 但是，除了它们的行为外，没有什么能将参数与其他过程区分开。 如果调用参数时必须采取比通过make-parameter机制容易容纳的更为复杂的动作，则可以直接使用case-lambda定义该参数\n (make-parameter object) | (make-parameter object procudure)\n make-parameter接受一个或两个参数。 第一个参数是内部变量的初始值，第二个参数（如果存在）是应用于初始值和所有后续值的过滤器。 过滤器应接受一个参数。 如果该值不合适，则过滤器应引发异常或将值转换为更合适的形式。\n例如，print-length的默认定义如下：\n(define print-length (make-parameter #f (lambda (x) (unless (or (not x) (and (fixnum? x) (fx\u0026gt;= x 0))) (assertion-violationf ’print-length \u0026quot;~s is not a positive fixnum or #f\u0026quot; x)) x))) (print-length) ⇒ #f (print-length 3) (print-length) ⇒ 3 (format\u0026quot;~s\u0026quot;’(123456)) ⇒ \u0026quot;(123...)\u0026quot; (print-length #f) (format\u0026quot;~s\u0026quot;’(123456)) ⇒ \u0026quot;(123456)\u0026quot;  make-parameter的定义使用case-lambda很简单：\n(define make-parameter (case-lambda [(init guard) (let ([v (guard init)]) (case-lambda [() v] [(u) (set! v (guard u))]))] [(init) (make-parameter init (lambda (x) x))]))   (parameterize ((param expr) \u0026hellip;) body1 body2 \u0026hellip;)\n 使用语法形式parameterize，可以以类似于普通变量的fluid-let的方式更改参数的值。 在计算body时，将每个param 设置为相应的expr 的值。\n(define test (make-parameter 0)) (test) ⇒ 0 (test 1) (test) ⇒ 1 (parameterize ([test 2]) (test)) ⇒ 2 (test) ⇒ 1 (parameterize ([test 2]) (test 3) (test)) ⇒ 3 (test) ⇒ 1 (define k (lambda (x) x)) (begin (set! k (call/cc k)) ’k) ⇒ k (parameterize ([test 2]) (test (call/cc k)) (test)) ⇒ k (test) ⇒ 1 (k3) ⇒3 (test) ⇒ 1  虚拟寄存器Virtual registers 编译器支持一组有限的虚拟寄存器 ，以供需要高速，全局和可变存储位置的程序使用。 引用或分配虚拟寄存器可能比访问可分配的局部变量或全局变量更快，并且访问时永远不会比它们更慢，而且这样做的代码序列通常更小。 分配可能会显著加快，因为不需要跟踪从虚拟寄存器到年轻对象的指针，因为可能存在于较早一世代中的可变位置。 在系统的线程版本上，虚拟寄存器是“每个线程”的，因此可以以比线程参数低廉的方式用作thread-local存储。\n该接口包含三个过程：virtual-register-count（返回虚拟寄存器的数量），set-virtual-register!（设置指定的虚拟寄存器的值）和virtual-register（获取指定虚拟寄存器的值）。\n虚拟寄存器由小于虚拟寄存器数量的非负fixnum索引指定。 为了获得set-virtual-register!和virtual-register的最佳性能，索引应该是直接嵌入在调用中的常量（或者可以通过对调用的优化来传播）。 为了避免将这些常量放在源代码中，程序员应考虑使用标识符宏为虚拟寄存器命名，例如：\n(define-syntax current-state (identifier-syntax [id (virtual-register 0)] [(set! id e) (set-virtual-register! 0 e)])) (set! current-state 'start) current-state ⇒ start  虚拟寄存器必须被视为应用程序级资源，即，打算由多个应用程序使用的库通常不应使用虚拟寄存器，以避免与应用程序使用寄存器冲突。\n (virtual-register-count)\n 从9.0版开始，虚拟寄存器的数量设置为16。除非通过源重新编译Chez Scheme，否则无法更改。\n (set-virtual-register! k x)\n set-virtual-register!将x 存储在虚拟寄存器k 中。 k 必须是小于（virtual-register-count）的值的非负fixnum。\n (virtual-register k)\n virtual-register返回最后一次存储在虚拟寄存器k 中的值（在当前线程上）。\n环境查询和设置Environmental Queries and Settings  (scheme-version)\n Chez Scheme的版本\n (threaded?)\n 返回：#t（如果在系统为线程版本），否则返回#f\n (get-process-id)\n 返回：当前进程的PID\n (getenv key)\n 返回：环境中key 的值，或 #f\n(getenv \u0026quot;HOME\u0026quot;) ⇒ \u0026quot;/u/freddy\u0026quot;   (putenv key value)\n key 和 value 必须是字符串\n(putenv \u0026quot;SCHEME\u0026quot; \u0026quot;rocks!\u0026quot;) (getenv \u0026quot;SCHEME\u0026quot;) ⇒ \u0026quot;rocks!\u0026quot;   (get-registry key)\n 返回：key 的注册表值，或者#f\n (put-registry! key val) | (remove-registry! key)\n key 和 value 必须是字符串\n","id":1,"section":"posts","summary":"异常 (warning who msg irritant \u0026hellip;) 返回：未指定 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止","tags":["scheme"],"title":"系统操作(System Operations in Chez Scheme)","uri":"https://lvsq.net/2020/02/system-operations/","year":"2020"},{"content":" define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回true的谓词、以及每个字段的访问procedure和针对可变字段的赋值procedure。总的来说，与Java中的POJO类比较相似，不过不用自定义getter和setter方法，这与Kotlin倒为类似，例如：\n(define-record-type point (fields x y))  创建了一个名为point的record类型，并且有两个字段x和y，和如下几个定义式（自动生成）：\n| \u0026mdash; | \u0026mdash; (make-point x y) | 构造函数 (point? obj) | 谓词 (point-x p) | 字段x的访问器 (point-y p) | 字段y的访问器\n默认下，字段是不可变的，但是可以声明为可变的（mutable）。如下定义point中，字段x是可变的，但y维持不变：\n(define-record-type point (fields (mutable x) y))  当然亦可显式地将字段声明为不可变的：\n(define-record-type point (fields (mutable x) (immutable y)))  在这个例子中，define-record-type除了生成了上述的几个定义式之外，还为字段x增加了一个赋值过程：\n(point-x-set! p x)\n该赋值过程可以用于改变x的内容\n(define p (make-point 36 -17)) (point-x-set! p (- (point-x p) 12)) (point-x p) =\u0026gt; 24  自动生成的几个定义式是允许改变名称的，下面的point定义式，其构造函数名为mkpoint, 谓词为ispoint?，x和y的访问器分别为x-val和y-val, x的赋值器为set-x-val!\n(define-record-type (point mkpoint ispoint?) (fields (mutable x x-val set-x-val!) (immutable y y-val)))  默认情况下，每次一个record definition创建一个新类型（为方便理解，可以用Java来解释，即对于同一个POJO类new出两个实例，但这两个实例并不能equal），如下所示：\n(define (f p) (define-record-type point (fields x y)) (if (eq? p 'make) (make-point 3 4) (point? p))) (f (f 'make)) =\u0026gt; #f  第一个f的调用即(f \u0026lsquo;make)返回一个point类型的p，将p传递给第二个f，但p是由第一个调用生成的类型，所以point?返回#f。按照SICP的说法，这两个define-record-type并不在一个环境中，只是名字一样而已。\n默认的生产行为(generative behavior)或许可以由记录定义式中的nongenerative子句来重载：\n(define (f p) (define-record-type point (fields x y) (nongenerative)) (if (eq? p 'make) (make-point 3 4) (point? p))) (f (f 'make)) =\u0026gt; #t  以这种方式创建的记录类型仍然不同于由定义出现在程序的不同部分中创建的记录类型，即使这些定义在语法上是相同的：\n(define (f) (define-record-type point (fields x y) (nongenerative)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative)) (point? p)) (g (f)) =\u0026gt; #f  甚至可以通过在nongenerative子句中包含uid（唯一id）来覆盖它：\n(define (f) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (point? p)) (g (f)) =\u0026gt; #t  记录类型可以定义为有parent子句的子类型，即一个记录类型可以声明为某一个记录类型的子类型，如果指定了父类型，则子类型将继承父类型所有字段，且子类型的每个实例都被视为父类型的实例，因此可以直接使用父类型的访问器和字段等等。\n(define-record-type point (fields x y)) (define-record-type cpoint (parent point) (fields color)) (define cp (make-cpoint 3 4 'red)) (point? (make-cpoint 3 4 'red)) =\u0026gt; #t (cpoint? (make-point 3 4)) =\u0026gt; #f (define cp (make-cpoint 3 4 'red)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (cpoint-color cp) =\u0026gt; red  到目前为止，define-record-type定义的默认构造函数接受record包含的字段一样多的参数，其实我们可以重写默认值，这里需要引入protocol子句，以下定义将创建一个具有三个字段的点记录：x，y和d，其中d表示距原点的位移。构造函数仍然只接受两个参数，即x和y值，并将d初始化为x和y平方和的平方根。\n(define-record-type point (fields x y d) (protocol (lambda (new) (lambda (x y) (new x y (sqrt (+ (* x x) (* y y)))))))) (define p (make-point 3 4)) (point-x p) =\u0026gt; 3 (point-y p) =\u0026gt; 4 (point-d p) =\u0026gt; 5  另外，子类型的构造函数中的参数顺序是不可改变的，即先是父类型构造函数的字段，然后才是子类型的参数，如果需要改变子类型的构造函数的参数顺序该如何呢？\n(define-record-type cpoint (parent point) (fields color) (protocol (lambda (pargs-\u0026gt;new) (lambda (x c y) ((pargs-\u0026gt;new x y) c))))) (define cp (make-cpoint 3 'red 4)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (point-d cp) =\u0026gt; 5 (cpoint-color cp) =\u0026gt; red  最后来看看define-record-type的语法形式：\n syntax: (define-record-type record-name clause \u0026hellip;)\nsyntax: (define-record-type (record-name constructor pred) clause \u0026hellip;)\n Fields clause语法形式:\n (fields field-spec \u0026hellip;)\n field-spec必须是下面5个中的一个:\n field-name (immmutable field-name) (mutable field-name) (immmutable field-name accessor-name) (mutable field-name accessor-name mutator-name)  define-record in Chez Scheme Chez Scheme依然支持$R^6RS$中传统的record类型的定义，另外还提供一个新的语法，即define-record，其语法形式与define-record-type一样，所不同的地方在于，define-record中的字段默认是可变的，这与$R^6RS$中的record相反，因此，创建一个记录类型时，同时会定义下列过程：\n(define-record point (x y)) (make-point x y) ;;\tconstructor (point? obj) ;;\tpredicate (point-x p) ;;\taccessor for field x (point-y p) ;;\taccessor for field y (set-point-x! p obj) ;;\tmutator for field x (set-point-y! p obj) ;;\tmutator for field y  通过对define-record-type的了解，可以发现其非常OO，smalltalk是否受其影响不得而知，至少经过纵向比较对于我们学习技术大有裨益。\n","id":2,"section":"posts","summary":"define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回tr","tags":["scheme"],"title":"Scheme语法define-record-type介绍","uri":"https://lvsq.net/2020/02/define-record-type/","year":"2020"},{"content":" Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以在 Chez Scheme 中以“微模块”级别使用，因为 Chez Scheme 中的模块和 import 形式属于定义，并且可以出现在定义可以出现的任意位置，包括在 lambda 表达式的程序体或其他局部作用域中。\n 微模块与函数孰好？？？还是视情况而定？？？\n 模块控制绑定的可见性，可以用作扩展词法作用域，以允许更精确地控制绑定的可见范围。模块导出标识符的绑定，即变量绑定、关键字绑定或模块名绑定。模块可以是具名的抑或匿名的。只要模块名可见，那么在具名模块出现处导入的绑定都可见。匿名模块中导出的绑定，在模块出现的地方被隐式地导入。匿名模块可用于隐藏一组绑定中的一些绑定，同时允许其余绑定可见。\n语法  (module name interface defn \u0026hellip; init \u0026hellip;)\n(module interface defn \u0026hellip; init \u0026hellip;)\n name 是标识符，defn \u0026hellip; 是定义，init \u0026hellip; 是表达式。interface 是形如 (export \u0026hellip;) 的导出表，其中每个 export 都是标识符 identifier 抑或形式 (identifier export \u0026hellip;)。\n模块由一组（可能为空的）定义和一组（可能为空的）初始化表达式序列组成。模块中定义的标识符（可理解为变量或者状态，下同）在模块的程序体中可见，被导出的标识符在模块的导入作用域内亦可见。模块接口中列出的每个标识符必须在该模块中定义或被导入该到模块。module 形式是一种定义，因此可以出现在其他定义可以出现的任何位置，包括嵌套在 lambda 表达式的程序体、 library 形式、顶层程序，以及嵌套在其他模块中。此外，因为模块名的作用域与其他标识符相同，所以模块和库可以像变量和关键字那样导出模块名。\n模块名与其他标识符占用相同的名字空间，并遵循相同的作用域规则。除非被导出，否则模块中定义的标识符仅在该模块中可见。\n模块内的表达式可以引用在模块外部绑定的标识符。\n(let ([x 3]) (module m (plusx) (define plusx (lambda (y) (+ x y)))) (import m) (let ([x 4]) (plusx 5))) ; =\u0026gt; 8,注意不是9哦，可以将plusx视为：(define plusx (lambda (y) (+ 3 y))))  同样，import不会阻止访问出现导入表单的可见标识符，但import标识符所覆盖的变量除外（啥叫覆盖，看下面两段代码）。\n(module m (y) (define y 'm-y)) (let ([x 'local-x] [y 'local-y]) (import m) (list x y)) ; =\u0026gt; (local-x m-y)  模块m中定义了标识符y, 在其被import之后会覆盖let中的y；\n(module m (y) (define y 'm-y)) (let () (import m) (let ([x 'local-x] [y 'local-y]) (list x y)) ; =\u0026gt; (local-x local-y) )  先import m，之后再定义y，模块中定义的y不会覆盖let的y。\n另一方面，在模块中使用 import-only 会建立一个隔离的作用域，其中唯一可见的是被导入模块所导出的标识符，下面的代码中只有y可见。\n对于静态验证，有时不希望使用任何标识符，除了明确导入模块或本地范围的标识符外，这有时是合乎需要的。\n(module m (y) (define y 'm-y)) (let ([x 'local-x] [y 'local-y]) (import-only m) x) ; =\u0026gt; Error: x is not visible  除非通过“import-only”导入的模块导出“import”或“import-only”以及至少一个模块的名称，否则无法在“import-only”范围内进行后续导入。 要创建一个包含多个模块导出的隔离范围而又不使“import”或“import-only”可见，必须以相同的“import-only”形式列出所有要导入的模块。\n另一种解决方案是创建一个包含每个其他模块的导出的模块。\n(module m2 (y) (define y 'y)) (module m1 (x) (define x 'x)) (module mega-module (cons x y) (import m1) (import m2) (import scheme)) (let ([y 3]) (import-only mega-module) (cons x y)) ; =\u0026gt; (x . y)  在它被编译之前，源程序被翻译成不含语法抽象、语法定义、库定义、模块定义以及 import 形式的核心语言程序。翻译由语法展开器负责，语法展开器以递归下降的方式处理源程序中的形式。\nmodule 和 import 特殊形式仅影响标识符(identifier)在源程序中的可见性，而不影响其含义。特别地，无论变量被绑定到在模块内部或外部定义的位置，import 都不会引入新位置。为了保持由模块和语法抽象建立的作用域关系，局部变量在必要时会被重命名。因此，表达式：\n(let ([x 1]) (module m (x setter) (define-syntax x (identifier-syntax z)) (define setter (lambda (x) (set! z x))) (define z 5)) (let ([y x] [z 0]) (import m) (setter 3) (+ x y z))) ; =\u0026gt; 4  等价于下面的表达式，其中标识符被统一地更名，并带上了下标：\n(let ([x0 1]) (define-syntax x1 (identifier-syntax z1)) (define setter1 (lambda (x2) (set! z1 x2))) (define z1 5) (let ([y3 x0] [z3 0]) (setter1 3) (+ x1 y3 z3)))  互递归module (module (a b) (module a (x) (define x (lambda () y))) (module b (y) (define y (lambda () x))) (import a) (import b))  此模式的一般化语法定义如下，允许定义多个互递归的模块\n(define-syntax rec-modules (syntax-rules (module) [(_ (module m (id ...) form ...) ...) (module (m ...) (module m (id ...) form ...) ... (import m) ...)]))  组合module 由于模块可以重新导出所导入的绑定，所以很容易在单个模块上提供多个视图，就像下面的 s 和 t 为 r 提供的视图那样，或者将几个模块组合成一个复合，就像 r 那样。\n(module p (x y) (define x 1) (define y 2)) (module q (y z) (define y 3) (define z 4)) (module r (a b c d) (import* p (a x) (b y)) (import* q (c y) (d z))) (module s (a c) (import r)) (module t (b d) (import r))  import* 稍微解释一下import*, 其语法定义如下：\n(define-syntax import* (syntax-rules () [(_ m) (begin)] [(_ m (new old)) (module (new) (module (tmp) (import m) (alias tmp old)) (alias new tmp))] [(_ m id) (module (id) (import m))] [(_ m spec0 spec1 ...) (begin (import* m spec0) (import* m spec1 ...))]))  它支持重命名import的绑定和选择性导入特定的绑定，无需使用内置的import子形式来选择和重命名标识符，举例来说：\n(let () (import* scheme (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7) (let () (import* (rnrs) (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7)  元定义Meta Definitions  语法：(meta . definition)\n meta 关键字实际上是一个可以放在任何定义关键字前面的前缀，例如，\n (meta define x 3)\n 它告诉展开器，该定义式产生的任何变量定义都只是展开期定义，只能用于其他元定义的右侧，最主要是用在转换器表达式中。它用于定义展开期辅助函数，以及供一个或多个 syntax-case 转换器所使用的其他信息。\n元定义的语义类似于let*，它可以是自递归，但不是互递归的。\n元定义通过宏展开传播，因此可以编写，例如：\n(module (a) (meta define-record foo (x)) (define-syntax a (let ([q (make-foo #''q)]) (lambda (x) (foo-x q))))) a ；=\u0026gt; q  条件展开Conditional expansion 可以通过 meta-cond 在展开期做出决策，这类似于 cond，但是是在展开期求值并测试表达式，并且可以在预期为定义的上下文中以及在表达式上下文中使用。\n 语法：(meta-cond clause1 clause2 \u0026hellip;)\n 除了最后一个 clause，其余的必须采取以下形式：\n (test expr1 expr2 \u0026hellip;)\n 最后一个 cluase 除可采取上述形式外，还可以使用下面的 else 子句形式：\n (else expr1 expr2 \u0026hellip;)\n 在展开期间，test 表达式会被顺序地求值，直到某条表达式求值为真或者求值完所有的表达式为止。如果一条 test 表达式求值为真，则 meta-cond 形式将展开为包含相应表达式 expr1 expr2 \u0026hellip; 所组成的 begin 形式。如果没有求值为真的 test 表达式，且存在 else 子句，则 meta-cond 形式将展开为由来自于 else 子句的表达式 expr1 expr2 \u0026hellip; 所组成的 begin 形式。否则，meta-cond 表达式展开为对 void 过程的调用。\nmeta-cond 可以按如下定义：\n(define-syntax meta-cond (syntax-rules () [(_ [a0 a1 a2 ...] [b0 b1 b2 ...] ...) (let-syntax ([expr (cond [a0 (identifier-syntax (begin a1 a2 ...))] [b0 (identifier-syntax (begin b1 b2 ...))] ...)]) expr)]))  meta-cond 用于在展开期从一组可能的形式中进行选择。例如，程序员可以定义过程的安全（进行错误检查）和不安全（不进行错误检查）版本，并根据编译期优化级别决定调用版本，如下所示:\n(meta-cond [(= (optimize-level) 3) (unsafe-frob x)] [else (safe-frob x)])  别名Aliases  语法：(alias id1 id2)\n alias 是一类定义，可以出现在其他定义可以出现的任何位置。它用于将绑定从一个标识符转移到另一个标识符。\n(let ([x 3]) (alias y x) (set! y 4) (list x y)) ; =\u0026gt; (4 4)  由于展开是由左至右进行的，别名应该出现在右侧的标识符的定义之后，例如：\n(let () (import-only (chezscheme)) (define y 3) (alias x y) x) ; =\u0026gt; 3  而不是：\n(let () (import-only (chezscheme)) (alias x y) (define y 3) x) ; =\u0026gt; exception: unbound identifier  ","id":3,"section":"posts","summary":"Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以","tags":["modules"],"title":"Chez Scheme Modules","uri":"https://lvsq.net/2020/01/modules/","year":"2020"},{"content":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。\n(define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_ ((a1 v1) (a2 v2) ...) bodys ...) (let ((a1 v1)) (my-let* ((a2 v2) ...) bodys ...)) ) ) )  注意，my-let*是可以递归使用的，以及\u0026hellip;的用法。\n(define-syntax my-let* (syntax-rules () ( (_ () bodys ...) (let () bodys ...) ) ( (_ ((a1 v1) ...) bodys ...) (let () (define a1 v1) ... bodys ... ) ) ) )  这个实现方式与上面的不同，上面的是嵌套let，这里将直接按顺序define内部变量，代码更短。注意此处的\u0026hellip;的用法。\n","id":4,"section":"posts","summary":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。 (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_","tags":["scheme"],"title":"自定义 Let*","uri":"https://lvsq.net/2020/01/my-let/","year":"2020"},{"content":" Fluid Keyword Bindings fluid-let-syntax  语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩展期间会暂时更改keyword的现有绑定，而不是引入keyword的新绑定。也就是说，在扩展form1 form2 \u0026hellip;的过程中，每个keyword的可见范围（或顶级）将会临时替换为新的绑定关系。\n (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 2 ) ) )  (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (fluid-let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 1 ) ) )  对比上述两段代码，可知：两个表达式基本相同的，除了前者采用内部let-synctax语法，第二个采用fluid-let-syntax语法。在第一个表达式中，(g 1)扩展中的出现的f引用的是let-bound的变量f，而第二个表达式，f引用的是由fluid-let-syntax绑定的f\n","id":5,"section":"posts","summary":"Fluid Keyword Bindings fluid-let-syntax 语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩","tags":["module","syntactic"],"title":"Syntactic Extension and Modules in Chez Scheme","uri":"https://lvsq.net/2020/01/syntactic-extension-and-modules/","year":"2020"},{"content":" Chez Scheme中有一种Boxes结构，它是一个*单元素*对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构可以共享指向一个对象的引用，或指针。例如，在采用此种参数传递规则的语言的解释器中，可以用 boxes 实现 call-by-reference 的语义。解释有点绕，按我的理解boxes就相当于Golang的struct、Java中的类，将一些状态包装成一个整块，外界通过引用该整块的指针来访问内部的各个状态。\nBoxes 的字面形式带有前缀 #\u0026amp; (发音为 “hash-ampersand”). 例如， #\u0026amp;(a b c) 是一个 box，内容为列表 (a b c). 读取器若遇到 #!r6rs ，则会在其后的输入流中禁用 box 语法，除非在更近的位置遇到 #!chezscheme.\n所有 boxes 默认是可变的，包括常量。程序可以通过 box-immutable 创建不可变 boxes. 尝试修改不可变 box 会导致抛出异常。\n我们来看看一些用法：\n(box? obj) 如果 obj 是 box, 则为 #t, 否则为 #f.\n(box? '#\u0026amp;a) =\u0026gt; #t (box? 'a) =\u0026gt; #f (box? (box 3)) =\u0026gt; #t  (box obj) 创建一个由obj组成的box\n(box 'a) =\u0026gt; #\u0026amp;a (box (box '(a b c))) =\u0026gt; #\u0026amp;#\u0026amp;(a b c)  (unbox box) 返回box的内容\n(unbox #\u0026amp;a) =\u0026gt; a (unbox #\u0026amp;#\u0026amp;(a b c)) =\u0026gt; #\u0026amp;(a b c) (let ([b (box \u0026quot;hi\u0026quot;)]) (unbox b)) =\u0026gt; \u0026quot;hi\u0026quot;  (set-box! box obj) box 必须是可变的。 set-box! 把 box 的内容设置为 obj.\n(let ([b (box 'x)]) (set-box! b 'y) b) =\u0026gt; #\u0026amp;y (let ([incr! (lambda (x) (set-box! x (+ (unbox x) 1)))]) (let ([b (box 3)]) (incr! b) (unbox b))) =\u0026gt; 4  (box-cas! box old-obj new-obj) 如果 box 被改变，则为 #t, 否则为 #f.\nbox 必须是可变的。 若 box 待替换的内容和 old-obj 相同(基于 eq?), 则 box-cas! 自动将 box 的内容替换为 new-obj; 若不相同，则 box 保持不变。即CAS操作，原子的。\n(define b (box 'old)) (box-cas! b 'old 'new) =\u0026gt; #t (unbox b) =\u0026gt; 'new (box-cas! b 'other 'wrong) =\u0026gt; #f (unbox b) =\u0026gt; 'new  (mutable-box? obj) 如果 obj 是可变的 box ，则为 #t, 否则为 #f.\n(immutable-box? obj) 如果 obj 是不可变的 box ，则为 #t, 否则为 #f.\n(box-immutable obj) 返回一个内容为obj的不可变的box。Boxes 通常用来支持共享的，可变的结构，所以不可变的 box 一般没什么用。\n","id":6,"section":"posts","summary":"Chez Scheme中有一种Boxes结构，它是一个*单元素*对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据","tags":["scheme"],"title":"Chez Scheme中Boxes介绍","uri":"https://lvsq.net/2020/01/boxes-in-chez/","year":"2020"},{"content":" Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x)))\n(atom? '(a b c)) ⇒ #f (atom? '(3 . 4)) ⇒ #f (atom? '()) ⇒ #t (atom? 3) ⇒ #t  list-head(Chez) 用法：(list-head list n) *n*是一个非负整数，且小于等于*list*的长度；list-head和Scheme标准过程list-tail可能会同时使用来切割一个list，不同点在于，list-tail不会分配内存而只是返回源list的一个子列表，list-head总是返回源list前n个元素的副本\n(list-head '(a b c) 0) ⇒ () (list-head '(a b c) 2) ⇒ (a b) (list-head '(a b c) 3) ⇒ (a b c) (list-head '(a b c . d) 2) ⇒ (a b) (list-head '(a b c . d) 3) ⇒ (a b c) (list-head '#1=(a . #1#) 5) ⇒ (a a a a a)  last-pair(Chez) 用法：(last-pair list) 列表不能为空。 last-pair返回列表的最后一对（pair）（不是最后一个元素）, list可能是不正确的列表，在这种情况下，最后一对是包含最后一个元素和终止对象的一个pair。\n(last-pair '(a b c d)) ⇒ (d) (last-pair '(a b c.d)) ⇒ (c . d)  list-copy(Chez) 用法： (list-copy list) 返回一个list的副本，equal?（结构和值相同）判断为#t\nlist*(Chez) 用法：(list* obj \u0026hellip; final-obj)\n返回一个由obj \u0026hellip; final-obj 组成的list, 与R6RS的cons*相同\nmake-list(Chez) 用法： (make-list n) 或者 (make-list n obj)\n返回n个对象的列表。n是一个正整数， 如果obj不指定，则返回的list是不确定的\n(make-list 0 '()) =\u0026gt; () (make-list 3 0) =\u0026gt; (0 0 0) (make-list 2 \u0026quot;hi\u0026quot;) =\u0026gt; (\u0026quot;hi\u0026quot; \u0026quot;hi\u0026quot;)  iota(Chez) 用法：(iota n)\n返回从 0（包含）到 n（不包含）的整数列表，n须为精确的非负整数\n(iota 0) =\u0026gt; () (iota 5) =\u0026gt; (0 1 2 3 4)  enumerate(Chez) 用法： (enumerate ls)\n返回: 从 0（包含）到长度 ls（不包含）的整数列表\n(enumerate '()) =\u0026gt; () (enumerate '(a b c)) =\u0026gt; (0 1 2) (let ([ls '(a b c)]) (map cons ls (enumerate ls))) =\u0026gt; ((a . 0) (b . 1) (c . 2))  remq! | remv! | remove!(Chez) 用法： (remq! obj list) | (remv! obj list) | (remove! obj list)\n返回: 列表中所有 obj 都被移除后的列表\n这些过程与 R6RS 中的 remq, remv, 及 remove 过程类似，只是 remq!, remv! 和 remove! 使用输入列表中的pair来构成输出列表。它们进行较少的空间分配，但并不一定比它们非破坏性的相应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(remq! 'a '(a b a c a d)) ⇒ (b c d) (remv! #\\a '(#\\a #\\b #\\c)) =\u0026gt; (#\\b #\\c) (remove! '(c) '((a) (b) (c))) =\u0026gt; ((a) (b))  substq | substv | subst | substq! | substv! | subst!(Chez) 用法： (subs* new old tree)\n返回：在tree中将匹配到的old元素全部替换为new之后的tree.\n对于 substq 和 substq! ，相等性测试是基于 eq?, substv 和 substv! 是基于 eqv?, 而 subst 和 subst! 是基于 equal? substq!, substv!, 和 subst! 执行破坏性的替换。它们进行较少的空间分配，但并不一定比它们非破坏性的对应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(substq 'a 'b '((b c) b a)) =\u0026gt; ((a c) a a) (substv 2 1 '((1 . 2) (1 . 4) . 1)) =\u0026gt; ((2 . 2) (2 . 4) . 2) (subst 'a '(a . b) '((a . b) (c a . b) . c)) =\u0026gt; (a (c . a) . c) (let ([tr '((b c) b a)]) (substq! 'a 'b tr) tr) =\u0026gt; ((a c) a a)  reverse! 用法：(reverse! list)\n返回：将原list反向输出\nreverse! 通过反转其链接破坏性地反向排序列表。以 reverse! 取代 reverse 减少了空间分配，但并不一定比使用 reverse 更快。如果滥用，会很容易导致混乱或错误的结果。\n(reverse! '()) =\u0026gt; () (reverse! '(a b c)) =\u0026gt; (c b a) (let ([x '(a b c)]) (reverse! x) x) =\u0026gt; (a) (let ([x '(a b c)]) (set! x (reverse! x)) x) =\u0026gt; (c b a)  append! 用法：(append! list \u0026hellip;)\n返回：将所有输入list串联起来的列表\n如同 append, append! 返回一个新的列表，其中元素依次为第一个列表中的元素，第二个列表中的元素，第三个列表中的元素，等等。不同之处在于， append! 重用所有参数中的点对以构造新列表。即，每一个列表参数的最后一个cdr, 其后一元素变为指向下一个列表参数。除最后一个参数外，如果任一参数为空列表，它实质上会被忽略。最后一个参数（并不一定得是列表）是不变的。\n相比于 append, append! 进行更少的空间分配（因为只修改指针，并没有数据拷贝），但并不一定更快。如果滥用，会很容易导致混乱或错误的结果。\n(append! '(a b) '(c d)) =\u0026gt; (a b c d) (let ([x '(a b)]) (append! x '(c d)) x) =\u0026gt; (a b c d) (append '(1 2 (3 4)) '(5 6)) =\u0026gt; (1 2 (3 4) 5 6) (append '(1 2 (3 4)) '() '(5 6)) =\u0026gt; (1 2 (3 4) 5 6)  ","id":7,"section":"posts","summary":"Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x))) (atom? '(a b c)) ⇒ #f (atom? '(3 . 4)) ⇒ #f (atom? '()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) *n*是一个非负整数，且小于等于*list","tags":["scheme"],"title":"Scheme/Chez Scheme 对象操作","uri":"https://lvsq.net/2019/12/operations-on-objects/","year":"2019"},{"content":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。\n (make-engine thunk)\n 通过传递一个无参数的thunk(形实转换程序)给make-engine来创建一个engine。thunk的body是会被engine执行的计算，engine本身是带3个参数的过程：\n ticks： 一个正整数，指定提供给engine的执行时间片（原文用的是fuel这个单词，意思是燃料，正对应这engine的本意，十分贴切）的数量，engine将会执行到时间片用完或者计算完成为止； complete： 一个或多个参数的函数，用于指定计算完成后的操作。它的参数是剩余的时间片数量和计算产生的值； expire： 一个参数的函数，该函数指定如果在计算完成之前时间片用完了该怎么办。它的参数是一个能从中断点继续进行计算的新引擎。  将引擎应用于其参数时，它将开启一个时长为ticks的计时器，如果引擎计算在计时器执行之前完成，系统将调用complete，并将剩余的ticks和计算产生的值传递给它；\n另一方面，如果计时器在引擎计算完成之前耗尽了，则系统会从中断计算的continuation中创建一个新引擎，并使该引擎过期。complete和expire会被新引擎继续使用。If, on the other hand, the timer goes off before the engine computation completes, the system creates a new engine from the continuation of the in- terrupted computation and passes this engine to expire. complete and expire are invoked in the continuation of the engine invocation.\n请勿同时使用计时器中断（set-timer），因为engine就是由计时器实现的。\n看看具体的例子：\n(define eng (make-engine (lambda () 3))) (eng 10 ;; ticks (lambda (ticks value) value) ;; complete (lambda (x) x) ;; expire ) ⇒ 3  通常将列表作为完整过程传递给引擎，使引擎完成时返回一个列表，该列表的第一个元素是剩余的ticks，另一个元素是计算返回的值，这通常很有用。\n(define eng (make-engine (lambda () 3))) (eng 10 list (lambda (x) x)) ⇒ (9 3)  在上面的示例中，计算值为3，还剩下9个时间片，即，需要一单位的时间片来计算出3。\n再看一个复杂点的例子： 先定义一个计算裴波那切值的函数\n(define fibonacci (lambda (n) (let fib ([i n]) (cond [(= i 0) 0] [(= i 1) 1] [else (+ (fib (- i 1)) (fib (- i 2)))]))))  创建engine\n(define eng (make-engine (lambda () (fibonacci 10))))  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ (21 55)  每次时间片（燃料）用完时，到期程序都会将eng分配给新引擎。整个计算需要4个blocks，每个block包含50个ticks。最后50个燃料中，有21个都用掉了。因此，使用的燃料总量为179个。\n我们还可以统计一下消耗的ticks数量\n(define mileage (lambda (thunk) (let loop ([eng (make-engine thunk)] [total-ticks 0]) (eng 50 (lambda (ticks . values) (+ total-ticks (- 50 ticks))) (lambda (new-eng) (loop new-eng (+ total-ticks 50))))))) (mileage (lambda () (fibonacci 10))) ⇒ 179  再看看一个例子——round-robin:\n(define round-robin (lambda (engs) (if (null? engs) '() ((car engs) 1 ;;ticks (lambda (ticks value) (cons value (round-robin (cdr engs)))) ;;complete (lambda (eng) ;;expire (round-robin (append (cdr engs) (list eng)))))))) (round-robin (map (lambda (x) (make-engine (lambda () (fibonacci x)))) '(4 5 2 8 3 7 6 2))) ⇒ (1 1 2 3 5 8 13 21)  这段代码需要费些思量，首先map函数创建了8个engine, 然后代入round-robin函数，该函数依次执行各个engine，但是每个engine分配的时间片只有1，对于参数\u0026rsquo;(4 5 2 8 3 7 6 2)，数字越小，越先执行完成，所以越早执行complete函数，最终结果就是排好顺序的了，很棒的程序！\n","id":8,"section":"posts","summary":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。 (make-engine thunk) 通过传递一个无参数的thun","tags":["engine","scheme"],"title":"Engine in Scheme","uri":"https://lvsq.net/2019/12/engine-in-scheme/","year":"2019"},{"content":" case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Scheme提供了case语法来处理这种情况，这与Java中的switch语法非常相似。\n我们来看看case的语法：\n (case expr0 clause1 clause2 \u0026hellip;)\n 除了最后一个clause之外，每个子句都必须采用以下形式之一：\n ((key \u0026hellip;) expr1 expr2 \u0026hellip;) (key expr1 expr2 \u0026hellip;)  每一个key值都应该是不同的，最后一个子句要么是上述那种形式，或者是一个像下面这样的else子句\n (else expr1 expr2 \u0026hellip;)  那么返回值是什么呢？\n匹配到某个key的或者else中的最后一个expr的值\n(define p (lambda (x) (case x [(\u0026quot;abc\u0026quot; \u0026quot;def\u0026quot;) 'one '1] [((a b c)) 'two] [else #f]))) (p (string #\\d #\\e #\\f)) ⇒ 1 (p '(a b c)) ⇒ two (p \u0026quot;eee\u0026quot;) ⇒ #f  上面的例子定义了一个函数p，接收一个参数x\n 如果x为字符串\u0026rdquo;abc\u0026rdquo;或者\u0026rdquo;def\u0026rdquo;，则返回1； 如果x为列表((a b c)，则返回two 其他情况返回#f  可见，有了case语法多条件判断写起来就方便很多，并且代码也容易读了，当然这里也可以用cond来写，这里只是为了描述case的语法而没有使用cond\n再看一个例子，就不用解释了：\n(let ([ls '(ii iv)]) (case (cadr ls) [i 1] [ii 2] [iii 3] [(iiii iv) 4] [else 'out-of-range])) ⇒ 4  record-case 来看看另一个很类似的扩展，也十分有用，它就是record-case。它可以以record为单位来做条件判断并执行指令。\n语法格式：  (record-case expr clause1 clause2 \u0026hellip;)\n 除了最后一个子句之外，每个clause的格式如下：\n ((key \u0026hellip;) formals body1 body2 \u0026hellip;)\n 每一个*key*都不应该相同, 最后一个clause可能是上述的格式或者是一个else子句：\n (else body1 body2 \u0026hellip;)\n expr必须是一个pair。Chez会拿(car expr)与各个子句中的key进行比较（用eqv?）来确定哪一个clause匹配, 然后(cdr expr)将与formals绑定。\n来看换一个例子：\n(define calc (lambda (x) (record-case x [(add) (x y) (+ x y)] [(sub) (x y) (- x y)] [(mul) (x y) (* x y)] [(div) (x y) (/ x y)] [else (assertion-violationf 'calc \u0026quot;invalid expression ~s\u0026quot; x)]))) (calc '(add 3 4)) =\u0026gt; 7 (calc '(div 3 4)) =\u0026gt; 3/4  ","id":9,"section":"posts","summary":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Schem","tags":["chez","scheme"],"title":"Chez Scheme中的case扩展","uri":"https://lvsq.net/2019/12/case-in-chez-scheme/","year":"2019"},{"content":" 易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴至，克尽其用，上下一体，俱不倦而事可毕矣\n 周云成康，汉言文景。无有六十年与民休息，累藏蓄积，汉武开疆之功便是空文，此厚积薄发耳，俗语言，胳膊收回来，打出去才有力\n 武帝一代雄主，文治武功，奋高祖之余烈，承三王之圣绪，开万世不拔之基，吾国斯民之幸，铭记汉青\n  ","id":10,"section":"posts","summary":"易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴","tags":["随想"],"title":"继学录","uri":"https://lvsq.net/2019/12/think/","year":"2019"},{"content":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。\n先看看该语法描述：\n(fluid-let ((var expr) \u0026hellip;) body1 body2 \u0026hellip;) returns: the values of the body body1 body2 \u0026hellip; libraries: (chezscheme)\n该Binding的作用类似局部变量，与set! 比较相似。由fluid-let定义的变量必须已绑定到顶层(top level)或者封闭的lambda内或者其他形式的绑定，这很关键！\n请看代码：\n(let ([x 3]) (+ (fluid-let ([x 5]) x) x)) ⇒ 8  先定义变量x=3，然后在加法操作当中临时将x的值改为5，最后结果为8，如果将fluid-let中的x换个名字，比如y，将如何呢？\n会得到一个异常：\n Exception: variable y is not bound\n y没有绑定，是的，y即没有在顶层中被定义，也未在某个lambda中或者任何其他形式，这里只能是x\n再学习下两个例子，加深印象：\n(let ([x 'a]) (letrec ([f (lambda (y) (cons x y))]) (fluid-let ([x 'b]) (f 'c)) )) ⇒ (b . c)  (let ([x 'a]) (call/cc (lambda (k) (fluid-let ([x 'b]) (letrec ([f (lambda (y) (k '*))]) (f '*))))) x) ⇒ a  ","id":11,"section":"posts","summary":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。 先看看该语法描","tags":["fluid-let","Scheme"],"title":"Fluid Binding in Chez Scheme","uri":"https://lvsq.net/2019/12/fluid-binding/","year":"2019"},{"content":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。\n这是语法描述：\n(rec var expr) syntax\nreturns: value of expr\nlibraries: (chezscheme)\nThe syntactic form rec creates a recursive object from expr by establishing a binding of var within expr to the value of expr. In essence, it is a special case of letrec for self-recursive objects.\nThis form is useful for creating recursive objects (especially procedures) that do not depend on external variables for the recursion, which are sometimes undesirable because the exter-nal bindings can change. For example, a recursive procedure defined at top level depends on the value of the top-level variable given as its name. If the value of this variable should change, the meaning of the procedure itself would change. If the procedure is defined instead with rec, its meaning is independent of the variable to which it is bound.\n简要翻译一下：\n语法rec 通过在expr中建立var与expr的值的绑定，创建一个递归对象。从本质上讲，这是letrec用于自递归对象的一种特殊情况。\n语法rec通过绑定expr中创建一个递归对象，用来 这种形式对于创建不依赖于外部变量进行递归的递归对象（尤其是过程）很有用，因为外部绑定可能会发生变化，所以有时这是不可取的。\n看一个例子来感受一下：\n给定一个全是数字的list，对于每一个数字n，算出$1+2+\u0026hellip;+n$的和，最终返回和的list.\n(map (rec sum (lambda (x) (if (= x 0) 0 (+ x (sum (- x 1)))))) ’(0 1 2 3 4 5)) ⇒ (0 1 3 6 10 15)  如果没有rec语法，用letrec也是可以的，但是稍显麻烦，代码也多一些，所以rec还是很好用的\n最后看一下rec语法的定义：\n(define-syntax rec (syntax-rules () [(_ x e) (letrec ((x e)) x)]))  ","id":12,"section":"posts","summary":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。 这是语法描述： (rec","tags":["Scheme","Chez","rec"],"title":"Recursive Bindings in Chez Scheme","uri":"https://lvsq.net/2019/12/recursive-bindings/","year":"2019"},{"content":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些时间，动手写了一个，目前已经在公司内部运行了几年，效果良好，并且已经开源在Github上，以飨各位。\n特点：\n API简洁 支持3种事件：\n UP DOWN JOIN  基于Vert.X\n  引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lvsq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jgossip\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  一个简单的例子：\nint gossip_port = 60001; String cluster = \u0026quot;gossip_cluster\u0026quot;; GossipSettings settings = new GossipSettings(); settings.setGossipInterval(1000); try { String myIpAddress = InetAddress.getLocalHost().getHostAddress(); List\u0026lt;SeedMember\u0026gt; seedNodes = new ArrayList\u0026lt;\u0026gt;(); SeedMember seed = new SeedMember(); seed.setCluster(cluster); seed.setIpAddress(myIpAddress); seed.setPort(60001); seedNodes.add(seed); gossipService = new GossipService(cluster, myIpAddress, gossip_port, null, seedNodes, settings, (member, state) -\u0026gt;System.out.println(\u0026quot;member:\u0026quot; + member + \u0026quot; state: \u0026quot; + state)); } catch (Exception e) { e.printStackTrace(); } gossipService.start();  详细介绍请看 =\u0026gt; 项目地址\n欢迎大家fork， 如果觉得好请start ~~~\n","id":13,"section":"posts","summary":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些","tags":["jgossip","gossip"],"title":"Jgossip - gossip协议的开源实现","uri":"https://lvsq.net/2019/12/jgossip/","year":"2019"},{"content":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加\nGolang的实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} nodes := []*ListNode{} var carry = 0 for { node, c := add(l1, l2, carry) carry = c if node != nil { nodes = append(nodes, node) if l1 != nil \u0026amp;\u0026amp; l1.Next != nil { l1 = l1.Next } else { l1 = nil } if l2 != nil \u0026amp;\u0026amp; l2.Next != nil { l2 = l2.Next } else { l2 = nil } if carry \u0026gt; 0 \u0026amp;\u0026amp; (l1 == nil \u0026amp;\u0026amp; l2 == nil) { nodes = append(nodes, \u0026amp;ListNode{Val:carry}) } } else { break } } for i, n := range nodes{ if i == 0 { result = n } if i + 1 \u0026lt; len(nodes) { n.Next = nodes[i + 1] } } return result } func add (n1 *ListNode, n2 *ListNode, carry int) (*ListNode, int) { node := \u0026amp;ListNode{} if (n1 == nil \u0026amp;\u0026amp; n2 == nil) { return nil, 0 } if n1 == nil { n1 = \u0026amp;ListNode{Val : 0} } if n2 == nil { n2 = \u0026amp;ListNode{Val : 0} } sum := n1.Val + n2.Val + carry carry = 0 if sum \u0026gt; 9 { carry = 1 sum = sum - 10 } node.Val = sum return node, carry }  下面提供Scheme版本的实现【(1 0) + (9 1 2) = (0 2 2)】，为了简单起见，与题目要求稍有不同，这里采用list，而不是题目要求的链表，但实际上应是一样的。比较之下可以看出，相对而言，Scheme语言的实现更加简短优雅，得益于其强大的表达能力\n(letrec ( [Polishing (lambda (l num) (if (eq? num 0) l (Polishing (append l '(0)) (- num 1))) ) ] [Align (lambda (l1 l2) (let ([len1 (length l1)] [len2 (length l2)]) (if [eq? len1 len2] [list l1 l2] [if (\u0026gt; len1 len2) (list l1 (Polishing l2 (- len1 len2))) (list (Polishing l1 (- len2 len1)) l2)])) ) ] [Add (lambda (l1 l2) (let ([ l (Align l1 l2)]) (Carry (map (lambda (x y) (+ x y)) (car l) (cadr l)) 0) ) ) ] [Carry (lambda (l c) (if (null? l) (if [eq? c 0] '() [cons c l]) (cons (mod ( + (car l) c ) 10) (Carry (cdr l) (quotient ( + (car l) c) 10))) ) ) ]) (Add '(1 0) '(9 1 2)))  Golang版本和Scheme版本的实现思路不相同，简要描述一下后者：\n (1 0) + (9 1 2), 先进行补位： (1 0 0) + (9 1 2), 按顺序相加，得： (10 1 2), 再计算进位： (0 2 2)  ","id":14,"section":"posts","summary":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加 Golang的实现： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result","tags":["Scheme","leetcode"],"title":"两数相加","uri":"https://lvsq.net/2019/12/leetcode-2/","year":"2019"},{"content":" 最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发。\n问题描述 假设我们已经有足够多的1分，2分，5分钱币，任意给定金额比如1元，问有多少种组合方式？ 换言之，$$1x+2y+5z = 100$$ 求x,y,z的解有多少个\n思路 组合方式的总和应为：\n 任意扣去一种钱币比如1分，1元采用2分，5分两种钱币的组合数，再加上：\n 总额为（1元-1分），采用1分，2分，5分三种钱币的组合数；\n  很明显这可以很容易用递归实现\n稍作一点解释：\na. 上面两步的意思是：不带1分的组合数 + 带1分的组合数 = 全部的组合数； 这是显而易见的\nb. 上述第2步，（1元-1分）的意思是：这样可以保证任意一种组合方式再加1分都等于1元，保证至少有1个1分的钱币\n(letrec [ (A (lambda (n d) (if (= 0 (mod n d)) 1 0))) (B (lambda (n d) (cond [(not (pair? d)) 0] [(null? d) 0] [(= 0 n) 1] [(\u0026gt; 0 n) 0] [(= 1 (length d)) (A n (car d))] [else ( + (B n (cdr d)) (B (- n (car d)) d)) ] ) ) ) ] [B 100 '(1 2 5)] )  ","id":15,"section":"posts","summary":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发","tags":["Scheme","SICP"],"title":"钱币组合问题","uri":"https://lvsq.net/2019/12/count-coins/","year":"2019"},{"content":" Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdquo;x-\u0026ldquo;）该如何开发做紧要的介绍。\n一切开始之前，有一点需要keep in mind，即增加扩展的位置不同，所用的方法不同，所以需要对Swagger的标准有所了解，可参考官方文档 springfox目前只允许三种扩展实现:\n ListVendorExtension:列表的形式,该对象支持泛型，最终形式：”x-field”:[{field:value}] ObjectVendorExtension:对象的扩展形式,最终的扩展形式是：”x-field”:[{field:value}] StringVendorExtension:string类型的扩展实现，最终的扩展形式是”x-field”:”value”  Swagger根对象扩展 以在info中添加一个x-logo为例\n\u0026quot;info\u0026quot;: { \u0026quot;description\u0026quot;: \u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;swagger-bootstrap-ui！！！\u0026quot;, \u0026quot;termsOfService\u0026quot;: \u0026quot;http://www.xxx.com/\u0026quot;, \u0026quot;contact\u0026quot;: { \u0026quot;name\u0026quot;: pxxxx@domain.com\u0026quot; }, \u0026quot;x-logo\u0026quot;: { \u0026quot;url\u0026quot;: \u0026quot;http://\u0026quot;, \u0026quot;color\u0026quot;: \u0026quot;#090807\u0026quot; } }, ...  后台代码：\nObjectVendorExtension logo = new ObjectVendorExtension(\u0026quot;x-logo\u0026quot;); logo.addProperty(new StringVendorExtension(\u0026quot;url\u0026quot;, \u0026quot;https://xxx.svg\u0026quot;)); logo.addProperty(new StringVendorExtension(\u0026quot;color\u0026quot;, \u0026quot;#090807\u0026quot;)); return new ApiInfoBuilder() .title(\u0026quot;swagger-bootstrap-ui！！\u0026quot;) .extensions(Lists.newArrayList(logo)) .description(\u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;) .termsOfServiceUrl(\u0026quot;http://www.xxx.com/\u0026quot;) .version(\u0026quot;1.0.0\u0026quot;) .build();  内部对象扩展 给Path添加一个扩展属性x-order为例\n@Component @Order(Ordered.HIGHEST_PRECEDENCE+100) public class OperationPositionBulderPlugin implements OperationBuilderPlugin { @Override public void apply(OperationContext context) { context.operationBuilder().extensions(Lists.newArrayList(new StringVendorExtension(\u0026quot;x-order\u0026quot;,\u0026quot;1\u0026quot;))); } @Override public boolean supports(DocumentationType delimiter) { return true; } }  详细介绍可以参考\n","id":16,"section":"posts","summary":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdq","tags":["swagger","vendorExtensions"],"title":"Swagger 如何使用vendorExtensions进行扩展","uri":"https://lvsq.net/2019/11/swagger-vendor/","year":"2019"},{"content":" 秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁，如平原君广纳异国宾客；苏秦上书于七国；荀子遍游天下者皆可证各国文字并无大乖。 《史籀篇》文首盖云“太史籀书”，人多误以太史籀所作，如此便望文生义了。太史乃官职，王国维先生引《说文》解释，籀即读，读即籀书。另太史籀书乃周世之成语，绝非人名。  ","id":17,"section":"posts","summary":"秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁","tags":["文史"],"title":"历史不能碰","uri":"https://lvsq.net/2019/11/do-not-touch-history/","year":"2019"},{"content":" M -\u0026gt; Alt(option) S -\u0026gt; Shift    快捷键 用途     M-v 上（后）一屏   C-v 下（前）一屏   C-l 重绘屏幕，将光标所在行置于屏幕中央   C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符   C-x C-f  查找或者新建一个文件   C-x C-b 列出缓冲区。 C-x 1 关闭缓冲区列表   C-x C-q 开启或者关闭buffer的只读模式   C-x C-s 保存当前文件   C-x s 保存所有文件   C-x h 全选   M-w 复制   C-y 粘贴   C-w 剪切   C-s 往前搜索   C-r 往后搜索. DEL 也可以往后搜索，   C-/ undo   M-x calendar 打开日历。按 q 退出。【g d 到指定日期】【. 到今日（不居中）】【\u0026gt; 前一个月】【\u0026lt; 后一个月】   M-x *-mode 选择Major mode   M-x shell 运行一个shell   M-x eshell 运行一个eshell   C-a 移到行首   C-a C-k、C-S-backspace 删除整行   C-u 5 C-S-backspace、M-5 C-S-backspace 删除后5行，不加数字则删除4行（默认），如果数字为负数，则往前删   C-g 停止当前的命令   C-k 删除从光标位置到行尾所有字符    Org-Mode    快捷键 用途     C-c . 插入时间   C-c C-e 导出其它格式   C-c C-s 在标题下面插入一个带有“==SCHEDULED==”关键字的时间戳。   C-c C-d 在标题下面插入一个带有“==DEADLINE==”关键字的时间戳   C-c C-t 将当前项的状态在（unmarked）-\u0026gt;TODO-\u0026gt;DONE 之间循环切换   M-RET 插入一个同级标题   M-LEFT/RIGHT 将当前的标题提升/降低一个等级   C-c C-c 插入标签tag。 光标在标题中   C-c C-q 插入标签tag。光标在任意位置   C-c , 设置当前标题的优先级,’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的   C-c  查找标签tag   S-Tab 展开所有标题   Tab 展开光标所在标题   C-c C-l 编辑链接   C-c C-o 打开链接    ","id":18,"section":"posts","summary":"M -\u0026gt; Alt(option) S -\u0026gt; Shift 快捷键 用途 M-v 上（后）一屏 C-v 下（前）一屏 C-l 重绘屏幕，将光标所在行置于屏幕中央 C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符 C-x C-f 查","tags":["emacs"],"title":"Emacs","uri":"https://lvsq.net/2019/11/emacs/","year":"2019"},{"content":" 垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。\n回收由默认的collect-request处理程序自动触发，该处理程序通过collect-request中断调用，该中断在分配了大约n个字节的存储空间后发生，其中n是参数collect-trip-bytes 的值。 默认的collect-request处理程序通过调用不带参数的collect程序来进行会睡。 可以通过更改参数collect-request-handler 的值来重新定义collect-request处理程序。 程序还可以通过直接调用collect来导致在collect-request中断之间发生回收。\nChez Scheme的回收器是基于分代 的。它根据对象的年龄（大致来说，回收幸存数）来对对象进行分类，且老对象比年轻对象回收的频率要低。由于年轻对象比老对象更快地变为不可访问，因此结果是大多数的回收花费的时间更少。系统还维护一个静态代（static generation, 类似Java的永久代），不会对此存储进行回收。仅当压缩堆（Scompact_heap）或要collect的target-generation 参数为static符号时，才将对象放入静态代中。\n非静态代的编号从最年轻的世代（开始于0）到collect-maximum-generation的当前值。存储管理器将新分配的对象放入第0代。在第0代的回收过程中，默认情况下，将第0代的对象挪到第1代，类似地，在第1代回收期间，存活的第0代和第1代对象移动到第2代，依此类推。在最大非静态对象回收的过程中，所有幸存的非静态对象都将移动（可能返回）到最大非静态代中。 通过这种机制，一个对象有可能跳过一个或多个世代，但这在许多对象上不太可能发生，并且如果这些对象变得不可访问，则最终将回收它们的存储。\n维护内部计数器gc-trip来控制何时回收每一代。 每次调用不带参数的collect 时（从默认的collect-request处理程序开始），gc-trip都会加1。在collect-generation基数为r 的情况下，回收的世代编号为g ，其gc-trip是$r^g$的倍数。 如果将collect-generation-radix设置为4，则系统将每次收集0代，每4次收集1代，每16次收集2代，依此类推。\n每次某个世代g 调用collect时，该世代g 被回收且gc-trip前进到下个$r^g$的边界，但是不会超过$r^{g+1}$的边界，r 不变还是collect-generation-radix的值。\n如果使用第二个参数tg 调用collect，则tg 确定目标代。 当g 是最大的非静态代时，tg 必须为g 或为static。 否则，tg 必须为g 或g + 1 。 当目标代是static符号时，非静态代中的所有数据都将移动到静态代中。静态代中的对象从不会被回收。 这在加载和初始化应用程序的永久代码和数据结构之后非常有用，以减少后续回收的开销。\n通过设置本节中描述的参数，可以对回收器的行为进行实质性的调整。通过重新定义collect-request处理程序且使用显式的g 和tg 参数调用collect，甚至有可能完全覆盖收集器的默认策略来确定何时回收每个世代。例如，程序员可以通过使用显式的g 和tg 参数调用collect来重新定义处理程序，以在长时间内将最大的非静态代视为静态代，该参数在该时间段内绝不等于最大的非静态代。\n (collect) | (collect g) | (collect g tg)\n g 必须是不大于最大非静态代（collect-maximum-generation返回的值）的非负确定编号。 如果g 已经是最大的非静态代编号，则tg 必须是一个等于g 的fixnum或static符号。 否则，tg 必须是一个等于g 或大于g 的fixnum。\n此过程使存储管理器执行垃圾回收。 collect是通过collect-request处理程序定期调用的，但是也可以显式调用它，以在特定时间（例如，在计时计算之前）强制进行回收。 在Chez Scheme的线程版本中，调用collect的线程必须是唯一的活动线程。\n系统将根据g 和tg （如果提供）确定回收哪些世代，如本节的介绍中所述。\n (collect-rendezvous)\n 请求垃圾回收的方式应该与由系统自动发起的GC的方式相一致。所有正在运行的线程经过协调，以便其中一个调用collect-request处理程序，而其他线程暂停直到处理程序返回。\n请注意，如果collect-request处理程序（请参阅collect-request-handler）没有调用collect，那么collect-rendezvous实际上不会执行垃圾回收。\n collect-notify\n 如果将collect-notify设置为true，则每当运行GC时，回收器都会打印一条消息。 默认情况下，collect-notify设置为#f。\n collect-trip-bytes\n Chez Scheme在内部以大块分配内存，并通过内联操作将这些块细分以提高效率。存储管理器确定是否为每个分配的大块仅请求一次回收。此外，在存储管理器请求回收和兑现回收请求之间可能会花费一些时间，尤其是如果通过with-interrupts-disabled或disable-interrupts临时禁用了中断时。因此，collect-trip-bytes仅是一种近似度量。\n collect-generation-radix\n 此参数确定默认情况下的collect-request处理程序调用不带参数的collect时回收每一代的频率。每$r^g$次发生一次对应世代的回收，其中r 是collect-generation-radix的值，g 是世代数。\n将collect-generation-radix设置为1会强制所有世代每次都被回收， 将collect-generation-radix设置为非常大的数目将无限期有效地延迟较早的一代的回收。\n collect-maximum-generation\n 此参数确定当前可以使用的最大非静态世代数,它的值是1到254范围内的精确整数。设置为1时，仅使用两个非静态生成。 设置为2时，将使用三个非静态世代，依此类推。 当设置为254时，将使用255个非静态代，再加上一个静态代，总共256个世代。增加世代数可以减少了收集旧对象的频率，潜在地减少了收集开销，但同时也潜在地增加了系统中保留的不可访问对象的数量，从而增加了所需的内存总量。\n collect-request-handler\n collect-request-handler的值必须是一个过程。当系统认为应该要进行GC时（即，自上次GC以来，系统分配了由参数collect-trip-bytes规定的存储量之后），该过程在不带参数的情况下被调用。\n默认情况下，collect-request-handler仅调用不带参数的collect。 可以通过将collect-request-handler设置为不执行任何操作的过程来禁用自动收集，例如：\n(collect-request-handler void)  也可以利用防止任何中断的critical-section来临时禁用GC\n release-minimum-generation\n 此参数的值必须介于0到collect-maximum-generation的值（包括）之间，并且默认为collect-maximum-generation的值。\n当分配新数据且进行GC时，storage-management会自动地从操作系统中请求额外的虚拟内存地址。相应地，在堆显著减小的情况下，系统尝试将先前从操作系统获得的某些虚拟内存返回给操作系统。默认情况下，系统仅在针对最大非静态时代的GC之后才这样做。也可以让系统在对更年轻的世代回收之后就执行此操作，方法是将release-minimum-generation的值更改为小于collect-maximum-generation的值。由参数指定的世代，或者任何较老的世代是GC的目标世代时，存储管理系统将在GC之后尝试将不需要的虚拟内存返回给操作系统。\n当collect-maximum-generation设置为一个新值g 时，release-minimum-generation也同时隐式地更改为g ，有两个前提：（a）修改前这两个参数具有相同的值；（b）release-minimum-generation的值大于g\n heap-reserve-ratio\n 此参数确定了保留的内存的大概数量（没有返回给OS，如release-minimum-generation所描述的）与当前已占用的内存量（不包含已变为静态的内存区域）的比例，它的值必须是不精确的非负整数值； 如果设置为精确的实数值，则精确的值将转换为不精确的值。默认值1.0，为每个当前占用的非静态页面保留一页内存。 将其设置为较小的值可能会导致较小的平均虚拟内存占用量，而将其设置为较大的值可能会导致较少的操作系统调用以请求和释放内存空间。\n弱序对，暂时序对和守护者Weak Pairs, Ephemeron Pairs, and Guardians weak pairs允许程序维护指向对象的弱指针。 指向对象的弱指针不会阻止存储管理系统回收该对象，但是只要该对象在系统中是可访问的，它仍然有效。\nephemeron pairs与weak pairs类似，但是ephemeron pairs拥有两个指针，其中仅仅在第一个指针存在的情况第二个指针才能存在\nguardians允许程序保护对象免遭垃圾回收器的重分配，并确定该对象何时被重新分配。\nweak paris, ephemeron pairs 和guardians允许程序将有关对象的信息保留在单独的数据结构（例如哈希表）中，而无需担心维护此信息将导致对象无限期地保留在系统中。\n另外，guardians允许无限期地从释放对象中保存对象，以便可以重用它们，或者可以使用存储在对象中的数据执行清理或其他操作。\n (weak-cons obj1 obj2)\n 返回：一个新的弱序对\nobj1 是新对的car, obj2构成了新对的cdr。弱序对和普通对是无法区分的，除了这两种方式：\n 弱序对可以使用weak-pair?这个谓词来区别普通对 弱序对维护了一个指向(car obj)的弱指针  弱序对的car中的弱指针就像普通指针一样，只要它指向的对象可以通过系统中某个地方的普通（非弱）指针访问即可。 但是，如果垃圾收集器在某个时候识别出不存在指向该对象的非弱指针，则它将每个指向该对象的弱指针替换为“ broken weak-pointer”对象#!bwp，并丢弃该对象。\n弱序对的cdr字段不是弱指针，因此可以使用弱序对来构造弱保持对象的列表。可以像使用普通的列表的处理操作（例如length，map和assv）来操作这些list。弱序对可以使用set-car!和set-cdr!来修改； 在set-car!之后，car字段包含指向新对象的弱指针，代替了旧对象。弱序对的打印方式与普通对相同。 弱序对没有reader语法。弱序对在被写入然后被读取时成为普通对。\n(define x (cons 'a 'b)) (define p (weak-cons x '())) (car p) ⇒ (a . b) (define x (cons 'a 'b)) (define p (weak-cons x '())) (set! x '*) (collect) (car p) ⇒ #!bwp   (weak-pair? obj)\n (weak-pair? (weak-cons ’a ’b)) ⇒ #t (weak-pair? (cons ’a ’b)) ⇒ #f (weak-pair? \u0026quot;oops\u0026quot;) ⇒ #f   (ephemeron-cons obj1 obj2)\n obj1 是新对的car, obj2构成了新对的cdr。暂时序对和普通对是无法区分的，除了这两种方式：\n 暂时序对可以使用ephemeron-pair?这个谓词来区别普通对 暂时序对维护了一个指向(car obj)的弱指针，并且仅仅在pair的car存在时cdr才能保留  暂时序对的行为与弱序对类似，不过cdr有特殊的处理：如果car被设置为#!bwp的同时也会将cdr设置为#!bwp。由于同时将car和cdr字段设置为为#!bwp，因此可以通过cdr对象引用car对象这一事实本身并不意味着必须保留car（与弱序对不同）。 相反，出于某种原因，car必须独立于cdr对象保存。\n与弱序对和其他对一样，暂时序对使用set-car!和set-cdr!来修改数据，暂时序对的打印方式与普通对一样，但没有reader语法\n(define x (cons 'a 'b)) (define p (ephemeron-cons x x)) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b) (define x (cons 'a 'b)) (define p (ephemeron-cons x x)) (set! x '*) (collect) (car p) ⇒ #!bwp (cdr p) ⇒ #!bwp (define x (cons 'a 'b)) (define p (weak-cons x x)) ; not an ephemeron pair (set! x '*) (collect) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b)  与弱序对一样，如果在将x设置为*之前进行了垃圾回收将该pair提升为较老的一代，则上面中间示例的最后两个表达式实际上可能返回（a . b）。 但是，在上面的最后一个示例中，最后两个表达式的结果将始终为（a . b），因为弱序对的cdr持有非弱引用，并且该非弱引用阻止car字段变** #!bwp**。\n (ephemeron-pair? obj)\n (ephemeron-pair? (ephemeron-cons 'a 'b)) ⇒ #t (ephemeron-pair? (cons 'a 'b)) ⇒ #f (ephemeron-pair? (weak-cons 'a 'b)) ⇒ #f (ephemeron-pair? \u0026quot;oops\u0026quot;) ⇒ #f   (bwp-object? obj)\n 返回：如果obj是断开的broken weak-pair对象，则返回#t，否则返回#f\n(bwp-object? #!bwp) ⇒ #t (bwp-object? 'bwp) ⇒ #f (define x (cons 'a 'b)) (define p (weak-cons x '())) (set! x '*) (collect (collect-maximum-generation)) (car p) ⇒ #!bwp (bwp-object? (car p)) ⇒ #t   (make-guardian)\n Guardians由要保护的对象组的过程表示。创建guardian后，注册对象组为空。 通过将对象作为参数传递给守护者，可以向guardian注册对象：\n(define G (make-guardian)) (define x (cons 'aaa 'bbb)) x ⇒ (aaa . bbb) (G x)  注册对象时也可以指定“representative”（即，y）对象。 继续上面的示例：\n(define y (cons 'ccc 'ddd)) y ⇒ (ccc . ddd) (G y 'rep)  与守护者关联的一组注册对象在逻辑上细分为两个不相交的子组：一个子组称为“可访问”对象，一个子组称为“不可访问”对象。不可访问的对象是已被证明无法访问的对象（通过guardian机制本身或通过弱序对或暂时序对的car字段除外），可访问的对象是未经证明的对象。“已证明”一词在这里很重要：可能是可访问组中的某些对象确实是不可访问的，但这尚未得到证明。 在某些情况下，直到对象实际上变得不可访问很久之后（在当前实现中，直到发生包含对象的世代的垃圾回收），才可能做出这种证明。\n向guardian注册的对象最初被放置在可访问组中，并在它们变得不可访问后的某个时刻移入不可访问组。 不可访问组中的对象是通过调用不带参数的guardian来检索的。 如果不可访问组中没有对象，则guardian返回#f。 继续上面的示例：\n(G) ⇒ #f (set! x #f) (set! y #f) (collect) (G) ⇒ (aaa . bbb) ; 也有可能这个后打印出来 (G) ⇒ rep ; 这个先打印出来 (G) ⇒ #f  对G的初始调用返回#f，因为绑定到x和y的对是向G注册的唯一对象，并且仍然可以通过这些绑定访问这些序对。调用collect时，对象将移入不可访问的组。 因此，对G的两个调用返回先前绑定到x的序对和先前绑定到y的序对的representative，尽管可能与所示顺序相反。 （如上所述，对于弱序对，如果对象已迁移到较老的一代，则调用collect实际上可能不足以证明该对象不可访问。）\n实际上，从guardian那里获取的对象在任何方面都没有特殊的地位。 此功能避免了共享或循环结构可能会出现的问题。 由不可访问对象组成的共享或循环结构将被完整保留，将注册由guardian保护的部分都放置在该guardian不可访问的集合中。 然后，程序员可以完全控制结构的处理顺序。\n一个对象可以在guardian处多次注册，在这种情况下，可以多次检索该对象：\n(define G (make-guardian)) (define x (cons 'aaa 'bbb)) (G x) (G x) (set! x #f) (collect) (G) ⇒ (aaa . bbb) (G) ⇒ (aaa . bbb)  它也可以向不止一个guardian注册，并且guardian本身也可以向其他guardian注册。 在没有“representative”的情况下向guardian注册的对象，并放置在一个弱序对或暂时对的car字段中，其直到从guardian处将返回并由程序丢弃，或者直到guardian本身被丢弃为止。\n(define G (make-guardian)) (define x (cons 'aaa 'bbb)) (define p (weak-cons x '())) (G x) (set! x #f) (collect) (set! y (G)) y ⇒ (aaa . bbb) (car p) ⇒ (aaa . bbb) (set! y #f) (collect 1) (car p) ⇒ #!bwp  另一方面，如果指定了representative（对象本身除外），则在从guardian处获得representative的同时，也会从弱序对或暂时序对的car字段中丢弃受保护的对象。\n(define G (make-guardian)) (define x (cons 'aaa 'bbb)) (define p (weak-cons x '())) (G x 'rep) (set! x #f) (collect) (G) ⇒ rep ; 获得representative的值 (car p) ⇒ #!bwp ; 自动丢弃  下面的示例说明了当guardian本身丢弃时，该对象已被释放并且弱序对的car字段设置为#!bwp：\n(define G (make-guardian)) (define x (cons aaa 'bbb)) (define p (weak-cons x '())) (G x) (set! x #f) (set! G #f) (collect) (car p) ⇒ #!bwp  下面的示例演示了如何使用guardian来释放外部存储，就像由C库“malloc”和“free”操作管理存储。\n(define malloc (let ([malloc-guardian (make-guardian)]) (lambda (size) ; first free any storage that has been dropped. to avoid long ; delays, it might be better to deallocate no more than, say, ; ten objects for each one allocated (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f)))) ; then allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x))))  do-malloc必须返回一个Scheme对象“header”，该header封装一个指向外部存储的指针（可能是无符号整数），并且必须通过此header对外部存储进行所有访问。特别是，必须注意在删除相应的header之后，在Scheme之外不存在指向外部存储的指针。 do-free必须使用封装的指针释放外部存储。这两个原语都可以使用外部分配和外部无关的定义，也可以作为外部过程导入的C库“malloc”和“free”运算符进行定义。\n如果不希望调用malloc来释放存储，则可以使用collect-request处理器来检查并释放已丢弃的存储，如下所示：\n(define malloc) (let ([malloc-guardian (make-guardian)]) (set! malloc (lambda (size) ; allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x))) (collect-request-handler (lambda () ; first, invoke the collector (collect) ; then free any storage that has been dropped (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f)))))))  通过一点重构，就有可能将封装的外部地址注册为带header的representative，在这种情况下，do-free将仅将外部地址作为参数。 这将使标头一旦变得不可访问，便可以将其从Scheme堆中删除。\n锁对象Locking Objects 来自C语言的变量或数据结构到Scheme对象的所有指针，通常应在输入（或重新输入）Scheme之前丢弃。 当无法遵循该准则时，可以通过锁定对象或等效的C库过程Slock_object锁定该对象。\n (lock-object obj)\n 锁定对象可防止存储管理器收回或重定位该对象。 应谨慎使用锁定，因为它会导致内存碎片并增加存储管理开销。\n如果未解锁对象，锁定也会导致意外保留存储空间。 可以通过解锁对象或等效的C库过程Sunlock_object来解锁对象。\n锁定立即数（例如，fixnum，布尔值和字符）或已被静态化的对象是不必要但无害的。\n (unlock-object obj)\n 通过连续调用lock-object，Slock_object或同时调用这两个对象，可以多次锁定对象，在这种情况下，必须先通过相等次数的对unlock-object或Sunlock_object的调用来将其解锁。\n除非存在指向对象的单独的C指针，否则也无需锁定包含在锁定对象中的对象（例如，锁定序对的car中的对象）。也就是说，如果仅允许通过外部对象来间接访问的内部对象，则应将其解锁，以便回收器在回收期间可以自由地重分配它。\n解锁立即值（例如，fixnum，布尔值和字符）或已设为静态的对象是不必要的，无效的，但无害。\n (locked-object? obj)\n 返回：如果obj是锁定的，立即的或静态的，返回#t\n如果回收器无法重分配或回收obj，则该谓词将返回true，包括立即值，例如fixnums，布尔值和字符以及已设为静态的对象。\n","id":19,"section":"posts","summary":"垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动","tags":["scheme"],"title":"存储管理(Storage Management in Chez Scheme)","uri":"https://lvsq.net/2020/02/storage-management/","year":"2020"},{"content":" 异常  (warning who msg irritant \u0026hellip;)\n返回：未指定\n 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止程序继续运行但可能在以后导致更严重问题的情况。\n通常最好是识别程序员已调用的过程，而不是程序员可能不知道的其他过程。 msg必须为字符串，并应描述异常情况。irritant可以是任何Scheme对象，并且应包含可能导致或严重涉及异常情况的值。\n (assertion-violationf who msg irritant \u0026hellip;) | (errorf who msg irritant \u0026hellip;) | (warningf who msg irritant \u0026hellip;)\n 这些过程类似于assertion-violation, error, warning, 所不同的在于 msg 设定为一个格式字符串\n中断 Chez Scheme允许程序在发生各种事件时控制Scheme系统的操作，这些事件包括键盘中断，由set-timer设置的内部计时器到期，由中断调用引发的断点或者来自存储管理器的请求启动GC。\n无论何时break被调用，系统都会立即启用中断处理程序\n (break who msg irritant \u0026hellip;) | (break who) | (break)\n break参数遵循上述errorf的协议。默认的中断处理程序（请参见break-handler）显示一条消息并调用调试器。可以省略格式字符串和对象，在这种情况下，默认中断处理程序发出的消息使用who参数标识中断，但不提供有关中断的更多信息。如果也省略了who参数，则不会生成任何消息。如果调试器正常退出，则默认的中断处理程序将正常返回。\n break-handler\n 此参数的值必须是一个过程。当前的中断处理程序由break调用，它传递其参数。有关默认中断处理程序的描述，请参见break。以下示例显示了如何禁用breaks。\n(break-handler (lambda args (void)))   (set-timer n)\n n 必须为非负整数。当n 为非零时，设置计时器启动一个内部计时器，其初始值为n。经过n个tick后，将发生计时器中断，从而导致计时器中断处理程序被调用。tick不是统一的时间单位，而是在很大程度上取决于每个过程调用要完成多少工作。\n当n为零时，设置计时器关闭计时器。\nengine机制建立在计时器中断之上，因此不应与engine共同使用。\n (register-signal-handler sig procedure)\n register-signal-handler用于为给定的底层信号建立信号处理程序。 sig必须是标识有效信号的精确整数，过程应接受一个参数。在注册了给定signal的处理程序之后，收到了给定的signal会调用该处理程序。signal编号会传递给该处理程序，从而允许同一处理程序用于不同的信号，同时区分它们。\n以这种方式处理的信号类似于键盘中断，因为在将信号传递到进程时不会立即调用处理程序，而是在信号传递后在某个过程调用边界处调用该处理程序。因此，为内存故障，非法指令等建立处理程序通常不是一个好主意，因为导致故障或非法指令的代码将在调用处理程序之前继续执行（可能是错误的）一段时间。\n另外，仅在基于Unix的系统上才支持register-signal-handler。\n环境 环境是包含标识符绑定的顶级（first-class）对象。它们类似于模块，但是与模块不同，它们可以在运行时进行操作。环境可以作为eval，expand以及过程的定义，分配或引用顶级值的可选参数。\n有几种内置环境，也可以通过复制现有环境或从现有环境中选择的绑定来创建新环境。\n环境可以是可变的或不变的。可变的环境可以使用新的绑定进行扩展，可以修改其现有绑定，还可以分配其变量。不变的环境不能以任何这些方式进行修改。\n 联想一下SICP中关于环境的内容 (environment? obj)\n (environment? (interaction-environment)) ⇒ #t (environment? 'interaction-environment) ⇒ #f (environment? (copy-environment (scheme-environment))) ⇒ #t (environment? (environment '(prefix (rnrs) $rnrs-))) ⇒ #t   (environment-mutable? env)\n (environment-mutable? (interaction-environment)) ⇒ #t (environment-mutable? (scheme-environment)) ⇒ #f (environment-mutable? (copy-environment (scheme-environment))) ⇒ #t (environment-mutable? (environment '(prefix (rnrs) $rnrs-))) ⇒ #f   (scheme-environment)\n scheme-environment返回一个包含初始顶级绑定的环境。该环境对应于Scheme模块。此过程返回的环境是不可变的。\n(define cons 3) (top-level-value 'cons (scheme-environment)) ⇒ #\u0026lt;procedure cons\u0026gt; (set-top-level-value! 'cons 3 (scheme-environment)) ⇒ exception   (copy-environment env) | (copy-environment env mutable?) | (copy-environment env mutable? syms)\n copy-environment返回env的副本，即包含与env 相同绑定的新环境。mutable? 如果为true，则该environment是可变的，反之则不可变；\n从env 复制到新环境的绑定集由syms 确定，其默认值为（environment-symbols env）。每个syms 元素的绑定（如果有）都被复制到新环境中，并且新环境中不存在其他绑定。\n在当前的实现中，永远不会收集环境使用的存储空间，因此重复使用复制环境最终将导致系统内存不足。\n(define e (copy-environment (scheme-environment))) (eval '(define cons +) e) (eval '(cons 3 4) e) ⇒ 7 (eval '(cons 3 4) (scheme-environment)) ⇒ (3 . 4)   (environment-symbols env)\n 此过程返回代表环境env中绑定的标识符的符号列表。它主要用于构建要从一种环境复制到另一种环境的符号列表。\n(define listless-environment (copy-environment (scheme-environment) #t (remq 'list (environment-symbols (scheme-environment))))) (eval '(let ([x (cons 3 4)]) x) listless-environment) ⇒ (3 . 4) (eval '(list 3 4) listless-environment) ⇒ exception  编译、求值和加载  (eval obj) | (eval obj env)\n eval将obj 视为表达式的表示形式。它在环境*env*中计算表达式并返回其值。如果未提供任何环境，则默认为由交互环境返回的环境。\n单参数求值是Chez Scheme的扩展。当环境可变时，Chez Scheme还允许obj表示非表达形式，比如一个definition。 Chez Scheme还允许obj作为一个annotation，默认求值程序利用注释将源文件信息合并到错误消息中，并将源文件信息与编译后的代码相关联。\n在Chez Scheme中，eval实际上是一个包装器，仅将其参数传递给当前求值器（请参阅current-eval）。默认的评估器是compile，它通过当前的扩展器（参阅current-expand）扩展表达式，对其进行编译，执行生成的代码，并返回其值。如果存在环境参数env ，则compile将其传递给当前的扩展器，默认情况下为sc-expand。\n (compile obj) | (compile obj env)\n obj 可以为Scheme表达式，在指定的环境（或交互环境，如果未提供环境）中使用当前扩展器（current-expand的值）进行扩展），编译为机器代码，然后执行。 compile是current-eval参数的默认值。\n(compile '(cons 1 2)) =\u0026gt; (1 . 2)   (interpret obj) | (interpret obj env)\n 解释类似于编译，只是表达式是解释的而不是编译的（the expression is interpreted rather than compiled）。解释可以用作编译的替代品，但有以下警告：\n 解释后的代码运行速度大大降低 解释后的代码不会生成检查器信息，因此检查器对于解释的代码不如在编译的代码中有用、 无法解释外部过程表达式，因此解释器需要为所有外部过程表达式调用编译器（这是透明完成的）  当求值形式运行时间较短时，解释有时比编译更快，因为它避免了在求值之前通过编译完成的某些工作。\n (load path) | (load path eval-proc)\n path 必须是字符串。 load读取并求值path 指定的文件的内容。该文件可能包含源代码或目标代码。默认情况下，load使用eval求值源文件中找到的每个源表达式。如果指定了eval-proc ，则load将使用此过程。 eval-proc 必须接受一个参数，即要求值的表达式。\neval-proc参数有助于实现嵌入的类似于Scheme的语言，并有助于使用用于Scheme程序的替代评估机制。 eval-proc也可以用于其他用途。例如，\n(load \u0026quot;myfile.ss\u0026quot; (lambda (x) (pretty-print (if (annotation? x) (annotation-stripped x) x)) (newline) (eval x)))  对每一个表达式求值之前使用pretty-print打印。\n参数source-directorys确定了搜索目录，以搜索未由绝对路径名标识的源文件。\n (load-library path) | (load-library path eval-proc)\n load-library与load相同，除了它会将输入文件视为由隐式＃!r6rs作为前缀。这有效地禁用了所有非R6RS词法语法，除非随后被＃！chezscheme覆盖\n (load-program path) | (load-program path eval-proc)\n path 必须是字符串。加载程序读取并求值path指定的文件的内容。\n该文件可能包含源代码或目标代码。如果包含源代码，则加载程序会将代码以顶级程序形式包装起来，以便将文件的内容视为RNRS顶级程序（Scheme编程语言，第4版的10.3节）。\n默认情况下，加载程序使用eval求值文件中找到的每个源表达式。如果指定了eval-proc，则装入程序将使用此过程。 eval-proc必须接受一个参数，即要评估的表达式。传递给eval-proc的表达式可能是注释或未注释的值。 参数source-directorys确定了搜索目录，以搜索未由绝对路径名标识的源文件。\n (load-compiled-from-port input-port)\n load-compiled-from-port读取并求值来自input-port的对象代码的内容，这些input-port是事先由诸如compile-file, compile-script, compile-library, compile-to-port创建的\n返回值是最后一个表达式的值，该表达式的编译形式为input-port。如果input-port为空，则结果值未指定。\n (compile-file input-filename) | (compile-file input-filename output-filename)\n input-filename 和output-filename 必须是字符串。input-filename 必须是已存在的可读文件。它必须包含零个或多个源表达式的序列；如果不是这种情况，则编译文件会引发条件类型为＆syntax的异常。\n正常求值过程分为两个步骤：编译和执行。 compile-file对整个源文件执行编译过程，从而生成目标文件。随后加载目标文件（请参见load）时，不需要编译过程，并且文件加载通常快几倍。\n (compile-script input-filename) | (compile-script input-filename output-filename)\n compile-script与compile-file类似，不同点在于，它会从源文件复制开头的#!行到目标文件，同时该行不会被压缩，尽管参数compile-compressed被设置为#t，其他代码会被压缩，这样会保证操作系统可以正确地解释。\ncompile-script允许从源脚本创建已编译的脚本文件，以减少脚本加载时间。与源代码脚本一样，可以使用\u0026ndash;script命令行选项运行已编译的脚本。\n (compile-library input-filename) | (compile-library input-filename oiutput-filename)\n compile-library与compile-file相同，不同之处在于，它会将输入文件视为由隐式＃!r6rs作为前缀。这有效地禁用了所有非R6RS词法语法，除非随后被＃!chezscheme覆盖。\n (compile-program input-filename) | (compile-program input-filename output-filename)\n compile-program类似于compile-script，但不同之处在于，它实现了RNRS顶级程序的语义，而compile-script则实现了交互式顶级程序的语义。与通过compile-file或compile-script进行编译相比，生成的已编译程序的运行速度也更快。\ncompile-program返回由编译的顶层程序直接调用的库的列表，不包括（rnrs）和（chezscheme）之类的内置库\n (compile-whole-program input-filename output-filename) | (compile-whole-program input-filename output-filename libs-visible?)\n compile-whole-program接受一个文件名作为名称输入，该文件名为顶级程序命名为“ whole program optimization”（wpo）文件，并生成一个包含该程序及其所依赖的每个库的目标文件，前提是需要一个可以找到库的wpo文件。\n如果wpo文件找不到所需库，但可以找到该库的目标文件，则该库不会合并到生成的目标文件中。这些库将在运行时加载。 compile-whole-program返回这些库的列表。如果没有这样的库，则生成的目标文件是自包含的，并且compile-whole-program返回空列表。\n如果libs-visible? 设置为非false，则库合并到目标文件是可见的（供environment和eval使用），任何合并到目标文件中并在运行时保留下来的目标文件所要求的库都是可见的。\n当generate-wpo-files参数设置为#t时，过程compile-file，compile-program，compile-library，compile-script和compile-whole-library会生成wpo文件以及普通目标文件。 （默认值为#f）。另外如果传递可选的wpo端口时，compile-port和compile-to-port也会这样做。\n (compile-whole-library input-filename output-filename)\n compile-whole-library类似于compile-whole-program，不同之处在于input-filename必须为库指定一个wpo文件，所有库自动显示，并生成一个新的wpo文件（当generate-wpo-files为#t时）以及用于生成的库组合的目标文件。\n (compile-port input-port output-port) | (compile-port input-port output-port sfd) | (compile-port input-port output-port sfd wpo-port)\n input-port 必须是文本输入端口。out-port 和*wpo-port*（如果存在）必须是二进制输出端口。如果存在sfd ,必须是源文件描述符。\n (make-boot-file output-filename base-boot-list input-filename \u0026hellip;)\n 所有参数都必须是字符串。\nmake-boot-file将引导标头（boot header）写入以output-filename 命名的文件，然后依次写入每个input-filename 的目标代码。如果尚未编译输入文件，make-boot-file将在对其进行编译。\n引导文件通过\u0026ndash;boot或-b命令行选项显式加载，或基于可执行文件的名称隐式加载。\n (make-boot-header output-filename base-boot1 base-boot2\u0026hellip;)\n 该过程已包含在make-boot-file中，并提供了向后兼容性。\n(make-boot-header output-filename base-boot1 base-boot2 \u0026hellip;)\n等价于：\n(make-boot-file output-filename ’(base-boot1 base-boot2 \u0026hellip;))\n源目录和文件  source-directories\n source-directories的值必须是一个字符串列表，每个字符串都命名一个目录路径。当通过load, load-library, load-program, include, visit, or revisit在交互式检查器中发生语法错误或打开源文件时，source-directory确定用于搜索源文件或目标文件的目录集。\n默认值为列表（“.”），这意味着仅在当前目录中或相对于当前目录才能找到源文件，除非使用绝对路径命名。\n (with-source-path who name procedure)\n 过程with-source-path依次搜索当前源目录路径，以查找具有指定名称的文件，并在结果上调用过程。如果未找到这样的文件，则引发\u0026amp;assertion和\u0026amp;who异常，\u0026amp;who的值为who 的值\n如果name 是绝对路径，或者以./（Windows下是./），或者../（Windows下是..\\），或者源目录列表中只包含“.”，或者默认值 \u0026ldquo;\u0026ldquo;，相当于 \u0026ldquo;.\u0026ldquo;，不执行搜索并返回*name*。\nwho 必须是符号，name 必须是字符串，procedure 应接受一个参数。\n以下示例假定文件“ pie”存在于目录“ ../spam”中，但不在“ ../ham”或当前目录中。\n(define find-file (lambda (fn) (with-source-path 'find-file fn values))) (find-file \u0026quot;pie\u0026quot;) ⇒ \u0026quot;pie\u0026quot; (source-directories '(\u0026quot;.\u0026quot; \u0026quot;../ham\u0026quot;)) (find-file \u0026quot;pie\u0026quot;) ⇒ exception in find-file: pie not found (source-directories '(\u0026quot;.\u0026quot; \u0026quot;../spam\u0026quot;)) (find-file \u0026quot;pie\u0026quot;) ⇒ \u0026quot;../spam/pie\u0026quot; (source-directories '(\u0026quot;.\u0026quot; \u0026quot;../ham\u0026quot;)) (find-file \u0026quot;/pie\u0026quot;) ⇒ \u0026quot;/pie\u0026quot; (source-directories '(\u0026quot;.\u0026quot; \u0026quot;../ham\u0026quot;)) (find-file \u0026quot;./pie\u0026quot;) ⇒ \u0026quot;./pie\u0026quot; (source-directories '(\u0026quot;.\u0026quot; \u0026quot;../spam\u0026quot;)) (find-file \u0026quot;../pie\u0026quot;) ⇒ \u0026quot;../ham/pie\u0026quot;  编译器管理  optimize-level\n 该参数可以是0，1，2，3这4个值中的一个。\n理论上，此参数控制编译器执行的优化量。 实际上，它只是间接执行此操作，唯一的区别在于优化级别3（编译器生成“不安全”代码）与优化级别0-2（编译器生成“安全”代码）之间。 安全代码会执行完整类型和范围检查，例如，尝试应用非过程，尝试对non-pair的car操作或尝试引用向量的末尾，均会导致 引发异常。 对于不安全的代码，相同的情况可能会导致无效的内存引用，Scheme堆损坏（这可能在以后引起看似无关的问题），系统崩溃或其他不良行为。不安全的代码通常会更快，但是应该谨慎使用优化级别3，并且仅运用在必须尽快运行且经过良好测试的代码中。\n尽管编译器为优化0至2级生成了相同的代码，但如果需要，用户定义的宏转换器可以区分不同的级别。\n一种使用优化级别的方法是在每个文件上，强制使用eval-when。 例如:\n(eval-when (compile) (optimize-level 3))  也可以通过\u0026ndash;optimize-level命令行选项设置优化级别。此选项对于通过\u0026ndash;program命令行选项在优化级别3运行RNRS顶层程序特别有用，因为eval-when对RNRS顶层程序无效。\n ($primitive variable) | ($primitive 2 variable) | ($primitive 3 variable)\n variable 必须是一个原始procedure的名字。** $primitive**语法形式允许以单个原始引用的粒度控制优化级别，并且它可以用于访问原始值。\n表达式（$primitive variable）可以缩写为#%variable。\n(#%car ’(a b c)) ⇒ a (let ([car cdr]) (car '(a b c))) ⇒ (b c) (let ([car cdr]) (#%car '(a b c))) ⇒ a (begin (set! car cdr) (#%car '(a b c))) ⇒ a   debug-level\n 该参数可以采用0、1、2和3这四个值之一。它用于告诉编译器保留调试信息的重要性，其中0的重要性最低，而3的重要性最高。 默认值是1。从9.0版开始，它仅用于确定在非尾部位置遇到的引起错误的调用是否被视为在尾部位置（因此，导致调用者的帧不出现在堆栈回溯中）。 这发生在低于2的调试级别。\n概要分析Profiling ChezScheme支持两种类型的配置文件：源代码概要分析和块概要分析。\n启用源概要分析后，编译器会对生成的代码进行检测，以计算每个源代码表达式的执行次数。 该信息可以HTML格式显示或打包在列表中，以进行任意用户定义的处理。 也可以将其转储到文件中，然后再加载到编译器的概要分析信息数据库中，以用于源代码级优化。\n源代码概要分析至少包含下面一些步骤： - 编译代码且开启source profiling - 运行编译后的代码生成源代码概要分析信息，且 - 转储概要分析信息\n通过将参数compile-profile设置为符号源或布尔值#t，可以启用源概要分析。 可以通过以下方式转储概要分析信息：\nprofile-dump-html 以HTML格式显示，以便程序员可以直观地看到使用彩色编码系统执行每个表达式的频率，该系统可以轻松发现“热点”\nprofile-dump-list 以适合用户定义的后处理的形式;\nprofile-dump 以适合于通过上述方法之一或某些自定义方式进行离线处理的形式，或\nprofile-dump-data 以适合加载到编译器数据库中的形式。\n由profile-dump-data转储的概要分析信息通过profile-load-data加载到编译器的profiling数据库中。 除非通过profile-dump-data显式转储并通过profile-load-data加载，否则分析信息对编译器不可用。\n当使用块概要文件信息进行优化时，步骤是相似的：\n- 编译代码并开启block profiling - 运行代码生成block-profiling信息 - 转储概要分析信息 - 加载概要信息，且 - 重新编译代码\n通过将参数compile-profile设置为符号块或布尔值#t，可以启用块分析。 概要文件信息必须通过profile-dump-data转储，并通过profile-load-data加载。 与源配置文件信息一样，块配置文件信息可以与转储信息的加载过程相同或不同。\n对于块优化，要重新编译的代码必须相同。 通常，这意味着所涉及的文件必须未经修改，并且其他任何更改都不会间接影响编译器生成的代码。\n出于同样的原因，当要同时使用源概要分析和块概要分析信息进行优化时，必须先收集并加载源信息，然后再运行涉及块概要分析的第一次和第二次编译。 即，必须使用以下步骤：\n1. 编译代码并起开源代码概要分析 2. 运行代码生成source-profiling信息 2. 转储source-profiling 3. 加载source-profiling 3. 重新编译代码，并开启块概要分析 4. 运行代码生成block-profiling信息 4. 转储block-profiling 5. 加载source-和block-profiling 5. 重新编译代码\n标记每个步骤的数字既指示步骤的顺序，又指示必须在同一计划过程中执行的顺序。 （如果需要，所有步骤都可以在同一Scheme流程中执行。） 当compile-profile设置为默认值#f时，将禁用源和块分析。\n假设文件/tmp/fatfib/fatfib.ss包含以下代码：\n(define fat+ (lambda (x y) (if (zero? y) x (fat+ (1+ x) (1- y))))) (define fatfib (lambda (x) (if (\u0026lt; x 2) 1 (fat+ (fatfib (1- x)) (fatfib (1- (1- x)))))))  我们可以像下面这样加载fatfib.ss并且开启概要分析：\n(parameterize ([compile-profile 'source]) (load \u0026quot;/tmp/fatfib/fatfib.ss\u0026quot;))  然后运行代码：\n(fatfib 20) ⇒ 10946  运行（或多次运行）之后，转储概要文件为一些html文件集合： 使用profile-dump-html\n(profile-dump-html)  这将创建一个名为profile.html的文件\n在图中，执行最频繁的代码以接近红色的颜色突出显示，而执行最不频繁的代码以接近紫色的颜色突出显示。\n compile-profile\n 当将此参数设置为符号source或布尔值#t时，编译器将使用指令对生成的代码进行检测，这些指令对源代码的每个部分执行的次数进行计数。 当设置为符号block时，编译器类似地使用指令对生成的代码进行检测，该指令对每个代码块的执行次数进行计数。 当设置为#f（默认值）时，编译器不会插入这些指令。\n当compile-profile为非false时生成的代码较大且效率较低，因此仅在需要概要分析信息时才应设置此参数。启用概要分析检测后编译的代码的概要文件计数器将无限期保留，即使与它们关联的代码已被垃圾收集器回收。 这样可以得到更完整和准确的概要分析数据，但会导致动态生成或加载代码的程序出现空间泄漏，程序可以通过profile-release-counters过程显式地释放计数器，从而避免潜在的空间泄漏。\n (profile-clear)\n 调用此过程会清空概要分析信息，代码每个部分关联的计数都被置为0\n (profile-release-counters)\n 调用此过程将丢弃概要分析\n (profile-dump)\n 此过程将生成自启动或上次调用profile-clear以来收集的所有配置文件信息的转储。 它返回一个pair的列表，其中每个pair的car是一个source-object，而cdr是一个精确的非负整数计数。\nprofile-dump优于profile-dump-list的优点在于，profile-dump仅执行最少的处理，并保留完整的源对象，包括其嵌入式源文件描述符。 例如，它可以用于将概要分析信息转储到一台计算机上的fasl文件中，以便在另一台计算机上进行后续处理。\n (profile-dump-html) | (profile-dump-html prefix) | (profile-dump-html prefix dump)\n 此过程将生成一个或多个HTML文件，包括profile.html（其中包含用颜色编码的摘要信息），以及一个文件source.html，其中每个源文件源都包含用源代码进行颜色编码的副本，如前导中所述： 在本节中。 如果指定了*prefix*，则它必须是字符串，并且在生成的HTML文件的名称之前。 例如，如果前缀为“ /tmp/”，则生成的文件将放置在目录/tmp中。 原始概要分析信息是从转储获取的，默认为profile-dump返回的值\n (profile-palette)\n 此参数的值必须是至少三对的非空向量。 每个pair的car是背景色，而cdr是前景（文本）色。 每种颜色都必须是一个字符串，并且每个字符串都应包含HTML层叠样式表（CSS）颜色说明符。 第一组用于未配置的代码，第二对用于未执行的配置的代码。 第三个用于执行频率最低的代码，第四个用于执行频率倒数第二低的代码，以此类推，最后一个用于执行频率最高的代码。 程序员可能希望提供自己的调色板以增强可见性或更改所用颜色的数量。\n默认情况下，黑色背景用于未配置文件的代码，灰色背景用于未执行的配置文件的代码。 根据执行频率，紫色到红色的背景颜色用于执行的概要分析代码，而最频繁执行的代码使用红色。\n(profile-palette) ⇒ #((\u0026quot;#111111\u0026quot; . \u0026quot;white\u0026quot;) (\u0026quot;#607D8B\u0026quot; . \u0026quot;white\u0026quot;) (\u0026quot;#9C27B0\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#673AB7\u0026quot; . \u0026quot;white\u0026quot;) (\u0026quot;#3F51B5\u0026quot; . \u0026quot;white\u0026quot;) (\u0026quot;#2196F3\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#00BCD4\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#4CAF50\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#CDDC39\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#FFEB3B\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#FFC107\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#FF9800\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#F44336\u0026quot; . \u0026quot;white\u0026quot;)) (profile-palette ; set palette with rainbow colors and black text ; for all but unprofiled or unexecuted code '#((\u0026quot;#000000\u0026quot; . \u0026quot;white\u0026quot;) (\u0026quot;#666666\u0026quot; . \u0026quot;white\u0026quot;) (\u0026quot;#8B00FF\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#6600FF\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#0000FF\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#00FF00\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#FFFF00\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#FF7F00\u0026quot; . \u0026quot;black\u0026quot;) (\u0026quot;#FF0000\u0026quot; . \u0026quot;black\u0026quot;))) ; red   (profile-line-number-color)\n 此参数的值必须是字符串或#f。 如果是字符串，则该字符串应包含HTML层叠样式表（CSS）颜色说明符。 如果参数设置为字符串，则profile-dump-html使用指定的颜色在每个源文件的html呈现中包括行号。 如果参数设置为#f，则不包含行号。\n个性化（Waiter Customization）  (new-cafe) | (new-cafe eval-proc)\n Chez Scheme通过waiter 或read-eval-print循环（REPL）与用户进行交互。 *waiter*在称为caf́e的上下文中运行。 当系统启动时，将用户置于caf́e中并分配waiter 。 new-cafe在旧的caf́e之上开启了一个新的Scheme caf́e。 除了启动waiter 之外，new-cafe还设置了caf́e的重置和退出处理程序（请参阅reset-handler和exit-handler）。 退出caf́e会返回到创建该caf́e的caf́e。从最初的caf́e退出后会完全退出了Scheme。 caf́e可以通过显式调用exit或通过接收end-of-file（Unix系统上为“ control-D”）来退出。在前一种情况下，传递给exit的任何值都是从new-cafe返回的。\n\u0026gt; (define x 1) \u0026gt; x 1 \u0026gt; (new-cafe) \u0026gt;\u0026gt; x 1 \u0026gt;\u0026gt; (define y 2) \u0026gt;\u0026gt; y 2 \u0026gt;\u0026gt; (exit 1) 1  如果指定了可选的eval-proc 参数，则使用eval-proc 求值从控制台输入的程序。 否则，将使用参数current-eval 的值。 eval-proc必须接受一个参数，即要求值的表达式。\n\u0026gt; (new-cafe (lambda (x) x)) \u0026gt;\u0026gt; 3 3 \u0026gt;\u0026gt; (a . (b . (c . ()))) (a b c) \u0026gt; (define sum (lambda (ls) (if (null? ls) 0 (+ (car ls) (sum (cdr ls)))))) \u0026gt; (new-cafe sum) \u0026gt;\u0026gt; (1 2 3) 6  时间和日期 时间由时间对象表示。 时间对象记录特定时间或持续时间的纳秒和秒，以及标识时间对象性质的time type 。 时间类型是以下符号之一：\ntime-utc: 从“纪元”1970年1月1日0点0分0秒以来的时间\ntime-monotonic: 从过去某个任意时间点开始经过的时间，理想情况下无需进行调整。\ntime-duration: 两个时间的间隔。当作为current-time的参数时，其行为与time-monotonic类似，但也可以用来表示两个时间对象相减的结果\ntime-process: 当前进程使用的CPU时间量。\ntime-thread: 当前线程使用的CPU时间量。 如果未运行线程，或者系统不允许确定单个线程时间，则该时间与time-process相同。\ntime-collector-cpu: 当前进程用于垃圾回收的这部分CPU消耗的时间。\ntime-collector-real: 当前进程用于垃圾回收的这部分实时消耗的时间\n日期由日期对象表示。 日期对象记录特定日期的纳秒，秒，分钟，小时，日，月和年，以及标识时区的偏移量。\n (current-time) | (current-time time-type)\n time-type 必须是上述的时间对象之一，默认为time-utc\n(current-time) ⇒ #\u0026lt;time-utc 1198815722.473668000\u0026gt; (current-time ’time-process) ⇒ #\u0026lt;time-process 0.120534264\u0026gt;   (make-time type nsec sec)\n type 必须是上面列出的时间类型符号之一。 nsec 表示纳秒，并且必须是小于$10^9$的精确非负整数。sec 表示秒，并且必须是精确的整数。\n(make-time 'time-utc 787511000 1198783214) (make-time 'time-duration 10 5) (make-time 'time-duration 10 -5)   (time? obj)\n(time? (current-time)) ⇒ #t (time? (make-time ’time-utc 0 0)) ⇒ #t (time? \u0026quot;1400 hours\u0026quot;) ⇒ #f  (time-type time)\n 返回time 的时间类型\n (time-nanosecond time)\n 返回time 的纳秒\n (time-second time)\n 返回time 的秒\n (set-time-type! time type) | (set-time-nanosecond! time nsec) | (set-time-second! time sec)\n 每一个过程都会修改时间对象，只改变局部，而其他值则不受影响。 例如，set-time-nanosecond! 只更改纳秒时间，而不更改秒或类型。 特别地，当时间对象的类型改变时，值并不会更改。\n (time=? time1 time2) | (time\u0026lt;? time1 time2) | (time\u0026gt;? time1 time2) | (time\u0026lt;=? time1 time2) | (time\u0026gt;=? time1 time2)\n 时间比较。\n (copy-time time)\n 复制时间。\n(define t1 (current-time)) (define t2 (copy-time t1)) (eq? t2 t1) ⇒ #f (eqv? (time-second t2) (time-second t1)) ⇒ #t (eqv? (time-nanosecond t2) (time-nanosecond t1)) ⇒ #t   (time-difference time1 time2 ) | (time-difference! time1 time2 ) | (add-duration time timed) | (add-duration! time timed) | (subtract-duration time timed) | (subtract-duration! time timed)\n 对于time-difference，time1和time2必须具有相同的时间类型，结果是时间类型为time-duration的时间对象。 对于add-duration，add-duration！，subtract-duration和subtract-duration！，timed必须具有时间类型time-duration，并且结果是时间类型与时间相同的时间对象。 time-difference！，add-duration！和subtract-duration！ 可能具有破坏性，即每个对象都可能修改并返回其第一个参数，或者可能分配了新的时间对象\n(let ([delay (make-time 'time-duration 0 1)]) (let ([t1 (current-time 'time-monotonic)]) (sleep delay) (let ([t2 (current-time 'time-monotonic)]) (let ([t3 (time-difference t2 t1)]) (and (eq? (time-type t3) 'time-duration) (time\u0026gt;=? t3 delay) (time=? (add-duration t1 t3) t2) (time=? (subtract-duration t2 t3) t1)))))) ⇒ #t   (current-date) | (current-date offset)\n 如上所述，offset 表示UTC以东的时区偏移量（以秒为单位）。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 可以通过传递零偏移量来获得UTC.offset表示UTC以东以秒为单位的时区偏移量，如上所述。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 UTC可以通过传递零偏移来获得。\n如果未提供offset ，则使用当前时区的offset，以及date-dst？ 和date-zone-name报告有关时区的信息。 如果提供了偏移量，那么date-dst？ 和结果日期对象上的date-zone-name都是#f。\n(current-date) ⇒ #\u0026lt;date Thu Dec 27 23:23:20 2007\u0026gt; (current-date 0) ⇒ #\u0026lt;date Fri Dec 28 04:23:20 2007\u0026gt; (date-zone-name (current-date)) ⇒ \u0026quot;EST\u0026quot; or other system-provided string (date-zone-name (current-date 0)) ⇒ #f   (make-date nsec sec min hour day mon year) | (make-date nsec sec min hour day mon year offset)\n nsec代表纳秒，并且必须是小于$10^9$的精确非负整数。sec代表秒，并且必须是小于62的精确非负整数。min代表分钟，并且必须是小于60的精确非负整数。hour必须是精确的非负整数 小于24。day必须是一个精确的整数，1≤day≤31。（实际上限可能取决于月份和年份。）mon表示月份必须是一个精确的整数，1≤mon≤12。年必须 是一个精确的整数。 如上所述，它应至少为1970。offset表示UTC以东的时区偏移（以秒为单位）。 它必须是-86400到+86400（含）范围内的精确整数。 可以通过传递零偏移量来指定UTC。\n(make-date 0 0 0 0 1 1 1970 0) ⇒ #\u0026lt;date Thu Jan 1 00:00:00 1970\u0026gt; (make-date 0 30 7 9 23 9 2007 -14400) ⇒ #\u0026lt;date Sun Sep 23 09:07:30 2007\u0026gt; (date-zone-name (make-date 0 30 7 9 23 9 2007 -14400)) ⇒ #f (string? (date-zone-name (make-date 0 30 7 9 23 9 2007))) ⇒ #t   (date-nanosecond date) | (date-second date) | (date-minute date) | (date-hour date) | (date-day date) | (date-month date) | (date-year date) | (date-zone-offset date)\n 如字面的意思， 返回日期的对应的部分的值\n (date-week-day date) | (date-year-day date)\n 通过这些过程，可以确定以date 表示的日期是星期几还是每年的某天。 week-day是小于7的精确非负整数，其中0表示星期日，1表示星期一，依此类推。 year-day是小于367的精确非负整数，其中0代表一年的第一天（1月1日），1代表第二天，2代表第三天，依此类推。\n (time-utc-\u0026gt;date time) | (time-utc-\u0026gt;date time offset) | (date-\u0026gt;time-utc date)\n 这些过程用于在时间和日期对象之间进行转换。 time-utc-\u0026gt;date的时间参数必须具有time-type utc，date-\u0026gt;time-utc始终返回带有time-type utc的时间对象。\n对于time-utc-\u0026gt;date，offset 表示UTC以东的秒数中的时区偏移，如本节开头所述。 它必须是一个介于-86400到+86400（含）之间的精确整数，并且默认为本地时区偏移量。 UTC可以通过传递零偏移来获得。\n (date-and-time) | (date-and-time date)\n 字符串始终采用以下示例所示的格式，长度始终为24。\n(date-and-time) ⇒ \u0026quot;Fri Jul 13 13:13:13 2001\u0026quot; (defined (make-date 0 0 0 0 1 1 2007 0)) (date-and-time d) ⇒ \u0026quot;Mon Jan 01 00:00:00 2007\u0026quot;   (sleep time)\n time 必须是类型为time-duration的时间对象。 sleep 导致调用线程在大约由时间对象指示的时间量内暂停操作，除非该进程收到中断睡眠操作的信号。 实际睡眠时间取决于系统时钟的粒度以及系统运行其他线程和进程的繁忙程度。\n时间和统计  (time expr) time求值expr ，并且作为副作用，打印（到console-output端口）cpu时间量，实时时间量，分配的字节数以及与求值expr 相关的收集开销。\n\u0026gt; (time (collect)) (time (collect)) 1 collection 1 ms elapsed cpu time, including 1 ms collecting 1 ms elapsed real time, including 1 ms collecting 160 bytes allocated, including 8184 bytes reclaimed  (cpu-time)\n 返回：自系统启动以来消耗的cpu时间量。\n该量以毫秒为单位。 该数量包括“system”时间和“user”时间，即代表进程在内核中花费的时间以及在进程本身中花费的时间。\n (real-time)\n 返回：自系统启动以来经过的实时时间\n以毫秒为单位的时间总量\n (bytes-allocated) | (bytes-allocated g)\n 返回：当前分配的字节数\n如果提供了g ，则bytes-allocated返回指定generation中当前为Scheme对象分配的字节数。 g 必须为非负精确整数，且不得大于最大非静态generation，即，collect-maximum-generation返回的值或符号为static。 如果未提供g ，则bytes-allocated返回所有generation中分配的字节总数。\n (initial-bytes-allocated)\n 返回：加载启动文件后分配的总字节数\n (bytes-deallocated)\n 返回：垃圾回收器释放的总字节数\n通过将（bytes-deallocated）和（bytes-allocated）相加并减去（initial-bytes-allocated），可以获得当前进程分配的总字节数（无论是否仍在使用中）。\n (current-memory-bytes)\n 返回：当前分配的字节总数，包括开销.\ncurrent-memory-bytes返回堆的总大小（以字节为单位），不仅包括Scheme对象占用的字节，还包括各种形式的开销（包括碎片和保留但当前不占用的内存），因此，它是操作系统中当前进程的堆内存量的准确度量值\n (maximum-memory-bytes)\n 返回：分配过的最大字节数，包括开销\n (reset-maximum-memory-bytes!)\n 将堆内存的最大记录值重置为当前堆大小\n (collections)\n 返回：到目前为止的垃圾回收次数\n (statistics)\n 返回：包含当前统计信息的sstats记录\nstatistics将各种时间和分配统计信息打包在一起，形成一个sstats记录。 sstats记录具有以下字段：\n         cpu, 消耗的cpu时间   real, 经过的时间   bytes, 分配的字节数   gc-count, gc次数   gc-real, gc经历的时间   gc-bytes, gc回收的字节数    所有值都是从系统启动开始算\nstatistics可以像如下定义：\n(define statistics (lambda () (make-sstats (current-time ’time-thread) (current-time ’time-monotonic) (- (+ (bytes-allocated) (bytes-deallocated)) (initial-bytes-allocated)) (collections) (current-time ’time-collector-cpu) (current-time ’time-collector-real) (bytes-deallocated))))   (make-sstats cpu real bytes gc-count gc-cpu gc-real gc-bytes) 返回：sstats记录\n(sstats-cpu s) | (sstats-real s) | (sstats-bytes s) | (sstats-gc-count s) | (sstats-gc-cpu s) | (sstats-gc-real s) | (sstats-gc-bytes s)\n 返回：s 对应的部分的值\n (set-sstats-cpu! s new-value) | (set-sstats-real! s new-value) | (set-sstats-bytes! s new-value) | (set-sstats-gc-count! s new-value) | (set-sstats-gc-cpu! s new-value) | (set-sstats-gc-real! s new-value) | (set-sstats-gc-bytes! s new-value)\n 设置对应部分的值\n (sstats-difference s1 s2)\n 比较两个sstats\n enable-object-counts\n enable-object-counts的值是一个布尔值，它确定收集器在运行时是否记录对象计数，从而确定过程对象计数返回的object-counts是否准确。 由于启用对象计数会增加收集的开销，因此默认情况下该参数设置为#f。\n (object-counts)\n 过程object-countsx返回一个嵌套的关联列表，该列表表示为一个或多个世代中至少有一个活动实例的每个堆分配的原始类型和记录类型分配的对象计数和字节。 （堆分配的基本类型包括，例如，pair和向量，但不包括，例如，fixnum或字符。）仅当enable-object-countsxx为#t时，收集器才会收集对象计数。\nobject-countsx返回的关联列表具有以下结构： ((type (generation count . bytes) \u0026hellip;) \u0026hellip;)\n*type*是原始类型的名称，以符号（例如，对）表示，或者是record-type描述符（rtd）。 generation是介于0和（collect-maximum-generation）的值（包含在内）或表示静态生成的符号static之间的非负固定编号。 *count*和字节是非负的fixnum。\n(collect-request-handler void) (enable-object-counts #t) (define-record-type frob (fields x)) (define x (make-frob (make-frob #f))) (collect 3 3) (cdr (assoc 3 (cdr (assoc (record-type-descriptor frob) (object-counts))))) =\u0026gt; (2. 16)  成本中心 Cost Centers 成本中心用于在求值选定的代码段时跟踪分配的字节，执行的指令和/或经过的CPU时间。 成本中心是通过过程make-cost-center创建的，而成本是通过with-cost-center过程进行跟踪的。\n仅为此目的代码跟踪分配和指令计数。 该工具由两个参数控制：generate-allocation-counts和generate-instruction-counts。 默认情况下禁用检测。 内置程序没有检测，解释代码或非Scheme代码也没有。 仅当过程with-cost-center的可选参数*timed?*有值且不为false时才会跟踪经历的时间\nwith-cost-center过程即使在使用同一成本中心重新输入，在多个线程中同时使用并通过继续调用退出或重新输入一次或多次后，也要遵循上述注意事项来准确跟踪成本。\n generate-allocation-counts\n 当此参数为true时，编译器会在生成的代码的每个分配点插入一小段指令，以跟踪发生的分配量。此参数最初为false。\n generate-instruction-counts\n 当此参数为true时，编译器将在生成的代码的每个块中插入简短的指令序列，以跟踪该块执行的指令数。 此参数最初为false。\n (make-cost-center)\n 返回: 新的成本中心\n (with-cost-center cost-center thunk) | (with-cost-center timed? cost-center thunk)\n thunk 必须是一个接受零参数的过程。 with-cost-center调用不带参数的thunk 并返回其值。 它还可以动态计算分配的字节数，执行的指令以及在计算thunk 调用时所经过的cpu时间，并将跟踪的成本添加到成本中心记录中。\n如上所述，仅对于将参数generate-allocation-counts 设置为true的编译的代码跟踪分配计数，并且仅对将generate-instruction-counts 设置为true的编译的代码跟踪指令计数。 仅在提供timed? 且不为false的情况下，才会跟踪cpu时间，其中包括在已测量的代码，未测量代码和非Scheme代码中花费的cpu时间。\n (cost-center-instruction-count cost-center)\n 返回：成本中心跟踪的指令数\n (cost-center-allocation-count cost-center)\n 返回：成本中心跟踪的已分配字节数\n (cost-center-time cost-center)\n 返回：成本中心跟踪的CPU时间\n (reset-cost-center! cost-center)\n 此过程将成本中心记录的成本重置为零。\n参数 本节介绍了用于创建和操作参数的机制。 可以使用make-parameter方便地创建新参数。 但是，除了它们的行为外，没有什么能将参数与其他过程区分开。 如果调用参数时必须采取比通过make-parameter机制容易容纳的更为复杂的动作，则可以直接使用case-lambda定义该参数\n (make-parameter object) | (make-parameter object procudure)\n make-parameter接受一个或两个参数。 第一个参数是内部变量的初始值，第二个参数（如果存在）是应用于初始值和所有后续值的过滤器。 过滤器应接受一个参数。 如果该值不合适，则过滤器应引发异常或将值转换为更合适的形式。\n例如，print-length的默认定义如下：\n(define print-length (make-parameter #f (lambda (x) (unless (or (not x) (and (fixnum? x) (fx\u0026gt;= x 0))) (assertion-violationf ’print-length \u0026quot;~s is not a positive fixnum or #f\u0026quot; x)) x))) (print-length) ⇒ #f (print-length 3) (print-length) ⇒ 3 (format\u0026quot;~s\u0026quot;’(123456)) ⇒ \u0026quot;(123...)\u0026quot; (print-length #f) (format\u0026quot;~s\u0026quot;’(123456)) ⇒ \u0026quot;(123456)\u0026quot;  make-parameter的定义使用case-lambda很简单：\n(define make-parameter (case-lambda [(init guard) (let ([v (guard init)]) (case-lambda [() v] [(u) (set! v (guard u))]))] [(init) (make-parameter init (lambda (x) x))]))   (parameterize ((param expr) \u0026hellip;) body1 body2 \u0026hellip;)\n 使用语法形式parameterize，可以以类似于普通变量的fluid-let的方式更改参数的值。 在计算body时，将每个param 设置为相应的expr 的值。\n(define test (make-parameter 0)) (test) ⇒ 0 (test 1) (test) ⇒ 1 (parameterize ([test 2]) (test)) ⇒ 2 (test) ⇒ 1 (parameterize ([test 2]) (test 3) (test)) ⇒ 3 (test) ⇒ 1 (define k (lambda (x) x)) (begin (set! k (call/cc k)) ’k) ⇒ k (parameterize ([test 2]) (test (call/cc k)) (test)) ⇒ k (test) ⇒ 1 (k3) ⇒3 (test) ⇒ 1  虚拟寄存器Virtual registers 编译器支持一组有限的虚拟寄存器 ，以供需要高速，全局和可变存储位置的程序使用。 引用或分配虚拟寄存器可能比访问可分配的局部变量或全局变量更快，并且访问时永远不会比它们更慢，而且这样做的代码序列通常更小。 分配可能会显著加快，因为不需要跟踪从虚拟寄存器到年轻对象的指针，因为可能存在于较早一世代中的可变位置。 在系统的线程版本上，虚拟寄存器是“每个线程”的，因此可以以比线程参数低廉的方式用作thread-local存储。\n该接口包含三个过程：virtual-register-count（返回虚拟寄存器的数量），set-virtual-register!（设置指定的虚拟寄存器的值）和virtual-register（获取指定虚拟寄存器的值）。\n虚拟寄存器由小于虚拟寄存器数量的非负fixnum索引指定。 为了获得set-virtual-register!和virtual-register的最佳性能，索引应该是直接嵌入在调用中的常量（或者可以通过对调用的优化来传播）。 为了避免将这些常量放在源代码中，程序员应考虑使用标识符宏为虚拟寄存器命名，例如：\n(define-syntax current-state (identifier-syntax [id (virtual-register 0)] [(set! id e) (set-virtual-register! 0 e)])) (set! current-state 'start) current-state ⇒ start  虚拟寄存器必须被视为应用程序级资源，即，打算由多个应用程序使用的库通常不应使用虚拟寄存器，以避免与应用程序使用寄存器冲突。\n (virtual-register-count)\n 从9.0版开始，虚拟寄存器的数量设置为16。除非通过源重新编译Chez Scheme，否则无法更改。\n (set-virtual-register! k x)\n set-virtual-register!将x 存储在虚拟寄存器k 中。 k 必须是小于（virtual-register-count）的值的非负fixnum。\n (virtual-register k)\n virtual-register返回最后一次存储在虚拟寄存器k 中的值（在当前线程上）。\n环境查询和设置Environmental Queries and Settings  (scheme-version)\n Chez Scheme的版本\n (threaded?)\n 返回：#t（如果在系统为线程版本），否则返回#f\n (get-process-id)\n 返回：当前进程的PID\n (getenv key)\n 返回：环境中key 的值，或 #f\n(getenv \u0026quot;HOME\u0026quot;) ⇒ \u0026quot;/u/freddy\u0026quot;   (putenv key value)\n key 和 value 必须是字符串\n(putenv \u0026quot;SCHEME\u0026quot; \u0026quot;rocks!\u0026quot;) (getenv \u0026quot;SCHEME\u0026quot;) ⇒ \u0026quot;rocks!\u0026quot;   (get-registry key)\n 返回：key 的注册表值，或者#f\n (put-registry! key val) | (remove-registry! key)\n key 和 value 必须是字符串\n","id":20,"section":"posts","summary":"异常 (warning who msg irritant \u0026hellip;) 返回：未指定 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止","tags":["scheme"],"title":"系统操作(System Operations in Chez Scheme)","uri":"https://lvsq.net/2020/02/system-operations/","year":"2020"},{"content":" define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回true的谓词、以及每个字段的访问procedure和针对可变字段的赋值procedure。总的来说，与Java中的POJO类比较相似，不过不用自定义getter和setter方法，这与Kotlin倒为类似，例如：\n(define-record-type point (fields x y))  创建了一个名为point的record类型，并且有两个字段x和y，和如下几个定义式（自动生成）：\n| \u0026mdash; | \u0026mdash; (make-point x y) | 构造函数 (point? obj) | 谓词 (point-x p) | 字段x的访问器 (point-y p) | 字段y的访问器\n默认下，字段是不可变的，但是可以声明为可变的（mutable）。如下定义point中，字段x是可变的，但y维持不变：\n(define-record-type point (fields (mutable x) y))  当然亦可显式地将字段声明为不可变的：\n(define-record-type point (fields (mutable x) (immutable y)))  在这个例子中，define-record-type除了生成了上述的几个定义式之外，还为字段x增加了一个赋值过程：\n(point-x-set! p x)\n该赋值过程可以用于改变x的内容\n(define p (make-point 36 -17)) (point-x-set! p (- (point-x p) 12)) (point-x p) =\u0026gt; 24  自动生成的几个定义式是允许改变名称的，下面的point定义式，其构造函数名为mkpoint, 谓词为ispoint?，x和y的访问器分别为x-val和y-val, x的赋值器为set-x-val!\n(define-record-type (point mkpoint ispoint?) (fields (mutable x x-val set-x-val!) (immutable y y-val)))  默认情况下，每次一个record definition创建一个新类型（为方便理解，可以用Java来解释，即对于同一个POJO类new出两个实例，但这两个实例并不能equal），如下所示：\n(define (f p) (define-record-type point (fields x y)) (if (eq? p 'make) (make-point 3 4) (point? p))) (f (f 'make)) =\u0026gt; #f  第一个f的调用即(f \u0026lsquo;make)返回一个point类型的p，将p传递给第二个f，但p是由第一个调用生成的类型，所以point?返回#f。按照SICP的说法，这两个define-record-type并不在一个环境中，只是名字一样而已。\n默认的生产行为(generative behavior)或许可以由记录定义式中的nongenerative子句来重载：\n(define (f p) (define-record-type point (fields x y) (nongenerative)) (if (eq? p 'make) (make-point 3 4) (point? p))) (f (f 'make)) =\u0026gt; #t  以这种方式创建的记录类型仍然不同于由定义出现在程序的不同部分中创建的记录类型，即使这些定义在语法上是相同的：\n(define (f) (define-record-type point (fields x y) (nongenerative)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative)) (point? p)) (g (f)) =\u0026gt; #f  甚至可以通过在nongenerative子句中包含uid（唯一id）来覆盖它：\n(define (f) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (make-point 3 4)) (define (g p) (define-record-type point (fields x y) (nongenerative really-the-same-point)) (point? p)) (g (f)) =\u0026gt; #t  记录类型可以定义为有parent子句的子类型，即一个记录类型可以声明为某一个记录类型的子类型，如果指定了父类型，则子类型将继承父类型所有字段，且子类型的每个实例都被视为父类型的实例，因此可以直接使用父类型的访问器和字段等等。\n(define-record-type point (fields x y)) (define-record-type cpoint (parent point) (fields color)) (define cp (make-cpoint 3 4 'red)) (point? (make-cpoint 3 4 'red)) =\u0026gt; #t (cpoint? (make-point 3 4)) =\u0026gt; #f (define cp (make-cpoint 3 4 'red)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (cpoint-color cp) =\u0026gt; red  到目前为止，define-record-type定义的默认构造函数接受record包含的字段一样多的参数，其实我们可以重写默认值，这里需要引入protocol子句，以下定义将创建一个具有三个字段的点记录：x，y和d，其中d表示距原点的位移。构造函数仍然只接受两个参数，即x和y值，并将d初始化为x和y平方和的平方根。\n(define-record-type point (fields x y d) (protocol (lambda (new) (lambda (x y) (new x y (sqrt (+ (* x x) (* y y)))))))) (define p (make-point 3 4)) (point-x p) =\u0026gt; 3 (point-y p) =\u0026gt; 4 (point-d p) =\u0026gt; 5  另外，子类型的构造函数中的参数顺序是不可改变的，即先是父类型构造函数的字段，然后才是子类型的参数，如果需要改变子类型的构造函数的参数顺序该如何呢？\n(define-record-type cpoint (parent point) (fields color) (protocol (lambda (pargs-\u0026gt;new) (lambda (x c y) ((pargs-\u0026gt;new x y) c))))) (define cp (make-cpoint 3 'red 4)) (point-x cp) =\u0026gt; 3 (point-y cp) =\u0026gt; 4 (point-d cp) =\u0026gt; 5 (cpoint-color cp) =\u0026gt; red  最后来看看define-record-type的语法形式：\n syntax: (define-record-type record-name clause \u0026hellip;)\nsyntax: (define-record-type (record-name constructor pred) clause \u0026hellip;)\n Fields clause语法形式:\n (fields field-spec \u0026hellip;)\n field-spec必须是下面5个中的一个:\n field-name (immmutable field-name) (mutable field-name) (immmutable field-name accessor-name) (mutable field-name accessor-name mutator-name)  define-record in Chez Scheme Chez Scheme依然支持$R^6RS$中传统的record类型的定义，另外还提供一个新的语法，即define-record，其语法形式与define-record-type一样，所不同的地方在于，define-record中的字段默认是可变的，这与$R^6RS$中的record相反，因此，创建一个记录类型时，同时会定义下列过程：\n(define-record point (x y)) (make-point x y) ;;\tconstructor (point? obj) ;;\tpredicate (point-x p) ;;\taccessor for field x (point-y p) ;;\taccessor for field y (set-point-x! p obj) ;;\tmutator for field x (set-point-y! p obj) ;;\tmutator for field y  通过对define-record-type的了解，可以发现其非常OO，smalltalk是否受其影响不得而知，至少经过纵向比较对于我们学习技术大有裨益。\n","id":21,"section":"posts","summary":"define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回tr","tags":["scheme"],"title":"Scheme语法define-record-type介绍","uri":"https://lvsq.net/2020/02/define-record-type/","year":"2020"},{"content":" Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以在 Chez Scheme 中以“微模块”级别使用，因为 Chez Scheme 中的模块和 import 形式属于定义，并且可以出现在定义可以出现的任意位置，包括在 lambda 表达式的程序体或其他局部作用域中。\n 微模块与函数孰好？？？还是视情况而定？？？\n 模块控制绑定的可见性，可以用作扩展词法作用域，以允许更精确地控制绑定的可见范围。模块导出标识符的绑定，即变量绑定、关键字绑定或模块名绑定。模块可以是具名的抑或匿名的。只要模块名可见，那么在具名模块出现处导入的绑定都可见。匿名模块中导出的绑定，在模块出现的地方被隐式地导入。匿名模块可用于隐藏一组绑定中的一些绑定，同时允许其余绑定可见。\n语法  (module name interface defn \u0026hellip; init \u0026hellip;)\n(module interface defn \u0026hellip; init \u0026hellip;)\n name 是标识符，defn \u0026hellip; 是定义，init \u0026hellip; 是表达式。interface 是形如 (export \u0026hellip;) 的导出表，其中每个 export 都是标识符 identifier 抑或形式 (identifier export \u0026hellip;)。\n模块由一组（可能为空的）定义和一组（可能为空的）初始化表达式序列组成。模块中定义的标识符（可理解为变量或者状态，下同）在模块的程序体中可见，被导出的标识符在模块的导入作用域内亦可见。模块接口中列出的每个标识符必须在该模块中定义或被导入该到模块。module 形式是一种定义，因此可以出现在其他定义可以出现的任何位置，包括嵌套在 lambda 表达式的程序体、 library 形式、顶层程序，以及嵌套在其他模块中。此外，因为模块名的作用域与其他标识符相同，所以模块和库可以像变量和关键字那样导出模块名。\n模块名与其他标识符占用相同的名字空间，并遵循相同的作用域规则。除非被导出，否则模块中定义的标识符仅在该模块中可见。\n模块内的表达式可以引用在模块外部绑定的标识符。\n(let ([x 3]) (module m (plusx) (define plusx (lambda (y) (+ x y)))) (import m) (let ([x 4]) (plusx 5))) ; =\u0026gt; 8,注意不是9哦，可以将plusx视为：(define plusx (lambda (y) (+ 3 y))))  同样，import不会阻止访问出现导入表单的可见标识符，但import标识符所覆盖的变量除外（啥叫覆盖，看下面两段代码）。\n(module m (y) (define y 'm-y)) (let ([x 'local-x] [y 'local-y]) (import m) (list x y)) ; =\u0026gt; (local-x m-y)  模块m中定义了标识符y, 在其被import之后会覆盖let中的y；\n(module m (y) (define y 'm-y)) (let () (import m) (let ([x 'local-x] [y 'local-y]) (list x y)) ; =\u0026gt; (local-x local-y) )  先import m，之后再定义y，模块中定义的y不会覆盖let的y。\n另一方面，在模块中使用 import-only 会建立一个隔离的作用域，其中唯一可见的是被导入模块所导出的标识符，下面的代码中只有y可见。\n对于静态验证，有时不希望使用任何标识符，除了明确导入模块或本地范围的标识符外，这有时是合乎需要的。\n(module m (y) (define y 'm-y)) (let ([x 'local-x] [y 'local-y]) (import-only m) x) ; =\u0026gt; Error: x is not visible  除非通过“import-only”导入的模块导出“import”或“import-only”以及至少一个模块的名称，否则无法在“import-only”范围内进行后续导入。 要创建一个包含多个模块导出的隔离范围而又不使“import”或“import-only”可见，必须以相同的“import-only”形式列出所有要导入的模块。\n另一种解决方案是创建一个包含每个其他模块的导出的模块。\n(module m2 (y) (define y 'y)) (module m1 (x) (define x 'x)) (module mega-module (cons x y) (import m1) (import m2) (import scheme)) (let ([y 3]) (import-only mega-module) (cons x y)) ; =\u0026gt; (x . y)  在它被编译之前，源程序被翻译成不含语法抽象、语法定义、库定义、模块定义以及 import 形式的核心语言程序。翻译由语法展开器负责，语法展开器以递归下降的方式处理源程序中的形式。\nmodule 和 import 特殊形式仅影响标识符(identifier)在源程序中的可见性，而不影响其含义。特别地，无论变量被绑定到在模块内部或外部定义的位置，import 都不会引入新位置。为了保持由模块和语法抽象建立的作用域关系，局部变量在必要时会被重命名。因此，表达式：\n(let ([x 1]) (module m (x setter) (define-syntax x (identifier-syntax z)) (define setter (lambda (x) (set! z x))) (define z 5)) (let ([y x] [z 0]) (import m) (setter 3) (+ x y z))) ; =\u0026gt; 4  等价于下面的表达式，其中标识符被统一地更名，并带上了下标：\n(let ([x0 1]) (define-syntax x1 (identifier-syntax z1)) (define setter1 (lambda (x2) (set! z1 x2))) (define z1 5) (let ([y3 x0] [z3 0]) (setter1 3) (+ x1 y3 z3)))  互递归module (module (a b) (module a (x) (define x (lambda () y))) (module b (y) (define y (lambda () x))) (import a) (import b))  此模式的一般化语法定义如下，允许定义多个互递归的模块\n(define-syntax rec-modules (syntax-rules (module) [(_ (module m (id ...) form ...) ...) (module (m ...) (module m (id ...) form ...) ... (import m) ...)]))  组合module 由于模块可以重新导出所导入的绑定，所以很容易在单个模块上提供多个视图，就像下面的 s 和 t 为 r 提供的视图那样，或者将几个模块组合成一个复合，就像 r 那样。\n(module p (x y) (define x 1) (define y 2)) (module q (y z) (define y 3) (define z 4)) (module r (a b c d) (import* p (a x) (b y)) (import* q (c y) (d z))) (module s (a c) (import r)) (module t (b d) (import r))  import* 稍微解释一下import*, 其语法定义如下：\n(define-syntax import* (syntax-rules () [(_ m) (begin)] [(_ m (new old)) (module (new) (module (tmp) (import m) (alias tmp old)) (alias new tmp))] [(_ m id) (module (id) (import m))] [(_ m spec0 spec1 ...) (begin (import* m spec0) (import* m spec1 ...))]))  它支持重命名import的绑定和选择性导入特定的绑定，无需使用内置的import子形式来选择和重命名标识符，举例来说：\n(let () (import* scheme (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7) (let () (import* (rnrs) (+ cons) (cons +)) (+ (cons 1 2) (cons 3 4))) ⇒ (3 . 7)  元定义Meta Definitions  语法：(meta . definition)\n meta 关键字实际上是一个可以放在任何定义关键字前面的前缀，例如，\n (meta define x 3)\n 它告诉展开器，该定义式产生的任何变量定义都只是展开期定义，只能用于其他元定义的右侧，最主要是用在转换器表达式中。它用于定义展开期辅助函数，以及供一个或多个 syntax-case 转换器所使用的其他信息。\n元定义的语义类似于let*，它可以是自递归，但不是互递归的。\n元定义通过宏展开传播，因此可以编写，例如：\n(module (a) (meta define-record foo (x)) (define-syntax a (let ([q (make-foo #''q)]) (lambda (x) (foo-x q))))) a ；=\u0026gt; q  条件展开Conditional expansion 可以通过 meta-cond 在展开期做出决策，这类似于 cond，但是是在展开期求值并测试表达式，并且可以在预期为定义的上下文中以及在表达式上下文中使用。\n 语法：(meta-cond clause1 clause2 \u0026hellip;)\n 除了最后一个 clause，其余的必须采取以下形式：\n (test expr1 expr2 \u0026hellip;)\n 最后一个 cluase 除可采取上述形式外，还可以使用下面的 else 子句形式：\n (else expr1 expr2 \u0026hellip;)\n 在展开期间，test 表达式会被顺序地求值，直到某条表达式求值为真或者求值完所有的表达式为止。如果一条 test 表达式求值为真，则 meta-cond 形式将展开为包含相应表达式 expr1 expr2 \u0026hellip; 所组成的 begin 形式。如果没有求值为真的 test 表达式，且存在 else 子句，则 meta-cond 形式将展开为由来自于 else 子句的表达式 expr1 expr2 \u0026hellip; 所组成的 begin 形式。否则，meta-cond 表达式展开为对 void 过程的调用。\nmeta-cond 可以按如下定义：\n(define-syntax meta-cond (syntax-rules () [(_ [a0 a1 a2 ...] [b0 b1 b2 ...] ...) (let-syntax ([expr (cond [a0 (identifier-syntax (begin a1 a2 ...))] [b0 (identifier-syntax (begin b1 b2 ...))] ...)]) expr)]))  meta-cond 用于在展开期从一组可能的形式中进行选择。例如，程序员可以定义过程的安全（进行错误检查）和不安全（不进行错误检查）版本，并根据编译期优化级别决定调用版本，如下所示:\n(meta-cond [(= (optimize-level) 3) (unsafe-frob x)] [else (safe-frob x)])  别名Aliases  语法：(alias id1 id2)\n alias 是一类定义，可以出现在其他定义可以出现的任何位置。它用于将绑定从一个标识符转移到另一个标识符。\n(let ([x 3]) (alias y x) (set! y 4) (list x y)) ; =\u0026gt; (4 4)  由于展开是由左至右进行的，别名应该出现在右侧的标识符的定义之后，例如：\n(let () (import-only (chezscheme)) (define y 3) (alias x y) x) ; =\u0026gt; 3  而不是：\n(let () (import-only (chezscheme)) (alias x y) (define y 3) x) ; =\u0026gt; exception: unbound identifier  ","id":22,"section":"posts","summary":"Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以","tags":["modules"],"title":"Chez Scheme Modules","uri":"https://lvsq.net/2020/01/modules/","year":"2020"},{"content":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。\n(define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_ ((a1 v1) (a2 v2) ...) bodys ...) (let ((a1 v1)) (my-let* ((a2 v2) ...) bodys ...)) ) ) )  注意，my-let*是可以递归使用的，以及\u0026hellip;的用法。\n(define-syntax my-let* (syntax-rules () ( (_ () bodys ...) (let () bodys ...) ) ( (_ ((a1 v1) ...) bodys ...) (let () (define a1 v1) ... bodys ... ) ) ) )  这个实现方式与上面的不同，上面的是嵌套let，这里将直接按顺序define内部变量，代码更短。注意此处的\u0026hellip;的用法。\n","id":23,"section":"posts","summary":"实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。 (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_","tags":["scheme"],"title":"自定义 Let*","uri":"https://lvsq.net/2020/01/my-let/","year":"2020"},{"content":" Fluid Keyword Bindings fluid-let-syntax  语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩展期间会暂时更改keyword的现有绑定，而不是引入keyword的新绑定。也就是说，在扩展form1 form2 \u0026hellip;的过程中，每个keyword的可见范围（或顶级）将会临时替换为新的绑定关系。\n (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 2 ) ) )  (let ([f (lambda (x) (+ x 1))]) (let-syntax ([g (syntax-rules () [(_ x) (f x)])]) (fluid-let-syntax ([f (syntax-rules () [(_ x) x])]) (g 1) =\u0026gt; 1 ) ) )  对比上述两段代码，可知：两个表达式基本相同的，除了前者采用内部let-synctax语法，第二个采用fluid-let-syntax语法。在第一个表达式中，(g 1)扩展中的出现的f引用的是let-bound的变量f，而第二个表达式，f引用的是由fluid-let-syntax绑定的f\n","id":24,"section":"posts","summary":"Fluid Keyword Bindings fluid-let-syntax 语法: fluid-let-syntax ((keyword expr) \u0026hellip;) form1 form2 \u0026hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩","tags":["module","syntactic"],"title":"Syntactic Extension and Modules in Chez Scheme","uri":"https://lvsq.net/2020/01/syntactic-extension-and-modules/","year":"2020"},{"content":" Chez Scheme中有一种Boxes结构，它是一个*单元素*对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构可以共享指向一个对象的引用，或指针。例如，在采用此种参数传递规则的语言的解释器中，可以用 boxes 实现 call-by-reference 的语义。解释有点绕，按我的理解boxes就相当于Golang的struct、Java中的类，将一些状态包装成一个整块，外界通过引用该整块的指针来访问内部的各个状态。\nBoxes 的字面形式带有前缀 #\u0026amp; (发音为 “hash-ampersand”). 例如， #\u0026amp;(a b c) 是一个 box，内容为列表 (a b c). 读取器若遇到 #!r6rs ，则会在其后的输入流中禁用 box 语法，除非在更近的位置遇到 #!chezscheme.\n所有 boxes 默认是可变的，包括常量。程序可以通过 box-immutable 创建不可变 boxes. 尝试修改不可变 box 会导致抛出异常。\n我们来看看一些用法：\n(box? obj) 如果 obj 是 box, 则为 #t, 否则为 #f.\n(box? '#\u0026amp;a) =\u0026gt; #t (box? 'a) =\u0026gt; #f (box? (box 3)) =\u0026gt; #t  (box obj) 创建一个由obj组成的box\n(box 'a) =\u0026gt; #\u0026amp;a (box (box '(a b c))) =\u0026gt; #\u0026amp;#\u0026amp;(a b c)  (unbox box) 返回box的内容\n(unbox #\u0026amp;a) =\u0026gt; a (unbox #\u0026amp;#\u0026amp;(a b c)) =\u0026gt; #\u0026amp;(a b c) (let ([b (box \u0026quot;hi\u0026quot;)]) (unbox b)) =\u0026gt; \u0026quot;hi\u0026quot;  (set-box! box obj) box 必须是可变的。 set-box! 把 box 的内容设置为 obj.\n(let ([b (box 'x)]) (set-box! b 'y) b) =\u0026gt; #\u0026amp;y (let ([incr! (lambda (x) (set-box! x (+ (unbox x) 1)))]) (let ([b (box 3)]) (incr! b) (unbox b))) =\u0026gt; 4  (box-cas! box old-obj new-obj) 如果 box 被改变，则为 #t, 否则为 #f.\nbox 必须是可变的。 若 box 待替换的内容和 old-obj 相同(基于 eq?), 则 box-cas! 自动将 box 的内容替换为 new-obj; 若不相同，则 box 保持不变。即CAS操作，原子的。\n(define b (box 'old)) (box-cas! b 'old 'new) =\u0026gt; #t (unbox b) =\u0026gt; 'new (box-cas! b 'other 'wrong) =\u0026gt; #f (unbox b) =\u0026gt; 'new  (mutable-box? obj) 如果 obj 是可变的 box ，则为 #t, 否则为 #f.\n(immutable-box? obj) 如果 obj 是不可变的 box ，则为 #t, 否则为 #f.\n(box-immutable obj) 返回一个内容为obj的不可变的box。Boxes 通常用来支持共享的，可变的结构，所以不可变的 box 一般没什么用。\n","id":25,"section":"posts","summary":"Chez Scheme中有一种Boxes结构，它是一个*单元素*对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据","tags":["scheme"],"title":"Chez Scheme中Boxes介绍","uri":"https://lvsq.net/2020/01/boxes-in-chez/","year":"2020"},{"content":" Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x)))\n(atom? '(a b c)) ⇒ #f (atom? '(3 . 4)) ⇒ #f (atom? '()) ⇒ #t (atom? 3) ⇒ #t  list-head(Chez) 用法：(list-head list n) *n*是一个非负整数，且小于等于*list*的长度；list-head和Scheme标准过程list-tail可能会同时使用来切割一个list，不同点在于，list-tail不会分配内存而只是返回源list的一个子列表，list-head总是返回源list前n个元素的副本\n(list-head '(a b c) 0) ⇒ () (list-head '(a b c) 2) ⇒ (a b) (list-head '(a b c) 3) ⇒ (a b c) (list-head '(a b c . d) 2) ⇒ (a b) (list-head '(a b c . d) 3) ⇒ (a b c) (list-head '#1=(a . #1#) 5) ⇒ (a a a a a)  last-pair(Chez) 用法：(last-pair list) 列表不能为空。 last-pair返回列表的最后一对（pair）（不是最后一个元素）, list可能是不正确的列表，在这种情况下，最后一对是包含最后一个元素和终止对象的一个pair。\n(last-pair '(a b c d)) ⇒ (d) (last-pair '(a b c.d)) ⇒ (c . d)  list-copy(Chez) 用法： (list-copy list) 返回一个list的副本，equal?（结构和值相同）判断为#t\nlist*(Chez) 用法：(list* obj \u0026hellip; final-obj)\n返回一个由obj \u0026hellip; final-obj 组成的list, 与R6RS的cons*相同\nmake-list(Chez) 用法： (make-list n) 或者 (make-list n obj)\n返回n个对象的列表。n是一个正整数， 如果obj不指定，则返回的list是不确定的\n(make-list 0 '()) =\u0026gt; () (make-list 3 0) =\u0026gt; (0 0 0) (make-list 2 \u0026quot;hi\u0026quot;) =\u0026gt; (\u0026quot;hi\u0026quot; \u0026quot;hi\u0026quot;)  iota(Chez) 用法：(iota n)\n返回从 0（包含）到 n（不包含）的整数列表，n须为精确的非负整数\n(iota 0) =\u0026gt; () (iota 5) =\u0026gt; (0 1 2 3 4)  enumerate(Chez) 用法： (enumerate ls)\n返回: 从 0（包含）到长度 ls（不包含）的整数列表\n(enumerate '()) =\u0026gt; () (enumerate '(a b c)) =\u0026gt; (0 1 2) (let ([ls '(a b c)]) (map cons ls (enumerate ls))) =\u0026gt; ((a . 0) (b . 1) (c . 2))  remq! | remv! | remove!(Chez) 用法： (remq! obj list) | (remv! obj list) | (remove! obj list)\n返回: 列表中所有 obj 都被移除后的列表\n这些过程与 R6RS 中的 remq, remv, 及 remove 过程类似，只是 remq!, remv! 和 remove! 使用输入列表中的pair来构成输出列表。它们进行较少的空间分配，但并不一定比它们非破坏性的相应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(remq! 'a '(a b a c a d)) ⇒ (b c d) (remv! #\\a '(#\\a #\\b #\\c)) =\u0026gt; (#\\b #\\c) (remove! '(c) '((a) (b) (c))) =\u0026gt; ((a) (b))  substq | substv | subst | substq! | substv! | subst!(Chez) 用法： (subs* new old tree)\n返回：在tree中将匹配到的old元素全部替换为new之后的tree.\n对于 substq 和 substq! ，相等性测试是基于 eq?, substv 和 substv! 是基于 eqv?, 而 subst 和 subst! 是基于 equal? substq!, substv!, 和 subst! 执行破坏性的替换。它们进行较少的空间分配，但并不一定比它们非破坏性的对应版本更快。如果滥用，很容易导致混乱或错误的结果。\n(substq 'a 'b '((b c) b a)) =\u0026gt; ((a c) a a) (substv 2 1 '((1 . 2) (1 . 4) . 1)) =\u0026gt; ((2 . 2) (2 . 4) . 2) (subst 'a '(a . b) '((a . b) (c a . b) . c)) =\u0026gt; (a (c . a) . c) (let ([tr '((b c) b a)]) (substq! 'a 'b tr) tr) =\u0026gt; ((a c) a a)  reverse! 用法：(reverse! list)\n返回：将原list反向输出\nreverse! 通过反转其链接破坏性地反向排序列表。以 reverse! 取代 reverse 减少了空间分配，但并不一定比使用 reverse 更快。如果滥用，会很容易导致混乱或错误的结果。\n(reverse! '()) =\u0026gt; () (reverse! '(a b c)) =\u0026gt; (c b a) (let ([x '(a b c)]) (reverse! x) x) =\u0026gt; (a) (let ([x '(a b c)]) (set! x (reverse! x)) x) =\u0026gt; (c b a)  append! 用法：(append! list \u0026hellip;)\n返回：将所有输入list串联起来的列表\n如同 append, append! 返回一个新的列表，其中元素依次为第一个列表中的元素，第二个列表中的元素，第三个列表中的元素，等等。不同之处在于， append! 重用所有参数中的点对以构造新列表。即，每一个列表参数的最后一个cdr, 其后一元素变为指向下一个列表参数。除最后一个参数外，如果任一参数为空列表，它实质上会被忽略。最后一个参数（并不一定得是列表）是不变的。\n相比于 append, append! 进行更少的空间分配（因为只修改指针，并没有数据拷贝），但并不一定更快。如果滥用，会很容易导致混乱或错误的结果。\n(append! '(a b) '(c d)) =\u0026gt; (a b c d) (let ([x '(a b)]) (append! x '(c d)) x) =\u0026gt; (a b c d) (append '(1 2 (3 4)) '(5 6)) =\u0026gt; (1 2 (3 4) 5 6) (append '(1 2 (3 4)) '() '(5 6)) =\u0026gt; (1 2 (3 4) 5 6)  ","id":26,"section":"posts","summary":"Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x))) (atom? '(a b c)) ⇒ #f (atom? '(3 . 4)) ⇒ #f (atom? '()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) *n*是一个非负整数，且小于等于*list","tags":["scheme"],"title":"Scheme/Chez Scheme 对象操作","uri":"https://lvsq.net/2019/12/operations-on-objects/","year":"2019"},{"content":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。\n (make-engine thunk)\n 通过传递一个无参数的thunk(形实转换程序)给make-engine来创建一个engine。thunk的body是会被engine执行的计算，engine本身是带3个参数的过程：\n ticks： 一个正整数，指定提供给engine的执行时间片（原文用的是fuel这个单词，意思是燃料，正对应这engine的本意，十分贴切）的数量，engine将会执行到时间片用完或者计算完成为止； complete： 一个或多个参数的函数，用于指定计算完成后的操作。它的参数是剩余的时间片数量和计算产生的值； expire： 一个参数的函数，该函数指定如果在计算完成之前时间片用完了该怎么办。它的参数是一个能从中断点继续进行计算的新引擎。  将引擎应用于其参数时，它将开启一个时长为ticks的计时器，如果引擎计算在计时器执行之前完成，系统将调用complete，并将剩余的ticks和计算产生的值传递给它；\n另一方面，如果计时器在引擎计算完成之前耗尽了，则系统会从中断计算的continuation中创建一个新引擎，并使该引擎过期。complete和expire会被新引擎继续使用。If, on the other hand, the timer goes off before the engine computation completes, the system creates a new engine from the continuation of the in- terrupted computation and passes this engine to expire. complete and expire are invoked in the continuation of the engine invocation.\n请勿同时使用计时器中断（set-timer），因为engine就是由计时器实现的。\n看看具体的例子：\n(define eng (make-engine (lambda () 3))) (eng 10 ;; ticks (lambda (ticks value) value) ;; complete (lambda (x) x) ;; expire ) ⇒ 3  通常将列表作为完整过程传递给引擎，使引擎完成时返回一个列表，该列表的第一个元素是剩余的ticks，另一个元素是计算返回的值，这通常很有用。\n(define eng (make-engine (lambda () 3))) (eng 10 list (lambda (x) x)) ⇒ (9 3)  在上面的示例中，计算值为3，还剩下9个时间片，即，需要一单位的时间片来计算出3。\n再看一个复杂点的例子： 先定义一个计算裴波那切值的函数\n(define fibonacci (lambda (n) (let fib ([i n]) (cond [(= i 0) 0] [(= i 1) 1] [else (+ (fib (- i 1)) (fib (- i 2)))]))))  创建engine\n(define eng (make-engine (lambda () (fibonacci 10))))  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ \u0026quot;expired\u0026quot;  (eng 50 list (lambda (new-eng) (set! eng new-eng) \u0026quot;expired\u0026quot;)) ⇒ (21 55)  每次时间片（燃料）用完时，到期程序都会将eng分配给新引擎。整个计算需要4个blocks，每个block包含50个ticks。最后50个燃料中，有21个都用掉了。因此，使用的燃料总量为179个。\n我们还可以统计一下消耗的ticks数量\n(define mileage (lambda (thunk) (let loop ([eng (make-engine thunk)] [total-ticks 0]) (eng 50 (lambda (ticks . values) (+ total-ticks (- 50 ticks))) (lambda (new-eng) (loop new-eng (+ total-ticks 50))))))) (mileage (lambda () (fibonacci 10))) ⇒ 179  再看看一个例子——round-robin:\n(define round-robin (lambda (engs) (if (null? engs) '() ((car engs) 1 ;;ticks (lambda (ticks value) (cons value (round-robin (cdr engs)))) ;;complete (lambda (eng) ;;expire (round-robin (append (cdr engs) (list eng)))))))) (round-robin (map (lambda (x) (make-engine (lambda () (fibonacci x)))) '(4 5 2 8 3 7 6 2))) ⇒ (1 1 2 3 5 8 13 21)  这段代码需要费些思量，首先map函数创建了8个engine, 然后代入round-robin函数，该函数依次执行各个engine，但是每个engine分配的时间片只有1，对于参数\u0026rsquo;(4 5 2 8 3 7 6 2)，数字越小，越先执行完成，所以越早执行complete函数，最终结果就是排好顺序的了，很棒的程序！\n","id":27,"section":"posts","summary":"Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。 (make-engine thunk) 通过传递一个无参数的thun","tags":["engine","scheme"],"title":"Engine in Scheme","uri":"https://lvsq.net/2019/12/engine-in-scheme/","year":"2019"},{"content":" case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Scheme提供了case语法来处理这种情况，这与Java中的switch语法非常相似。\n我们来看看case的语法：\n (case expr0 clause1 clause2 \u0026hellip;)\n 除了最后一个clause之外，每个子句都必须采用以下形式之一：\n ((key \u0026hellip;) expr1 expr2 \u0026hellip;) (key expr1 expr2 \u0026hellip;)  每一个key值都应该是不同的，最后一个子句要么是上述那种形式，或者是一个像下面这样的else子句\n (else expr1 expr2 \u0026hellip;)  那么返回值是什么呢？\n匹配到某个key的或者else中的最后一个expr的值\n(define p (lambda (x) (case x [(\u0026quot;abc\u0026quot; \u0026quot;def\u0026quot;) 'one '1] [((a b c)) 'two] [else #f]))) (p (string #\\d #\\e #\\f)) ⇒ 1 (p '(a b c)) ⇒ two (p \u0026quot;eee\u0026quot;) ⇒ #f  上面的例子定义了一个函数p，接收一个参数x\n 如果x为字符串\u0026rdquo;abc\u0026rdquo;或者\u0026rdquo;def\u0026rdquo;，则返回1； 如果x为列表((a b c)，则返回two 其他情况返回#f  可见，有了case语法多条件判断写起来就方便很多，并且代码也容易读了，当然这里也可以用cond来写，这里只是为了描述case的语法而没有使用cond\n再看一个例子，就不用解释了：\n(let ([ls '(ii iv)]) (case (cadr ls) [i 1] [ii 2] [iii 3] [(iiii iv) 4] [else 'out-of-range])) ⇒ 4  record-case 来看看另一个很类似的扩展，也十分有用，它就是record-case。它可以以record为单位来做条件判断并执行指令。\n语法格式：  (record-case expr clause1 clause2 \u0026hellip;)\n 除了最后一个子句之外，每个clause的格式如下：\n ((key \u0026hellip;) formals body1 body2 \u0026hellip;)\n 每一个*key*都不应该相同, 最后一个clause可能是上述的格式或者是一个else子句：\n (else body1 body2 \u0026hellip;)\n expr必须是一个pair。Chez会拿(car expr)与各个子句中的key进行比较（用eqv?）来确定哪一个clause匹配, 然后(cdr expr)将与formals绑定。\n来看换一个例子：\n(define calc (lambda (x) (record-case x [(add) (x y) (+ x y)] [(sub) (x y) (- x y)] [(mul) (x y) (* x y)] [(div) (x y) (/ x y)] [else (assertion-violationf 'calc \u0026quot;invalid expression ~s\u0026quot; x)]))) (calc '(add 3 4)) =\u0026gt; 7 (calc '(div 3 4)) =\u0026gt; 3/4  ","id":28,"section":"posts","summary":"case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Schem","tags":["chez","scheme"],"title":"Chez Scheme中的case扩展","uri":"https://lvsq.net/2019/12/case-in-chez-scheme/","year":"2019"},{"content":" 易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴至，克尽其用，上下一体，俱不倦而事可毕矣\n 周云成康，汉言文景。无有六十年与民休息，累藏蓄积，汉武开疆之功便是空文，此厚积薄发耳，俗语言，胳膊收回来，打出去才有力\n 武帝一代雄主，文治武功，奋高祖之余烈，承三王之圣绪，开万世不拔之基，吾国斯民之幸，铭记汉青\n  ","id":29,"section":"posts","summary":"易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴","tags":["随想"],"title":"继学录","uri":"https://lvsq.net/2019/12/think/","year":"2019"},{"content":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。\n先看看该语法描述：\n(fluid-let ((var expr) \u0026hellip;) body1 body2 \u0026hellip;) returns: the values of the body body1 body2 \u0026hellip; libraries: (chezscheme)\n该Binding的作用类似局部变量，与set! 比较相似。由fluid-let定义的变量必须已绑定到顶层(top level)或者封闭的lambda内或者其他形式的绑定，这很关键！\n请看代码：\n(let ([x 3]) (+ (fluid-let ([x 5]) x) x)) ⇒ 8  先定义变量x=3，然后在加法操作当中临时将x的值改为5，最后结果为8，如果将fluid-let中的x换个名字，比如y，将如何呢？\n会得到一个异常：\n Exception: variable y is not bound\n y没有绑定，是的，y即没有在顶层中被定义，也未在某个lambda中或者任何其他形式，这里只能是x\n再学习下两个例子，加深印象：\n(let ([x 'a]) (letrec ([f (lambda (y) (cons x y))]) (fluid-let ([x 'b]) (f 'c)) )) ⇒ (b . c)  (let ([x 'a]) (call/cc (lambda (k) (fluid-let ([x 'b]) (letrec ([f (lambda (y) (k '*))]) (f '*))))) x) ⇒ a  ","id":30,"section":"posts","summary":"Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。 先看看该语法描","tags":["fluid-let","Scheme"],"title":"Fluid Binding in Chez Scheme","uri":"https://lvsq.net/2019/12/fluid-binding/","year":"2019"},{"content":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。\n这是语法描述：\n(rec var expr) syntax\nreturns: value of expr\nlibraries: (chezscheme)\nThe syntactic form rec creates a recursive object from expr by establishing a binding of var within expr to the value of expr. In essence, it is a special case of letrec for self-recursive objects.\nThis form is useful for creating recursive objects (especially procedures) that do not depend on external variables for the recursion, which are sometimes undesirable because the exter-nal bindings can change. For example, a recursive procedure defined at top level depends on the value of the top-level variable given as its name. If the value of this variable should change, the meaning of the procedure itself would change. If the procedure is defined instead with rec, its meaning is independent of the variable to which it is bound.\n简要翻译一下：\n语法rec 通过在expr中建立var与expr的值的绑定，创建一个递归对象。从本质上讲，这是letrec用于自递归对象的一种特殊情况。\n语法rec通过绑定expr中创建一个递归对象，用来 这种形式对于创建不依赖于外部变量进行递归的递归对象（尤其是过程）很有用，因为外部绑定可能会发生变化，所以有时这是不可取的。\n看一个例子来感受一下：\n给定一个全是数字的list，对于每一个数字n，算出$1+2+\u0026hellip;+n$的和，最终返回和的list.\n(map (rec sum (lambda (x) (if (= x 0) 0 (+ x (sum (- x 1)))))) ’(0 1 2 3 4 5)) ⇒ (0 1 3 6 10 15)  如果没有rec语法，用letrec也是可以的，但是稍显麻烦，代码也多一些，所以rec还是很好用的\n最后看一下rec语法的定义：\n(define-syntax rec (syntax-rules () [(_ x e) (letrec ((x e)) x)]))  ","id":31,"section":"posts","summary":"rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。 这是语法描述： (rec","tags":["Scheme","Chez","rec"],"title":"Recursive Bindings in Chez Scheme","uri":"https://lvsq.net/2019/12/recursive-bindings/","year":"2019"},{"content":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些时间，动手写了一个，目前已经在公司内部运行了几年，效果良好，并且已经开源在Github上，以飨各位。\n特点：\n API简洁 支持3种事件：\n UP DOWN JOIN  基于Vert.X\n  引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lvsq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jgossip\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  一个简单的例子：\nint gossip_port = 60001; String cluster = \u0026quot;gossip_cluster\u0026quot;; GossipSettings settings = new GossipSettings(); settings.setGossipInterval(1000); try { String myIpAddress = InetAddress.getLocalHost().getHostAddress(); List\u0026lt;SeedMember\u0026gt; seedNodes = new ArrayList\u0026lt;\u0026gt;(); SeedMember seed = new SeedMember(); seed.setCluster(cluster); seed.setIpAddress(myIpAddress); seed.setPort(60001); seedNodes.add(seed); gossipService = new GossipService(cluster, myIpAddress, gossip_port, null, seedNodes, settings, (member, state) -\u0026gt;System.out.println(\u0026quot;member:\u0026quot; + member + \u0026quot; state: \u0026quot; + state)); } catch (Exception e) { e.printStackTrace(); } gossipService.start();  详细介绍请看 =\u0026gt; 项目地址\n欢迎大家fork， 如果觉得好请start ~~~\n","id":32,"section":"posts","summary":"Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些","tags":["jgossip","gossip"],"title":"Jgossip - gossip协议的开源实现","uri":"https://lvsq.net/2019/12/jgossip/","year":"2019"},{"content":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加\nGolang的实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} nodes := []*ListNode{} var carry = 0 for { node, c := add(l1, l2, carry) carry = c if node != nil { nodes = append(nodes, node) if l1 != nil \u0026amp;\u0026amp; l1.Next != nil { l1 = l1.Next } else { l1 = nil } if l2 != nil \u0026amp;\u0026amp; l2.Next != nil { l2 = l2.Next } else { l2 = nil } if carry \u0026gt; 0 \u0026amp;\u0026amp; (l1 == nil \u0026amp;\u0026amp; l2 == nil) { nodes = append(nodes, \u0026amp;ListNode{Val:carry}) } } else { break } } for i, n := range nodes{ if i == 0 { result = n } if i + 1 \u0026lt; len(nodes) { n.Next = nodes[i + 1] } } return result } func add (n1 *ListNode, n2 *ListNode, carry int) (*ListNode, int) { node := \u0026amp;ListNode{} if (n1 == nil \u0026amp;\u0026amp; n2 == nil) { return nil, 0 } if n1 == nil { n1 = \u0026amp;ListNode{Val : 0} } if n2 == nil { n2 = \u0026amp;ListNode{Val : 0} } sum := n1.Val + n2.Val + carry carry = 0 if sum \u0026gt; 9 { carry = 1 sum = sum - 10 } node.Val = sum return node, carry }  下面提供Scheme版本的实现【(1 0) + (9 1 2) = (0 2 2)】，为了简单起见，与题目要求稍有不同，这里采用list，而不是题目要求的链表，但实际上应是一样的。比较之下可以看出，相对而言，Scheme语言的实现更加简短优雅，得益于其强大的表达能力\n(letrec ( [Polishing (lambda (l num) (if (eq? num 0) l (Polishing (append l '(0)) (- num 1))) ) ] [Align (lambda (l1 l2) (let ([len1 (length l1)] [len2 (length l2)]) (if [eq? len1 len2] [list l1 l2] [if (\u0026gt; len1 len2) (list l1 (Polishing l2 (- len1 len2))) (list (Polishing l1 (- len2 len1)) l2)])) ) ] [Add (lambda (l1 l2) (let ([ l (Align l1 l2)]) (Carry (map (lambda (x y) (+ x y)) (car l) (cadr l)) 0) ) ) ] [Carry (lambda (l c) (if (null? l) (if [eq? c 0] '() [cons c l]) (cons (mod ( + (car l) c ) 10) (Carry (cdr l) (quotient ( + (car l) c) 10))) ) ) ]) (Add '(1 0) '(9 1 2)))  Golang版本和Scheme版本的实现思路不相同，简要描述一下后者：\n (1 0) + (9 1 2), 先进行补位： (1 0 0) + (9 1 2), 按顺序相加，得： (10 1 2), 再计算进位： (0 2 2)  ","id":33,"section":"posts","summary":"本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加 Golang的实现： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result","tags":["Scheme","leetcode"],"title":"两数相加","uri":"https://lvsq.net/2019/12/leetcode-2/","year":"2019"},{"content":" 最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发。\n问题描述 假设我们已经有足够多的1分，2分，5分钱币，任意给定金额比如1元，问有多少种组合方式？ 换言之，$$1x+2y+5z = 100$$ 求x,y,z的解有多少个\n思路 组合方式的总和应为：\n 任意扣去一种钱币比如1分，1元采用2分，5分两种钱币的组合数，再加上：\n 总额为（1元-1分），采用1分，2分，5分三种钱币的组合数；\n  很明显这可以很容易用递归实现\n稍作一点解释：\na. 上面两步的意思是：不带1分的组合数 + 带1分的组合数 = 全部的组合数； 这是显而易见的\nb. 上述第2步，（1元-1分）的意思是：这样可以保证任意一种组合方式再加1分都等于1元，保证至少有1个1分的钱币\n(letrec [ (A (lambda (n d) (if (= 0 (mod n d)) 1 0))) (B (lambda (n d) (cond [(not (pair? d)) 0] [(null? d) 0] [(= 0 n) 1] [(\u0026gt; 0 n) 0] [(= 1 (length d)) (A n (car d))] [else ( + (B n (cdr d)) (B (- n (car d)) d)) ] ) ) ) ] [B 100 '(1 2 5)] )  ","id":34,"section":"posts","summary":"最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发","tags":["Scheme","SICP"],"title":"钱币组合问题","uri":"https://lvsq.net/2019/12/count-coins/","year":"2019"},{"content":" Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdquo;x-\u0026ldquo;）该如何开发做紧要的介绍。\n一切开始之前，有一点需要keep in mind，即增加扩展的位置不同，所用的方法不同，所以需要对Swagger的标准有所了解，可参考官方文档 springfox目前只允许三种扩展实现:\n ListVendorExtension:列表的形式,该对象支持泛型，最终形式：”x-field”:[{field:value}] ObjectVendorExtension:对象的扩展形式,最终的扩展形式是：”x-field”:[{field:value}] StringVendorExtension:string类型的扩展实现，最终的扩展形式是”x-field”:”value”  Swagger根对象扩展 以在info中添加一个x-logo为例\n\u0026quot;info\u0026quot;: { \u0026quot;description\u0026quot;: \u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;swagger-bootstrap-ui！！！\u0026quot;, \u0026quot;termsOfService\u0026quot;: \u0026quot;http://www.xxx.com/\u0026quot;, \u0026quot;contact\u0026quot;: { \u0026quot;name\u0026quot;: pxxxx@domain.com\u0026quot; }, \u0026quot;x-logo\u0026quot;: { \u0026quot;url\u0026quot;: \u0026quot;http://\u0026quot;, \u0026quot;color\u0026quot;: \u0026quot;#090807\u0026quot; } }, ...  后台代码：\nObjectVendorExtension logo = new ObjectVendorExtension(\u0026quot;x-logo\u0026quot;); logo.addProperty(new StringVendorExtension(\u0026quot;url\u0026quot;, \u0026quot;https://xxx.svg\u0026quot;)); logo.addProperty(new StringVendorExtension(\u0026quot;color\u0026quot;, \u0026quot;#090807\u0026quot;)); return new ApiInfoBuilder() .title(\u0026quot;swagger-bootstrap-ui！！\u0026quot;) .extensions(Lists.newArrayList(logo)) .description(\u0026quot;\u0026lt;div style='font-size:14px;color:red;'\u0026gt;swagger-bootstrap-ui-demo RESTful APIs\u0026lt;/div\u0026gt;\u0026quot;) .termsOfServiceUrl(\u0026quot;http://www.xxx.com/\u0026quot;) .version(\u0026quot;1.0.0\u0026quot;) .build();  内部对象扩展 给Path添加一个扩展属性x-order为例\n@Component @Order(Ordered.HIGHEST_PRECEDENCE+100) public class OperationPositionBulderPlugin implements OperationBuilderPlugin { @Override public void apply(OperationContext context) { context.operationBuilder().extensions(Lists.newArrayList(new StringVendorExtension(\u0026quot;x-order\u0026quot;,\u0026quot;1\u0026quot;))); } @Override public boolean supports(DocumentationType delimiter) { return true; } }  详细介绍可以参考\n","id":35,"section":"posts","summary":"Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以\u0026rdq","tags":["swagger","vendorExtensions"],"title":"Swagger 如何使用vendorExtensions进行扩展","uri":"https://lvsq.net/2019/11/swagger-vendor/","year":"2019"},{"content":" 秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁，如平原君广纳异国宾客；苏秦上书于七国；荀子遍游天下者皆可证各国文字并无大乖。 《史籀篇》文首盖云“太史籀书”，人多误以太史籀所作，如此便望文生义了。太史乃官职，王国维先生引《说文》解释，籀即读，读即籀书。另太史籀书乃周世之成语，绝非人名。  ","id":36,"section":"posts","summary":"秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁","tags":["文史"],"title":"历史不能碰","uri":"https://lvsq.net/2019/11/do-not-touch-history/","year":"2019"},{"content":" M -\u0026gt; Alt(option) S -\u0026gt; Shift    快捷键 用途     M-v 上（后）一屏   C-v 下（前）一屏   C-l 重绘屏幕，将光标所在行置于屏幕中央   C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符   C-x C-f  查找或者新建一个文件   C-x C-b 列出缓冲区。 C-x 1 关闭缓冲区列表   C-x C-q 开启或者关闭buffer的只读模式   C-x C-s 保存当前文件   C-x s 保存所有文件   C-x h 全选   M-w 复制   C-y 粘贴   C-w 剪切   C-s 往前搜索   C-r 往后搜索. DEL 也可以往后搜索，   C-/ undo   M-x calendar 打开日历。按 q 退出。【g d 到指定日期】【. 到今日（不居中）】【\u0026gt; 前一个月】【\u0026lt; 后一个月】   M-x *-mode 选择Major mode   M-x shell 运行一个shell   M-x eshell 运行一个eshell   C-a 移到行首   C-a C-k、C-S-backspace 删除整行   C-u 5 C-S-backspace、M-5 C-S-backspace 删除后5行，不加数字则删除4行（默认），如果数字为负数，则往前删   C-g 停止当前的命令   C-k 删除从光标位置到行尾所有字符    Org-Mode    快捷键 用途     C-c . 插入时间   C-c C-e 导出其它格式   C-c C-s 在标题下面插入一个带有“==SCHEDULED==”关键字的时间戳。   C-c C-d 在标题下面插入一个带有“==DEADLINE==”关键字的时间戳   C-c C-t 将当前项的状态在（unmarked）-\u0026gt;TODO-\u0026gt;DONE 之间循环切换   M-RET 插入一个同级标题   M-LEFT/RIGHT 将当前的标题提升/降低一个等级   C-c C-c 插入标签tag。 光标在标题中   C-c C-q 插入标签tag。光标在任意位置   C-c , 设置当前标题的优先级,’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的   C-c  查找标签tag   S-Tab 展开所有标题   Tab 展开光标所在标题   C-c C-l 编辑链接   C-c C-o 打开链接    ","id":37,"section":"posts","summary":"M -\u0026gt; Alt(option) S -\u0026gt; Shift 快捷键 用途 M-v 上（后）一屏 C-v 下（前）一屏 C-l 重绘屏幕，将光标所在行置于屏幕中央 C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符 C-x C-f 查","tags":["emacs"],"title":"Emacs","uri":"https://lvsq.net/2019/11/emacs/","year":"2019"}],"tags":[{"title":"about","uri":"https://lvsq.net/tags/about/"},{"title":"chez","uri":"https://lvsq.net/tags/chez/"},{"title":"emacs","uri":"https://lvsq.net/tags/emacs/"},{"title":"engine","uri":"https://lvsq.net/tags/engine/"},{"title":"fluid-let","uri":"https://lvsq.net/tags/fluid-let/"},{"title":"gossip","uri":"https://lvsq.net/tags/gossip/"},{"title":"jgossip","uri":"https://lvsq.net/tags/jgossip/"},{"title":"leetcode","uri":"https://lvsq.net/tags/leetcode/"},{"title":"module","uri":"https://lvsq.net/tags/module/"},{"title":"modules","uri":"https://lvsq.net/tags/modules/"},{"title":"rec","uri":"https://lvsq.net/tags/rec/"},{"title":"scheme","uri":"https://lvsq.net/tags/scheme/"},{"title":"SICP","uri":"https://lvsq.net/tags/sicp/"},{"title":"swagger","uri":"https://lvsq.net/tags/swagger/"},{"title":"syntactic","uri":"https://lvsq.net/tags/syntactic/"},{"title":"vendorExtensions","uri":"https://lvsq.net/tags/vendorextensions/"},{"title":"文史","uri":"https://lvsq.net/tags/%E6%96%87%E5%8F%B2/"},{"title":"随想","uri":"https://lvsq.net/tags/%E9%9A%8F%E6%83%B3/"}]}