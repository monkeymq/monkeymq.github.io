<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>存储管理(Storage Management in Chez Scheme) | 思泉笔谈 | AI-Life</title>
<meta name="keywords" content="scheme">
<meta name="description" content="垃圾回收
Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。">
<meta name="author" content="">
<link rel="canonical" href="https://continuation.cn/2020/02/storage-management/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://continuation.cn/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://continuation.cn/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://continuation.cn/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://continuation.cn/apple-touch-icon.png">
<link rel="mask-icon" href="https://continuation.cn/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://continuation.cn/2020/02/storage-management/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://continuation.cn/2020/02/storage-management/">
  <meta property="og:site_name" content="思泉笔谈 | AI-Life">
  <meta property="og:title" content="存储管理(Storage Management in Chez Scheme)">
  <meta property="og:description" content="垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-02-12T16:18:53+08:00">
    <meta property="article:modified_time" content="2020-02-12T16:18:53+08:00">
    <meta property="article:tag" content="Scheme">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="存储管理(Storage Management in Chez Scheme)">
<meta name="twitter:description" content="垃圾回收
Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://continuation.cn/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "存储管理(Storage Management in Chez Scheme)",
      "item": "https://continuation.cn/2020/02/storage-management/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "存储管理(Storage Management in Chez Scheme)",
  "name": "存储管理(Storage Management in Chez Scheme)",
  "description": "垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。\n",
  "keywords": [
    "scheme"
  ],
  "articleBody": "垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。\n回收由默认的collect-request处理程序自动触发，该处理程序通过collect-request中断调用，该中断在分配了大约n个字节的存储空间后发生，其中n是参数collect-trip-bytes 的值。 默认的collect-request处理程序通过调用不带参数的collect程序来进行会睡。 可以通过更改参数collect-request-handler 的值来重新定义collect-request处理程序。 程序还可以通过直接调用collect来导致在collect-request中断之间发生回收。\nChez Scheme的回收器是基于分代 的。它根据对象的年龄（大致来说，回收幸存数）来对对象进行分类，且老对象比年轻对象回收的频率要低。由于年轻对象比老对象更快地变为不可访问，因此结果是大多数的回收花费的时间更少。系统还维护一个静态代（static generation, 类似Java的永久代），不会对此存储进行回收。仅当压缩堆（Scompact_heap）或要collect的target-generation 参数为static符号时，才将对象放入静态代中。\n非静态代的编号从最年轻的世代（开始于0）到collect-maximum-generation的当前值。存储管理器将新分配的对象放入第0代。在第0代的回收过程中，默认情况下，将第0代的对象挪到第1代，类似地，在第1代回收期间，存活的第0代和第1代对象移动到第2代，依此类推。在最大非静态对象回收的过程中，所有幸存的非静态对象都将移动（可能返回）到最大非静态代中。 通过这种机制，一个对象有可能跳过一个或多个世代，但这在许多对象上不太可能发生，并且如果这些对象变得不可访问，则最终将回收它们的存储。\n维护内部计数器gc-trip来控制何时回收每一代。 每次调用不带参数的collect 时（从默认的collect-request处理程序开始），gc-trip都会加1。在collect-generation基数为r 的情况下，回收的世代编号为g ，其gc-trip是$r^g$的倍数。 如果将collect-generation-radix设置为4，则系统将每次收集0代，每4次收集1代，每16次收集2代，依此类推。\n每次某个世代g 调用collect时，该世代g 被回收且gc-trip前进到下个$r^g$的边界，但是不会超过$r^{g+1}$的边界，r 不变还是collect-generation-radix的值。\n如果使用第二个参数tg 调用collect，则tg 确定目标代。 当g 是最大的非静态代时，tg 必须为g 或为static。 否则，tg 必须为g 或g + 1 。 当目标代是static符号时，非静态代中的所有数据都将移动到静态代中。静态代中的对象从不会被回收。 这在加载和初始化应用程序的永久代码和数据结构之后非常有用，以减少后续回收的开销。\n通过设置本节中描述的参数，可以对回收器的行为进行实质性的调整。通过重新定义collect-request处理程序且使用显式的g 和tg 参数调用collect，甚至有可能完全覆盖收集器的默认策略来确定何时回收每个世代。例如，程序员可以通过使用显式的g 和tg 参数调用collect来重新定义处理程序，以在长时间内将最大的非静态代视为静态代，该参数在该时间段内绝不等于最大的非静态代。\n(collect) | (collect g) | (collect g tg)\ng 必须是不大于最大非静态代（collect-maximum-generation返回的值）的非负确定编号。 如果g 已经是最大的非静态代编号，则tg 必须是一个等于g 的fixnum或static符号。 否则，tg 必须是一个等于g 或大于g 的fixnum。\n此过程使存储管理器执行垃圾回收。 collect是通过collect-request处理程序定期调用的，但是也可以显式调用它，以在特定时间（例如，在计时计算之前）强制进行回收。 在Chez Scheme的线程版本中，调用collect的线程必须是唯一的活动线程。\n系统将根据g 和tg （如果提供）确定回收哪些世代，如本节的介绍中所述。\n(collect-rendezvous)\n请求垃圾回收的方式应该与由系统自动发起的GC的方式相一致。所有正在运行的线程经过协调，以便其中一个调用collect-request处理程序，而其他线程暂停直到处理程序返回。\n请注意，如果collect-request处理程序（请参阅collect-request-handler）没有调用collect，那么collect-rendezvous实际上不会执行垃圾回收。\ncollect-notify\n如果将collect-notify设置为true，则每当运行GC时，回收器都会打印一条消息。 默认情况下，collect-notify设置为#f。\ncollect-trip-bytes\nChez Scheme在内部以大块分配内存，并通过内联操作将这些块细分以提高效率。存储管理器确定是否为每个分配的大块仅请求一次回收。此外，在存储管理器请求回收和兑现回收请求之间可能会花费一些时间，尤其是如果通过with-interrupts-disabled或disable-interrupts临时禁用了中断时。因此，collect-trip-bytes仅是一种近似度量。\ncollect-generation-radix\n此参数确定默认情况下的collect-request处理程序调用不带参数的collect时回收每一代的频率。每$r^g$次发生一次对应世代的回收，其中r 是collect-generation-radix的值，g 是世代数。\n将collect-generation-radix设置为1会强制所有世代每次都被回收， 将collect-generation-radix设置为非常大的数目将无限期有效地延迟较早的一代的回收。\ncollect-maximum-generation\n此参数确定当前可以使用的最大非静态世代数,它的值是1到254范围内的精确整数。设置为1时，仅使用两个非静态生成。 设置为2时，将使用三个非静态世代，依此类推。 当设置为254时，将使用255个非静态代，再加上一个静态代，总共256个世代。增加世代数可以减少了收集旧对象的频率，潜在地减少了收集开销，但同时也潜在地增加了系统中保留的不可访问对象的数量，从而增加了所需的内存总量。\ncollect-request-handler\ncollect-request-handler的值必须是一个过程。当系统认为应该要进行GC时（即，自上次GC以来，系统分配了由参数collect-trip-bytes规定的存储量之后），该过程在不带参数的情况下被调用。\n默认情况下，collect-request-handler仅调用不带参数的collect。 可以通过将collect-request-handler设置为不执行任何操作的过程来禁用自动收集，例如：\n(collect-request-handler void) 也可以利用防止任何中断的critical-section来临时禁用GC\nrelease-minimum-generation\n此参数的值必须介于0到collect-maximum-generation的值（包括）之间，并且默认为collect-maximum-generation的值。\n当分配新数据且进行GC时，storage-management会自动地从操作系统中请求额外的虚拟内存地址。相应地，在堆显著减小的情况下，系统尝试将先前从操作系统获得的某些虚拟内存返回给操作系统。默认情况下，系统仅在针对最大非静态时代的GC之后才这样做。也可以让系统在对更年轻的世代回收之后就执行此操作，方法是将release-minimum-generation的值更改为小于collect-maximum-generation的值。由参数指定的世代，或者任何较老的世代是GC的目标世代时，存储管理系统将在GC之后尝试将不需要的虚拟内存返回给操作系统。\n当collect-maximum-generation设置为一个新值g 时，release-minimum-generation也同时隐式地更改为g ，有两个前提：（a）修改前这两个参数具有相同的值；（b）release-minimum-generation的值大于g\nheap-reserve-ratio\n此参数确定了保留的内存的大概数量（没有返回给OS，如release-minimum-generation所描述的）与当前已占用的内存量（不包含已变为静态的内存区域）的比例，它的值必须是不精确的非负整数值； 如果设置为精确的实数值，则精确的值将转换为不精确的值。默认值1.0，为每个当前占用的非静态页面保留一页内存。 将其设置为较小的值可能会导致较小的平均虚拟内存占用量，而将其设置为较大的值可能会导致较少的操作系统调用以请求和释放内存空间。\n弱序对，暂时序对和守护者Weak Pairs, Ephemeron Pairs, and Guardians weak pairs允许程序维护指向对象的弱指针。 指向对象的弱指针不会阻止存储管理系统回收该对象，但是只要该对象在系统中是可访问的，它仍然有效。\nephemeron pairs与weak pairs类似，但是ephemeron pairs拥有两个指针，其中仅仅在第一个指针存在的情况第二个指针才能存在\nguardians允许程序保护对象免遭垃圾回收器的重分配，并确定该对象何时被重新分配。\nweak paris, ephemeron pairs 和guardians允许程序将有关对象的信息保留在单独的数据结构（例如哈希表）中，而无需担心维护此信息将导致对象无限期地保留在系统中。\n另外，guardians允许无限期地从释放对象中保存对象，以便可以重用它们，或者可以使用存储在对象中的数据执行清理或其他操作。\n(weak-cons obj1 obj2)\n返回：一个新的弱序对\nobj1 是新对的car, obj2构成了新对的cdr。弱序对和普通对是无法区分的，除了这两种方式：\n弱序对可以使用**weak-pair?**这个谓词来区别普通对 弱序对维护了一个指向(car obj)的弱指针 弱序对的car中的弱指针就像普通指针一样，只要它指向的对象可以通过系统中某个地方的普通（非弱）指针访问即可。 但是，如果垃圾收集器在某个时候识别出不存在指向该对象的非弱指针，则它将每个指向该对象的弱指针替换为“ broken weak-pointer”对象**#!bwp**，并丢弃该对象。\n弱序对的cdr字段不是弱指针，因此可以使用弱序对来构造弱保持对象的列表。可以像使用普通的列表的处理操作（例如length，map和assv）来操作这些list。弱序对可以使用set-car!和set-cdr!来修改； 在set-car!之后，car字段包含指向新对象的弱指针，代替了旧对象。弱序对的打印方式与普通对相同。 弱序对没有reader语法。弱序对在被写入然后被读取时成为普通对。\n(define x (cons 'a 'b)) (define p (weak-cons x '())) (car p) ⇒ (a . b) (define x (cons 'a 'b)) (define p (weak-cons x '())) (set! x '*) (collect) (car p) ⇒ #!bwp (weak-pair? obj)\n(weak-pair? (weak-cons ’a ’b)) ⇒ #t (weak-pair? (cons ’a ’b)) ⇒ #f (weak-pair? \"oops\") ⇒ #f (ephemeron-cons obj1 obj2)\nobj1 是新对的car, obj2构成了新对的cdr。暂时序对和普通对是无法区分的，除了这两种方式：\n暂时序对可以使用**ephemeron-pair?**这个谓词来区别普通对 暂时序对维护了一个指向(car obj)的弱指针，并且仅仅在pair的car存在时cdr才能保留 暂时序对的行为与弱序对类似，不过cdr有特殊的处理：如果car被设置为**#!bwp的同时也会将cdr设置为#!bwp**。由于同时将car和cdr字段设置为为**#!bwp**，因此可以通过cdr对象引用car对象这一事实本身并不意味着必须保留car（与弱序对不同）。 相反，出于某种原因，car必须独立于cdr对象保存。\n与弱序对和其他对一样，暂时序对使用**set-car!和set-cdr!**来修改数据，暂时序对的打印方式与普通对一样，但没有reader语法\n(define x (cons 'a 'b)) (define p (ephemeron-cons x x)) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b) (define x (cons 'a 'b)) (define p (ephemeron-cons x x)) (set! x '*) (collect) (car p) ⇒ #!bwp (cdr p) ⇒ #!bwp (define x (cons 'a 'b)) (define p (weak-cons x x)) ; not an ephemeron pair (set! x '*) (collect) (car p) ⇒ (a . b) (cdr p) ⇒ (a . b) 与弱序对一样，如果在将x设置为*之前进行了垃圾回收将该pair提升为较老的一代，则上面中间示例的最后两个表达式实际上可能返回（a . b）。 但是，在上面的最后一个示例中，最后两个表达式的结果将始终为（a . b），因为弱序对的cdr持有非弱引用，并且该非弱引用阻止car字段变** #!bwp**。\n(ephemeron-pair? obj)\n(ephemeron-pair? (ephemeron-cons 'a 'b)) ⇒ #t (ephemeron-pair? (cons 'a 'b)) ⇒ #f (ephemeron-pair? (weak-cons 'a 'b)) ⇒ #f (ephemeron-pair? \"oops\") ⇒ #f (bwp-object? obj)\n返回：如果obj是断开的broken weak-pair对象，则返回#t，否则返回#f\n(bwp-object? #!bwp) ⇒ #t (bwp-object? 'bwp) ⇒ #f (define x (cons 'a 'b)) (define p (weak-cons x '())) (set! x '*) (collect (collect-maximum-generation)) (car p) ⇒ #!bwp (bwp-object? (car p)) ⇒ #t (make-guardian)\nGuardians由要保护的对象组的过程表示。创建guardian后，注册对象组为空。 通过将对象作为参数传递给守护者，可以向guardian注册对象：\n(define G (make-guardian)) (define x (cons 'aaa 'bbb)) x ⇒ (aaa . bbb) (G x) 注册对象时也可以指定“representative”（即，y）对象。 继续上面的示例：\n(define y (cons 'ccc 'ddd)) y ⇒ (ccc . ddd) (G y 'rep) 与守护者关联的一组注册对象在逻辑上细分为两个不相交的子组：一个子组称为“可访问”对象，一个子组称为“不可访问”对象。不可访问的对象是已被证明无法访问的对象（通过guardian机制本身或通过弱序对或暂时序对的car字段除外），可访问的对象是未经证明的对象。“已证明”一词在这里很重要：可能是可访问组中的某些对象确实是不可访问的，但这尚未得到证明。 在某些情况下，直到对象实际上变得不可访问很久之后（在当前实现中，直到发生包含对象的世代的垃圾回收），才可能做出这种证明。\n向guardian注册的对象最初被放置在可访问组中，并在它们变得不可访问后的某个时刻移入不可访问组。 不可访问组中的对象是通过调用不带参数的guardian来检索的。 如果不可访问组中没有对象，则guardian返回#f。 继续上面的示例：\n(G) ⇒ #f (set! x #f) (set! y #f) (collect) (G) ⇒ (aaa . bbb) ; 也有可能这个后打印出来 (G) ⇒ rep ; 这个先打印出来 (G) ⇒ #f 对G的初始调用返回#f，因为绑定到x和y的对是向G注册的唯一对象，并且仍然可以通过这些绑定访问这些序对。调用collect时，对象将移入不可访问的组。 因此，对G的两个调用返回先前绑定到x的序对和先前绑定到y的序对的representative，尽管可能与所示顺序相反。 （如上所述，对于弱序对，如果对象已迁移到较老的一代，则调用collect实际上可能不足以证明该对象不可访问。）\n实际上，从guardian那里获取的对象在任何方面都没有特殊的地位。 此功能避免了共享或循环结构可能会出现的问题。 由不可访问对象组成的共享或循环结构将被完整保留，将注册由guardian保护的部分都放置在该guardian不可访问的集合中。 然后，程序员可以完全控制结构的处理顺序。\n一个对象可以在guardian处多次注册，在这种情况下，可以多次检索该对象：\n(define G (make-guardian)) (define x (cons 'aaa 'bbb)) (G x) (G x) (set! x #f) (collect) (G) ⇒ (aaa . bbb) (G) ⇒ (aaa . bbb) 它也可以向不止一个guardian注册，并且guardian本身也可以向其他guardian注册。 在没有“representative”的情况下向guardian注册的对象，并放置在一个弱序对或暂时对的car字段中，其直到从guardian处将返回并由程序丢弃，或者直到guardian本身被丢弃为止。\n(define G (make-guardian)) (define x (cons 'aaa 'bbb)) (define p (weak-cons x '())) (G x) (set! x #f) (collect) (set! y (G)) y ⇒ (aaa . bbb) (car p) ⇒ (aaa . bbb) (set! y #f) (collect 1) (car p) ⇒ #!bwp 另一方面，如果指定了representative（对象本身除外），则在从guardian处获得representative的同时，也会从弱序对或暂时序对的car字段中丢弃受保护的对象。\n(define G (make-guardian)) (define x (cons 'aaa 'bbb)) (define p (weak-cons x '())) (G x 'rep) (set! x #f) (collect) (G) ⇒ rep ; 获得representative的值 (car p) ⇒ #!bwp ; 自动丢弃 下面的示例说明了当guardian本身丢弃时，该对象已被释放并且弱序对的car字段设置为#!bwp：\n(define G (make-guardian)) (define x (cons aaa 'bbb)) (define p (weak-cons x '())) (G x) (set! x #f) (set! G #f) (collect) (car p) ⇒ #!bwp 下面的示例演示了如何使用guardian来释放外部存储，就像由C库“malloc”和“free”操作管理存储。\n(define malloc (let ([malloc-guardian (make-guardian)]) (lambda (size) ; first free any storage that has been dropped. to avoid long ; delays, it might be better to deallocate no more than, say, ; ten objects for each one allocated (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f)))) ; then allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x)))) do-malloc必须返回一个Scheme对象“header”，该header封装一个指向外部存储的指针（可能是无符号整数），并且必须通过此header对外部存储进行所有访问。特别是，必须注意在删除相应的header之后，在Scheme之外不存在指向外部存储的指针。 do-free必须使用封装的指针释放外部存储。这两个原语都可以使用外部分配和外部无关的定义，也可以作为外部过程导入的C库“malloc”和“free”运算符进行定义。\n如果不希望调用malloc来释放存储，则可以使用collect-request处理器来检查并释放已丢弃的存储，如下所示：\n(define malloc) (let ([malloc-guardian (make-guardian)]) (set! malloc (lambda (size) ; allocate and register the new storage (let ([x (do-malloc size)]) (malloc-guardian x) x))) (collect-request-handler (lambda () ; first, invoke the collector (collect) ; then free any storage that has been dropped (let f () (let ([x (malloc-guardian)]) (when x (do-free x) (f))))))) 通过一点重构，就有可能将封装的外部地址注册为带header的representative，在这种情况下，do-free将仅将外部地址作为参数。 这将使标头一旦变得不可访问，便可以将其从Scheme堆中删除。\n锁对象Locking Objects 来自C语言的变量或数据结构到Scheme对象的所有指针，通常应在输入（或重新输入）Scheme之前丢弃。 当无法遵循该准则时，可以通过锁定对象或等效的C库过程Slock_object锁定该对象。\n(lock-object obj)\n锁定对象可防止存储管理器收回或重定位该对象。 应谨慎使用锁定，因为它会导致内存碎片并增加存储管理开销。\n如果未解锁对象，锁定也会导致意外保留存储空间。 可以通过解锁对象或等效的C库过程Sunlock_object来解锁对象。\n锁定立即数（例如，fixnum，布尔值和字符）或已被静态化的对象是不必要但无害的。\n(unlock-object obj)\n通过连续调用lock-object，Slock_object或同时调用这两个对象，可以多次锁定对象，在这种情况下，必须先通过相等次数的对unlock-object或Sunlock_object的调用来将其解锁。\n除非存在指向对象的单独的C指针，否则也无需锁定包含在锁定对象中的对象（例如，锁定序对的car中的对象）。也就是说，如果仅允许通过外部对象来间接访问的内部对象，则应将其解锁，以便回收器在回收期间可以自由地重分配它。\n解锁立即值（例如，fixnum，布尔值和字符）或已设为静态的对象是不必要的，无效的，但无害。\n(locked-object? obj)\n返回：如果obj是锁定的，立即的或静态的，返回#t\n如果回收器无法重分配或回收obj，则该谓词将返回true，包括立即值，例如fixnums，布尔值和字符以及已设为静态的对象。\n",
  "wordCount" : "7664",
  "inLanguage": "zh",
  "datePublished": "2020-02-12T16:18:53+08:00",
  "dateModified": "2020-02-12T16:18:53+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://continuation.cn/2020/02/storage-management/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "思泉笔谈 | AI-Life",
    "logo": {
      "@type": "ImageObject",
      "url": "https://continuation.cn/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://continuation.cn/" accesskey="h" title="思泉笔谈 | AI-Life (Alt + H)">思泉笔谈 | AI-Life</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://continuation.cn/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://continuation.cn/posts" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://continuation.cn/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://continuation.cn/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://continuation.cn/about" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      存储管理(Storage Management in Chez Scheme)
    </h1>
    <div class="post-meta"><span title='2020-02-12 16:18:53 +0800 CST'>二月 12, 2020</span>

</div>
  </header> 
  <div class="post-content"><h3 id="垃圾回收">垃圾回收<a hidden class="anchor" aria-hidden="true" href="#垃圾回收">#</a></h3>
<p>Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。</p>
<p>回收由默认的<strong>collect-request</strong>处理程序自动触发，该处理程序通过<strong>collect-request</strong>中断调用，该中断在分配了大约n个字节的存储空间后发生，其中n是参数<em>collect-trip-bytes</em> 的值。 默认的<strong>collect-request</strong>处理程序通过调用不带参数的<strong>collect</strong>程序来进行会睡。 可以通过更改参数<em>collect-request-handler</em> 的值来重新定义<strong>collect-request</strong>处理程序。 程序还可以通过直接调用<strong>collect</strong>来导致在<strong>collect-request</strong>中断之间发生回收。</p>
<p>Chez Scheme的回收器是基于<strong>分代</strong> 的。它根据对象的年龄（大致来说，回收幸存数）来对对象进行分类，且老对象比年轻对象回收的频率要低。由于年轻对象比老对象更快地变为不可访问，因此结果是大多数的回收花费的时间更少。系统还维护一个静态代（static generation, 类似Java的永久代），不会对此存储进行回收。仅当压缩堆（Scompact_heap）或要<strong>collect</strong>的<em>target-generation</em> 参数为<strong>static</strong>符号时，才将对象放入静态代中。</p>
<p>非静态代的编号从最年轻的世代（开始于0）到<strong>collect-maximum-generation</strong>的当前值。存储管理器将新分配的对象放入第0代。在第0代的回收过程中，默认情况下，将第0代的对象挪到第1代，类似地，在第1代回收期间，存活的第0代和第1代对象移动到第2代，依此类推。在最大非静态对象回收的过程中，所有幸存的非静态对象都将移动（可能返回）到最大非静态代中。 通过这种机制，一个对象有可能跳过一个或多个世代，但这在许多对象上不太可能发生，并且如果这些对象变得不可访问，则最终将回收它们的存储。</p>
<p>维护内部计数器gc-trip来控制何时回收每一代。 每次调用不带参数的<strong>collect</strong> 时（从默认的collect-request处理程序开始），gc-trip都会加1。在<strong>collect-generation</strong>基数为<em>r</em> 的情况下，回收的世代编号为<em>g</em> ，其gc-trip是$r^g$的倍数。 如果将<strong>collect-generation-radix</strong>设置为4，则系统将每次收集0代，每4次收集1代，每16次收集2代，依此类推。</p>
<p>每次某个世代<em>g</em> 调用<strong>collect</strong>时，该世代<em>g</em> 被回收且gc-trip前进到下个$r^g$的边界，但是不会超过$r^{g+1}$的边界，<em>r</em> 不变还是<strong>collect-generation-radix</strong>的值。</p>
<p>如果使用第二个参数<em>tg</em> 调用<strong>collect</strong>，则<em>tg</em> 确定目标代。 当<em>g</em> 是最大的非静态代时，<em>tg</em> 必须为<em>g</em> 或为<strong>static</strong>。 否则，<em>tg</em> 必须为<em>g</em> 或<em>g + 1</em> 。 当目标代是<strong>static</strong>符号时，非静态代中的所有数据都将移动到静态代中。静态代中的对象从不会被回收。 这在加载和初始化应用程序的永久代码和数据结构之后非常有用，以减少后续回收的开销。</p>
<p>通过设置本节中描述的参数，可以对回收器的行为进行实质性的调整。通过重新定义<strong>collect-request</strong>处理程序且使用显式的<em>g</em> 和<em>tg</em> 参数调用<strong>collect</strong>，甚至有可能完全覆盖收集器的默认策略来确定何时回收每个世代。例如，程序员可以通过使用显式的<em>g</em> 和<em>tg</em> 参数调用<strong>collect</strong>来重新定义处理程序，以在长时间内将最大的非静态代视为静态代，该参数在该时间段内绝不等于最大的非静态代。</p>
<blockquote>
<p>(collect) |  (collect g) |  (collect g tg)</p></blockquote>
<p><em>g</em> 必须是不大于最大非静态代（collect-maximum-generation返回的值）的非负确定编号。 如果<em>g</em> 已经是最大的非静态代编号，则<em>tg</em> 必须是一个等于<em>g</em> 的fixnum或<strong>static</strong>符号。 否则，<em>tg</em> 必须是一个等于<em>g</em> 或大于<em>g</em> 的fixnum。</p>
<p>此过程使存储管理器执行垃圾回收。 <strong>collect</strong>是通过<strong>collect-request</strong>处理程序定期调用的，但是也可以显式调用它，以在特定时间（例如，在计时计算之前）强制进行回收。 在Chez Scheme的线程版本中，调用<strong>collect</strong>的线程必须是唯一的活动线程。</p>
<p>系统将根据<em>g</em> 和<em>tg</em> （如果提供）确定回收哪些世代，如本节的介绍中所述。</p>
<blockquote>
<p>(collect-rendezvous)</p></blockquote>
<p>请求垃圾回收的方式应该与由系统自动发起的GC的方式相一致。所有正在运行的线程经过协调，以便其中一个调用<strong>collect-request</strong>处理程序，而其他线程暂停直到处理程序返回。</p>
<p>请注意，如果collect-request处理程序（请参阅collect-request-handler）没有调用collect，那么collect-rendezvous实际上不会执行垃圾回收。</p>
<blockquote>
<p>collect-notify</p></blockquote>
<p>如果将collect-notify设置为true，则每当运行GC时，回收器都会打印一条消息。 默认情况下，collect-notify设置为#f。</p>
<blockquote>
<p>collect-trip-bytes</p></blockquote>
<p>Chez Scheme在内部以大块分配内存，并通过内联操作将这些块细分以提高效率。存储管理器确定是否为每个分配的大块仅请求一次回收。此外，在存储管理器请求回收和兑现回收请求之间可能会花费一些时间，尤其是如果通过<strong>with-interrupts-disabled</strong>或<strong>disable-interrupts</strong>临时禁用了中断时。因此，<strong>collect-trip-bytes</strong>仅是一种近似度量。</p>
<blockquote>
<p>collect-generation-radix</p></blockquote>
<p>此参数确定默认情况下的<strong>collect-request</strong>处理程序调用不带参数的<strong>collect</strong>时回收每一代的频率。每$r^g$次发生一次对应世代的回收，其中<em>r</em> 是<strong>collect-generation-radix</strong>的值，<em>g</em> 是世代数。</p>
<p>将<strong>collect-generation-radix</strong>设置为<strong>1</strong>会强制所有世代每次都被回收， 将<strong>collect-generation-radix</strong>设置为非常大的数目将无限期有效地延迟较早的一代的回收。</p>
<blockquote>
<p>collect-maximum-generation</p></blockquote>
<p>此参数确定当前可以使用的最大非静态世代数,它的值是1到254范围内的精确整数。设置为1时，仅使用两个非静态生成。 设置为2时，将使用三个非静态世代，依此类推。 当设置为254时，将使用255个非静态代，再加上一个静态代，总共256个世代。增加世代数可以减少了收集旧对象的频率，潜在地减少了收集开销，但同时也潜在地增加了系统中保留的不可访问对象的数量，从而增加了所需的内存总量。</p>
<blockquote>
<p>collect-request-handler</p></blockquote>
<p><strong>collect-request-handler</strong>的值必须是一个过程。当系统认为应该要进行GC时（即，自上次GC以来，系统分配了由参数<strong>collect-trip-bytes</strong>规定的存储量之后），该过程在不带参数的情况下被调用。</p>
<p>默认情况下，collect-request-handler仅调用不带参数的collect。 可以通过将collect-request-handler设置为不执行任何操作的过程来禁用自动收集，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">collect-request-handler</span> void)
</span></span></code></pre></div><p>也可以利用防止任何中断的<strong>critical-section</strong>来临时禁用GC</p>
<blockquote>
<p>release-minimum-generation</p></blockquote>
<p>此参数的值必须介于0到collect-maximum-generation的值（包括）之间，并且默认为collect-maximum-generation的值。</p>
<p>当分配新数据且进行GC时，storage-management会自动地从操作系统中请求额外的虚拟内存地址。相应地，在堆显著减小的情况下，系统尝试将先前从操作系统获得的某些虚拟内存返回给操作系统。默认情况下，系统仅在针对最大非静态时代的GC之后才这样做。也可以让系统在对更年轻的世代回收之后就执行此操作，方法是将<strong>release-minimum-generation</strong>的值更改为小于<strong>collect-maximum-generation</strong>的值。由参数指定的世代，或者任何较老的世代是GC的目标世代时，存储管理系统将在GC之后尝试将不需要的虚拟内存返回给操作系统。</p>
<p>当<strong>collect-maximum-generation</strong>设置为一个新值<em>g</em> 时，<strong>release-minimum-generation</strong>也同时隐式地更改为<em>g</em> ，有两个前提：（a）修改前这两个参数具有相同的值；（b）<strong>release-minimum-generation</strong>的值大于<em>g</em></p>
<blockquote>
<p>heap-reserve-ratio</p></blockquote>
<p>此参数确定了保留的内存的大概数量（没有返回给OS，如<strong>release-minimum-generation</strong>所描述的）与当前已占用的内存量（不包含已变为静态的内存区域）的比例，它的值必须是不精确的非负整数值； 如果设置为精确的实数值，则精确的值将转换为不精确的值。默认值1.0，为每个当前占用的非静态页面保留一页内存。 将其设置为较小的值可能会导致较小的平均虚拟内存占用量，而将其设置为较大的值可能会导致较少的操作系统调用以请求和释放内存空间。</p>
<h3 id="弱序对暂时序对和守护者weak-pairs-ephemeron-pairs-and-guardians">弱序对，暂时序对和守护者Weak Pairs, Ephemeron Pairs, and Guardians<a hidden class="anchor" aria-hidden="true" href="#弱序对暂时序对和守护者weak-pairs-ephemeron-pairs-and-guardians">#</a></h3>
<p>weak pairs允许程序维护指向对象的弱指针。 指向对象的弱指针不会阻止存储管理系统回收该对象，但是只要该对象在系统中是可访问的，它仍然有效。</p>
<p>ephemeron pairs与weak pairs类似，但是ephemeron pairs拥有两个指针，其中仅仅在第一个指针存在的情况第二个指针才能存在</p>
<p>guardians允许程序保护对象免遭垃圾回收器的重分配，并确定该对象何时被重新分配。</p>
<p>weak paris, ephemeron pairs 和guardians允许程序将有关对象的信息保留在单独的数据结构（例如哈希表）中，而无需担心维护此信息将导致对象无限期地保留在系统中。</p>
<p>另外，guardians允许无限期地从释放对象中保存对象，以便可以重用它们，或者可以使用存储在对象中的数据执行清理或其他操作。</p>
<blockquote>
<p>(weak-cons obj1 obj2)</p></blockquote>
<p>返回：一个新的弱序对</p>
<p><em>obj1</em> 是新对的car, obj2构成了新对的cdr。弱序对和普通对是无法区分的，除了这两种方式：</p>
<ul>
<li>弱序对可以使用**weak-pair?**这个谓词来区别普通对</li>
<li>弱序对维护了一个指向(car obj)的弱指针</li>
</ul>
<p>弱序对的car中的弱指针就像普通指针一样，只要它指向的对象可以通过系统中某个地方的普通（非弱）指针访问即可。 但是，如果垃圾收集器在某个时候识别出不存在指向该对象的非弱指针，则它将每个指向该对象的弱指针替换为“ broken weak-pointer”对象**#!bwp**，并丢弃该对象。</p>
<p>弱序对的cdr字段不是弱指针，因此可以使用弱序对来构造弱保持对象的列表。可以像使用普通的列表的处理操作（例如length，map和assv）来操作这些list。弱序对可以使用set-car!和set-cdr!来修改； 在set-car!之后，car字段包含指向新对象的弱指针，代替了旧对象。弱序对的打印方式与普通对相同。 弱序对没有reader语法。弱序对在被写入然后被读取时成为普通对。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>x (cons <span style="color:#e6db74">&#39;a</span> <span style="color:#e6db74">&#39;b</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>p (<span style="color:#a6e22e">weak-cons</span> x <span style="color:#f92672">&#39;</span>()))
</span></span><span style="display:flex;"><span>(car p) <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">.</span> b)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>x (cons <span style="color:#e6db74">&#39;a</span> <span style="color:#e6db74">&#39;b</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>p (<span style="color:#a6e22e">weak-cons</span> x <span style="color:#f92672">&#39;</span>()))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>x <span style="color:#e6db74">&#39;*</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">collect</span>)
</span></span><span style="display:flex;"><span>(car p) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#f92672">#</span>!bwp
</span></span></code></pre></div><blockquote>
<p>(weak-pair? obj)</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">weak-pair?</span> (<span style="color:#a6e22e">weak-cons</span> <span style="color:#960050;background-color:#1e0010">’</span>a <span style="color:#960050;background-color:#1e0010">’</span>b)) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#t</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">weak-pair?</span> (cons <span style="color:#960050;background-color:#1e0010">’</span>a <span style="color:#960050;background-color:#1e0010">’</span>b)) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#f</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">weak-pair?</span> <span style="color:#e6db74">&#34;oops&#34;</span>) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#f</span>
</span></span></code></pre></div><blockquote>
<p>(ephemeron-cons obj1 obj2)</p></blockquote>
<p><em>obj1</em> 是新对的car, obj2构成了新对的cdr。暂时序对和普通对是无法区分的，除了这两种方式：</p>
<ul>
<li>暂时序对可以使用**ephemeron-pair?**这个谓词来区别普通对</li>
<li>暂时序对维护了一个指向(car obj)的弱指针，并且仅仅在pair的car存在时cdr才能保留</li>
</ul>
<p>暂时序对的行为与弱序对类似，不过cdr有特殊的处理：如果car被设置为**#!bwp<strong>的同时也会将cdr设置为</strong>#!bwp**。由于同时将car和cdr字段设置为为**#!bwp**，因此可以通过cdr对象引用car对象这一事实本身并不意味着必须保留car（与弱序对不同）。 相反，出于某种原因，car必须独立于cdr对象保存。</p>
<p>与弱序对和其他对一样，暂时序对使用**set-car!<strong>和</strong>set-cdr!**来修改数据，暂时序对的打印方式与普通对一样，但没有reader语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>x (cons <span style="color:#e6db74">&#39;a</span> <span style="color:#e6db74">&#39;b</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>p (<span style="color:#a6e22e">ephemeron-cons</span> x x))
</span></span><span style="display:flex;"><span>(car p) <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">.</span> b)
</span></span><span style="display:flex;"><span>(cdr p) <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">.</span> b)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>x (cons <span style="color:#e6db74">&#39;a</span> <span style="color:#e6db74">&#39;b</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>p (<span style="color:#a6e22e">ephemeron-cons</span> x x))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>x <span style="color:#e6db74">&#39;*</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">collect</span>)
</span></span><span style="display:flex;"><span>(car p) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#f92672">#</span>!bwp
</span></span><span style="display:flex;"><span>(cdr p) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#f92672">#</span>!bwp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>x (cons <span style="color:#e6db74">&#39;a</span> <span style="color:#e6db74">&#39;b</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>p (<span style="color:#a6e22e">weak-cons</span> x x)) <span style="color:#75715e">; not an ephemeron pair</span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>x <span style="color:#e6db74">&#39;*</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">collect</span>)
</span></span><span style="display:flex;"><span>(car p) <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">.</span> b)
</span></span><span style="display:flex;"><span>(cdr p) <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">.</span> b)
</span></span></code></pre></div><p>与弱序对一样，如果在将x设置为*之前进行了垃圾回收将该pair提升为较老的一代，则上面中间示例的最后两个表达式实际上可能返回（a . b）。 但是，在上面的最后一个示例中，最后两个表达式的结果将始终为（a . b），因为弱序对的cdr持有非弱引用，并且该非弱引用阻止car字段变** #!bwp**。</p>
<blockquote>
<p>(ephemeron-pair? obj)</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">ephemeron-pair?</span> (<span style="color:#a6e22e">ephemeron-cons</span> <span style="color:#e6db74">&#39;a</span> <span style="color:#e6db74">&#39;b</span>)) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#t</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">ephemeron-pair?</span> (cons <span style="color:#e6db74">&#39;a</span> <span style="color:#e6db74">&#39;b</span>)) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#f</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">ephemeron-pair?</span> (<span style="color:#a6e22e">weak-cons</span> <span style="color:#e6db74">&#39;a</span> <span style="color:#e6db74">&#39;b</span>)) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#f</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">ephemeron-pair?</span> <span style="color:#e6db74">&#34;oops&#34;</span>) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#f</span>
</span></span></code></pre></div><blockquote>
<p>(bwp-object? obj)</p></blockquote>
<p>返回：如果obj是断开的broken weak-pair对象，则返回#t，否则返回#f</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">bwp-object?</span> <span style="color:#f92672">#</span>!bwp) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#t</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">bwp-object?</span> <span style="color:#e6db74">&#39;bwp</span>) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#f</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>x (cons <span style="color:#e6db74">&#39;a</span> <span style="color:#e6db74">&#39;b</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>p (<span style="color:#a6e22e">weak-cons</span> x <span style="color:#f92672">&#39;</span>()))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>x <span style="color:#e6db74">&#39;*</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">collect</span> (<span style="color:#a6e22e">collect-maximum-generation</span>))
</span></span><span style="display:flex;"><span>(car p) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#f92672">#</span>!bwp
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">bwp-object?</span> (car p)) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#t</span>
</span></span></code></pre></div><blockquote>
<p>(make-guardian)</p></blockquote>
<p><strong>Guardians</strong>由要保护的对象组的过程表示。创建guardian后，注册对象组为空。 通过将对象作为参数传递给守护者，可以向guardian注册对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>G (<span style="color:#a6e22e">make-guardian</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>x (cons <span style="color:#e6db74">&#39;aaa</span> <span style="color:#e6db74">&#39;bbb</span>))
</span></span><span style="display:flex;"><span>x <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">aaa</span> <span style="color:#f92672">.</span> bbb)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span> x)
</span></span></code></pre></div><p>注册对象时也可以指定“representative”（即，y）对象。 继续上面的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>y (cons <span style="color:#e6db74">&#39;ccc</span> <span style="color:#e6db74">&#39;ddd</span>))
</span></span><span style="display:flex;"><span>y <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">ccc</span> <span style="color:#f92672">.</span> ddd)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span> y <span style="color:#e6db74">&#39;rep</span>)
</span></span></code></pre></div><p>与守护者关联的一组注册对象在逻辑上细分为两个不相交的子组：一个子组称为“可访问”对象，一个子组称为“不可访问”对象。不可访问的对象是已被证明无法访问的对象（通过guardian机制本身或通过弱序对或暂时序对的car字段除外），可访问的对象是未经证明的对象。“已证明”一词在这里很重要：可能是可访问组中的某些对象确实是不可访问的，但这尚未得到证明。 在某些情况下，直到对象实际上变得不可访问很久之后（在当前实现中，直到发生包含对象的世代的垃圾回收），才可能做出这种证明。</p>
<p>向guardian注册的对象最初被放置在可访问组中，并在它们变得不可访问后的某个时刻移入不可访问组。 不可访问组中的对象是通过调用不带参数的guardian来检索的。 如果不可访问组中没有对象，则guardian返回#f。 继续上面的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span>) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#f</span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>x <span style="color:#66d9ef">#f</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>y <span style="color:#66d9ef">#f</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">collect</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span>) <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">aaa</span> <span style="color:#f92672">.</span> bbb) <span style="color:#75715e">; 也有可能这个后打印出来</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span>) <span style="color:#960050;background-color:#1e0010">⇒</span> rep         <span style="color:#75715e">; 这个先打印出来</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span>) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#f</span>
</span></span></code></pre></div><p>对G的初始调用返回#f，因为绑定到x和y的对是向G注册的唯一对象，并且仍然可以通过这些绑定访问这些序对。调用collect时，对象将移入不可访问的组。 因此，对G的两个调用返回先前绑定到x的序对和先前绑定到y的序对的representative，尽管可能与所示顺序相反。 （如上所述，对于弱序对，如果对象已迁移到较老的一代，则调用collect实际上可能不足以证明该对象不可访问。）</p>
<p>实际上，从guardian那里获取的对象在任何方面都没有特殊的地位。 此功能避免了共享或循环结构可能会出现的问题。 由不可访问对象组成的共享或循环结构将被完整保留，将注册由guardian保护的部分都放置在该guardian不可访问的集合中。 然后，程序员可以完全控制结构的处理顺序。</p>
<p>一个对象可以在guardian处多次注册，在这种情况下，可以多次检索该对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>G (<span style="color:#a6e22e">make-guardian</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>x (cons <span style="color:#e6db74">&#39;aaa</span> <span style="color:#e6db74">&#39;bbb</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span> x)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span> x)
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>x <span style="color:#66d9ef">#f</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">collect</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span>) <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">aaa</span> <span style="color:#f92672">.</span> bbb)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span>) <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">aaa</span> <span style="color:#f92672">.</span> bbb)
</span></span></code></pre></div><p>它也可以向不止一个guardian注册，并且guardian本身也可以向其他guardian注册。
在没有“representative”的情况下向guardian注册的对象，并放置在一个弱序对或暂时对的car字段中，其直到从guardian处将返回并由程序丢弃，或者直到guardian本身被丢弃为止。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>G (<span style="color:#a6e22e">make-guardian</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>x (cons <span style="color:#e6db74">&#39;aaa</span> <span style="color:#e6db74">&#39;bbb</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>p (<span style="color:#a6e22e">weak-cons</span> x <span style="color:#f92672">&#39;</span>()))
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span> x)
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>x <span style="color:#66d9ef">#f</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">collect</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>y (<span style="color:#a6e22e">G</span>))
</span></span><span style="display:flex;"><span>y <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">aaa</span> <span style="color:#f92672">.</span> bbb)
</span></span><span style="display:flex;"><span>(car p) <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">aaa</span> <span style="color:#f92672">.</span> bbb)
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>y <span style="color:#66d9ef">#f</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">collect</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>(car p) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#f92672">#</span>!bwp
</span></span></code></pre></div><p>另一方面，如果指定了representative（对象本身除外），则在从guardian处获得representative的同时，也会从弱序对或暂时序对的car字段中丢弃受保护的对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>G (<span style="color:#a6e22e">make-guardian</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>x (cons <span style="color:#e6db74">&#39;aaa</span> <span style="color:#e6db74">&#39;bbb</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>p (<span style="color:#a6e22e">weak-cons</span> x <span style="color:#f92672">&#39;</span>()))
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span> x <span style="color:#e6db74">&#39;rep</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>x <span style="color:#66d9ef">#f</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">collect</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span>) <span style="color:#960050;background-color:#1e0010">⇒</span> rep  <span style="color:#75715e">; 获得representative的值</span>
</span></span><span style="display:flex;"><span>(car p) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#f92672">#</span>!bwp <span style="color:#75715e">; 自动丢弃</span>
</span></span></code></pre></div><p>下面的示例说明了当guardian本身丢弃时，该对象已被释放并且弱序对的car字段设置为#!bwp：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>G (<span style="color:#a6e22e">make-guardian</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>x (cons aaa <span style="color:#e6db74">&#39;bbb</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>p (<span style="color:#a6e22e">weak-cons</span> x <span style="color:#f92672">&#39;</span>()))
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">G</span> x)
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>x <span style="color:#66d9ef">#f</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">set! </span>G <span style="color:#66d9ef">#f</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">collect</span>)
</span></span><span style="display:flex;"><span>(car p) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#f92672">#</span>!bwp
</span></span></code></pre></div><p>下面的示例演示了如何使用guardian来释放外部存储，就像由C库“malloc”和“free”操作管理存储。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>malloc
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">let </span>([malloc-guardian (<span style="color:#a6e22e">make-guardian</span>)])
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">size</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">; first free any storage that has been dropped.  to avoid long</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">; delays, it might be better to deallocate no more than, say,</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">; ten objects for each one allocated</span>
</span></span><span style="display:flex;"><span>      (<span style="color:#66d9ef">let </span>f ()
</span></span><span style="display:flex;"><span>        (<span style="color:#66d9ef">let </span>([x (<span style="color:#a6e22e">malloc-guardian</span>)])
</span></span><span style="display:flex;"><span>          (<span style="color:#a6e22e">when</span> x
</span></span><span style="display:flex;"><span>		    (<span style="color:#a6e22e">do-free</span> x)
</span></span><span style="display:flex;"><span>			(<span style="color:#a6e22e">f</span>))))
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">; then allocate and register the new storage</span>
</span></span><span style="display:flex;"><span>      (<span style="color:#66d9ef">let </span>([x (<span style="color:#a6e22e">do-malloc</span> size)])
</span></span><span style="display:flex;"><span>        (<span style="color:#a6e22e">malloc-guardian</span> x)
</span></span><span style="display:flex;"><span>        x))))
</span></span></code></pre></div><p><strong>do-malloc</strong>必须返回一个Scheme对象“header”，该header封装一个指向外部存储的指针（可能是无符号整数），并且必须通过此header对外部存储进行所有访问。特别是，必须注意在删除相应的header之后，在Scheme之外不存在指向外部存储的指针。 <strong>do-free</strong>必须使用封装的指针释放外部存储。这两个原语都可以使用外部分配和外部无关的定义，也可以作为外部过程导入的C库“malloc”和“free”运算符进行定义。</p>
<p>如果不希望调用malloc来释放存储，则可以使用collect-request处理器来检查并释放已丢弃的存储，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>malloc)
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">let </span>([malloc-guardian (<span style="color:#a6e22e">make-guardian</span>)])
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">set! </span>malloc
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">size</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">; allocate and register the new storage</span>
</span></span><span style="display:flex;"><span>      (<span style="color:#66d9ef">let </span>([x (<span style="color:#a6e22e">do-malloc</span> size)])
</span></span><span style="display:flex;"><span>        (<span style="color:#a6e22e">malloc-guardian</span> x)
</span></span><span style="display:flex;"><span>        x)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">collect-request-handler</span>
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">lambda </span>()
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">; first, invoke the collector</span>
</span></span><span style="display:flex;"><span>      (<span style="color:#a6e22e">collect</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">; then free any storage that has been dropped</span>
</span></span><span style="display:flex;"><span>      (<span style="color:#66d9ef">let </span>f ()
</span></span><span style="display:flex;"><span>        (<span style="color:#66d9ef">let </span>([x (<span style="color:#a6e22e">malloc-guardian</span>)])
</span></span><span style="display:flex;"><span>          (<span style="color:#a6e22e">when</span> x
</span></span><span style="display:flex;"><span>            (<span style="color:#a6e22e">do-free</span> x)
</span></span><span style="display:flex;"><span>            (<span style="color:#a6e22e">f</span>)))))))
</span></span></code></pre></div><p>通过一点重构，就有可能将封装的外部地址注册为带header的representative，在这种情况下，do-free将仅将外部地址作为参数。 这将使标头一旦变得不可访问，便可以将其从Scheme堆中删除。</p>
<h3 id="锁对象locking-objects">锁对象Locking Objects<a hidden class="anchor" aria-hidden="true" href="#锁对象locking-objects">#</a></h3>
<p>来自C语言的变量或数据结构到Scheme对象的所有指针，通常应在输入（或重新输入）Scheme之前丢弃。 当无法遵循该准则时，可以通过锁定对象或等效的C库过程Slock_object锁定该对象。</p>
<blockquote>
<p>(lock-object obj)</p></blockquote>
<p>锁定对象可防止存储管理器收回或重定位该对象。 应谨慎使用锁定，因为它会导致内存碎片并增加存储管理开销。</p>
<p>如果未解锁对象，锁定也会导致意外保留存储空间。 可以通过解锁对象或等效的C库过程Sunlock_object来解锁对象。</p>
<p>锁定立即数（例如，fixnum，布尔值和字符）或已被静态化的对象是不必要但无害的。</p>
<blockquote>
<p>(unlock-object obj)</p></blockquote>
<p>通过连续调用<strong>lock-object，Slock_object</strong>或同时调用这两个对象，可以多次锁定对象，在这种情况下，必须先通过相等次数的对<strong>unlock-object</strong>或<strong>Sunlock_object</strong>的调用来将其解锁。</p>
<p>除非存在指向对象的单独的C指针，否则也无需锁定包含在锁定对象中的对象（例如，锁定序对的car中的对象）。也就是说，如果仅允许通过外部对象来间接访问的内部对象，则应将其解锁，以便回收器在回收期间可以自由地重分配它。</p>
<p>解锁立即值（例如，fixnum，布尔值和字符）或已设为静态的对象是不必要的，无效的，但无害。</p>
<blockquote>
<p>(locked-object? obj)</p></blockquote>
<p>返回：如果obj是锁定的，立即的或静态的，返回#t</p>
<p>如果回收器无法重分配或回收obj，则该谓词将返回true，包括立即值，例如fixnums，布尔值和字符以及已设为静态的对象。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://continuation.cn/tags/scheme/">Scheme</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://continuation.cn/">思泉笔谈 | AI-Life</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
