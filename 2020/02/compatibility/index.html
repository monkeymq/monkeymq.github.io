<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>兼容性（Compatibility Features in Chez Scheme） | 思泉笔谈 | AI-Life</title>
<meta name="keywords" content="scheme">
<meta name="description" content="本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可能使用Scheme标准机制。">
<meta name="author" content="">
<link rel="canonical" href="https://continuation.cn/2020/02/compatibility/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://continuation.cn/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://continuation.cn/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://continuation.cn/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://continuation.cn/apple-touch-icon.png">
<link rel="mask-icon" href="https://continuation.cn/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://continuation.cn/2020/02/compatibility/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://continuation.cn/2020/02/compatibility/">
  <meta property="og:site_name" content="思泉笔谈 | AI-Life">
  <meta property="og:title" content="兼容性（Compatibility Features in Chez Scheme）">
  <meta property="og:description" content="本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可能使用Scheme标准机制。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-02-18T14:23:39+08:00">
    <meta property="article:modified_time" content="2020-02-18T14:23:39+08:00">
    <meta property="article:tag" content="Scheme">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="兼容性（Compatibility Features in Chez Scheme）">
<meta name="twitter:description" content="本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可能使用Scheme标准机制。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://continuation.cn/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "兼容性（Compatibility Features in Chez Scheme）",
      "item": "https://continuation.cn/2020/02/compatibility/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "兼容性（Compatibility Features in Chez Scheme）",
  "name": "兼容性（Compatibility Features in Chez Scheme）",
  "description": "本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可能使用Scheme标准机制。\n",
  "keywords": [
    "scheme"
  ],
  "articleBody": "本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可能使用Scheme标准机制。\nHash Tables 略过。应使用标准hash table.\nExtend-Syntax Macros 本节介绍了extend-syntax，它是一种功能强大但易于使用的基于模式匹配的语法扩展工具。 使用extend-syntax编写的语法转换与使用define-syntax和syntax-case编写的语法转换相似，不同之处在于extend-syntax产生的转换不会自动遵循词法作用域。\n通常不可能将使用syntax-case编写的语法抽象与使用extend-syntax编写的语法抽象无缝地混合在一起。 通常尽可能只使用其中一种。 仅在迁移到syntax-case时提供了对syntax-case扩展器中extend-syntax的支持。\n(extend-syntax (name key …) (pat fender template) …)\n标识符name 是要定义的句法扩展名或语法关键字。 当系统扩展器处理car为name 的任何list表达式时，将在该表达式上调用extend-syntax生成的语法转换过程。 其余的标识符key … 是在扩展过程中要在输入表达式中识别的其他关键字（例如cond中的else或case）。\nkey列表之后的每个子句都包含一个模式pat ，一个可选的fender 和一个template 。 可选的fender 经常被省略。pat 指定了语法，用于匹配子句。模式中不是关键字（模式变量）的标识符绑定到输入表达式的相应部分。fender 如果存在，则是Scheme表达式，它指定输入表达式（通过模式变量访问）上的附加约束，必须选择这些约束才能选择子句。template 通常根据模式变量来指定输出采用什么形式。\n在扩展过程中，转换过程extend-syntax会尝试以给定的子句的顺序将输入表达式与每个模式进行匹配。如果输入表达式匹配了某个模式，则将模式变量绑定到输入表达式的相应部分，并对子句的fender （如果有）进行求值。如果fender 返回一个真值，则执行给定的扩展。 如果输入与模式不匹配，或者fender 返回错误值，则转换过程将尝试下一个子句。如果无法选择任何子句，则会引发条件类型**＆assertion**的异常。\n在模式内，省略号（…）可用于指定零个或多个出现的前面的模式片段或原型。类似地，可以在输出中使用省略号来指定零个或多个扩展原型的结构。在这种情况下，扩展原型必须包含输入模式原型的一部分。\n第一个例子，定义了rec, 使用单个关键字，一个子句，且没有fender和省略号\n(extend-syntax (rec) [(rec id val) (let ([id #f]) (set! id val) id)]) 第二个例子，定义了when，展示了如何使用省略号\n(extend-syntax (when) [(when test exp1 exp2 ...) (if test (begin exp1 exp2 ...) #f)]) 下一个示例显示let的定义。 let的定义显示了多个省略号的使用，其中一个用于标识符/值序对，另一个用于body中的表达式。它还表明原型不必是单个标识符，并且在template中可以将原型的各个部分彼此分开。\n(extend-syntax (let) [(let ([x e] ...) b1 b2 ...) ((lambda (x ...) b1 b2 ...) e ...)]) 下一个示例显示let*，其语法与let相同，但是根据let以两个子句（一个用于基本情况，一个用于递归步骤）递归定义，因为它必须产生一个嵌套结构。\n(extend-syntax (let*) [(let* () b1 b2 ...) (let () b1 b2 ...)] [(let* ([x e] more ...) b1 b2 ...) (let ([x e]) (let* (more ...) b1 b2 ...))]) 定义式and需要3个子句。第一个子句对于识别**(and)是必要的，后两个以递归方式定义所有其他and**形式。\n(extend-syntax (and) [(and) #t] [(and x) x] [(and x y ...) (if x (and y ...) #f)]) cond的定义需要四个子句。 与let*一样，必须对cond进行递归描述，部分原因是它会产生嵌套的if表达式，部分原因是一个省略号原型不足以描述所有可能的cond子句。 cond的定义还要求除cond之外，我们还指定else作为关键字。 这是定义：\n(extend-syntax (cond else) [(cond) #f] [(cond (else e1 e2 ...)) (begin e1 e2 ...)] [(cond (test) more ...) (or test (cond more ...))] [(cond (test e1 e2 ...) more ...) (if test (begin e1 e2 ...) (cond more ...))]) 为了使let的语法绝对正确，我们实际上必须要求输入中的绑定标识符是符号。 如果我们输入类似**（let（[3 x]）x）的内容，则不会从let**中得到错误，因为它不会检查验证标识符位置中的对象是否为符号。 相反，lambda可能会抱怨，或者可能是扩展完成很久之后的求值程序。 这是fenders 起作用的地方。\n(extend-syntax (let) [(let ([x e] ...) b1 b2 ...) (andmap symbol? '(x ...)) ((lambda (x ...) b1 b2 ...) e ...)]) ’（x …）上的symbol?的andmap确保每个绑定标识符都是一个符号。 fender 仅仅是Scheme表达式。 在该表达式中，首先使用与子句的template 部分相同的规则来扩展引用的对象。 在这种情况下，将**’（x …）**扩展到标识符/值对中的标识符列表。\nextend-syntax通常可以处理您的一切需求，但是某些语法扩展定义要求能够包含对任意Scheme表达式求值的结果。 该功能由with提供。\n(with ((pat expr) …) template)\nwith仅在extend-syntax内部的template 内有效。 with模式与extend-syntax模式相同，with表达式与extend-syntax的fenders 相同，with模板与extend-syntax模板相同。\nwith可用于引入新的模式标识符，该标识符绑定到extend-syntax模板中的任意Scheme表达式所生成的表达式。 也就是说，with允许从extend-syntax的声明式样式转为full Scheme的过程式样式。\nwith的一种常见用法是在模板中引入临时标识符或临时标识符列表。 如果在extend-syntax框架内执行，with也可用于执行可能笨拙或效率低下的复杂转换。\n例如，or需要使用临时标识符。 我们可以如下定义or：\n(extend-syntax (or) [(or) #f] [(or x) x] [(or x y ...) (let ([temp x]) (if temp temp (or y ...)))]) 这会一直有效，直到将or表达式放置在temp发生的范围内为止，在这种情况下，可能会发生奇怪的事情，因为extend-syntax不尊重词法作用域。 （这是define-syntax优于extend-syntax的原因之一。）\n(let ([temp #t]) (or #f temp)) ⇒ #f 如果将标识符temp换个名字，则一切正常。就可以理解\"extend-syntax不尊重词法作用域\"这句话了。 实际上，上述的(let …)表达式，展开之后就变成了：\n(let ([temp #t]) (let ([temp #f]) (if temp temp (or temp)) ) ) 一种解决方案是，使用gensym和with来创建临时标识符，如下：\n(extend-syntax (or) [(or) #f] [(or x) x] [(or x y ...) (with ([temp (gensym)]) (let ([temp x]) (if temp temp (or y ...))))]) 而且，with可以以extend-syntax无法直接使用的方式来组合输入模式的元素，例如以下folding-plus示例:\n(extend-syntax (folding-plus) [(folding-plus x y) (and (number? 'x) (number? 'y)) (with ([val (+ 'x 'y)]) val)] [(folding-plus x y) (+ x y)]) 如果x和y均为数字常数，则folding-plus折叠为（+ x y）的值。 否则，folding-plus转换为（+ x y）以供以后评估。 fender在扩展时检查操作数是否为数字，并使用with进行求值。 与fender一样，扩展仅在带引号的表达式内执行，因为quote将数据与Scheme表达式的其余部分区分开。\n下面的示例利用with允许我们将模式绑定到表达式这一事实，将模式变量列表绑定到临时符号列表。 此临时列表帮助我们实现sigma语法扩展。 sigma与lambda相似，除了它在标识符列表中分配标识符而不是创建新绑定之外。 它可用于并行执行一系列分配。\n(extend-syntax (sigma) [(sigma (x ...) e1 e2 ...) (with ([(t ...) (map (lambda (x) (gensym)) '(x ...))]) (lambda (t ...) (set! x t) ... e1 e2 ...))]) (let ([x 'a] [y 'b]) ((sigma (x y) (list x y)) y x)) ⇒ (b a) 结构体 本节介绍一种机制，类似于第7.15节的record定义机制，该机制允许使用固定的命名字段集创建数据结构。 与record类型不同，结构体类型不是唯一类型，而是实现为向量。 具体而言，将结构体实现为向量，其长度比字段数大一倍，并且其第一个元素包含该结构体的符号名称。\n将结构体表示为向量可以在某种程度上简化结构体的读取和打印以及结构体定义工具的扩展。但是，它确实有一些缺点。 一个是在不适当的情况下，结构体可能会被错误地视为普通向量。当在程序中处理结构体和向量时，在检查更通用的向量类型之前，必须注意先寻找更具体的结构体类型，例如在一系列cond子句中。一个类似的缺点是，结构体实例容易被有意或无意地“伪造”。 也不可能控制如何打印和读取结构体。\n通过define-structure创建结构体。 每个结构体定义式都定义一个构造过程，一个类型谓词，每个字段的访问过程以及每个字段的分配过程。define-structure允许程序员控制哪些字段是构造函数过程的参数，以及哪些字段由构造函数过程显式初始化。define-structure非常简单，但对于大多数应用程序来说足够强大，如果还不足以应付应用程序的需求还可以很容易的扩展以满足之。 本节末尾给出的define-structure定义可以作为更复杂变体的起点。\n(define-structure (name id1 …) ((id2 expr) …))\ndefine-structure形式可以出现在任意位置。\ndefine-structure定义一个新的数据结构name ，并创建一组用于构造和操作该结构实例的过程。 标识符id1 … 和id2 … 命名数据结构的字段。\n下面的过程都有define-structure定义：\n名为**make-**name 的构造过程 名为name? 的类型谓词 对于每一个字段id1 … 和id2 … ，都有名为name-field 的访问过程 对于每一个字段id1 … 和id2 … ，都有名为**set-**name-field! 的分配过程 标识符id1 … 命名的字段由构造函数的参数初始化。 由标识符id2 … 命名的字段被显式初始化为表达式expr … 的值。每个表达式都在标识符id1 … （绑定到相应的字段值）的范围内进行求值，并且在标识符id2 … （绑定到相应的字段值）的范围内出现（类似let*） 。\n为了清晰起见，构造函数的行为就像定义为：\n(define make-name (lambda (id1 ...) (let* ([id2 expr ] ...) body ))) 其中body 根据标识符id1 … 和id2 … 的值构建结构体。\n如果不需要除构造函数过程的参数初始化的字段以外的其他字段，则可以省略第二个子表达式*( (id2 expr) …)* 。\n以下简单示例演示了如何在Scheme中定义pair（如果它们不存在的话）。 这两个字段都由构造函数过程的参数初始化。\n(define-structure (pare car cdr)) (define p (make-pare ’a ’b)) (pare? p) ⇒ #t (pair? p) ⇒ #f (pare? ’(a . b)) ⇒ #f (pare-car p) ⇒ a (pare-cdr p) ⇒ b (set-pare-cdr! p (make-pare 'b 'c)) (pare-car (pare-cdr p)) ⇒ b (pare-cdr (pare-cdr p)) ⇒ c 以下示例定义了一个方便的字符串数据结构，称为strext-string ，该结构会根据需要增长。本例子中，会显式地初始化一个字段的值，该字段在构造函数中定义。\n(define-structure (stretch-string length fill) ([string (make-string length fill)])) (define stretch-string-ref (lambda (s i) (let ([n (stretch-string-length s)]) (when (\u003e= i n) (stretch-stretch-string! s (+ i 1) n)) (string-ref (stretch-string-string s) i)))) (define stretch-string-set! (lambda (s i c) (let ([n (stretch-string-length s)]) (when (\u003e= i n) (stretch-stretch-string! s (+ i 1) n)) (string-set! (stretch-string-string s) i c)))) (define stretch-string-fill! (lambda (s c) (string-fill! (stretch-string-string s) c) (set-stretch-string-fill! s c))) (define stretch-stretch-string! (lambda (s i n) (set-stretch-string-length! s i) (let ([str (stretch-string-string s)] [fill (stretch-string-fill s)]) (let ([xtra (make-string (- i n) fill)]) (set-stretch-string-string! s (string-append str xtra)))))) 通常，大多数自动定义的过程都用于定义更特殊的过程， 在这个例子中，说的就是stretch-string-ref ** 和stretch-string-set!。而stretch-string-length** 和 stretch-string-string是惟一直接使用的自动生成的过程。\n(define ss (make-stretch-string 2 #\\X)) (stretch-string-string ss) ⇒ \"XX\" (stretch-string-ref ss 3) ⇒ #\\X (stretch-string-length ss) ⇒ 4 (stretch-string-string ss) ⇒ \"XXXX\" (stretch-string-fill! ss #\\@) (stretch-string-string ss) ⇒ \"@@@@\" (stretch-string-ref ss 5) ⇒ #\\@ (stretch-string-string ss) ⇒ \"@@@@@@\" (stretch-string-set! ss 7 #\\=) (stretch-string-length ss) ⇒ 8 (stretch-string-string ss) ⇒ \"@@@@@@@=\" 《The Scheme Programming Language》（第4版）的8.4节定义了define-structure的简化变体，作为使用syntax-case的示例。 下面给出的定义实现了完整版本。\n(define-syntax define-structure (lambda (x) (define gen-id (lambda (template-id . args) (datum-\u003esyntax template-id (string-\u003esymbol (apply string-append (map (lambda (x) (if (string? x) x (symbol-\u003estring (syntax-\u003edatum x)))) args)))))) (syntax-case x () ((_ (name field1 ...)) (andmap identifier? #'(name field1 ...)) #'(define-structure (name field1 ...) ())) ((_ (name field1 ...) ((field2 init) ...)) (andmap identifier? #'(name field1 ... field2 ...)) (with-syntax ((constructor (gen-id #'name \"make-\" #'name)) (predicate (gen-id #'name #'name \"?\")) ((access ...) (map (lambda (x) (gen-id x #'name \"-\" x)) #'(field1 ... field2 ...))) ((assign ...) (map (lambda (x) (gen-id x \"set-\" #'name \"-\" x \"!\")) #'(field1 ... field2 ...))) (structure-length (+ (length #'(field1 ... field2 ...)) 1)) ((index ...) (let f ([i 1] [ids #'(field1 ... field2 ...)]) (if (null? ids) '() (cons i (f (+ i 1) (cdr ids))))))) #'(begin (define constructor (lambda (field1 ...) (let* ([field2 init] ...) (vector 'name field1 ... field2 ...)))) (define predicate (lambda (x) (and (vector? x) (#3%fx= (vector-length x) structure-length) (eq? (vector-ref x 0) 'name)))) (define access (lambda (x) (vector-ref x index))) ... (define assign (lambda (x update) (vector-set! x index update))) ...)))))) ",
  "wordCount" : "4765",
  "inLanguage": "zh",
  "datePublished": "2020-02-18T14:23:39+08:00",
  "dateModified": "2020-02-18T14:23:39+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://continuation.cn/2020/02/compatibility/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "思泉笔谈 | AI-Life",
    "logo": {
      "@type": "ImageObject",
      "url": "https://continuation.cn/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://continuation.cn/" accesskey="h" title="思泉笔谈 | AI-Life (Alt + H)">思泉笔谈 | AI-Life</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://continuation.cn/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://continuation.cn/posts" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://continuation.cn/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://continuation.cn/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://continuation.cn/about" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      兼容性（Compatibility Features in Chez Scheme）
    </h1>
    <div class="post-meta"><span title='2020-02-18 14:23:39 +0800 CST'>二月 18, 2020</span>

</div>
  </header> 
  <div class="post-content"><p>本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可能使用Scheme标准机制。</p>
<h3 id="hash-tables">Hash Tables<a hidden class="anchor" aria-hidden="true" href="#hash-tables">#</a></h3>
<p>略过。应使用标准hash table.</p>
<h3 id="extend-syntax-macros">Extend-Syntax Macros<a hidden class="anchor" aria-hidden="true" href="#extend-syntax-macros">#</a></h3>
<p>本节介绍了<strong>extend-syntax</strong>，它是一种功能强大但易于使用的基于模式匹配的语法扩展工具。 使用<strong>extend-syntax</strong>编写的语法转换与使用<strong>define-syntax</strong>和<strong>syntax-case</strong>编写的语法转换相似，不同之处在于<strong>extend-syntax</strong>产生的转换不会自动遵循词法作用域。</p>
<p>通常不可能将使用<strong>syntax-case</strong>编写的语法抽象与使用<strong>extend-syntax</strong>编写的语法抽象无缝地混合在一起。 通常尽可能只使用其中一种。 仅在迁移到<strong>syntax-case</strong>时提供了对<strong>syntax-case</strong>扩展器中<strong>extend-syntax</strong>的支持。</p>
<blockquote>
<p>(extend-syntax (name key &hellip;) (pat fender template) &hellip;)</p></blockquote>
<p>标识符<em>name</em> 是要定义的句法扩展名或语法关键字。 当系统扩展器处理car为<em>name</em> 的任何list表达式时，将在该表达式上调用<strong>extend-syntax</strong>生成的语法转换过程。 其余的标识符<em>key &hellip;</em> 是在扩展过程中要在输入表达式中识别的其他关键字（例如cond中的else或case）。</p>
<p>key列表之后的每个子句都包含一个模式<em>pat</em> ，一个可选的<em>fender</em> 和一个<em>template</em> 。 可选的<em>fender</em> 经常被省略。<em>pat</em> 指定了语法，用于匹配子句。模式中不是关键字（模式变量）的标识符绑定到输入表达式的相应部分。<em>fender</em> 如果存在，则是Scheme表达式，它指定输入表达式（通过模式变量访问）上的附加约束，必须选择这些约束才能选择子句。<em>template</em> 通常根据模式变量来指定输出采用什么形式。</p>
<p>在扩展过程中，转换过程<strong>extend-syntax</strong>会尝试以给定的子句的顺序将输入表达式与每个模式进行匹配。如果输入表达式匹配了某个模式，则将模式变量绑定到输入表达式的相应部分，并对子句的<em>fender</em> （如果有）进行求值。如果<em>fender</em> 返回一个真值，则执行给定的扩展。 如果输入与模式不匹配，或者<em>fender</em> 返回错误值，则转换过程将尝试下一个子句。如果无法选择任何子句，则会引发条件类型**＆assertion**的异常。</p>
<p>在模式内，省略号（&hellip;）可用于指定零个或多个出现的前面的模式片段或原型。类似地，可以在输出中使用省略号来指定零个或多个扩展原型的结构。在这种情况下，扩展原型必须包含输入模式原型的一部分。</p>
<p>第一个例子，定义了<strong>rec</strong>, 使用单个关键字，一个子句，且没有fender和省略号</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">extend-syntax</span> (<span style="color:#a6e22e">rec</span>)
</span></span><span style="display:flex;"><span>  [(<span style="color:#a6e22e">rec</span> id val)
</span></span><span style="display:flex;"><span>   (<span style="color:#66d9ef">let </span>([id <span style="color:#66d9ef">#f</span>])
</span></span><span style="display:flex;"><span>     (<span style="color:#66d9ef">set! </span>id val)
</span></span><span style="display:flex;"><span>     id)])
</span></span></code></pre></div><p>第二个例子，定义了<strong>when</strong>，展示了如何使用省略号</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">extend-syntax</span> (<span style="color:#a6e22e">when</span>)
</span></span><span style="display:flex;"><span>  [(<span style="color:#a6e22e">when</span> test exp1 exp2 <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>   (<span style="color:#66d9ef">if </span>test (<span style="color:#66d9ef">begin </span>exp1 exp2 <span style="color:#f92672">...</span>) <span style="color:#66d9ef">#f</span>)])
</span></span></code></pre></div><p>下一个示例显示let的定义。 let的定义显示了多个省略号的使用，其中一个用于标识符/值序对，另一个用于body中的表达式。它还表明原型不必是单个标识符，并且在template中可以将原型的各个部分彼此分开。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">extend-syntax</span> (<span style="color:#a6e22e">let</span>)
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">let </span>([x e] <span style="color:#f92672">...</span>) b1 b2 <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>   ((<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">...</span>) b1 b2 <span style="color:#f92672">...</span>) e <span style="color:#f92672">...</span>)])
</span></span></code></pre></div><p>下一个示例显示let*，其语法与let相同，但是根据let以两个子句（一个用于基本情况，一个用于递归步骤）递归定义，因为它必须产生一个嵌套结构。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">extend-syntax</span> (<span style="color:#a6e22e">let*</span>)
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">let* </span>() b1 b2 <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>   (<span style="color:#66d9ef">let </span>() b1 b2 <span style="color:#f92672">...</span>)]
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">let* </span>([x e] more <span style="color:#f92672">...</span>) b1 b2 <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>   (<span style="color:#66d9ef">let </span>([x e]) (<span style="color:#66d9ef">let* </span>(<span style="color:#a6e22e">more</span> <span style="color:#f92672">...</span>) b1 b2 <span style="color:#f92672">...</span>))])
</span></span></code></pre></div><p>定义式<strong>and</strong>需要3个子句。第一个子句对于识别**(and)<strong>是必要的，后两个以递归方式定义所有其他</strong>and**形式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">extend-syntax</span> (<span style="color:#a6e22e">and</span>)
</span></span><span style="display:flex;"><span>  [(<span style="color:#a6e22e">and</span>) <span style="color:#66d9ef">#t</span>]
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">and </span>x) x]
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">and </span>x y <span style="color:#f92672">...</span>) (<span style="color:#66d9ef">if </span>x (<span style="color:#66d9ef">and </span>y <span style="color:#f92672">...</span>) <span style="color:#66d9ef">#f</span>)])
</span></span></code></pre></div><p><strong>cond</strong>的定义需要四个子句。 与<strong>let*<strong>一样，必须对cond进行递归描述，部分原因是它会产生嵌套的</strong>if</strong>表达式，部分原因是一个省略号原型不足以描述所有可能的<strong>cond</strong>子句。 <strong>cond</strong>的定义还要求除<strong>cond</strong>之外，我们还指定<strong>else</strong>作为关键字。 这是定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">extend-syntax</span> (<span style="color:#66d9ef">cond </span>else)
</span></span><span style="display:flex;"><span>  [(<span style="color:#a6e22e">cond</span>) <span style="color:#66d9ef">#f</span>]
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">cond </span>(<span style="color:#66d9ef">else </span>e1 e2 <span style="color:#f92672">...</span>))
</span></span><span style="display:flex;"><span>   (<span style="color:#66d9ef">begin </span>e1 e2 <span style="color:#f92672">...</span>)]
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">cond </span>(<span style="color:#a6e22e">test</span>) more <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>   (<span style="color:#66d9ef">or </span>test (<span style="color:#66d9ef">cond </span>more <span style="color:#f92672">...</span>))]
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">cond </span>(<span style="color:#a6e22e">test</span> e1 e2 <span style="color:#f92672">...</span>) more <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>   (<span style="color:#66d9ef">if </span>test
</span></span><span style="display:flex;"><span>       (<span style="color:#66d9ef">begin </span>e1 e2 <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>       (<span style="color:#66d9ef">cond </span>more <span style="color:#f92672">...</span>))])
</span></span></code></pre></div><p>为了使<strong>let</strong>的语法绝对正确，我们实际上必须要求输入中的绑定标识符是符号。 如果我们输入类似**（let（[3 x]）x）<strong>的内容，则不会从</strong>let**中得到错误，因为它不会检查验证标识符位置中的对象是否为符号。 相反，lambda可能会抱怨，或者可能是扩展完成很久之后的求值程序。 这是<em>fenders</em> 起作用的地方。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">extend-syntax</span> (<span style="color:#a6e22e">let</span>)
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">let </span>([x e] <span style="color:#f92672">...</span>) b1 b2 <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>   (<span style="color:#a6e22e">andmap</span> symbol? <span style="color:#f92672">&#39;</span>(x <span style="color:#f92672">...</span>))
</span></span><span style="display:flex;"><span>   ((<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">...</span>) b1 b2 <span style="color:#f92672">...</span>) e <span style="color:#f92672">...</span>)])
</span></span></code></pre></div><p><strong>&rsquo;（x &hellip;）<strong>上的</strong>symbol?<strong>的</strong>andmap</strong>确保每个绑定标识符都是一个符号。 <em>fender</em> 仅仅是Scheme表达式。 在该表达式中，首先使用与子句的<em>template</em> 部分相同的规则来扩展引用的对象。 在这种情况下，将**&rsquo;（x &hellip;）**扩展到标识符/值对中的标识符列表。</p>
<p><strong>extend-syntax</strong>通常可以处理您的一切需求，但是某些语法扩展定义要求能够包含对任意Scheme表达式求值的结果。 该功能由<strong>with</strong>提供。</p>
<blockquote>
<p>(with ((pat expr) &hellip;) template)</p></blockquote>
<p><strong>with</strong>仅在<strong>extend-syntax</strong>内部的<em>template</em> 内有效。 <strong>with</strong>模式与<strong>extend-syntax</strong>模式相同，<strong>with</strong>表达式与<strong>extend-syntax</strong>的<em>fenders</em> 相同，<strong>with</strong>模板与<strong>extend-syntax</strong>模板相同。</p>
<p><strong>with</strong>可用于引入新的模式标识符，该标识符绑定到<strong>extend-syntax</strong>模板中的任意Scheme表达式所生成的表达式。 也就是说，<strong>with</strong>允许从<strong>extend-syntax</strong>的声明式样式转为full Scheme的过程式样式。</p>
<p><strong>with</strong>的一种常见用法是在模板中引入临时标识符或临时标识符列表。 如果在<strong>extend-syntax</strong>框架内执行，<strong>with</strong>也可用于执行可能笨拙或效率低下的复杂转换。</p>
<p>例如，<strong>or</strong>需要使用临时标识符。 我们可以如下定义<strong>or</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">extend-syntax</span> (<span style="color:#a6e22e">or</span>)
</span></span><span style="display:flex;"><span>  [(<span style="color:#a6e22e">or</span>) <span style="color:#66d9ef">#f</span>]
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">or </span>x) x]
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">or </span>x y <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>   (<span style="color:#66d9ef">let </span>([temp x])
</span></span><span style="display:flex;"><span>     (<span style="color:#66d9ef">if </span>temp temp (<span style="color:#66d9ef">or </span>y <span style="color:#f92672">...</span>)))])
</span></span></code></pre></div><p>这会一直有效，直到将<strong>or</strong>表达式放置在<strong>temp</strong>发生的范围内为止，在这种情况下，可能会发生奇怪的事情，因为<strong>extend-syntax</strong>不尊重词法作用域。 （这是<strong>define-syntax</strong>优于<strong>extend-syntax</strong>的原因之一。）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">let </span>([temp <span style="color:#66d9ef">#t</span>])
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">or </span><span style="color:#66d9ef">#f</span> temp)) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#f</span>
</span></span></code></pre></div><blockquote>
<p>如果将标识符temp换个名字，则一切正常。就可以理解&quot;<strong>extend-syntax</strong>不尊重词法作用域&quot;这句话了。 实际上，上述的(let &hellip;)表达式，展开之后就变成了：</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">let </span>([temp <span style="color:#66d9ef">#t</span>])
</span></span><span style="display:flex;"><span>   (<span style="color:#66d9ef">let </span>([temp <span style="color:#66d9ef">#f</span>])
</span></span><span style="display:flex;"><span>       (<span style="color:#66d9ef">if </span>temp temp (<span style="color:#66d9ef">or </span>temp))
</span></span><span style="display:flex;"><span>   )
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>一种解决方案是，使用<strong>gensym</strong>和<strong>with</strong>来创建临时标识符，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">extend-syntax</span> (<span style="color:#a6e22e">or</span>)
</span></span><span style="display:flex;"><span>  [(<span style="color:#a6e22e">or</span>) <span style="color:#66d9ef">#f</span>]
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">or </span>x) x]
</span></span><span style="display:flex;"><span>  [(<span style="color:#66d9ef">or </span>x y <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>   (<span style="color:#a6e22e">with</span> ([temp (<span style="color:#a6e22e">gensym</span>)])
</span></span><span style="display:flex;"><span>     (<span style="color:#66d9ef">let </span>([temp x])
</span></span><span style="display:flex;"><span>	   (<span style="color:#66d9ef">if </span>temp temp (<span style="color:#66d9ef">or </span>y <span style="color:#f92672">...</span>))))])
</span></span></code></pre></div><p>而且，<strong>with</strong>可以以<strong>extend-syntax</strong>无法直接使用的方式来组合输入模式的元素，例如以下<strong>folding-plus</strong>示例:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">extend-syntax</span> (<span style="color:#a6e22e">folding-plus</span>)
</span></span><span style="display:flex;"><span>  [(<span style="color:#a6e22e">folding-plus</span> x y)
</span></span><span style="display:flex;"><span>   (<span style="color:#66d9ef">and </span>(number? <span style="color:#e6db74">&#39;x</span>) (number? <span style="color:#e6db74">&#39;y</span>))
</span></span><span style="display:flex;"><span>   (<span style="color:#a6e22e">with</span> ([val (+ <span style="color:#e6db74">&#39;x</span> <span style="color:#e6db74">&#39;y</span>)])
</span></span><span style="display:flex;"><span>      val)]
</span></span><span style="display:flex;"><span>  [(<span style="color:#a6e22e">folding-plus</span> x y) (+ x y)])
</span></span></code></pre></div><p>如果x和y均为数字常数，则folding-plus折叠为（+ x y）的值。 否则，folding-plus转换为（+ x y）以供以后评估。 fender在扩展时检查操作数是否为数字，并使用with进行求值。 与fender一样，扩展仅在带引号的表达式内执行，因为quote将数据与Scheme表达式的其余部分区分开。</p>
<p>下面的示例利用with允许我们将模式绑定到表达式这一事实，将模式变量列表绑定到临时符号列表。 此临时列表帮助我们实现sigma语法扩展。 sigma与lambda相似，除了它在标识符列表中分配标识符而不是创建新绑定之外。 它可用于并行执行一系列分配。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">extend-syntax</span> (<span style="color:#a6e22e">sigma</span>)
</span></span><span style="display:flex;"><span>  [(<span style="color:#a6e22e">sigma</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">...</span>) e1 e2 <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>   (<span style="color:#a6e22e">with</span> ([(<span style="color:#a6e22e">t</span> <span style="color:#f92672">...</span>) (map (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">x</span>) (<span style="color:#a6e22e">gensym</span>)) <span style="color:#f92672">&#39;</span>(x <span style="color:#f92672">...</span>))])
</span></span><span style="display:flex;"><span>     (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>       (<span style="color:#66d9ef">set! </span>x t) <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>       e1 e2 <span style="color:#f92672">...</span>))])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">let </span>([x <span style="color:#e6db74">&#39;a</span>] [y <span style="color:#e6db74">&#39;b</span>])
</span></span><span style="display:flex;"><span>	((<span style="color:#a6e22e">sigma</span> (<span style="color:#a6e22e">x</span> y) (list x y)) y x)) <span style="color:#960050;background-color:#1e0010">⇒</span> (<span style="color:#a6e22e">b</span> a)
</span></span></code></pre></div><h3 id="结构体">结构体<a hidden class="anchor" aria-hidden="true" href="#结构体">#</a></h3>
<p>本节介绍一种机制，类似于第7.15节的record定义机制，该机制允许使用固定的命名字段集创建数据结构。 与record类型不同，结构体类型不是唯一类型，而是实现为向量。 具体而言，将结构体实现为向量，其长度比字段数大一倍，并且其第一个元素包含该结构体的符号名称。</p>
<p>将结构体表示为向量可以在某种程度上简化结构体的读取和打印以及结构体定义工具的扩展。但是，它确实有一些缺点。 一个是在不适当的情况下，结构体可能会被错误地视为普通向量。当在程序中处理结构体和向量时，在检查更通用的向量类型之前，必须注意先寻找更具体的结构体类型，例如在一系列cond子句中。一个类似的缺点是，结构体实例容易被有意或无意地“伪造”。 也不可能控制如何打印和读取结构体。</p>
<p>通过<strong>define-structure</strong>创建结构体。 每个结构体定义式都定义一个构造过程，一个类型谓词，每个字段的访问过程以及每个字段的分配过程。<strong>define-structure</strong>允许程序员控制哪些字段是构造函数过程的参数，以及哪些字段由构造函数过程显式初始化。<strong>define-structure</strong>非常简单，但对于大多数应用程序来说足够强大，如果还不足以应付应用程序的需求还可以很容易的扩展以满足之。 本节末尾给出的define-structure定义可以作为更复杂变体的起点。</p>
<blockquote>
<p>(define-structure (name id1 &hellip;) ((id2 expr) &hellip;))</p></blockquote>
<p><strong>define-structure</strong>形式可以出现在任意位置。</p>
<p><strong>define-structure</strong>定义一个新的数据结构<em>name</em> ，并创建一组用于构造和操作该结构实例的过程。 标识符<em>id1 &hellip;</em> 和<em>id2 &hellip;</em> 命名数据结构的字段。</p>
<p>下面的过程都有<strong>define-structure</strong>定义：</p>
<ul>
<li>名为**make-**<em>name</em> 的构造过程</li>
<li>名为<em>name?</em> 的类型谓词</li>
<li>对于每一个字段<em>id1 &hellip;</em> 和<em>id2 &hellip;</em> ，都有名为<em>name-field</em> 的访问过程</li>
<li>对于每一个字段<em>id1 &hellip;</em> 和<em>id2 &hellip;</em> ，都有名为**set-**<em>name-field!</em> 的分配过程</li>
</ul>
<p>标识符<em>id1 &hellip;</em> 命名的字段由构造函数的参数初始化。 由标识符<em>id2 &hellip;</em> 命名的字段被显式初始化为表达式<em>expr &hellip;</em> 的值。每个表达式都在标识符<em>id1 &hellip;</em> （绑定到相应的字段值）的范围内进行求值，并且在标识符<em>id2 &hellip;</em> （绑定到相应的字段值）的范围内出现（类似<strong>let*</strong>） 。</p>
<p>为了清晰起见，构造函数的行为就像定义为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>make-name
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">id1</span> <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">let* </span>([id2 expr ] <span style="color:#f92672">...</span>) body )))
</span></span></code></pre></div><p>其中<em>body</em> 根据标识符<em>id1 &hellip;</em> 和<em>id2 &hellip;</em> 的值构建结构体。</p>
<p>如果不需要除构造函数过程的参数初始化的字段以外的其他字段，则可以省略第二个子表达式*( (id2 expr) &hellip;)* 。</p>
<p>以下简单示例演示了如何在Scheme中定义pair（如果它们不存在的话）。 这两个字段都由构造函数过程的参数初始化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">define-structure</span> (<span style="color:#a6e22e">pare</span> car cdr))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>p (<span style="color:#a6e22e">make-pare</span> <span style="color:#960050;background-color:#1e0010">’</span>a <span style="color:#960050;background-color:#1e0010">’</span>b))
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">pare?</span> p) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#t</span>
</span></span><span style="display:flex;"><span>(pair? p) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#f</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">pare?</span> <span style="color:#960050;background-color:#1e0010">’</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">.</span> b)) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#66d9ef">#f</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">pare-car</span> p) <span style="color:#960050;background-color:#1e0010">⇒</span> a
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">pare-cdr</span> p) <span style="color:#960050;background-color:#1e0010">⇒</span> b
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">set-pare-cdr!</span> p (<span style="color:#a6e22e">make-pare</span> <span style="color:#e6db74">&#39;b</span> <span style="color:#e6db74">&#39;c</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">pare-car</span> (<span style="color:#a6e22e">pare-cdr</span> p)) <span style="color:#960050;background-color:#1e0010">⇒</span> b
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">pare-cdr</span> (<span style="color:#a6e22e">pare-cdr</span> p)) <span style="color:#960050;background-color:#1e0010">⇒</span> c
</span></span></code></pre></div><p>以下示例定义了一个方便的字符串数据结构，称为<strong>strext-string</strong> ，该结构会根据需要增长。本例子中，会显式地初始化一个字段的值，该字段在构造函数中定义。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">define-structure</span> (<span style="color:#a6e22e">stretch-string</span> length fill)
</span></span><span style="display:flex;"><span>  ([string (make-string length fill)]))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>stretch-string-ref
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">s</span> i)
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">let </span>([n (<span style="color:#a6e22e">stretch-string-length</span> s)])
</span></span><span style="display:flex;"><span>      (<span style="color:#a6e22e">when</span> (&gt;= i n) (<span style="color:#a6e22e">stretch-stretch-string!</span> s (+ i <span style="color:#ae81ff">1</span>) n))
</span></span><span style="display:flex;"><span>      (string-ref (<span style="color:#a6e22e">stretch-string-string</span> s) i))))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>stretch-string-set!
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">s</span> i c)
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">let </span>([n (<span style="color:#a6e22e">stretch-string-length</span> s)])
</span></span><span style="display:flex;"><span>      (<span style="color:#a6e22e">when</span> (&gt;= i n) (<span style="color:#a6e22e">stretch-stretch-string!</span> s (+ i <span style="color:#ae81ff">1</span>) n))
</span></span><span style="display:flex;"><span>      (string-set! (<span style="color:#a6e22e">stretch-string-string</span> s) i c))))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>stretch-string-fill!
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">s</span> c)
</span></span><span style="display:flex;"><span>    (string-fill! (<span style="color:#a6e22e">stretch-string-string</span> s) c)
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">set-stretch-string-fill!</span> s c)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>stretch-stretch-string!
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">s</span> i n)
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">set-stretch-string-length!</span> s i)
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">let </span>([str (<span style="color:#a6e22e">stretch-string-string</span> s)]
</span></span><span style="display:flex;"><span>          [fill (<span style="color:#a6e22e">stretch-string-fill</span> s)])
</span></span><span style="display:flex;"><span>      (<span style="color:#66d9ef">let </span>([xtra (make-string (- i n) fill)])
</span></span><span style="display:flex;"><span>        (<span style="color:#a6e22e">set-stretch-string-string!</span> s
</span></span><span style="display:flex;"><span>          (string-append str xtra))))))
</span></span></code></pre></div><p>通常，大多数自动定义的过程都用于定义更特殊的过程， 在这个例子中，说的就是<strong>stretch-string-ref ** 和</strong>stretch-string-set!<strong>。而</strong>stretch-string-length** 和 <strong>stretch-string-string</strong>是惟一直接使用的自动生成的过程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>ss (<span style="color:#a6e22e">make-stretch-string</span> <span style="color:#ae81ff">2</span> <span style="color:#e6db74">#\X</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">stretch-string-string</span> ss) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#e6db74">&#34;XX&#34;</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">stretch-string-ref</span> ss <span style="color:#ae81ff">3</span>) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#e6db74">#\X</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">stretch-string-length</span> ss) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">stretch-string-string</span> ss) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#e6db74">&#34;XXXX&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">stretch-string-fill!</span> ss <span style="color:#e6db74">#\@</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">stretch-string-string</span> ss) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#e6db74">&#34;@@@@&#34;</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">stretch-string-ref</span> ss <span style="color:#ae81ff">5</span>) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#e6db74">#\@</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">stretch-string-string</span> ss) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#e6db74">&#34;@@@@@@&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">stretch-string-set!</span> ss <span style="color:#ae81ff">7</span> <span style="color:#e6db74">#\=</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">stretch-string-length</span> ss) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">stretch-string-string</span> ss) <span style="color:#960050;background-color:#1e0010">⇒</span> <span style="color:#e6db74">&#34;@@@@@@@=&#34;</span>
</span></span></code></pre></div><p>《The Scheme Programming Language》（第4版）的8.4节定义了define-structure的简化变体，作为使用syntax-case的示例。 下面给出的定义实现了完整版本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define-syntax </span>define-structure
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">define </span>gen-id
</span></span><span style="display:flex;"><span>      (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">template-id</span> <span style="color:#f92672">.</span> args)
</span></span><span style="display:flex;"><span>        (<span style="color:#a6e22e">datum-&gt;syntax</span> template-id
</span></span><span style="display:flex;"><span>          (<span style="color:#a6e22e">string-&gt;symbol</span>
</span></span><span style="display:flex;"><span>            (apply string-append
</span></span><span style="display:flex;"><span>                   (map (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>                          (<span style="color:#66d9ef">if </span>(string? x)
</span></span><span style="display:flex;"><span>                              x
</span></span><span style="display:flex;"><span>                              (<span style="color:#a6e22e">symbol-&gt;string</span>
</span></span><span style="display:flex;"><span>                                (<span style="color:#a6e22e">syntax-&gt;datum</span> x))))
</span></span><span style="display:flex;"><span>	                    args))))))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">syntax-case</span> x ()
</span></span><span style="display:flex;"><span>      ((<span style="color:#a6e22e">_</span> (<span style="color:#a6e22e">name</span> field1 <span style="color:#f92672">...</span>))
</span></span><span style="display:flex;"><span>       (<span style="color:#a6e22e">andmap</span> identifier? <span style="color:#f92672">#&#39;</span>(name field1 <span style="color:#f92672">...</span>))
</span></span><span style="display:flex;"><span>       <span style="color:#f92672">#&#39;</span>(define-structure (<span style="color:#a6e22e">name</span> field1 <span style="color:#f92672">...</span>) ()))
</span></span><span style="display:flex;"><span>      ((<span style="color:#a6e22e">_</span> (<span style="color:#a6e22e">name</span> field1 <span style="color:#f92672">...</span>) ((<span style="color:#a6e22e">field2</span> init) <span style="color:#f92672">...</span>))
</span></span><span style="display:flex;"><span>       (<span style="color:#a6e22e">andmap</span> identifier? <span style="color:#f92672">#&#39;</span>(name field1 <span style="color:#f92672">...</span> field2 <span style="color:#f92672">...</span>))
</span></span><span style="display:flex;"><span>       (<span style="color:#a6e22e">with-syntax</span>
</span></span><span style="display:flex;"><span>         ((<span style="color:#a6e22e">constructor</span> (<span style="color:#a6e22e">gen-id</span> <span style="color:#f92672">#</span><span style="color:#e6db74">&#39;name</span> <span style="color:#e6db74">&#34;make-&#34;</span> <span style="color:#f92672">#</span><span style="color:#e6db74">&#39;name</span>))
</span></span><span style="display:flex;"><span>          (<span style="color:#a6e22e">predicate</span> (<span style="color:#a6e22e">gen-id</span> <span style="color:#f92672">#</span><span style="color:#e6db74">&#39;name</span> <span style="color:#f92672">#</span><span style="color:#e6db74">&#39;name</span> <span style="color:#e6db74">&#34;?&#34;</span>))
</span></span><span style="display:flex;"><span>          ((<span style="color:#a6e22e">access</span> <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	       (map (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">x</span>) (<span style="color:#a6e22e">gen-id</span> x <span style="color:#f92672">#</span><span style="color:#e6db74">&#39;name</span> <span style="color:#e6db74">&#34;-&#34;</span> x))
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">#&#39;</span>(field1 <span style="color:#f92672">...</span> field2 <span style="color:#f92672">...</span>)))
</span></span><span style="display:flex;"><span>          ((<span style="color:#a6e22e">assign</span> <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>           (map (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">x</span>) (<span style="color:#a6e22e">gen-id</span> x <span style="color:#e6db74">&#34;set-&#34;</span> <span style="color:#f92672">#</span><span style="color:#e6db74">&#39;name</span> <span style="color:#e6db74">&#34;-&#34;</span> x <span style="color:#e6db74">&#34;!&#34;</span>))
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">#&#39;</span>(field1 <span style="color:#f92672">...</span> field2 <span style="color:#f92672">...</span>)))
</span></span><span style="display:flex;"><span>          (<span style="color:#a6e22e">structure-length</span>
</span></span><span style="display:flex;"><span>           (+ (length <span style="color:#f92672">#&#39;</span>(field1 <span style="color:#f92672">...</span> field2 <span style="color:#f92672">...</span>)) <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>          ((<span style="color:#a6e22e">index</span> <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>           (<span style="color:#66d9ef">let </span>f ([i <span style="color:#ae81ff">1</span>] [ids <span style="color:#f92672">#&#39;</span>(field1 <span style="color:#f92672">...</span> field2 <span style="color:#f92672">...</span>)])
</span></span><span style="display:flex;"><span>             (<span style="color:#66d9ef">if </span>(null? ids)
</span></span><span style="display:flex;"><span>				 <span style="color:#f92672">&#39;</span>()
</span></span><span style="display:flex;"><span>                 (cons i (<span style="color:#a6e22e">f</span> (+ i <span style="color:#ae81ff">1</span>) (cdr ids)))))))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	      <span style="color:#f92672">#&#39;</span>(begin
</span></span><span style="display:flex;"><span>             (<span style="color:#66d9ef">define </span>constructor
</span></span><span style="display:flex;"><span>               (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">field1</span> <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>                 (<span style="color:#66d9ef">let* </span>([field2 init] <span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>                   (vector <span style="color:#e6db74">&#39;name</span> field1 <span style="color:#f92672">...</span> field2 <span style="color:#f92672">...</span>))))
</span></span><span style="display:flex;"><span>             (<span style="color:#66d9ef">define </span>predicate
</span></span><span style="display:flex;"><span>               (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>                 (<span style="color:#66d9ef">and </span>(vector? x)
</span></span><span style="display:flex;"><span>                      (<span style="color:#f92672">#</span><span style="color:#ae81ff">3</span>%fx= (vector-length x) structure-length)
</span></span><span style="display:flex;"><span>                      (eq? (vector-ref x <span style="color:#ae81ff">0</span>) <span style="color:#e6db74">&#39;name</span>))))
</span></span><span style="display:flex;"><span>             (<span style="color:#66d9ef">define </span>access (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">x</span>) (vector-ref x index)))
</span></span><span style="display:flex;"><span>             <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>             (<span style="color:#66d9ef">define </span>assign
</span></span><span style="display:flex;"><span>               (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">x</span> update) (vector-set! x index update)))
</span></span><span style="display:flex;"><span>             <span style="color:#f92672">...</span>))))))
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://continuation.cn/tags/scheme/">Scheme</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://continuation.cn/">思泉笔谈 | AI-Life</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
