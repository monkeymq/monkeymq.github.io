<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Racket Modules | 思泉笔谈 | AI-Life</title>
<meta name="keywords" content="racket, module">
<meta name="description" content="模块基础
一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set!
通常，每个Racket模块驻留在自己的文件中，换句话说，可以认为一个.rkt 文件里的内容属于某一个模块，模块名就是文件名。">
<meta name="author" content="">
<link rel="canonical" href="https://continuation.cn/2021/07/racket-modules/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://continuation.cn/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://continuation.cn/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://continuation.cn/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://continuation.cn/apple-touch-icon.png">
<link rel="mask-icon" href="https://continuation.cn/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://continuation.cn/2021/07/racket-modules/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://continuation.cn/2021/07/racket-modules/">
  <meta property="og:site_name" content="思泉笔谈 | AI-Life">
  <meta property="og:title" content="Racket Modules">
  <meta property="og:description" content="模块基础 一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set!
通常，每个Racket模块驻留在自己的文件中，换句话说，可以认为一个.rkt 文件里的内容属于某一个模块，模块名就是文件名。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-07-08T11:00:25+08:00">
    <meta property="article:modified_time" content="2021-07-08T11:00:25+08:00">
    <meta property="article:tag" content="Racket">
    <meta property="article:tag" content="Module">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Racket Modules">
<meta name="twitter:description" content="模块基础
一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set!
通常，每个Racket模块驻留在自己的文件中，换句话说，可以认为一个.rkt 文件里的内容属于某一个模块，模块名就是文件名。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://continuation.cn/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Racket Modules",
      "item": "https://continuation.cn/2021/07/racket-modules/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Racket Modules",
  "name": "Racket Modules",
  "description": "模块基础 一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set!\n通常，每个Racket模块驻留在自己的文件中，换句话说，可以认为一个.rkt 文件里的内容属于某一个模块，模块名就是文件名。\n",
  "keywords": [
    "racket", "module"
  ],
  "articleBody": "模块基础 一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set!\n通常，每个Racket模块驻留在自己的文件中，换句话说，可以认为一个.rkt 文件里的内容属于某一个模块，模块名就是文件名。\n在任意目录下创建一个子目录：mod_demo\n├── mod_demo\n│ ├── ext\n│ │ └── cake.rkt\n│ └── main.rkt\nmod_demo目录下有一个main.rkt模块，和一个ext目录，该目录下有一个cake.rkt的模块。\ncake.rkt的内容如下：\n#lang racket (provide print-cake) (define (print-cake n) (show \" ~a \" n #\\.) (show \" .-~a-. \" n #\\|) (show \" | ~a | \" n #\\space) (show \"---~a---\" n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (provide print-cake) 意味着将函数print-cake导出，在模块外部就可以使用该函数了；还有一个私有的函数show, 该函数未导出，所以外部无法访问。 main.rkt的内容为：\n#lang racket (require \"ext/cake.rkt\") (print-cake (random 30)) (require “ext/cake.rkt”) 将cake模块引入，引用路径符合Unix风格(但是，不能以文件分隔符即’/‘作为开始或者结束)，也支持相对路径，(require “./ext/cake.rkt”) 也是完全可以的。\nCollections collection中的模块通过不带引号的、无后缀的路径引用。例如：以下模块引用了作为“racket” collection一部分的“date.rkt”库：\n#lang racket (require racket/date) (printf \"Today is ~s\\n\" (date-\u003estring (seconds-\u003edate (current-seconds)))) 注意，(require racket/date)没有带双引号。像racket/date这样的模块看起来像一个标识符，当require看到一个未加引号的模块引用时，它会将引用转换为基于collection的模块路径：\n首先，如果未引用的路径不包含 /，然后 require会自动向引用添加一个“/main”。例如，( require slideshow )等效于( require slideshow/main )。 其次，require 向路径隐式添加了“.rkt”后缀。 最后，require通过在已安装的collection中搜索来解析路径，而不是将路径视为相对于封闭模块的路径。 Packages and Collections 一个package是一组通过Racket包管理器安装的库的集合。Racket 程序不直接引用包。相反，程序通过collections引用库，并且添加或删除包会更改可用的基于集合的库集。\n添加Collections library的旨在跨多个项目使用，因此将库的源文件保存在一个目录中并没有意义，更不能将库复制到不同的项目中使用。在这种情况下，最好的选择是新增一个collection，将lib放在collection中，这样就可以使用不带引号的路径引用它，就像Racket 发行版中包含的库一样。\n不用担心，创建一个包无需提交到公开的包服务器，可以安装到本地来使用。\n采用raco pkg命令行工具： raco pkg install –link /path/to/mod_demo\n安装之后，在任何模块中使用(require mod_demo/ext/cake)都会从/path/to/mod_demo/ext/cake.rkt导入print-cake含函数。\n\u003e (require mod_demo/ext/cake) \u003e (print-cake 4) ...... .-||||||-. | | ------------ \u003e 默认情况下，您安装的目录名称既用作包名称又用作包提供的collection\n将lib放入collection之后，仍然可以使用raco make来编译库的源文件，但是使用raco setup更加方便。尤其是修改了模块代码后，使用raco setup会重新编译所有库文件，并重新安装包。与raco make不同的是，raco setup 后面的参数是包名，即raco setup mod_demo, 而raco make后面是模块名，即raco make main.rkt。\n模块语法 模块文件开头处的#lang其实是模块形式的简写，但不能用于REPL。\n模块形式 普通形式的模块声明，可以工作于REPL\n(module name-id initial-module-path decl …)\nname-id是模块的名字，initial-module-path 为初始化导入，每个decl可以是导入，或者导出，或者定义，或者表达式。\ninitial-module-path是必须的，模块内部也是一个环境（SICP中的环境，即上下文），内部使用的指令是需要通过initial-module-path引导的。常用的initial-module-path是racket, require/define/provide等等都来自racket。另一个常用的initial-module-path是racket-base,它提供的功能较少，但仍然是很常用。\n上一节中的“cake.rkt”也可以写成：\n(module cake racket (provide print-cake) (define (print-cake n) (show \" ~a \" n #\\.) (show \" .-~a-. \" n #\\|) (show \" | ~a | \" n #\\space) (show \"---~a---\" n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline))) 这种模块形式是可以被REPL求值的（注意(require ‘cake)， 模块名cake需要被quote，因为这时cake是非文件的模块声明）：\n\u003e (require 'cake) \u003e (print-cake 3) ... .-|||-. | | --------- 声明一个模块，其body不会被立刻求值，只有在显式地被require之后才会求值一次。\n\u003e (module hi racket (printf \"Hello\\n\")) \u003e (require 'hi) Hello \u003e (require 'hi) #lang #lang声明的模块的body没有特定的语法，因为其语法由#lang之后的名称所决定。\n比如，#lang racket的语法是：\n#lang racket decl ... 等同于：\n(module name racket decl ...) name是包含#lang形式的文件名\n子模块 一个模块可以嵌套在另一个模块中，父模块可以直接访问子模块导出的函数、定义、表达式。\n#lang racket (module zoo racket (provide tiger) (define tiger \"Tony\")) (require 'zoo) tiger module* module*形式类似module：\n(module* name-id initial-module-path-or-#f decl ...) module*与module的不同之处在于：\n由module声明的子模块，可以被其父模块require, 但是子模块不能require父模块； 由module*声明的字模块，可以require父模块，但是父模块不能require该子模块； 此外，module*形式可以用#f代替initial-module-path，这意味着，子模块可以访问父模块所以绑定，包括未通过provide导出的绑定。\n因此，用module*和#f来声明一个模块的一个用途是，将某个模块未provide出去的绑定导出。\n#lang racket (provide print-cake) (define (print-cake n) (show \" ~a \" n #\\.) (show \" .-~a-. \" n #\\|) (show \" | ~a | \" n #\\space) (show \"---~a---\" n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (module* extras #f (provide show)) 尽管show函数未导出，但是子模块extras却将其导出了，外部程序可以使用(require (submod “caske.rkt” extras))来访问隐藏的show函数。\nMain和Test子模块 #lang racket (define (print-cake n) (show \" ~a \" n #\\.) (show \" .-~a-. \" n #\\|) (show \" | ~a | \" n #\\space) (show \"---~a---\" n #\\-)) (define (show fmt n ch) (printf fmt (make-string n ch)) (newline)) (module* main #f (print-cake 10)) 这个“cake.rkt”变体，包含了一个main子模块，并调用了print-cake函数。\n一般来说，运行一个模块时并不会运行其中由module*声明的子模块，但是main子模块除外。\nmain子模块并不一定由module*声明，如果不需要使用父模块的绑定，也可以由module来声明。 更常见的做法是由module+来声明\n``lisp (module+ name-id decl …)\nmodule+声明的模块就像采用module*声明且使用#f作为initial-module-path的模块。此外，多个module+模块可以同名，同名的模块会组合成一个模块。这种组合特性可以用来定义一个test模块，在使用 raco test命令时就可以大显身手了。 假设\"physics.rkt\" 为： ```lisp #lang racket (module+ test (require rackunit) (define ε 1e-10)) (provide drop to-energy) (define (drop t) (* 1/2 9.8 t t)) (module+ test (check-= (drop 0) 0 ε) (check-= (drop 10) 490 ε)) (define (to-energy m) (* m (expt 299792458.0 2))) (module+ test (check-= (to-energy 0) 0 ε) (check-= (to-energy 1) 9e+16 1e+15)) 导入\"physics.rkt\" 时，并不会运行drop和to-energy的测试，不过运行raco test physics.rkt将会执行这些测试。\n这等价于使用module*:\n#lang racket (provide drop to-energy) (define (drop t) (* 1/2 49/5 t t)) (define (to-energy m) (* m (expt 299792458 2))) (module* test #f (require rackunit) (define ε 1e-10) (check-= (drop 0) 0 ε) (check-= (drop 10) 490 ε) (check-= (to-energy 0) 0 ε) (check-= (to-energy 1) 9e+16 1e+15)) module+的组合行为对main模块也有帮助，即使不需要组合， ( module+ main …. )也是首选，因为它比( module* main #f …. )更具可读性 。\nRequire require的定义为：\n(require require-spec …)\nonly-in 用来限制模块导出的绑定，也可重命名绑定\n\u003e (module m (lib \"racket\") (provide tastes-great? less-filling?) (define tastes-great? #t) (define less-filling? #t)) \u003e (require (only-in 'm tastes-great?)) \u003e tastes-great? #t \u003e less-filling? less-filling?: undefined; cannot reference an identifier before its definition in module: top-level \u003e (require (only-in 'm [less-filling? lite?])) \u003e lite? #t except-in 是only-in的补充，用来排除某些绑定\n(except-in require-spec id …)\nrename-in 与only-in类似。\n(rename-in require-spec [orig-id bind-id] …)\nprefix-in (prefix-in prefix-id require-spec) 给每一个require-spec的绑定添加前缀\nProvide (provide provide-spec …)\nprovide-spec允许递归定义：\nid: 最简单的形式，上文中多次出现\n(rename-out [orig-id export-id] …): 重命名导出的绑定\n(struct-out struct-id): 导出struct\n(all-defined-out): 导出所有绑定，不推荐\n(all-from-out module-path): 导出所有由module-path指定的绑定\n(except-out provide-spec id …): 排除id指定的绑定\n(prefix-out prefix-id provide-spec)：给每个导出绑定添加一个前缀\n欢迎加入Racket 隐修会 ：731859928(QQ)\n",
  "wordCount" : "3391",
  "inLanguage": "zh",
  "datePublished": "2021-07-08T11:00:25+08:00",
  "dateModified": "2021-07-08T11:00:25+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://continuation.cn/2021/07/racket-modules/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "思泉笔谈 | AI-Life",
    "logo": {
      "@type": "ImageObject",
      "url": "https://continuation.cn/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://continuation.cn/" accesskey="h" title="思泉笔谈 | AI-Life (Alt + H)">思泉笔谈 | AI-Life</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://continuation.cn/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://continuation.cn/posts" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://continuation.cn/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://continuation.cn/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://continuation.cn/about" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Racket Modules
    </h1>
    <div class="post-meta"><span title='2021-07-08 11:00:25 +0800 CST'>七月 8, 2021</span>

</div>
  </header> 
  <div class="post-content"><h2 id="模块基础">模块基础<a hidden class="anchor" aria-hidden="true" href="#模块基础">#</a></h2>
<p>一个模块可以被另一个模块使用，但是模块内部的变量不能直接修改，即set!</p>
<p>通常，每个Racket模块驻留在自己的文件中，换句话说，可以认为一个.rkt 文件里的内容属于某一个模块，模块名就是文件名。</p>
<p>在任意目录下创建一个子目录：mod_demo</p>
<p>├── mod_demo</p>
<p>│   ├── ext</p>
<p>│   │   └── cake.rkt</p>
<p>│   └── main.rkt</p>
<p>mod_demo目录下有一个main.rkt模块，和一个ext目录，该目录下有一个cake.rkt的模块。</p>
<p>cake.rkt的内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>lang racket
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">provide</span> print-cake)
</span></span><span style="display:flex;"><span>(define (print-cake n)
</span></span><span style="display:flex;"><span>  (show <span style="color:#e6db74">&#34;   ~a   &#34;</span> n <span style="color:#e6db74">#\.</span>)
</span></span><span style="display:flex;"><span>  (show <span style="color:#e6db74">&#34; .-~a-. &#34;</span> n <span style="color:#e6db74">#\|</span>)
</span></span><span style="display:flex;"><span>  (show <span style="color:#e6db74">&#34; | ~a | &#34;</span> n <span style="color:#e6db74">#\space</span>)
</span></span><span style="display:flex;"><span>  (show <span style="color:#e6db74">&#34;---~a---&#34;</span> n <span style="color:#e6db74">#\-</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(define (show fmt n ch)
</span></span><span style="display:flex;"><span>  (printf fmt (<span style="color:#a6e22e">make-string</span> n ch))
</span></span><span style="display:flex;"><span>  (newline))
</span></span></code></pre></div><p>(provide print-cake) 意味着将函数print-cake导出，在模块外部就可以使用该函数了；还有一个私有的函数show, 该函数未导出，所以外部无法访问。
main.rkt的内容为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>lang racket
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">require</span> <span style="color:#e6db74">&#34;ext/cake.rkt&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(print-cake (<span style="color:#a6e22e">random</span> <span style="color:#ae81ff">30</span>))
</span></span></code></pre></div><p>(require &ldquo;ext/cake.rkt&rdquo;) 将cake模块引入，引用路径符合Unix风格(但是，不能以文件分隔符即&rsquo;/&lsquo;作为开始或者结束)，也支持相对路径，(require &ldquo;./ext/cake.rkt&rdquo;) 也是完全可以的。</p>
<h3 id="collections">Collections<a hidden class="anchor" aria-hidden="true" href="#collections">#</a></h3>
<p>collection中的模块通过不带引号的、无后缀的路径引用。例如：以下模块引用了作为“racket” collection一部分的“date.rkt”库：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>lang racket
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">require</span> racket/date)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(printf <span style="color:#e6db74">&#34;Today is ~s\n&#34;</span>
</span></span><span style="display:flex;"><span>        (date-&gt;string (seconds-&gt;date (current-seconds))))
</span></span></code></pre></div><p>注意，(require racket/date)没有带双引号。像racket/date这样的模块看起来像一个标识符，当require看到一个未加引号的模块引用时，它会将引用转换为基于collection的模块路径：</p>
<ul>
<li>首先，如果未引用的路径不包含 /，然后 require会自动向引用添加一个“/main”。例如，( require slideshow )等效于( require slideshow/main )。</li>
<li>其次，require 向路径隐式添加了“.rkt”后缀。</li>
<li>最后，require通过在已安装的collection中搜索来解析路径，而不是将路径视为相对于封闭模块的路径。</li>
</ul>
<h3 id="packages-and-collections">Packages and Collections<a hidden class="anchor" aria-hidden="true" href="#packages-and-collections">#</a></h3>
<p>一个package是一组通过Racket包管理器安装的库的集合。Racket 程序不直接引用包。相反，程序通过collections引用库，并且添加或删除包会更改可用的基于集合的库集。</p>
<h3 id="添加collections">添加Collections<a hidden class="anchor" aria-hidden="true" href="#添加collections">#</a></h3>
<p>library的旨在跨多个项目使用，因此将库的源文件保存在一个目录中并没有意义，更不能将库复制到不同的项目中使用。在这种情况下，最好的选择是新增一个collection，将lib放在collection中，这样就可以使用不带引号的路径引用它，就像Racket 发行版中包含的库一样。</p>
<p>不用担心，创建一个包无需提交到公开的包服务器，可以安装到本地来使用。</p>
<blockquote>
<p>采用raco pkg命令行工具：
raco pkg install &ndash;link /path/to/mod_demo</p></blockquote>
<p>安装之后，在任何模块中使用(require mod_demo/ext/cake)都会从/path/to/mod_demo/ext/cake.rkt导入print-cake含函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> (<span style="color:#a6e22e">require</span> mod_demo/ext/cake)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> (print-cake <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">.</span><span style="color:#a6e22e">-</span><span style="color:#960050;background-color:#1e0010">|||||</span>|-.
</span></span><span style="display:flex;"><span> |        <span style="color:#960050;background-color:#1e0010">|</span>
</span></span><span style="display:flex;"><span>------------
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span>
</span></span></code></pre></div><p>默认情况下，您安装的目录名称既用作包名称又用作包提供的collection</p>
<p>将lib放入collection之后，仍然可以使用raco make来编译库的源文件，但是使用raco setup更加方便。尤其是修改了模块代码后，使用raco setup会重新编译所有库文件，并重新安装包。与raco make不同的是，raco setup 后面的参数是包名，即raco setup mod_demo, 而raco make后面是模块名，即raco make main.rkt。</p>
<h2 id="模块语法">模块语法<a hidden class="anchor" aria-hidden="true" href="#模块语法">#</a></h2>
<p>模块文件开头处的#lang其实是模块形式的简写，但不能用于REPL。</p>
<h3 id="模块形式">模块形式<a hidden class="anchor" aria-hidden="true" href="#模块形式">#</a></h3>
<p>普通形式的模块声明，可以工作于REPL</p>
<blockquote>
<p>(module name-id initial-module-path       decl &hellip;)</p></blockquote>
<p>name-id是模块的名字，initial-module-path 为初始化导入，每个decl可以是导入，或者导出，或者定义，或者表达式。</p>
<p>initial-module-path是必须的，模块内部也是一个环境（SICP中的环境，即上下文），内部使用的指令是需要通过initial-module-path引导的。常用的initial-module-path是racket, require/define/provide等等都来自racket。另一个常用的initial-module-path是racket-base,它提供的功能较少，但仍然是很常用。</p>
<p>上一节中的“cake.rkt”也可以写成：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(module cake racket
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">provide</span> print-cake)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  (define (print-cake n)
</span></span><span style="display:flex;"><span>    (show <span style="color:#e6db74">&#34;   ~a   &#34;</span> n <span style="color:#e6db74">#\.</span>)
</span></span><span style="display:flex;"><span>    (show <span style="color:#e6db74">&#34; .-~a-. &#34;</span> n <span style="color:#e6db74">#\|</span>)
</span></span><span style="display:flex;"><span>    (show <span style="color:#e6db74">&#34; | ~a | &#34;</span> n <span style="color:#e6db74">#\space</span>)
</span></span><span style="display:flex;"><span>    (show <span style="color:#e6db74">&#34;---~a---&#34;</span> n <span style="color:#e6db74">#\-</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  (define (show fmt n ch)
</span></span><span style="display:flex;"><span>    (printf fmt (<span style="color:#a6e22e">make-string</span> n ch))
</span></span><span style="display:flex;"><span>    (newline)))
</span></span></code></pre></div><p>这种模块形式是可以被REPL求值的（注意(require &lsquo;cake)， 模块名cake需要被quote，因为这时cake是非文件的模块声明）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> (<span style="color:#a6e22e">require</span> <span style="color:#e6db74">&#39;cake</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> (print-cake <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">.</span><span style="color:#a6e22e">-</span><span style="color:#960050;background-color:#1e0010">||</span>|-.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> |     <span style="color:#960050;background-color:#1e0010">|</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>---------
</span></span></code></pre></div><p>声明一个模块，其body不会被立刻求值，只有在显式地被require之后才会求值一次。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> (module hi racket
</span></span><span style="display:flex;"><span>    (printf <span style="color:#e6db74">&#34;Hello\n&#34;</span>))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> (<span style="color:#a6e22e">require</span> <span style="color:#e6db74">&#39;hi</span>)
</span></span><span style="display:flex;"><span>Hello
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> (<span style="color:#a6e22e">require</span> <span style="color:#e6db74">&#39;hi</span>)
</span></span></code></pre></div><h3 id="lang">#lang<a hidden class="anchor" aria-hidden="true" href="#lang">#</a></h3>
<p>#lang声明的模块的body没有特定的语法，因为其语法由#lang之后的名称所决定。</p>
<p>比如，#lang racket的语法是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>lang racket
</span></span><span style="display:flex;"><span>decl <span style="color:#f92672">...</span>
</span></span></code></pre></div><p>等同于：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(module name racket
</span></span><span style="display:flex;"><span>  decl <span style="color:#f92672">...</span>)
</span></span></code></pre></div><p>name是包含#lang形式的文件名</p>
<h3 id="子模块">子模块<a hidden class="anchor" aria-hidden="true" href="#子模块">#</a></h3>
<p>一个模块可以嵌套在另一个模块中，父模块可以直接访问子模块导出的函数、定义、表达式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>lang racket
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(module zoo racket
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">provide</span> tiger)
</span></span><span style="display:flex;"><span>  (define tiger <span style="color:#e6db74">&#34;Tony&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">require</span> <span style="color:#e6db74">&#39;zoo</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tiger
</span></span></code></pre></div><h4 id="module">module*<a hidden class="anchor" aria-hidden="true" href="#module">#</a></h4>
<p>module*形式类似module：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(module* name-id initial-module-path-or-#f
</span></span><span style="display:flex;"><span>  decl <span style="color:#f92672">...</span>)
</span></span></code></pre></div><p>module*与module的不同之处在于：</p>
<ul>
<li>由module声明的子模块，可以被其父模块require, 但是子模块不能require父模块；</li>
<li>由module*声明的字模块，可以require父模块，但是父模块不能require该子模块；</li>
</ul>
<p>此外，module*形式可以用#f代替initial-module-path，这意味着，子模块可以访问父模块所以绑定，包括未通过provide导出的绑定。</p>
<p>因此，用module*和#f来声明一个模块的一个用途是，将某个模块未provide出去的绑定导出。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>lang racket
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">provide</span> print-cake)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(define (print-cake n)
</span></span><span style="display:flex;"><span>  (show <span style="color:#e6db74">&#34;   ~a   &#34;</span> n <span style="color:#e6db74">#\.</span>)
</span></span><span style="display:flex;"><span>  (show <span style="color:#e6db74">&#34; .-~a-. &#34;</span> n <span style="color:#e6db74">#\|</span>)
</span></span><span style="display:flex;"><span>  (show <span style="color:#e6db74">&#34; | ~a | &#34;</span> n <span style="color:#e6db74">#\space</span>)
</span></span><span style="display:flex;"><span>  (show <span style="color:#e6db74">&#34;---~a---&#34;</span> n <span style="color:#e6db74">#\-</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(define (show fmt n ch)
</span></span><span style="display:flex;"><span>  (printf fmt (<span style="color:#a6e22e">make-string</span> n ch))
</span></span><span style="display:flex;"><span>  (newline))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(module* extras <span style="color:#960050;background-color:#1e0010">#</span>f
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">provide</span> show))
</span></span></code></pre></div><p>尽管show函数未导出，但是子模块extras却将其导出了，外部程序可以使用(require (submod &ldquo;caske.rkt&rdquo; extras))来访问隐藏的show函数。</p>
<h3 id="main和test子模块">Main和Test子模块<a hidden class="anchor" aria-hidden="true" href="#main和test子模块">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>lang racket
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(define (print-cake n)
</span></span><span style="display:flex;"><span>  (show <span style="color:#e6db74">&#34;   ~a   &#34;</span> n <span style="color:#e6db74">#\.</span>)
</span></span><span style="display:flex;"><span>  (show <span style="color:#e6db74">&#34; .-~a-. &#34;</span> n <span style="color:#e6db74">#\|</span>)
</span></span><span style="display:flex;"><span>  (show <span style="color:#e6db74">&#34; | ~a | &#34;</span> n <span style="color:#e6db74">#\space</span>)
</span></span><span style="display:flex;"><span>  (show <span style="color:#e6db74">&#34;---~a---&#34;</span> n <span style="color:#e6db74">#\-</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(define (show fmt n ch)
</span></span><span style="display:flex;"><span>  (printf fmt (<span style="color:#a6e22e">make-string</span> n ch))
</span></span><span style="display:flex;"><span>  (newline))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(module* main <span style="color:#960050;background-color:#1e0010">#</span>f
</span></span><span style="display:flex;"><span>  (print-cake <span style="color:#ae81ff">10</span>))
</span></span></code></pre></div><p>这个“cake.rkt”变体，包含了一个main子模块，并调用了print-cake函数。</p>
<p>一般来说，运行一个模块时并不会运行其中由module*声明的子模块，但是main子模块除外。</p>
<p>main子模块并不一定由module*声明，如果不需要使用父模块的绑定，也可以由module来声明。 更常见的做法是由module+来声明</p>
<p>``lisp
(module+ name-id
decl &hellip;)</p>
<pre tabindex="0"><code>
module+声明的模块就像采用module*声明且使用#f作为initial-module-path的模块。此外，多个module+模块可以同名，同名的模块会组合成一个模块。这种组合特性可以用来定义一个test模块，在使用 raco test命令时就可以大显身手了。

假设&#34;physics.rkt&#34; 为：
```lisp
#lang racket
(module+ test
  (require rackunit)
  (define ε 1e-10))

(provide drop
         to-energy)

(define (drop t)
  (* 1/2 9.8 t t))

(module+ test
  (check-= (drop 0) 0 ε)
  (check-= (drop 10) 490 ε))

(define (to-energy m)
  (* m (expt 299792458.0 2)))

(module+ test
  (check-= (to-energy 0) 0 ε)
  (check-= (to-energy 1) 9e+16 1e+15))
</code></pre><p>导入&quot;physics.rkt&quot; 时，并不会运行drop和to-energy的测试，不过运行raco test physics.rkt将会执行这些测试。</p>
<p>这等价于使用module*:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>lang racket
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">provide</span> drop
</span></span><span style="display:flex;"><span>         to-energy)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(define (drop <span style="color:#66d9ef">t</span>)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">*</span> <span style="color:#ae81ff">1/2</span> <span style="color:#ae81ff">49/5</span> <span style="color:#66d9ef">t</span> <span style="color:#66d9ef">t</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(define (to-energy m)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">*</span> m (<span style="color:#a6e22e">expt</span> <span style="color:#ae81ff">299792458</span> <span style="color:#ae81ff">2</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(module* test <span style="color:#960050;background-color:#1e0010">#</span>f
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">require</span> rackunit)
</span></span><span style="display:flex;"><span>  (define ε <span style="color:#ae81ff">1e-10</span>)
</span></span><span style="display:flex;"><span>  (check-= (drop <span style="color:#ae81ff">0</span>) <span style="color:#ae81ff">0</span> ε)
</span></span><span style="display:flex;"><span>  (check-= (drop <span style="color:#ae81ff">10</span>) <span style="color:#ae81ff">490</span> ε)
</span></span><span style="display:flex;"><span>  (check-= (to-energy <span style="color:#ae81ff">0</span>) <span style="color:#ae81ff">0</span> ε)
</span></span><span style="display:flex;"><span>  (check-= (to-energy <span style="color:#ae81ff">1</span>) <span style="color:#ae81ff">9e+16</span> <span style="color:#ae81ff">1e+15</span>))
</span></span></code></pre></div><p>module+的组合行为对main模块也有帮助，即使不需要组合， ( module+ main &hellip;. )也是首选，因为它比( module* main #f &hellip;. )更具可读性 。</p>
<h2 id="require">Require<a hidden class="anchor" aria-hidden="true" href="#require">#</a></h2>
<p>require的定义为：</p>
<blockquote>
<p>(require require-spec &hellip;)</p></blockquote>
<h3 id="only-in">only-in<a hidden class="anchor" aria-hidden="true" href="#only-in">#</a></h3>
<p>用来限制模块导出的绑定，也可重命名绑定</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> (module m (lib <span style="color:#e6db74">&#34;racket&#34;</span>)
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">provide</span> tastes-great?
</span></span><span style="display:flex;"><span>             less-filling?)
</span></span><span style="display:flex;"><span>    (define tastes-great? <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#66d9ef">t</span>)
</span></span><span style="display:flex;"><span>    (define less-filling? <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#66d9ef">t</span>))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> (<span style="color:#a6e22e">require</span> (only-in <span style="color:#e6db74">&#39;m</span> tastes-great?))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> tastes-great?
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#66d9ef">t</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> less-filling?
</span></span><span style="display:flex;"><span>less-filling?: undefined<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> cannot reference an identifier before its definition
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  in module: top-level
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> (<span style="color:#a6e22e">require</span> (only-in <span style="color:#e6db74">&#39;m</span> [less-filling? lite?]))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">&gt;</span> lite?
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#66d9ef">t</span>
</span></span></code></pre></div><h3 id="except-in">except-in<a hidden class="anchor" aria-hidden="true" href="#except-in">#</a></h3>
<p>是only-in的补充，用来排除某些绑定</p>
<blockquote>
<p>(except-in require-spec id &hellip;)</p></blockquote>
<h3 id="rename-in">rename-in<a hidden class="anchor" aria-hidden="true" href="#rename-in">#</a></h3>
<p>与only-in类似。</p>
<blockquote>
<p>(rename-in require-spec [orig-id bind-id] &hellip;)</p></blockquote>
<h3 id="prefix-in">prefix-in<a hidden class="anchor" aria-hidden="true" href="#prefix-in">#</a></h3>
<blockquote>
<p>(prefix-in prefix-id require-spec)
给每一个require-spec的绑定添加前缀</p></blockquote>
<h2 id="provide">Provide<a hidden class="anchor" aria-hidden="true" href="#provide">#</a></h2>
<blockquote>
<p>(provide provide-spec &hellip;)</p></blockquote>
<p>provide-spec允许递归定义：</p>
<blockquote>
<p>id: 最简单的形式，上文中多次出现</p></blockquote>
<blockquote>
<p>(rename-out [orig-id export-id] &hellip;): 重命名导出的绑定</p></blockquote>
<blockquote>
<p>(struct-out struct-id): 导出struct</p></blockquote>
<blockquote>
<p>(all-defined-out): 导出所有绑定，不推荐</p></blockquote>
<blockquote>
<p>(all-from-out module-path): 导出所有由module-path指定的绑定</p></blockquote>
<blockquote>
<p>(except-out provide-spec id &hellip;): 排除id指定的绑定</p></blockquote>
<blockquote>
<p>(prefix-out prefix-id provide-spec)：给每个导出绑定添加一个前缀</p></blockquote>
<hr>
<p>欢迎加入<strong>Racket 隐修会</strong> ：731859928(QQ)</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://continuation.cn/tags/racket/">Racket</a></li>
      <li><a href="https://continuation.cn/tags/module/">Module</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://continuation.cn/">思泉笔谈 | AI-Life</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
