<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gossip on 思泉笔谈 | AI-Life</title>
    <link>https://lvsq.net/tags/gossip/</link>
    <description>Recent content in gossip on 思泉笔谈 | AI-Life</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 19 Dec 2019 16:07:31 +0800</lastBuildDate>
    
        <atom:link href="https://lvsq.net/tags/gossip/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>基于Chez Scheme重建Racket</title>
      <link>https://lvsq.net/2020/10/rebuilding-racket/</link>
      <pubDate>Tue, 20 Oct 2020 10:49:13 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/10/rebuilding-racket/</guid>
      <description>作者 MATTHEW FLATT, University of Utah,USACANER DERICI, Indiana University, USAR. KENT DYBVIG, Cisco Systems, Inc., USAANDREW W. KEEP, Cisco Systems, Inc., USAGUSTAVO E. MASSACCESI, Universidad de Buenos Aires, ArgentinaSARAH SPALL, Indiana University, USASAM TOBIN-HOCHSTADT, Indiana University, USAJON ZEPPIERI, independent researcher, USA 概要 我们在Chez Scheme上重建了Racket，并且</description>
    </item>
    
    <item>
      <title>Lexical Scoping and Dynamic Scoping</title>
      <link>https://lvsq.net/2020/09/lexical-dynamic-scoping/</link>
      <pubDate>Wed, 23 Sep 2020 11:24:24 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/09/lexical-dynamic-scoping/</guid>
      <description>我相信每一位程序员在学习或者实践编程时，都会遇到作用域的问题。您可能觉得作用域很简单，甚至都不能当做一个问题来看待，我想原因可能是目前主流的</description>
    </item>
    
    <item>
      <title>快速排序（Lisp版本）</title>
      <link>https://lvsq.net/2020/07/quick-sort-in-cl/</link>
      <pubDate>Mon, 20 Jul 2020 14:57:29 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/07/quick-sort-in-cl/</guid>
      <description>快速排序是一种常见的排序手段，由C.A.R.Hoare在1960年提出。其基本思路为： 设定一个分界值，通常为第一个元素； 遍历列表，将所有小于</description>
    </item>
    
    <item>
      <title>从“八皇后”到amb</title>
      <link>https://lvsq.net/2020/05/n-queens/</link>
      <pubDate>Sat, 23 May 2020 15:41:35 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/05/n-queens/</guid>
      <description>讲故事并不是我擅长的事情，不过事情总有一个开始，诸位看官莫嫌我絮烦，只是希望可以讲述的更有条理一些。某日正读一本关于Erlang的书，书中出</description>
    </item>
    
    <item>
      <title>[译]BEAM vs JVM</title>
      <link>https://lvsq.net/2020/05/beam-vs-jvm/</link>
      <pubDate>Thu, 14 May 2020 10:13:25 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/05/beam-vs-jvm/</guid>
      <description>作者是 Francesco Cesarini &amp;amp; Gabor Olah 任何编程语言在Erlang生态系统中的成功都可以分为三个紧密耦合的组件。它们是：1）Erlang编程语言的语义，并在其上实现</description>
    </item>
    
    <item>
      <title>无重复字符的最长子串-Scheme实现</title>
      <link>https://lvsq.net/2020/03/longest-substr/</link>
      <pubDate>Thu, 12 Mar 2020 18:02:45 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/03/longest-substr/</guid>
      <description>实现 下面将使用Scheme语言来实现“无重复字符的最长子串”，即，对于字符串&amp;quot;abbabcx&amp;rdquo;,其最长无重复字符的子串</description>
    </item>
    
    <item>
      <title>使用Golang进行函数式编程</title>
      <link>https://lvsq.net/2020/03/fp-in-go/</link>
      <pubDate>Thu, 12 Mar 2020 10:38:55 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/03/fp-in-go/</guid>
      <description>为什么要用Go练习函数式编程？简而言之，正是由于缺少状态和可变数据，函数式编程使您的代码更易读，更易于测试且不太复杂。如果遇到错误，只要不违</description>
    </item>
    
    <item>
      <title>Scheme实现一个FIFO队列</title>
      <link>https://lvsq.net/2020/03/fifo-queue/</link>
      <pubDate>Fri, 06 Mar 2020 17:35:49 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/03/fifo-queue/</guid>
      <description>闲来无事，用Scheme实现一个FIFO队列，数据从末端插入，从前端删除或者查询。 队列可以看成是由下面一组操作定义的结构： 构造函数 (make</description>
    </item>
    
    <item>
      <title>兼容性（Compatibility Features in Chez Scheme）</title>
      <link>https://lvsq.net/2020/02/compatibility/</link>
      <pubDate>Tue, 18 Feb 2020 14:23:39 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/02/compatibility/</guid>
      <description>本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可</description>
    </item>
    
    <item>
      <title>线程（Thread System in Chez Scheme）</title>
      <link>https://lvsq.net/2020/02/thread/</link>
      <pubDate>Mon, 17 Feb 2020 15:18:39 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/02/thread/</guid>
      <description>下面介绍Chez Scheme线程系统过程和语法形式。 除了锁，锁增量和锁减量之外，线程系统的功能在非基于Windows的系统上在Posix线程</description>
    </item>
    
    <item>
      <title>存储管理(Storage Management in Chez Scheme)</title>
      <link>https://lvsq.net/2020/02/storage-management/</link>
      <pubDate>Wed, 12 Feb 2020 16:18:53 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/02/storage-management/</guid>
      <description>垃圾回收 Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动</description>
    </item>
    
    <item>
      <title>系统操作(System Operations in Chez Scheme)</title>
      <link>https://lvsq.net/2020/02/system-operations/</link>
      <pubDate>Thu, 06 Feb 2020 10:54:14 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/02/system-operations/</guid>
      <description>异常 (warning who msg irritant &amp;hellip;) 返回：未指定 警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止</description>
    </item>
    
    <item>
      <title>Scheme语法define-record-type介绍</title>
      <link>https://lvsq.net/2020/02/define-record-type/</link>
      <pubDate>Mon, 03 Feb 2020 14:51:17 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/02/define-record-type/</guid>
      <description>define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回tr</description>
    </item>
    
    <item>
      <title>Chez Scheme Modules</title>
      <link>https://lvsq.net/2020/01/modules/</link>
      <pubDate>Fri, 17 Jan 2020 15:07:58 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/01/modules/</guid>
      <description>Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以</description>
    </item>
    
    <item>
      <title>自定义 Let*</title>
      <link>https://lvsq.net/2020/01/my-let/</link>
      <pubDate>Fri, 17 Jan 2020 10:13:27 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/01/my-let/</guid>
      <description>实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。 (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_</description>
    </item>
    
    <item>
      <title>Syntactic Extension and Modules in Chez Scheme</title>
      <link>https://lvsq.net/2020/01/syntactic-extension-and-modules/</link>
      <pubDate>Wed, 15 Jan 2020 16:00:51 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/01/syntactic-extension-and-modules/</guid>
      <description>Fluid Keyword Bindings fluid-let-syntax 语法: fluid-let-syntax ((keyword expr) &amp;hellip;) form1 form2 &amp;hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩</description>
    </item>
    
    <item>
      <title>Chez Scheme中Boxes介绍</title>
      <link>https://lvsq.net/2020/01/boxes-in-chez/</link>
      <pubDate>Fri, 03 Jan 2020 14:44:33 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/01/boxes-in-chez/</guid>
      <description>Chez Scheme中有一种Boxes结构，它是一个单元素对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构</description>
    </item>
    
    <item>
      <title>Scheme/Chez Scheme 对象操作</title>
      <link>https://lvsq.net/2019/12/operations-on-objects/</link>
      <pubDate>Mon, 30 Dec 2019 16:27:27 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/12/operations-on-objects/</guid>
      <description>Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x))) (atom? &amp;#39;(a b c)) ⇒ #f (atom? &amp;#39;(3 . 4)) ⇒ #f (atom? &amp;#39;()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) n是一个非负整数，且小于等于list的长度</description>
    </item>
    
    <item>
      <title>Engine in Scheme</title>
      <link>https://lvsq.net/2019/12/engine-in-scheme/</link>
      <pubDate>Fri, 27 Dec 2019 10:30:09 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/12/engine-in-scheme/</guid>
      <description>Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。 (make-engine thunk) 通过传递一个无参数的thun</description>
    </item>
    
    <item>
      <title>Chez Scheme中的case扩展</title>
      <link>https://lvsq.net/2019/12/case-in-chez-scheme/</link>
      <pubDate>Wed, 25 Dec 2019 16:47:08 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/12/case-in-chez-scheme/</guid>
      <description>case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Schem</description>
    </item>
    
  </channel>
</rss>
