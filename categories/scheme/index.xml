<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Scheme on 思泉笔谈 | AI-Life</title>
    <link>https://continuation.cn/categories/scheme/</link>
    <description>Recent content in Scheme on 思泉笔谈 | AI-Life</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 23 May 2020 15:41:35 +0800</lastBuildDate>
    <atom:link href="https://continuation.cn/categories/scheme/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>从“八皇后”到amb</title>
      <link>https://continuation.cn/2020/05/n-queens/</link>
      <pubDate>Sat, 23 May 2020 15:41:35 +0800</pubDate>
      <guid>https://continuation.cn/2020/05/n-queens/</guid>
      <description>&lt;p&gt;讲故事并不是我擅长的事情，不过事情总有一个开始，诸位看官莫嫌我絮烦，只是希望可以讲述的更有条理一些。某日正读一本关于Erlang的书，书中出了一个关于&lt;strong&gt;八皇后&lt;/strong&gt;的题目，这是计算机科学中经典的问题，当年上学时曾绞尽脑汁仍然云山雾罩，不得其解。如今再次相遇，岂能再坐壁上观？！更何况手边已有趁手的兵器。试看Erlang的实现：&lt;/p&gt;</description>
    </item>
    <item>
      <title>无重复字符的最长子串-Scheme实现</title>
      <link>https://continuation.cn/2020/03/longest-substr/</link>
      <pubDate>Thu, 12 Mar 2020 18:02:45 +0800</pubDate>
      <guid>https://continuation.cn/2020/03/longest-substr/</guid>
      <description>&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;
&lt;p&gt;下面将使用Scheme语言来实现“无重复字符的最长子串”，即，对于字符串&amp;quot;abbabcx&amp;quot;,其最长无重复字符的子串为&amp;quot;abcx&amp;quot;，长度4，详细描述可访问&lt;a href=&#34;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&#34;&gt;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scheme实现一个FIFO队列</title>
      <link>https://continuation.cn/2020/03/fifo-queue/</link>
      <pubDate>Fri, 06 Mar 2020 17:35:49 +0800</pubDate>
      <guid>https://continuation.cn/2020/03/fifo-queue/</guid>
      <description>&lt;p&gt;闲来无事，用Scheme实现一个FIFO队列，数据从末端插入，从前端删除或者查询。&lt;/p&gt;
&lt;p&gt;队列可以看成是由下面一组操作定义的结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(make-queue)&lt;!-- raw HTML omitted --&gt;
返回一个空队列&lt;/p&gt;</description>
    </item>
    <item>
      <title>兼容性（Compatibility Features in Chez Scheme）</title>
      <link>https://continuation.cn/2020/02/compatibility/</link>
      <pubDate>Tue, 18 Feb 2020 14:23:39 +0800</pubDate>
      <guid>https://continuation.cn/2020/02/compatibility/</guid>
      <description>&lt;p&gt;本章介绍了当前版本的Chez Scheme中包含的几个项目，主要是为了与系统的较早版本兼容。由于兼容功能可能在未来会被放弃，所以新项目中应尽可能使用Scheme标准机制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程（Thread System in Chez Scheme）</title>
      <link>https://continuation.cn/2020/02/thread/</link>
      <pubDate>Mon, 17 Feb 2020 15:18:39 +0800</pubDate>
      <guid>https://continuation.cn/2020/02/thread/</guid>
      <description>&lt;p&gt;下面介绍Chez Scheme线程系统过程和语法形式。 除了锁，锁增量和锁减量之外，线程系统的功能在非基于Windows的系统上在Posix线程系统（pthreads）之上实现，并在基于Windows的系统上直接使用Windows API。 有关线程创建和交互的基本详细信息，请查阅系统上的相应文档。&lt;/p&gt;</description>
    </item>
    <item>
      <title>存储管理(Storage Management in Chez Scheme)</title>
      <link>https://continuation.cn/2020/02/storage-management/</link>
      <pubDate>Wed, 12 Feb 2020 16:18:53 +0800</pubDate>
      <guid>https://continuation.cn/2020/02/storage-management/</guid>
      <description>&lt;h3 id=&#34;垃圾回收&#34;&gt;垃圾回收&lt;/h3&gt;
&lt;p&gt;Scheme程序不会显式地释放诸如序对，字符串和过程之类的Scheme对象。 相反，一旦存储管理系统证明不再可以访问该对象，它就会自动回收与该对象关联的存储。 为了回收此存储，Chez Scheme使用了一个垃圾收集器，该垃圾收集器在程序运行时定期运行。 垃圾收集器从一组已知的根开始（例如，机器注册），查找所有可访问对象，并在大多数情况下复制它们，以消除可访问对象之间的碎片，并回收不可访问对象所占用的存储。&lt;/p&gt;</description>
    </item>
    <item>
      <title>系统操作(System Operations in Chez Scheme)</title>
      <link>https://continuation.cn/2020/02/system-operations/</link>
      <pubDate>Thu, 06 Feb 2020 10:54:14 +0800</pubDate>
      <guid>https://continuation.cn/2020/02/system-operations/</guid>
      <description>&lt;h3 id=&#34;异常&#34;&gt;异常&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;(warning who msg irritant &amp;hellip;)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;返回：未指定&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;警告会引发条件类型＆warning的持续异常，并应用于描述＆warning条件类型适用的情况，通常是一种不应该阻止程序继续运行但可能在以后导致更严重问题的情况。&lt;!-- raw HTML omitted --&gt;
通常最好是识别程序员已调用的过程，而不是程序员可能不知道的其他过程。 msg必须为字符串，并应描述异常情况。irritant可以是任何Scheme对象，并且应包含可能导致或严重涉及异常情况的值。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scheme语法define-record-type介绍</title>
      <link>https://continuation.cn/2020/02/define-record-type/</link>
      <pubDate>Mon, 03 Feb 2020 14:51:17 +0800</pubDate>
      <guid>https://continuation.cn/2020/02/define-record-type/</guid>
      <description>&lt;h3 id=&#34;define-record-type&#34;&gt;define-record-type&lt;/h3&gt;
&lt;p&gt;Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回true的谓词、以及每个字段的访问procedure和针对可变字段的赋值procedure。总的来说，与Java中的POJO类比较相似，不过不用自定义getter和setter方法，这与Kotlin倒为类似，例如：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Chez Scheme Modules</title>
      <link>https://continuation.cn/2020/01/modules/</link>
      <pubDate>Fri, 17 Jan 2020 15:07:58 +0800</pubDate>
      <guid>https://continuation.cn/2020/01/modules/</guid>
      <description>&lt;h2 id=&#34;modules&#34;&gt;Modules&lt;/h2&gt;
&lt;p&gt;模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以在 Chez Scheme 中以“微模块”级别使用，因为 Chez Scheme 中的模块和 import 形式属于定义，并且可以出现在定义可以出现的任意位置，包括在 lambda 表达式的程序体或其他局部作用域中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>自定义 Let*</title>
      <link>https://continuation.cn/2020/01/my-let/</link>
      <pubDate>Fri, 17 Jan 2020 10:13:27 +0800</pubDate>
      <guid>https://continuation.cn/2020/01/my-let/</guid>
      <description>&lt;p&gt;实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;define-syntax &lt;/span&gt;my-let*
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#66d9ef&#34;&gt;syntax-rules &lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ((&lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; () bodys &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;() bodys &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (&lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; ((&lt;span style=&#34;color:#a6e22e&#34;&gt;a1&lt;/span&gt; v1)) bodys &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;a1&lt;/span&gt; v1)) bodys &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (&lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; ((&lt;span style=&#34;color:#a6e22e&#34;&gt;a1&lt;/span&gt; v1) (&lt;span style=&#34;color:#a6e22e&#34;&gt;a2&lt;/span&gt; v2) &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;) bodys &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;a1&lt;/span&gt; v1)) (&lt;span style=&#34;color:#a6e22e&#34;&gt;my-let*&lt;/span&gt; ((&lt;span style=&#34;color:#a6e22e&#34;&gt;a2&lt;/span&gt; v2) &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;) bodys &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意，my-let*是可以递归使用的，以及**&amp;hellip;**的用法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Syntactic Extension and Modules in Chez Scheme</title>
      <link>https://continuation.cn/2020/01/syntactic-extension-and-modules/</link>
      <pubDate>Wed, 15 Jan 2020 16:00:51 +0800</pubDate>
      <guid>https://continuation.cn/2020/01/syntactic-extension-and-modules/</guid>
      <description>&lt;h2 id=&#34;fluid-keyword-bindings&#34;&gt;Fluid Keyword Bindings&lt;/h2&gt;
&lt;h3 id=&#34;fluid-let-syntax&#34;&gt;fluid-let-syntax&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;语法: fluid-let-syntax ((keyword expr) &amp;hellip;) form1 form2 &amp;hellip;)
&lt;strong&gt;fluid-let-syntax&lt;/strong&gt;与标准&lt;strong&gt;let&lt;/strong&gt;语法相似，不同之处在于Fluid-let-syntax在其body扩展期间会暂时更改keyword的现有绑定，而不是引入keyword的新绑定。也就是说，在扩展form1 form2 &amp;hellip;的过程中，每个keyword的可见范围（或顶级）将会&lt;strong&gt;临时&lt;/strong&gt;替换为新的绑定关系。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Chez Scheme中Boxes介绍</title>
      <link>https://continuation.cn/2020/01/boxes-in-chez/</link>
      <pubDate>Fri, 03 Jan 2020 14:44:33 +0800</pubDate>
      <guid>https://continuation.cn/2020/01/boxes-in-chez/</guid>
      <description>&lt;p&gt;Chez Scheme中有一种Boxes结构，它是一个&lt;em&gt;单元素&lt;/em&gt;对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构可以共享指向一个对象的引用，或指针。例如，在采用此种参数传递规则的语言的解释器中，可以用 boxes 实现 call-by-reference 的语义。解释有点绕，按我的理解boxes就相当于Golang的struct、Java中的类，将一些状态包装成一个整块，外界通过引用该整块的指针来访问内部的各个状态。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scheme/Chez Scheme 对象操作</title>
      <link>https://continuation.cn/2019/12/operations-on-objects/</link>
      <pubDate>Mon, 30 Dec 2019 16:27:27 +0800</pubDate>
      <guid>https://continuation.cn/2019/12/operations-on-objects/</guid>
      <description>&lt;h3 id=&#34;pairs-and-lists&#34;&gt;Pairs and Lists&lt;/h3&gt;
&lt;h4 id=&#34;atom&#34;&gt;atom?&lt;/h4&gt;
&lt;p&gt;atom? 相当于 (lambda (x) (not (pair? x)))&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;atom?&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;(a b c)) &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;⇒&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;#f&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;atom?&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)) &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;⇒&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;#f&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;atom?&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;()) &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;⇒&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;#t&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;atom?&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;⇒&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;#t&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;list-headchez&#34;&gt;list-head(Chez)&lt;/h4&gt;
&lt;p&gt;用法：(list-head list n) &lt;!-- raw HTML omitted --&gt;
&lt;em&gt;n&lt;/em&gt;是一个非负整数，且小于等于&lt;em&gt;list&lt;/em&gt;的长度；&lt;strong&gt;list-head&lt;/strong&gt;和Scheme标准过程&lt;strong&gt;list-tail&lt;/strong&gt;可能会同时使用来切割一个list，不同点在于，&lt;strong&gt;list-tail&lt;/strong&gt;不会分配内存而只是返回源list的一个子列表，&lt;strong&gt;list-head&lt;/strong&gt;总是返回源list前n个元素的副本&lt;/p&gt;</description>
    </item>
    <item>
      <title>Engine in Scheme</title>
      <link>https://continuation.cn/2019/12/engine-in-scheme/</link>
      <pubDate>Fri, 27 Dec 2019 10:30:09 +0800</pubDate>
      <guid>https://continuation.cn/2019/12/engine-in-scheme/</guid>
      <description>&lt;p&gt;Engine(引擎)是支持&lt;em&gt;时间抢占&lt;/em&gt; 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(make-engine thunk)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;通过传递一个无参数的thunk(形实转换程序)给make-engine来创建一个engine。thunk的body是会被engine执行的计算，engine本身是带3个参数的过程：&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Chez Scheme中的case扩展</title>
      <link>https://continuation.cn/2019/12/case-in-chez-scheme/</link>
      <pubDate>Wed, 25 Dec 2019 16:47:08 +0800</pubDate>
      <guid>https://continuation.cn/2019/12/case-in-chez-scheme/</guid>
      <description>&lt;h3 id=&#34;case&#34;&gt;case&lt;/h3&gt;
&lt;p&gt;Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Scheme提供了&lt;strong&gt;case&lt;/strong&gt;语法来处理这种情况，这与Java中的&lt;strong&gt;switch&lt;/strong&gt;语法非常相似。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fluid Binding in Chez Scheme</title>
      <link>https://continuation.cn/2019/12/fluid-binding/</link>
      <pubDate>Tue, 24 Dec 2019 16:43:57 +0800</pubDate>
      <guid>https://continuation.cn/2019/12/fluid-binding/</guid>
      <description>&lt;p&gt;Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫&lt;strong&gt;易变绑定&lt;/strong&gt;吧，如果有更好的翻译请在文后的评论中尽情发表。&lt;/p&gt;
&lt;p&gt;先看看该语法描述：&lt;!-- raw HTML omitted --&gt;
(&lt;strong&gt;fluid-let&lt;/strong&gt; ((var expr) &amp;hellip;) body1 body2 &amp;hellip;) &lt;!-- raw HTML omitted --&gt;
&lt;strong&gt;returns:&lt;/strong&gt; the values of the body body1 body2 &amp;hellip; &lt;!-- raw HTML omitted --&gt;
&lt;strong&gt;libraries:&lt;/strong&gt; (chezscheme)&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Recursive Bindings in Chez Scheme</title>
      <link>https://continuation.cn/2019/12/recursive-bindings/</link>
      <pubDate>Tue, 24 Dec 2019 15:20:48 +0800</pubDate>
      <guid>https://continuation.cn/2019/12/recursive-bindings/</guid>
      <description>&lt;p&gt;&lt;strong&gt;rec&lt;/strong&gt;语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这是语法描述：&lt;!-- raw HTML omitted --&gt;
(&lt;strong&gt;rec&lt;/strong&gt; var expr) syntax&lt;!-- raw HTML omitted --&gt;
&lt;strong&gt;returns:&lt;/strong&gt; value of expr&lt;!-- raw HTML omitted --&gt;
&lt;strong&gt;libraries:&lt;/strong&gt; (chezscheme)&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>钱币组合问题</title>
      <link>https://continuation.cn/2019/12/count-coins/</link>
      <pubDate>Fri, 13 Dec 2019 15:11:35 +0800</pubDate>
      <guid>https://continuation.cn/2019/12/count-coins/</guid>
      <description>&lt;p&gt;最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
