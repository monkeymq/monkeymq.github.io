<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>文史 on Siquan的网络日志 | AI-Life</title>
    <link>https://lvsq.net/categories/%E6%96%87%E5%8F%B2/</link>
    <description>Recent content in 文史 on Siquan的网络日志 | AI-Life</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 24 Dec 2019 17:24:01 +0800</lastBuildDate>
    
        <atom:link href="https://lvsq.net/categories/%E6%96%87%E5%8F%B2/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Scheme语法define-record-type介绍</title>
      <link>https://lvsq.net/2020/02/define-record-type/</link>
      <pubDate>Mon, 03 Feb 2020 14:51:17 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/02/define-record-type/</guid>
      <description>define-record-type Scheme语言中的define-record-type形式用来定义一个记录类型，并定义该类型的构造函数、仅对该类型的record返回tr</description>
    </item>
    
    <item>
      <title>Chez Scheme Modules</title>
      <link>https://lvsq.net/2020/01/modules/</link>
      <pubDate>Fri, 17 Jan 2020 15:07:58 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/01/modules/</guid>
      <description>Modules 模块用于帮助将程序组织成单独的部分，这些部分通过声明好的接口干净地交互。尽管模块化编程通常可以为多人参加的大型程序开发带来便利，但它也可以</description>
    </item>
    
    <item>
      <title>自定义 Let*</title>
      <link>https://lvsq.net/2020/01/my-let/</link>
      <pubDate>Fri, 17 Jan 2020 10:13:27 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/01/my-let/</guid>
      <description>实现Let*语法的两种方式，主要目的是记录两种编程思路，在编写其他程序时应该也有所裨益。 (define-syntax my-let* (syntax-rules () ((_ () bodys ...) (let () bodys ...)) ( (_ ((a1 v1)) bodys ...) (let ((a1 v1)) bodys ...) ) ( (_</description>
    </item>
    
    <item>
      <title>Syntactic Extension and Modules in Chez Scheme</title>
      <link>https://lvsq.net/2020/01/syntactic-extension-and-modules/</link>
      <pubDate>Wed, 15 Jan 2020 16:00:51 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/01/syntactic-extension-and-modules/</guid>
      <description>Fluid Keyword Bindings fluid-let-syntax 语法: fluid-let-syntax ((keyword expr) &amp;hellip;) form1 form2 &amp;hellip;) fluid-let-syntax与标准let语法相似，不同之处在于Fluid-let-syntax在其body扩</description>
    </item>
    
    <item>
      <title>Chez Scheme中Boxes介绍</title>
      <link>https://lvsq.net/2020/01/boxes-in-chez/</link>
      <pubDate>Fri, 03 Jan 2020 14:44:33 +0800</pubDate>
      
      <guid>https://lvsq.net/2020/01/boxes-in-chez/</guid>
      <description>Chez Scheme中有一种Boxes结构，它是一个*单元素*对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据</description>
    </item>
    
    <item>
      <title>Scheme/Chez Scheme 对象操作</title>
      <link>https://lvsq.net/2019/12/operations-on-objects/</link>
      <pubDate>Mon, 30 Dec 2019 16:27:27 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/12/operations-on-objects/</guid>
      <description>Pairs and Lists atom? atom? 相当于 (lambda (x) (not (pair? x))) (atom? &#39;(a b c)) ⇒ #f (atom? &#39;(3 . 4)) ⇒ #f (atom? &#39;()) ⇒ #t (atom? 3) ⇒ #t list-head(Chez) 用法：(list-head list n) *n*是一个非负整数，且小于等于*list</description>
    </item>
    
    <item>
      <title>Engine in Scheme</title>
      <link>https://lvsq.net/2019/12/engine-in-scheme/</link>
      <pubDate>Fri, 27 Dec 2019 10:30:09 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/12/engine-in-scheme/</guid>
      <description>Engine(引擎)是支持时间抢占 的高级抽象过程， 它可被用于模拟多任务处理、实现操作系统内核和非确定性计算。 (make-engine thunk) 通过传递一个无参数的thun</description>
    </item>
    
    <item>
      <title>Chez Scheme中的case扩展</title>
      <link>https://lvsq.net/2019/12/case-in-chez-scheme/</link>
      <pubDate>Wed, 25 Dec 2019 16:47:08 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/12/case-in-chez-scheme/</guid>
      <description>case Scheme原生提供了if语法，用于判断十分便利，但是对于某些多于一个的条件，就只能嵌套写if来实现了，写起来有些不便，Chez Schem</description>
    </item>
    
    <item>
      <title>继学录</title>
      <link>https://lvsq.net/2019/12/think/</link>
      <pubDate>Tue, 24 Dec 2019 17:24:01 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/12/think/</guid>
      <description>易经曰：通其变，使民不倦。引颜师古注：此易下系之辞也，言通物之变，胡能乐其器用，不解倦也。不才私度其意，白话言之：人物一理，应明其格，顺其兴</description>
    </item>
    
    <item>
      <title>Fluid Binding in Chez Scheme</title>
      <link>https://lvsq.net/2019/12/fluid-binding/</link>
      <pubDate>Tue, 24 Dec 2019 16:43:57 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/12/fluid-binding/</guid>
      <description>Fluid Binding是Chez另一个扩展，这个名词不太好翻译，我想想暂时就叫流式绑定吧，如果有更好的翻译请在文后的评论中尽情发表。 先看看该语法描</description>
    </item>
    
    <item>
      <title>Recursive Bindings in Chez Scheme</title>
      <link>https://lvsq.net/2019/12/recursive-bindings/</link>
      <pubDate>Tue, 24 Dec 2019 15:20:48 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/12/recursive-bindings/</guid>
      <description>rec语法是Chez Scheme中一个非常有用的扩展，在不依赖外部变量进行递归时将很有用，可以减轻代码且使代码更加容易阅读。 这是语法描述： (rec</description>
    </item>
    
    <item>
      <title>Jgossip - gossip协议的开源实现</title>
      <link>https://lvsq.net/2019/12/jgossip/</link>
      <pubDate>Thu, 19 Dec 2019 16:07:31 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/12/jgossip/</guid>
      <description>Gossip是一种一致性协议，在系统设计和开发当中有着广泛的应用，网上有一些开源实现，但是并不好用有些甚至出现了一些bug，于是乎，花了一些</description>
    </item>
    
    <item>
      <title>两数相加</title>
      <link>https://lvsq.net/2019/12/leetcode-2/</link>
      <pubDate>Tue, 17 Dec 2019 20:00:31 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/12/leetcode-2/</guid>
      <description>本文在于解答LeetCode中的第二题，问题的描述可参见 两数相加 Golang的实现： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { result</description>
    </item>
    
    <item>
      <title>钱币组合问题</title>
      <link>https://lvsq.net/2019/12/count-coins/</link>
      <pubDate>Fri, 13 Dec 2019 15:11:35 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/12/count-coins/</guid>
      <description>最近同事参加公司的黑客竞赛，有一道题目与钱币组合问题比较像，记得SICP里面有所描述，正好不是很忙，就试着实现该算法，用Scheme语言开发</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://lvsq.net/about/</link>
      <pubDate>Tue, 03 Dec 2019 09:06:26 +0800</pubDate>
      
      <guid>https://lvsq.net/about/</guid>
      <description>生于僻壤之乡，幸赖民风酣淳,稻花香中逐戏，松风竹影与我入眠。 学无所长，怕读文章，与父母之意大悖。年少好游，使气任侠，蒙父母乡民垂爱，宥我之过</description>
    </item>
    
    <item>
      <title>Swagger 如何使用vendorExtensions进行扩展</title>
      <link>https://lvsq.net/2019/11/swagger-vendor/</link>
      <pubDate>Fri, 29 Nov 2019 10:21:12 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/11/swagger-vendor/</guid>
      <description>Swagger或者叫OpenAPI是一套完备且通用的API标准，本文并不介绍Swagger的用法，仅针对某些场景需要扩展（扩展需要以&amp;rdq</description>
    </item>
    
    <item>
      <title>历史不能碰</title>
      <link>https://lvsq.net/2019/11/do-not-touch-history/</link>
      <pubDate>Thu, 28 Nov 2019 12:43:50 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/11/do-not-touch-history/</guid>
      <description>秦始皇即得天下，同度量衡，皆因各国差别太大，此种说法多见于历史课本，但有问题。有成语叫朝秦暮楚，如若差异太大，必难去秦适楚。周姬以末交通殷繁</description>
    </item>
    
    <item>
      <title>Emacs</title>
      <link>https://lvsq.net/2019/11/emacs/</link>
      <pubDate>Wed, 27 Nov 2019 20:58:09 +0800</pubDate>
      
      <guid>https://lvsq.net/2019/11/emacs/</guid>
      <description>M -&amp;gt; Alt(option) S -&amp;gt; Shift 快捷键 用途 M-v 上（后）一屏 C-v 下（前）一屏 C-l 重绘屏幕，将光标所在行置于屏幕中央 C-u(M-num) 重复执行。C-u 8 C-f(M-8 C-u) 会把光标往前移动8个字符 C-x C-f 查</description>
    </item>
    
  </channel>
</rss>
